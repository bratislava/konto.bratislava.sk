/* tslint:disable */
/* eslint-disable */
/**
 * Nest clamav scanner
 * NestJS ClamAV Scanner using ClamAV.js for scanning files and streams.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface ClamavVersionDto
 */
export interface ClamavVersionDto {
  /**
   * clamav version
   * @type {string}
   * @memberof ClamavVersionDto
   */
  version: string
}
/**
 *
 * @export
 * @interface ScanFileDto
 */
export interface ScanFileDto {
  /**
   * uid/name of the file
   * @type {string}
   * @memberof ScanFileDto
   */
  fileUid: string
  /**
   * uid/name of the bucket. If not set, default bucket will be used
   * @type {string}
   * @memberof ScanFileDto
   */
  bucketUid?: string
}
/**
 *
 * @export
 * @interface ScanFileResponseDto
 */
export interface ScanFileResponseDto {
  /**
   * scan result
   * @type {string}
   * @memberof ScanFileResponseDto
   */
  status: ScanFileResponseDtoStatusEnum
  /**
   * id of the record in db
   * @type {string}
   * @memberof ScanFileResponseDto
   */
  id: string
  /**
   * File Uid
   * @type {string}
   * @memberof ScanFileResponseDto
   */
  fileUid: string
  /**
   * more info
   * @type {string}
   * @memberof ScanFileResponseDto
   */
  message: string
}

export const ScanFileResponseDtoStatusEnum = {
  Accepted: 'ACCEPTED',
  Error: 'ERROR',
} as const

export type ScanFileResponseDtoStatusEnum =
  (typeof ScanFileResponseDtoStatusEnum)[keyof typeof ScanFileResponseDtoStatusEnum]

/**
 *
 * @export
 * @interface ScanStatusDto
 */
export interface ScanStatusDto {
  /**
   * uid/name of the file
   * @type {string}
   * @memberof ScanStatusDto
   */
  fileUid: string
  /**
   * uid of the bucket
   * @type {string}
   * @memberof ScanStatusDto
   */
  bucketUid: string
  /**
   * File size in bytes
   * @type {number}
   * @memberof ScanStatusDto
   */
  fileSize: number
  /**
   * File mime type of file
   * @type {string}
   * @memberof ScanStatusDto
   */
  fileMimeType: string
  /**
   * scan result
   * @type {string}
   * @memberof ScanStatusDto
   */
  status: ScanStatusDtoStatusEnum
  /**
   * other meta data
   * @type {object}
   * @memberof ScanStatusDto
   */
  meta?: object
  /**
   * created at
   * @type {string}
   * @memberof ScanStatusDto
   */
  createdAt: string
  /**
   * updated at
   * @type {string}
   * @memberof ScanStatusDto
   */
  updatedAt: string
}

export const ScanStatusDtoStatusEnum = {
  Accepted: 'ACCEPTED',
  Queued: 'QUEUED',
  Scanning: 'SCANNING',
  Safe: 'SAFE',
  Infected: 'INFECTED',
  NotFound: 'NOT FOUND',
  MoveErrorSafe: 'MOVE ERROR SAFE',
  MoveErrorInfected: 'MOVE ERROR INFECTED',
  ScanError: 'SCAN ERROR',
  ScanTimeout: 'SCAN TIMEOUT',
} as const

export type ScanStatusDtoStatusEnum =
  (typeof ScanStatusDtoStatusEnum)[keyof typeof ScanStatusDtoStatusEnum]

/**
 *
 * @export
 * @interface ServiceRunningDto
 */
export interface ServiceRunningDto {
  /**
   * is service running?
   * @type {boolean}
   * @memberof ServiceRunningDto
   */
  running: boolean
}
/**
 *
 * @export
 * @interface ServicesStatusDto
 */
export interface ServicesStatusDto {
  /**
   *
   * @type {ServiceRunningDto}
   * @memberof ServicesStatusDto
   */
  prisma: ServiceRunningDto
  /**
   *
   * @type {ServiceRunningDto}
   * @memberof ServicesStatusDto
   */
  minio: ServiceRunningDto
  /**
   *
   * @type {ServiceRunningDto}
   * @memberof ServicesStatusDto
   */
  forms: ServiceRunningDto
  /**
   *
   * @type {ServiceRunningDto}
   * @memberof ServicesStatusDto
   */
  clamav: ServiceRunningDto
  /**
   *
   * @type {ClamavVersionDto}
   * @memberof ServicesStatusDto
   */
  clamavVersion: ClamavVersionDto
}

/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Hello world!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks if this service is running
     * @summary Check status of this service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerIsStatusRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/health`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Hello world!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerGetHello(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['HealthApi.appControllerGetHello']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks if this service is running
     * @summary Check status of this service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerIsStatusRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.appControllerIsStatusRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['HealthApi.appControllerIsStatusRunning']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Hello world!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks if this service is running
     * @summary Check status of this service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerIsStatusRunning(options?: RawAxiosRequestConfig): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .appControllerIsStatusRunning(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Hello world!
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public appControllerGetHello(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .appControllerGetHello(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks if this service is running
   * @summary Check status of this service
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HealthApi
   */
  public appControllerIsStatusRunning(options?: RawAxiosRequestConfig) {
    return HealthApiFp(this.configuration)
      .appControllerIsStatusRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ScannerApi - axios parameter creator
 * @export
 */
export const ScannerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerDeleteFileById: async (
      resourceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists('scannerControllerDeleteFileById', 'resourceId', resourceId)
      const localVarPath = `/api/scan/file/{resourceId}`.replace(
        `{${'resourceId'}}`,
        encodeURIComponent(String(resourceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} bucketUid64
     * @param {string} fileUid64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerGetStatus: async (
      bucketUid64: string,
      fileUid64: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'bucketUid64' is not null or undefined
      assertParamExists('scannerControllerGetStatus', 'bucketUid64', bucketUid64)
      // verify required parameter 'fileUid64' is not null or undefined
      assertParamExists('scannerControllerGetStatus', 'fileUid64', fileUid64)
      const localVarPath = `/api/scan/file/{fileUid64}/{bucketUid64}`
        .replace(`{${'bucketUid64'}}`, encodeURIComponent(String(bucketUid64)))
        .replace(`{${'fileUid64'}}`, encodeURIComponent(String(fileUid64)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerGetStatusById: async (
      resourceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resourceId' is not null or undefined
      assertParamExists('scannerControllerGetStatusById', 'resourceId', resourceId)
      const localVarPath = `/api/scan/file/{resourceId}`.replace(
        `{${'resourceId'}}`,
        encodeURIComponent(String(resourceId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
     * @summary Scan list of files in bucket via clamav scanner.
     * @param {ScanFileDto} scanFileDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerScanFile: async (
      scanFileDto: ScanFileDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scanFileDto' is not null or undefined
      assertParamExists('scannerControllerScanFile', 'scanFileDto', scanFileDto)
      const localVarPath = `/api/scan/file`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        scanFileDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
     * @summary Scan list of files in bucket via clamav scanner.
     * @param {Array<object>} requestBody List of files to scan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerScanFiles: async (
      requestBody: Array<object>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('scannerControllerScanFiles', 'requestBody', requestBody)
      const localVarPath = `/api/scan/files`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication basic required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ScannerApi - functional programming interface
 * @export
 */
export const ScannerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScannerApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scannerControllerDeleteFileById(
      resourceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanStatusDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scannerControllerDeleteFileById(
        resourceId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannerApi.scannerControllerDeleteFileById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} bucketUid64
     * @param {string} fileUid64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scannerControllerGetStatus(
      bucketUid64: string,
      fileUid64: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanStatusDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scannerControllerGetStatus(
        bucketUid64,
        fileUid64,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannerApi.scannerControllerGetStatus']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scannerControllerGetStatusById(
      resourceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanStatusDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scannerControllerGetStatusById(
        resourceId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannerApi.scannerControllerGetStatusById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
     * @summary Scan list of files in bucket via clamav scanner.
     * @param {ScanFileDto} scanFileDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scannerControllerScanFile(
      scanFileDto: ScanFileDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanFileResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scannerControllerScanFile(
        scanFileDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannerApi.scannerControllerScanFile']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
     * @summary Scan list of files in bucket via clamav scanner.
     * @param {Array<object>} requestBody List of files to scan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scannerControllerScanFiles(
      requestBody: Array<object>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanFileResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scannerControllerScanFiles(
        requestBody,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ScannerApi.scannerControllerScanFiles']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ScannerApi - factory interface
 * @export
 */
export const ScannerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ScannerApiFp(configuration)
  return {
    /**
     *
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerDeleteFileById(
      resourceId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScanStatusDto> {
      return localVarFp
        .scannerControllerDeleteFileById(resourceId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} bucketUid64
     * @param {string} fileUid64
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerGetStatus(
      bucketUid64: string,
      fileUid64: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScanStatusDto> {
      return localVarFp
        .scannerControllerGetStatus(bucketUid64, fileUid64, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerGetStatusById(
      resourceId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScanStatusDto> {
      return localVarFp
        .scannerControllerGetStatusById(resourceId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
     * @summary Scan list of files in bucket via clamav scanner.
     * @param {ScanFileDto} scanFileDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerScanFile(
      scanFileDto: ScanFileDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScanFileResponseDto> {
      return localVarFp
        .scannerControllerScanFile(scanFileDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
     * @summary Scan list of files in bucket via clamav scanner.
     * @param {Array<object>} requestBody List of files to scan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scannerControllerScanFiles(
      requestBody: Array<object>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ScanFileResponseDto> {
      return localVarFp
        .scannerControllerScanFiles(requestBody, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ScannerApi - object-oriented interface
 * @export
 * @class ScannerApi
 * @extends {BaseAPI}
 */
export class ScannerApi extends BaseAPI {
  /**
   *
   * @param {string} resourceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannerApi
   */
  public scannerControllerDeleteFileById(resourceId: string, options?: RawAxiosRequestConfig) {
    return ScannerApiFp(this.configuration)
      .scannerControllerDeleteFileById(resourceId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} bucketUid64
   * @param {string} fileUid64
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannerApi
   */
  public scannerControllerGetStatus(
    bucketUid64: string,
    fileUid64: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ScannerApiFp(this.configuration)
      .scannerControllerGetStatus(bucketUid64, fileUid64, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} resourceId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannerApi
   */
  public scannerControllerGetStatusById(resourceId: string, options?: RawAxiosRequestConfig) {
    return ScannerApiFp(this.configuration)
      .scannerControllerGetStatusById(resourceId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
   * @summary Scan list of files in bucket via clamav scanner.
   * @param {ScanFileDto} scanFileDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannerApi
   */
  public scannerControllerScanFile(scanFileDto: ScanFileDto, options?: RawAxiosRequestConfig) {
    return ScannerApiFp(this.configuration)
      .scannerControllerScanFile(scanFileDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * You have to provide list of files which are already uploaded to bucket and you want to scan them. Service will return list of files with status saying that files where accepted for scanning. If not then proper error will be propagated.
   * @summary Scan list of files in bucket via clamav scanner.
   * @param {Array<object>} requestBody List of files to scan.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannerApi
   */
  public scannerControllerScanFiles(requestBody: Array<object>, options?: RawAxiosRequestConfig) {
    return ScannerApiFp(this.configuration)
      .scannerControllerScanFiles(requestBody, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StatusesApi - axios parameter creator
 * @export
 */
export const StatusesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint checks if clamav is running
     * @summary Check clamav status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsClamavRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/status/clamav`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks if forms backend is running
     * @summary Check forms backend status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsFormsRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/status/forms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks if minio is running
     * @summary Check minio status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsMinioRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/status/minio`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks if prisma is running
     * @summary Check prisma status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsPrismaRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/status/prisma`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks all services status
     * @summary Check all services status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/status`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint shows clamav version
     * @summary Show clamav version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/status/clamav/version`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StatusesApi - functional programming interface
 * @export
 */
export const StatusesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StatusesApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint checks if clamav is running
     * @summary Check clamav status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerIsClamavRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusControllerIsClamavRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerIsClamavRunning']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks if forms backend is running
     * @summary Check forms backend status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerIsFormsRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusControllerIsFormsRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerIsFormsRunning']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks if minio is running
     * @summary Check minio status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerIsMinioRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusControllerIsMinioRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerIsMinioRunning']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks if prisma is running
     * @summary Check prisma status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerIsPrismaRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusControllerIsPrismaRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerIsPrismaRunning']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks all services status
     * @summary Check all services status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerStatus(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicesStatusDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.statusControllerStatus(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerStatus']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint shows clamav version
     * @summary Show clamav version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerVersion(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClamavVersionDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.statusControllerVersion(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerVersion']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StatusesApi - factory interface
 * @export
 */
export const StatusesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StatusesApiFp(configuration)
  return {
    /**
     * This endpoint checks if clamav is running
     * @summary Check clamav status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsClamavRunning(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .statusControllerIsClamavRunning(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks if forms backend is running
     * @summary Check forms backend status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsFormsRunning(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .statusControllerIsFormsRunning(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks if minio is running
     * @summary Check minio status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsMinioRunning(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .statusControllerIsMinioRunning(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks if prisma is running
     * @summary Check prisma status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsPrismaRunning(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .statusControllerIsPrismaRunning(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks all services status
     * @summary Check all services status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerStatus(options?: RawAxiosRequestConfig): AxiosPromise<ServicesStatusDto> {
      return localVarFp.statusControllerStatus(options).then((request) => request(axios, basePath))
    },
    /**
     * This endpoint shows clamav version
     * @summary Show clamav version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerVersion(options?: RawAxiosRequestConfig): AxiosPromise<ClamavVersionDto> {
      return localVarFp.statusControllerVersion(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * StatusesApi - object-oriented interface
 * @export
 * @class StatusesApi
 * @extends {BaseAPI}
 */
export class StatusesApi extends BaseAPI {
  /**
   * This endpoint checks if clamav is running
   * @summary Check clamav status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusesApi
   */
  public statusControllerIsClamavRunning(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerIsClamavRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks if forms backend is running
   * @summary Check forms backend status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusesApi
   */
  public statusControllerIsFormsRunning(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerIsFormsRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks if minio is running
   * @summary Check minio status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusesApi
   */
  public statusControllerIsMinioRunning(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerIsMinioRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks if prisma is running
   * @summary Check prisma status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusesApi
   */
  public statusControllerIsPrismaRunning(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerIsPrismaRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks all services status
   * @summary Check all services status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusesApi
   */
  public statusControllerStatus(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerStatus(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint shows clamav version
   * @summary Show clamav version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusesApi
   */
  public statusControllerVersion(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerVersion(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
