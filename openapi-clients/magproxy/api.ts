/* tslint:disable */
/* eslint-disable */
/**
 * Bratislava magproxy
 * Bratislava
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

export interface Activity {
  priznakAktualnehoZaznamu: boolean
  platnostOd: string
  platnostDo: string
  pozastavenieOd: string
  pozastavenieDo: string
  kod: string
  popis: string
  klasifikacia: CodelistDto
}
export interface ActivityDto {
  /**
   * Predmet činnosti
   */
  economicActivityDescription?: string
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
  /**
   * Platnosť pozastavená od
   */
  suspendedFrom?: string
  /**
   * Platnosť pozastavená do
   */
  suspendedTo?: string
}
export interface AddressDetailDto {
  /**
   * Latitude of found address. Part of base response.
   */
  lat?: number | null
  /**
   * Longitude of found address. Part of base response.
   */
  long?: number | null
  /**
   * Hyperlink which can be used to get detailed response. Part of base response.
   */
  addressId?: string | null
  /**
   * Origin of data. Part of detailed response.
   */
  publisher?: string
  /**
   * Official name of country. Part of detailed response.
   */
  country?: string
  /**
   * Full address containing street, registration and orientation numbers, city, district and postal code. Part of detailed response.
   */
  fullAddress?: string | null
  /**
   * Official name of county. Part of detailed response.
   */
  county?: string | null
  /**
   * Official name of region. Part of detailed response.
   */
  region?: string
  /**
   * City with city part. Part of detailed response.
   */
  municipality?: string | null
  /**
   * Orientation number, may contain numbers and letters, unique within a single street. Part of detailed response.
   */
  orientationNumber?: string
  /**
   * Postal code. Part of detailed response.
   */
  postCode?: string
  /**
   * Registration number of a building, unique for building within a city. Part of detailed response.
   */
  registrationNumber?: string
  /**
   * Street name. Part of detailed response.
   */
  street?: string
}
export interface AddressDto {
  /**
   * Formátovaná adresa
   */
  formatedAddress?: string
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
  /**
   * Ulica
   */
  street?: string
  /**
   * Súpisné číslo
   */
  regNumber?: number
  /**
   * Orientačné číslo
   */
  buildingNumber?: string
  /**
   * PSČ
   */
  postalCodes?: Array<string>
  /**
   * Municipality
   */
  municipality?: CodeValueDto
  /**
   * Country
   */
  country?: CodeValueDto
  /**
   * District
   */
  district?: CodeValueDto
  /**
   * Index domu resp. identifikátor adresy z Registra adries
   */
  buildingIndex?: string
}
export interface BadRequestErrorDto {
  /**
   * Status code
   */
  statusCode: number
  /**
   * State
   */
  state: string
  /**
   * Error type
   */
  type: string
  /**
   * Error name
   */
  errorName: BadRequestErrorDtoErrorNameEnum
  /**
   * Additional info about error
   */
  messsage?: object
}

export const BadRequestErrorDtoErrorNameEnum = {
  DcomRequestError: 'DCOM_REQUEST_ERROR',
  ParserError: 'PARSER_ERROR',
  DcomNotfound: 'DCOM_NOTFOUND',
  InternalServerError: 'INTERNAL_SERVER_ERROR',
  MarkPersonError: 'MARK_PERSON_ERROR',
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const

export type BadRequestErrorDtoErrorNameEnum =
  (typeof BadRequestErrorDtoErrorNameEnum)[keyof typeof BadRequestErrorDtoErrorNameEnum]

export interface BankConnectionDto {
  menoBanky: string
  menoFyzickejOsoby: PhysicalPersonNameDto
  plnyNazovPo: string
  domaceBankoveSpojenie: DomesticBankDto
  zahranicneBankoveSpojenie: ForeignBankDto
}
export interface BirthDto {
  datumNarodenia: string
  miestoNarodenia: string
}
export interface CodeValueDto {
  /**
   * Hodnota atribútu
   */
  value?: string
  /**
   * Kód hodnoty atribútu
   */
  code?: string
  /**
   * Kód číselníka
   */
  codelistCode?: string
}
export interface CodelistDto {
  kodCiselnika: string
  kod: string
  nazov: string
}
export interface CodelistWithHistory {
  priznakAktualnehoZaznamu: boolean
  platnostOd: string
  platnostDo: string
  hodnota: CodelistDto
}
export interface DcomKNSAddressDto {
  Id: number
  Street: string
  HouseNo: string
  Municipality: string
  Zip: string
  State: string
  ValidTo: string
}
export interface DcomKNSubjectDto {
  Id: number
  AddressId: number
  No: number | null
  BirthYear: number
  Surname: string
  FirstName: string
  BirthSurname: string
  Title: string
  ValidTo: string
  BirthDate: string
  BirthNo: number | null
  IdNo: number | null
  FirstNameSearch: string
  SurnameSearch: string
  BirthSurnameSearch: DcomKNSAddressDto
}
export interface DeathDto {
  datum: string
  miesto: string
}
export interface DeliveryAddressDto {
  psc: string
  pobox: string
  prijemca: RecieverDto
}
export interface DepositDto {
  typ: string
  vyska: string
  datumSplatnosti: string
  mena: CodelistDto
}
export interface DomesticBankDto {
  formatovane: string
  predcislie: string
  cisloUctu: string
  kodBanky: string
}
export interface EntityIdGet200ResponseDepositsInnerDto {
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
  /**
   * Person name
   */
  personName?: PersonNameDto
  /**
   * Názov zainteresovanej osoby (PO)
   */
  fullName?: string
  /**
   * Typ vkladu
   */
  type?: string
  /**
   * Výška vkladu
   */
  amount?: number
  /**
   * Currency
   */
  currency?: CodeValueDto
}
export interface EntityIdGet200ResponseDto {
  /**
   * Jedinedinečný identifikátor záznamu
   */
  id: number
  /**
   * Dátum poslednej aktualizácie údajov o PO v databáze, t.j. kedy začala byť aktuálna verzia záznamu dostupná cez toto API.
   */
  dbModificationDate?: string
  /**
   * IČO
   */
  identifiers: Array<TimedValueEntryDto>
  /**
   * Plný názov PO
   */
  fullNames?: Array<TimedValueEntryDto>
  /**
   * Alternatívny názov PO
   */
  alternativeNames?: Array<TimedValueEntryDto>
  /**
   * Adresa sídla PO
   */
  addresses?: Array<AddressDto>
  /**
   * Dátum vzniku
   */
  establishment: string
  /**
   * Dátum zániku
   */
  termination?: string
  /**
   * Predmet činnosti
   */
  activities?: Array<ActivityDto>
  /**
   * Štatutárny orgán
   */
  statutoryBodies?: Array<StatutaryBodyDto>
  /**
   * Zainteresovaná osoba
   */
  stakeholders?: Array<StakeholderSusrDto>
  /**
   * Právny stav PO (číselník CL010108)
   */
  legalStatuses?: Array<TimedCodeValueEntryDto>
  /**
   * Iné právne skutočnosti
   */
  otherLegalFacts?: Array<TimedValueEntryDto>
  /**
   * Oprávnenie konať v mene PO
   */
  authorizations?: Array<TimedValueEntryDto>
  /**
   * Základné imanie
   */
  equities?: Array<EntityIdGet200ResponseEquitiesInnerDto>
  /**
   * Akcie
   */
  shares?: Array<EntityIdGet200ResponseSharesInnerDto>
  /**
   * Vklady
   */
  deposits?: Array<EntityIdGet200ResponseDepositsInnerDto>
  /**
   * Source register
   */
  sourceRegister?: SearchGet200ResponseResultsInnerSourceRegisterDto
  /**
   * Právny predchodca PO
   */
  predecessors?: Array<EntityIdGet200ResponsePredecessorsInnerDto>
  /**
   * Právny nástupca PO
   */
  successors?: Array<EntityIdGet200ResponsePredecessorsInnerDto>
  /**
   * Štatistické kódy
   */
  statisticalCodes?: EntityIdGet200ResponseStatisticalCodesDto
  /**
   * Základné údaje o konečnom užívateľovi výhod
   */
  kuvPersonsInfo?: Array<EntityIdGet200ResponseKuvPersonsInfoInnerDto>
  /**
   * Základné údaje o vrcholovom manažmente konečného užívateľa výhod
   */
  topManagementsInfo?: Array<EntityIdGet200ResponseTopManagementsInfoInnerDto>
  /**
   * Údaje o organizačných zložkách
   */
  organizationUnits?: Array<EntityIdGet200ResponseOrganizationUnitsInnerDto>
  /**
   * Licenčné informácie
   */
  license?: string
}
export interface EntityIdGet200ResponseEquitiesInnerDto {
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
  /**
   * Výška základného imania
   */
  value?: number
  /**
   * Výška splateného imania
   */
  valuePaid?: number
  /**
   * Schválená výška
   */
  valueApproved?: number
  /**
   * Currency
   */
  currency?: CodeValueDto
}
export interface EntityIdGet200ResponseKuvPersonsInfoInnerDto {
  /**
   * Person name
   */
  personName?: PersonNameDto
  /**
   * Dátum narodenia
   */
  birthDate?: string
  /**
   * Citizenship
   */
  citizenship?: CodeValueDto
  /**
   * Country
   */
  country?: CodeValueDto
  /**
   * Údaje o postavení konečného užívateľa výhod (číselník CL010430)
   */
  kuvInfo?: Array<TimedCodeValueEntryDto>
}
export interface EntityIdGet200ResponseOrganizationUnitsInnerDto {
  /**
   * Type
   */
  type?: CodeValueDto
  /**
   * IČO
   */
  identifier?: string
  /**
   * Plný názov organizačnej zložky
   */
  fullNames?: Array<TimedValueEntryDto>
  /**
   * Adresa
   */
  addresses?: Array<AddressDto>
  /**
   * Dátum vzniku
   */
  establishment?: string
  /**
   * Dátum zániku
   */
  termination?: string
  /**
   * Zainteresovaná osoba
   */
  stakeholders?: Array<StakeholderSusrDto>
  /**
   * Predmet činnosti
   */
  activities?: Array<ActivityDto>
}
export interface EntityIdGet200ResponsePredecessorsInnerDto {
  /**
   * IČO
   */
  identifier?: string
  /**
   * Názov
   */
  fullName?: string
  /**
   * Adresa
   */
  address?: AddressDto
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
}
export interface EntityIdGet200ResponseSharesInnerDto {
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
  /**
   * Názov zainteresovanej osoby (PO)
   */
  fullName?: string
  /**
   * Person name
   */
  personName?: PersonNameDto
  /**
   * Share type
   */
  shareType?: CodeValueDto
  /**
   * Podoba akcie
   */
  shareForm?: string
  /**
   * Menovitá hodnota akcie
   */
  shareNominalValue?: number
  /**
   * Share currency
   */
  shareCurrency?: CodeValueDto
  /**
   * Množstvo akcií
   */
  amountOfFunds?: number
  /**
   * Prevoditelnosť akcií
   */
  transferability?: string
}
export interface EntityIdGet200ResponseStatisticalCodesDto {
  /**
   * Dátum aktualizácie štatistických kódov
   */
  statCodesActualization?: string
  /**
   * Main activity
   */
  mainActivity?: CodeValueDto
  /**
   * ESA2010
   */
  esa2010?: CodeValueDto
}
export interface EntityIdGet200ResponseTopManagementsInfoInnerDto {
  /**
   * Person name
   */
  personName?: PersonNameDto
  /**
   * Dátum narodenia
   */
  birthDate?: string
  /**
   * Citizenship
   */
  citizenship?: CodeValueDto
  /**
   * Country
   */
  country?: CodeValueDto
  /**
   * Údaje o type vrcholového manažmentu (číselník CL010113)
   */
  kuvInfo?: Array<TimedCodeValueEntryDto>
}
export interface Equity {
  priznakAktualnehoZaznamu: boolean
  platnostOd: string
  platnostDo: string
  hodnota: string
  splatene: string
  schvalene: string
  mena: CodelistDto
}
export interface FindOneByIcoFromApiResponse {
  /**
   * Legal person
   */
  legalPerson: SearchGet200ResponseDto
  /**
   * Legal person detail
   */
  detail?: EntityIdGet200ResponseDto
}
export interface ForeignBankDto {
  iban: string
  bic: string
}
export interface HealthCheckResponseDto {
  response: string
}
export interface IdDto {
  identifikator: string
  typIdentifikatora: CodelistDto
}
export interface IdWithHistory {
  priznakAktualnehoZaznamu: boolean
  platnostOd: string
  platnostDo: string
  externeId: IdDto
}
export interface LegalPersonDto {
  addMissingProps: string
}
export interface NamesPropsDto {
  platnostOd: string
  platnostDo: string
  priznakAktualnehoZaznamu: string
  plnyNazov: string
}
export interface NotFoundErrorDto {
  /**
   * Status code
   */
  statusCode: number
  /**
   * State
   */
  state: string
  /**
   * Error type
   */
  type: string
  /**
   * Error name
   */
  errorName: NotFoundErrorDtoErrorNameEnum
  /**
   * Requested object to be found
   */
  detail: string
}

export const NotFoundErrorDtoErrorNameEnum = {
  DcomRequestError: 'DCOM_REQUEST_ERROR',
  ParserError: 'PARSER_ERROR',
  DcomNotfound: 'DCOM_NOTFOUND',
  InternalServerError: 'INTERNAL_SERVER_ERROR',
  MarkPersonError: 'MARK_PERSON_ERROR',
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const

export type NotFoundErrorDtoErrorNameEnum =
  (typeof NotFoundErrorDtoErrorNameEnum)[keyof typeof NotFoundErrorDtoErrorNameEnum]

export interface OrganizationUnitDto {
  externeId: IdDto
  datumVzniku: string
  datumZaniku: string
  typ: CodelistDto
  adresy: Array<PhysicalAddress>
  predmetyCinnosti: Array<Activity>
  zainteresovaneOsoby: Array<StakeholderDto>
}
export interface PersonDto {
  fyzickaOsoba: PhysicalPersonDto
  pravnickaOsoba: LegalPersonDto
}
export interface PersonNameDto {
  /**
   * Formatované meno
   */
  formatedName?: string
  /**
   * Meno
   */
  givenNames: Array<string>
  /**
   * Priezvisko
   */
  familyNames: Array<string>
  /**
   * Rodné priezvisko
   */
  givenFamilyNames?: Array<string>
  /**
   * Titul pred menom (číselníky CL000062 / TIT)
   */
  prefixes?: Array<CodeValueDto>
  /**
   * Titul za menom (číselníky CL000063 / TIT)
   */
  postfixes?: Array<CodeValueDto>
}
export interface PhoneAddressDto {
  typ: string
  formatovanieCislo: string
  medzinarodnyKodKrajiny: string
  narodneCislo: string
  miestnaPredvolba: string
  cisloUcastnika: string
  klapka: string
}
export interface PhysicalAddress {
  priznakAktualnehoZaznamu: boolean
  platnostOd: string
  platnostDo: string
  formatovanaAdresa: string
  stat: CodelistDto
  obec: CodelistDto
  okres: CodelistDto
  castObce: CodelistDto
  regiony: Array<CodelistDto>
  typAdresy: CodelistDto
  nazovUlice: string
  cisloDomu: string
  supisneCislo: string
  dodacieAdresy: Array<DeliveryAddressDto>
  referenciaDoRegistraAdries: string
}
export interface PhysicalPersonDto {
  adresa: PhysicalAddress
  rodinnyStav: CodelistDto
  pohlavie: CodelistDto
  statnaPrislusnost: CodelistDto
  narodenie: BirthDto
  umrtie: DeathDto
  alternativneMena: Array<ValueWithHistory>
  dodacieAdresy: Array<DeliveryAddressDto>
  menoFyzickejOsoby: PhysicalPersonNameDto
  externeIds: Array<IdDto>
}
export interface PhysicalPersonNameDto {
  formatovaneMeno: string
  ineMeno: string
  legalneMeno: string
  rodneMena: Array<string>
  priezviska: SurnamePropsDto
  rodnePriezviska: SurnamePropsDto
  tituly: TitlesPropsDto
}
export interface PredecessorSuccessor {
  priznakAktualnehoZaznamu: boolean
  platnostOd: string
  platnostDo: string
  plnyNazov: string
  externeId: IdDto
  adresa: PhysicalAddress
}
export interface RecieverDto {
  dodatocneTexty: string
  menoOrganizacjnejJednotky: string
  nazovPo: string
  menoFyzickejOsoby: string
}
export interface ResponseKNGetOwnersDto {
  data: Array<DcomKNSubjectDto>
}
export interface ResponseKNGetPropertiesDto {
  /**
   * Name of owner (from input data)
   */
  firstName: string
  /**
   * Surname of owner (from input data)
   */
  surname: string
  /**
   * Dtail about user - name, surname, birth surname, addres of permanent residence
   */
  userDetail: string
  /**
   * ID of municipality
   */
  municipalityId: number
  /**
   * Cadastral unit of participant permanent residence
   */
  participantCadastralUnitId: number
  /**
   * Date of record
   */
  validTo: string
  /**
   * Flats and other spaces - it is need to be added to non living parcels and hosues
   */
  spaceRecords: Array<ResponseKNGetPropertiesSpaceRecordsDto>
}
export interface ResponseKNGetPropertiesSpaceRecordsDto {
  /**
   * Id of ownership of property, unique identifier for flat and person
   */
  ownershipId: number
  /**
   * Dtail about user - name, surname, birth surname, addres of permanent residence
   */
  userDetail: string
  /**
   * ID of municipality
   */
  municipalityId: number
  /**
   * Cadastral unit of participant permanent residence
   */
  participantCadastralUnitId: number
  /**
   * Date of record
   */
  validTo: string
  /**
   * Flats and other spaces detail - it is need to be added to non living parcels and hosues
   */
  spaces: Array<ResponseKNGetPropertiesSpaceRecordsSpacesDto>
}
export interface ResponseKNGetPropertiesSpaceRecordsSpacesDto {
  /**
   * Id of the parcel / property / house / flat
   */
  id: number
  /**
   * Id of Entrance (vchod)
   */
  entranceId: number
  /**
   * Id of type of the parcel / property / house / flat
   */
  typeId: number
  /**
   * Register number of the house
   */
  houseNo: number
  /**
   * Address with address number
   */
  address: string
  /**
   * Number of floor, it can be also negative or zero
   */
  floorNo: number | null
  /**
   * Flat number, if it is constructuin of flats (residential) (bytovy priestor)
   */
  flatNo: number | null
  /**
   * If it is nonresidentail space
   */
  nonresidentialNo: number | null
  /**
   * If it is nonresidentail space
   */
  nonresidentialTypeId: number | null
  /**
   * If it is nonresidentail space
   */
  area: number | null
  /**
   * Id of construction
   */
  constructionId: number
  /**
   * Id of cadastral unit
   */
  cadastralUnitId: number
  /**
   * Name of cadastral unit
   */
  cadastralUnitName: string
  /**
   * Code of cadastral unit
   */
  cadastralUnitCode: number
  /**
   * Search of cadastral unit (without spaces and diacritics and capitals)
   */
  cadastralUnitSearch: string
  /**
   * Id of municipality
   */
  municipalityId: number
  /**
   * Name of municipality
   */
  municipalityName: string
  /**
   * Code of municipality
   */
  municipalityCode: number
  /**
   * Search of municipality (without spaces and diacritics and capitals)
   */
  municipalitySearch: string
  /**
   * Id of district
   */
  districtId: number
  /**
   * Name of district
   */
  districtName: string
  /**
   * Code of district
   */
  districtCode: number
  /**
   * Search of district (without spaces and diacritics and capitals)
   */
  districtSearch: string
  /**
   * Id of region
   */
  regionId: number
}
export interface ResponseNEVBasicInfoPropsDto {
  /**
   * Id of vehicle (VI)
   */
  id: number
  /**
   * Id of vehicle (VI)
   */
  vozidloId: number
  /**
   * Date of first registration
   */
  datumPrvejEvidenie: string
  /**
   * Date of first registration Sr
   */
  datumPrvejEvidenieSr: string
  /**
   * Workplace of registration
   */
  pracoviskoPriradenia: string
  /**
   * Licence plate of vehicle
   */
  evidencneCislo: string
  /**
   * Vehicle identification number
   */
  vin: string
  /**
   * State of vehicle
   */
  stavVozidla: string
  /**
   * Type of change
   */
  druhZmeny: string
  /**
   * Timestamp of change
   */
  druhZmenyDatum: string
  /**
   * Year of production
   */
  rokVyroby: number
  /**
   * Individual import
   */
  individualnyDozvoz: boolean
  /**
   * Is vehicle blocked?
   */
  blokacia: boolean
  /**
   * Workplace Id
   */
  pracoviskoPriradeniaId: number
  /**
   * Vehicle status Id
   */
  stavVozidlaId: number
  /**
   * Is vehicle new?
   */
  noveVozidlo: boolean
  /**
   * Is vehicle in leasing?
   */
  leasing: boolean
  /**
   * Type if change Id
   */
  druhZmenyId: number
  /**
   * oev
   */
  oev: string
  /**
   * tp
   */
  tp: string
  /**
   * Validity to oe
   */
  oePlatnostDokladu: string
  /**
   * oe
   */
  oe: string
  /**
   * Previous ECV
   */
  predchadajucaEc: string
  /**
   * Tech code
   */
  tecKod: string
  /**
   * Tech id
   */
  tecId: number
  /**
   * Workplace of unregistration
   */
  pracoviskoOdhlasenia: string
  /**
   * Workplace of unregistration Id
   */
  pracoviskoOdhlaseniaId: string
  /**
   * Release date
   */
  oeDatumVydania: string
  /**
   * oev Release date
   */
  oevDatumVydania: string
  /**
   * tp release date
   */
  tpDatumVydania: string
  /**
   * tp Place of release
   */
  tpMiestoVydania: string
  /**
   * oe Place of release
   */
  oeMiestoVydania: string
  /**
   * ECV Id
   */
  evidencneCisloId: number
  /**
   * tp State Id
   */
  tpStavId: number
  /**
   * oev State Id
   */
  oevStavId: number
  /**
   * oe state Id
   */
  oeStavId: number
  /**
   * State of tp
   */
  tpStavNazov: string
  /**
   * State of oev
   */
  oevStavNazov: string
  /**
   * State of oe
   */
  oeStavNazov: string
  /**
   * some Id
   */
  tecPrednaId: number
  /**
   * some state
   */
  tecZadnaStav: string
  /**
   * another state
   */
  tecPrednaStav: string
}
export interface ResponseNEVInsuranceContractPropsDto {
  /**
   * Id
   */
  id: number
  /**
   * Vehicle id
   */
  vozidloId: number
  /**
   * Contract number
   */
  cisloZmluvy: string
  /**
   * Insurer
   */
  poistovatel: string
  /**
   * Onset date
   */
  datumZaciatku: string
  /**
   * Termination date
   */
  datumUkoncenia: string
}
export interface ResponseNEVMainDto {
  /**
   * Basic information
   */
  zakladneInformacie: ResponseNEVBasicInfoPropsDto
  /**
   * Owner and holder
   */
  drzitelAVlastnik: ResponseNEVOwnerAndHolderPropsDto
  /**
   * Technical details
   */
  technickeUdaje: ResponseNEVTecDetailPropsDto
  /**
   * Insurance contract
   */
  poistnaZmluva: ResponseNEVInsuranceContractPropsDto
  /**
   * Document of processing
   */
  dokladOSpracovani: ResponseNEVProcessDocPropsDto
  /**
   * Origin check protocol
   */
  protokolKontrolyOriginality: ResponseNEVOriginProtocolPropsDto
  /**
   * Sport and historic vehicle license
   */
  preukazSportovehoAHistorickehoVozidla: ResponseNEVSportHistLicensePropsDto
  /**
   * Error message
   */
  sprava: ResponseNEVMessagePropsDto
}
export interface ResponseNEVMessagePropsDto {
  /**
   * Error number
   */
  cisloChyby: string
  /**
   * Error message
   */
  textChyby: string
}
export interface ResponseNEVOriginProtocolPropsDto {
  /**
   * Id
   */
  id: number
  /**
   * Vehicle id
   */
  vozidloId: number
  /**
   * Appraisal form number
   */
  cisloPosudku: string
  /**
   * Protocol code
   */
  kodProtokolu: string
  /**
   * Origin check - result
   */
  vysledokKontrolyOriginality: number
  /**
   * Number of check label
   */
  cisloKontrolnejNalepky: string
  /**
   * Date of check
   */
  kontrolaDatum: string
}
export interface ResponseNEVOwnerAndHolderPropsDto {
  /**
   * Vehicle id
   */
  vozidloId: number
  /**
   * Owner - type
   */
  vlastnikTyp: string
  /**
   * Owner - Name
   */
  vlastnikMeno: string
  /**
   * Owner - Surname
   */
  vlastnikPriezvisko: string
  /**
   * Owner - Full name
   */
  vlastnikNazov: string
  /**
   * Owner - Date of birth
   */
  vlastnikDatumNarodenia: string
  /**
   * Owner - Business Id
   */
  vlastnikIco: string
  /**
   * Owner - Birth number
   */
  vlastnikRodneCislo: string
  /**
   * Owner - District
   */
  vlastnikOkres: string
  /**
   * Owner - Municipality
   */
  vlastnikObec: string
  /**
   * Owner - Street
   */
  vlastnikUlica: string
  /**
   * Owner - Street number
   */
  vlastnikOrientacneCislo: number
  /**
   * Owner - Register number
   */
  vlastnikSupisneCislo: number
  /**
   * Owner - residence out of SR
   */
  vlastnikPobytMimoSr: string
  /**
   * Owner - what is this?
   */
  vlastnikMimoSrStat: string
  /**
   * Holder - type
   */
  drzitelTyp: string
  /**
   * Holder - name
   */
  drzitelMeno: string
  /**
   * Holder - surname
   */
  drzitelPriezvisko: string
  /**
   * Holder - full name
   */
  drzitelNazov: string
  /**
   * Holder - date of birth
   */
  drzitelDatumNarodenia: string
  /**
   * Holder - business id
   */
  drzitelIco: string
  /**
   * Holder - Birth number
   */
  drzitelRodneCislo: string
  /**
   * Holder - district
   */
  drzitelOkres: string
  /**
   * Holder - municipality
   */
  drzitelObec: string
  /**
   * Holder - street
   */
  drzitelUlica: string
  /**
   * Holder - street number
   */
  drzitelOrientacneCislo: number
  /**
   * Holder - register number
   */
  drzitelSupisneCislo: number
  /**
   * Owner - type id
   */
  vlastnikTypId: number
  /**
   * Owner - regob id
   */
  vlastnikRegobId: number
  /**
   * Owner - stay out of SR
   */
  vlastnikPobytMimoSrId: string
  /**
   * Holder - type id
   */
  drzitelTypId: number
  /**
   * Holder - regob id
   */
  drzitelRegobId: number
  /**
   * Holder - type of stay id
   */
  drzitelTypPobytuId: number
  /**
   * Holder - stay out of SR status
   */
  drzitelMimoSrStat: string
  /**
   * Holder - stay out of SR
   */
  drzitelPobytMimoSr: string
  /**
   * Owner - type of stay id
   */
  vlastnikTypPobytuId: number
  /**
   * Holder - nationality id
   */
  drzitelStatnaPrislusnostId: number
  /**
   * Owner - nationality id
   */
  vlastnikStatnaPrislusnostId: number
  /**
   * Holder - door number id
   */
  drzitelVchodDomuId: number
  /**
   * Owner - door number id
   */
  vlastnikVchodDomuId: number
  /**
   * Holder - disclosure level id
   */
  drzitelStupenZverejneniaId: number
  /**
   * Owner - disclosure level id
   */
  vlastnikStupenZverejneniaId: number
}
export interface ResponseNEVProcessDocPropsDto {
  /**
   * Id
   */
  id: number
  /**
   * Vehicle id
   */
  vozidloId: number
  /**
   * Certificate of processing - date
   */
  dokladSpracovania: string
  /**
   * Certificate of processing - number
   */
  dokladSpracovaniaCislo: number
  /**
   * Certificate of processing - executor
   */
  dokladSpracovaniaVydal: string
}
export interface ResponseNEVSportHistLicensePropsDto {
  /**
   * Id
   */
  id: number
  /**
   * VehicleId
   */
  vozidloId: number
  /**
   * License date
   */
  preukazSportHistVozidlaDatum: string
  /**
   * License number
   */
  preukazSportHistVozidlaDatumCislo: string
  /**
   * License issued by
   */
  preukazSportHistVozidlaDatumVydal: string
}
export interface ResponseNEVTecDetailPropsDto {
  /**
   * Vehicle id
   */
  vozidloId: number
  /**
   * Vehicle type
   */
  druh: string
  /**
   * Vehicle category
   */
  kategoria: string
  /**
   * Factory brand
   */
  tovarenskaZnacka: string
  /**
   * Brand
   */
  znacka: string
  /**
   * Trade name
   */
  obchodnyNazov: string
  /**
   * Version
   */
  typVariantVerzia: string
  /**
   * Manufacturer
   */
  vyrobcaVozidla: string
  /**
   * Ts number
   */
  cisloTs: string
  /**
   * Ts date
   */
  datumTs: string
  /**
   * Engine manufacturer
   */
  vyrobcaMotora: string
  /**
   * Engine type
   */
  typMotora: string
  /**
   * Stroke
   */
  zdvih: number
  /**
   * Catalyst
   */
  katalyzator: string
  /**
   * Max power
   */
  maximalnyVykon: number
  /**
   * Operating speed
   */
  otacky: number
  /**
   * Fuel
   */
  druhPaliva: string
  /**
   * Power / weight
   */
  vykonHmotnost: string
  /**
   * Gearbox
   */
  prevodovka: string
  /**
   * Number of gears
   */
  prevodovkaStupne: number
  /**
   * Bodywork type
   */
  karoseriaDruh: string
  /**
   * Colour
   */
  farba: string
  /**
   * Additional colour
   */
  doplnkovaFarba: string
  /**
   * Additional colour type
   */
  doplnkovaFarbaDruh: string
  /**
   * Bodywork manufacturer
   */
  karoseriaVyrobca: string
  /**
   * Bodywork number
   */
  karoseriaVyrobneCislo: string
  /**
   * Number of seats
   */
  pocetSedenie: number
  /**
   * Number of emergency seats
   */
  pocetNudzove: number
  /**
   * Number of standing places?
   */
  pocetStatie: number
  /**
   * Number of sleeping seats
   */
  pocetLozka: number
  /**
   * Roof load
   */
  zatazenieStrechy: number
  /**
   * Cistern capacity
   */
  objemCisterny: number
  /**
   * Tank capacity
   */
  objemNadrze: number
  /**
   * Length
   */
  dlzka: number
  /**
   * Width
   */
  sirka: number
  /**
   * Height
   */
  vyska: number
  /**
   * Loading area length
   */
  loznaPlochaDlzka: number
  /**
   * Loading area width
   */
  loznaPlochaSirka: number
  /**
   * Weight
   */
  hmotnostPrevadzkova: number
  /**
   * Max weight
   */
  hmotnostPripustna: number
  /**
   * Max weight per axle 1
   */
  hmotnostMaxNaprava1: number
  /**
   * Max weight per axle 2
   */
  hmotnostMaxNaprava2: number
  /**
   * Max weight per axle 3
   */
  hmotnostMaxNaprava3: number
  /**
   * Max weight per axle 4
   */
  hmotnostMaxNaprava4: number
  /**
   * Weight of set
   */
  hmotnostSupravy: number
  /**
   * Weight of towed vehicle with breaks
   */
  hmotnostPvozidlaBrzd: number
  /**
   * Weight of towed vehicle without breaks
   */
  hmotnostPvozidlaNebrzd: string
  /**
   * ABS
   */
  brzdaAbs: boolean
  /**
   * Break - something
   */
  brzdyEsEhk: string
  /**
   * Service break
   */
  brzdaPrevadzkova: boolean
  /**
   * Parking break
   */
  brzdaParkovacia: boolean
  /**
   * Lightening break
   */
  brzdaOdlahcovacia: boolean
  /**
   * Emergency break
   */
  brzdaNudzova: boolean
  /**
   * Number of axles
   */
  pocetNaprav: number
  /**
   * Axle 1 propulsion
   */
  pohonNaprava1: boolean
  /**
   * Axle 2 propulsion
   */
  pohonNaprava2: boolean
  /**
   * Axle 3 propulsion
   */
  pohonNaprava3: boolean
  /**
   * Axle 4 propulsion
   */
  pohonNaprava4: boolean
  /**
   * Wheelbase
   */
  razvor: number
  /**
   * Connecting device type
   */
  spajacieZariadenieTyp: string
  /**
   * Connecting device class
   */
  spajacieZariadenieTrieda: string
  /**
   * Connecting device H max weight
   */
  hzavesMaxHmotnost: number
  /**
   * Connecting device S max weight
   */
  szavesMaxHmotnost: number
  /**
   * Connecting device T max weight
   */
  tocnicaMaxHmostnost: number
  /**
   * Noise - standing
   */
  emisieZvukuStojace: number
  /**
   * Noise - driving
   */
  emisieZvukuJazda: number
  /**
   * Emission of CO2
   */
  emisieSpotrebaCo2: number
  /**
   * Emission of CO
   */
  emisieSpotrebaCo: number
  /**
   * Emission of HC
   */
  emisieSpotrebaHc: number
  /**
   * Emission of NOx
   */
  emisieSpotrebaNox: number
  /**
   * Emission of HC + NOx
   */
  emisieSpotrebaHcnox: number
  /**
   * Emission - particles
   */
  emisieSpotrebaCastice: number
  /**
   * Absorption of emissions
   */
  emisieSpotrebaAbsorbcia: number
  /**
   * Fuel consumption
   */
  spotrebaPaliva: number
  /**
   * Max speed
   */
  maxRychlost: number
  /**
   * Type of vehicle id
   */
  druhId: number
  /**
   * Category id
   */
  kategoriaId: number
  /**
   * Brand id
   */
  znackaId: number
  /**
   * Manufacturer id
   */
  vyrobcaVozidlaId: number
  /**
   * Engine manufacturer id
   */
  vyrobcaMotoraId: number
  /**
   * Catalyst id
   */
  katalyzatorId: number
  /**
   * Fuel id
   */
  druhPalivaId: number
  /**
   * Gearbox id
   */
  prevodovkaId: number
  /**
   * Bodywork id
   */
  karoseriaDruhId: number
  /**
   * Bodywork manufacturer id
   */
  karoseriaVyrobcaId: number
  /**
   * Colour id
   */
  farbaId: number
  /**
   * Additional colour id
   */
  doplnkovaFarbaId: number
  /**
   * Additional colour type id
   */
  doplnkovaFarbaDruhId: number
  /**
   * Engine number
   */
  cisloMotora: string
  /**
   * Wheel type
   */
  druhKolies: string
  /**
   * Wheel type id
   */
  druhKoliesId: number
  /**
   * Tires type - axle 1
   */
  druhPneuNaprava1: string
  /**
   * Tires type - axle 2
   */
  druhPneuNaprava2: string
  /**
   * Tires type - axle 3
   */
  druhPneuNaprava3: string
  /**
   * Tires type - axle 4
   */
  druhPneuNaprava4: string
  /**
   * Doubled axle 1
   */
  zdvojenaNaprava1: boolean
  /**
   * Doubled axle 2
   */
  zdvojenaNaprava2: boolean
  /**
   * Doubled axle 3
   */
  zdvojenaNaprava3: boolean
  /**
   * Doubled axle 4
   */
  zdvojenaNaprava4: boolean
  /**
   * Wheel rim - axle 1
   */
  rafikNaprava1: string
  /**
   * Wheel rim - axle 2
   */
  rafikNaprava2: string
  /**
   * Wheel rim - axle 3
   */
  rafikNaprava3: string
  /**
   * Wheel rim - axle 4
   */
  rafikNaprava4: string
  /**
   * Connecting device brand
   */
  spajacieZariadenieZnacka: string
  /**
   * Docking device certified brand
   */
  spajacieZariadenieSchvalZnacka: string
  /**
   * Noise
   */
  emisieZvuku: string
  /**
   * Noise - operating speed
   */
  emisieZvukuOtacky: number
  /**
   * Consumption
   */
  emisieSpotreba: string
  /**
   * Smoke emission
   */
  emisieSpotrebaDymivost: string
  /**
   * Type certification number
   */
  tsCisloKonania: string
  /**
   * Type certification ZTO
   */
  tsCisloZto: string
  /**
   * Type certification date
   */
  tsDatumKonania: string
  /**
   * Type certification - place of issue
   */
  tsMiestoVydania: string
  /**
   * Type certification - date of issue
   */
  tsDatumVydania: string
  /**
   * Type certification - validity date
   */
  tsPlatnost: string
  /**
   * Type certification - proceeding number
   */
  tsCisloJednania: string
  /**
   * Type certification - number of extension certificate
   */
  tsNadstavbaCisloOsvedcenia: string
  /**
   * Type certification - extension proceeding number
   */
  tsNadstavbaCisloKonania: string
  /**
   * Type certification - extension proceeding date
   */
  tsNadstavbaDatumKonania: string
  /**
   * Type certification - extension place of issue
   */
  tsNadstavbaMiestoVydania: string
  /**
   * Type certification - extension date of issue
   */
  tsNadstavbaDatumVydania: string
  /**
   * Type certification - number of certificate
   */
  tsCisloOsvedcenia: string
  /**
   * Extra equipment
   */
  zvlastnaVybava: string
  /**
   * Additional information
   */
  duzText: string
  /**
   * VIN
   */
  vin: string
  /**
   * Date of change
   */
  druhZmenyDatum: string
  /**
   * Type of change
   */
  druhZmeny: string
  /**
   * Limiter
   */
  obmedzovac: boolean
  /**
   * Fuel consumption - city
   */
  spotrebaPalivaMesto: number
  /**
   * Fuel consumption - out of city
   */
  spotrebaPalivaMimoMesto: number
  /**
   * Wheel base 2
   */
  razvor2: number
  /**
   * Wheel base 3
   */
  razvor3: number
  /**
   * Smoke emission id
   */
  emisieSpotrebaDymivostId: number
  /**
   * Consumption id
   */
  emisieSpotrebaId: number
  /**
   * Noise id
   */
  emisieZvukuId: number
  /**
   * CO unit measure id
   */
  mernaJednotkaCoId: number
  /**
   * HC unit measure id
   */
  mernaJednotkaHcId: number
  /**
   * NOx unit measure id
   */
  mernaJednotkaNoxId: number
  /**
   * Particles unit measure id
   */
  mernaJednotkaCasticeId: number
  /**
   * Breaks - noise id
   */
  brzdyEsEhkId: number
  /**
   * CO unit measure
   */
  mernaJednotkaCo: string
  /**
   * HC unit measure
   */
  mernaJednotkaHc: string
  /**
   * NOx unit measure
   */
  mernaJednotkaNox: string
  /**
   * Particles unit measure
   */
  mernaJednotkaCastice: string
}
export interface ResponseNEVTkEkDto {
  /**
   * Technical control
   */
  technickaKontrola: ResponseNEVTkEkPropsDto
  /**
   * Emision control
   */
  emisnaKontrola: ResponseNEVTkEkPropsDto
}
export interface ResponseNEVTkEkPropsDto {
  /**
   * Is control valid or not?
   */
  platna: boolean
  /**
   * Date of control
   */
  datumVykonania: string
  /**
   * Date of validity to
   */
  datumPlatnosti: string
  /**
   * Number of control certificate
   */
  cisloOsvedcenia: string
  /**
   * Number of sticker
   */
  cisloNalepky: string
  /**
   * Number of protocol
   */
  cisloProtokolu: string
  /**
   * Result of control in text
   */
  vysledok: string
  /**
   * Type of control
   */
  druhKontroly: string
  /**
   * Result of control, is shown when you send not valid ID or there is another error
   */
  resultTEKontrola?: string
}
export interface ResponseRaAddressDto {
  objectId: number
  zaciatokPlatnosti: string
  koniecPlatnosti: string
  ucinnost: string
  orientacneCislo: number
  identifikatorAdresy: number
  psc: string
  adresnyBodZemepisnaSirka: number
  adresnyBodZemepisnaDlzka: number
  budovaObjectId: number
  budova?: ResponseRaBuildingDto
  ulicaObjectId: number
  ulica?: ResponseRaStreetDto
}
export interface ResponseRaBuildingDto {
  objectId: number
  zaciatokPlatnosti: string
  koniecPlatnosti: string
  ucinnost: string
  ucelKodCiselnika: number
  ucelKodPolozky: number
  ucelNazov: string
  typKodCiselnika: number
  typKodPolozky: number
  typNazov: string
  maByty: boolean
  supisneCislo: number
  obecObjectId: number
  obec?: ResponseRaMunicipalityDto
  castObceObjectId: number
  castObce?: ResponseRaMunicipalityPartDto
}
export interface ResponseRaDistrictDto {
  objectId: number
  zaciatokPlatnosti: string
  koniecPlatnosti: string
  ucinnost: string
  kodPolozky: string
  kodCiselnika: string
  nazov: string
  krajObjectId: number
  kraj?: ResponseRaRegionDto
}
export interface ResponseRaMunicipalityDto {
  objectId: number
  zaciatokPlatnosti: string
  koniecPlatnosti: string
  ucinnost: string
  kodPolozky: string
  kodCiselnika: string
  nazov: string
  statutObce: string
  okresObjectId: number
  okres?: ResponseRaDistrictDto
}
export interface ResponseRaMunicipalityPartDto {
  objectId: number
  zaciatokPlatnosti: string
  koniecPlatnosti: string
  ucinnost: string
  kodPolozky: string
  kodCiselnika: string
  nazov: string
  obecObjectId: number
  obec?: ResponseRaMunicipalityDto
}
export interface ResponseRaRegionDto {
  objectId: number
  zaciatokPlatnosti: string
  koniecPlatnosti: string
  ucinnost: string
  kodPolozky: string
  kodCiselnika: string
  nazov: string
}
export interface ResponseRaStreetDto {
  objectId: number
  zaciatokPlatnosti: string
  koniecPlatnosti: string
  ucinnost: string
  nazov: string
  obecObjectId: number
  obec?: ResponseRaMunicipalityDto
  castObceObjectIds: Array<number>
  castiObce?: ResponseRaMunicipalityPartDto
}
export interface ResponseRfoDocPropsDto {
  /**
   * Document code
   */
  druhDokladuKod: number
  /**
   * Document type
   */
  druhDokladu: string
  /**
   * Document id
   */
  jednoznacnyIdentifikator: string
  /**
   * In possesion
   */
  udrzitela: boolean
}
export interface ResponseRfoFamilyMemberPropsDto {
  /**
   * Related person id
   */
  identifikatorVztahovejOsoby: string
  /**
   * Type of relationship - code
   */
  typRodinnehoVztahuKod: number
  /**
   * Type of relationship
   */
  typRodinnehoVztahu: string
  /**
   * Date of origin
   */
  datumVznikuVztahu: string
  /**
   * Marriage certificate - place of issue code
   */
  miestoVydaniaSobasnehoListuKod: string
  /**
   * Marriage certificate - place of issue
   */
  miestoVydaniaSobasnehoListu: string
  /**
   * Marriage certificate - place of issue out of country
   */
  miestoVydaniaSobasnehoListuMimoC: string
  /**
   * Related person relationship code
   */
  vztahRolaVztahovejOsobyKod: number
  /**
   * Related person relationship
   */
  vztahRolaVztahovejOsoby: string
  /**
   * Primary person relationship code
   */
  vztahRolaPrimarnejOsobyKod: number
  /**
   * Primary person relationship
   */
  vztahRolaPrimarnejOsoby: string
  /**
   * Marriage register code
   */
  sobasnaMatrikaKod: number
  /**
   * Marriage register
   */
  sobasnaMatrika: string
}
export interface ResponseRfoFamilyNamePropsDto {
  /**
   * Family name
   */
  rodnePriezvisko: string
  /**
   * Order - family name
   */
  poradieRodnehoPriezviska: number
}
export interface ResponseRfoForeignRegionsPropsDto {
  /**
   * Region order number
   */
  poradoveCisloRegionu: number
  /**
   * Name of the region
   */
  nazovRegionu: string
}
export interface ResponseRfoGivenNamePropsDto {
  /**
   * Given name
   */
  meno: string
  /**
   * Order - name
   */
  poradieMena: number
}
export interface ResponseRfoPersonDto {
  /**
   * Id
   */
  ifo: string
  /**
   *
   */
  identifikatorPravejOsoby: string
  /**
   * Birth number
   */
  rodneCislo: string
  /**
   * Date of birth
   */
  datumNarodenia: string
  /**
   * Place of birth - code
   */
  miestoNarodeniaKod: number
  /**
   * Place of birth
   */
  miestoNarodenia: string
  /**
   * Place of birth out of dial
   */
  miestoNarodeniaMimoCiselnika: string
  /**
   * Country of birth - code
   */
  statNarodeniaKod: number
  /**
   * Country of birth
   */
  statNarodenia: string
  /**
   * Sex - code
   */
  pohlavieOsobyKod: number
  /**
   * Sex
   */
  pohlavieOsoby: string
  /**
   * Marital status - code
   */
  rodinnyStavKod: number
  /**
   * Marital status
   */
  rodinnyStav: string
  /**
   * Birth register code
   */
  rodnaMatrikaKod: number
  /**
   * Birth register
   */
  rodnaMatrika: string
  /**
   * Nationality - code
   */
  narodnostKod?: number
  /**
   * Nationality
   */
  narodnost: string
  /**
   * Date of death
   */
  datumUmrtia: string
  /**
   * Place of death - code
   */
  miestoUmrtiaKod: number
  /**
   * Place of death
   */
  miestoUmrtia: string
  /**
   * Place of death out of dial
   */
  miestoUmrtiaMimoCiselnika: string
  /**
   * Death register code
   */
  umrtnaMatrikaKod: number
  /**
   * Death register
   */
  umrtnaMatrika: string
  /**
   * Country of death - code
   */
  statUmrtiaKod: number
  /**
   * Country of death
   */
  statUmrtia: string
  /**
   *
   */
  bifo: string
  /**
   * Status of person - code
   */
  typOsobyKod: number
  /**
   * Status of person
   */
  typOsoby: string
  /**
   * Region of birth - code
   */
  okresNarodeniaKod: number
  /**
   * Region of birth
   */
  okresNarodenia: string
  /**
   * Region of death - code
   */
  okresUmrtiaKod: number
  /**
   * Region of death
   */
  okresUmrtia: string
  /**
   * Foreigner id
   */
  identifikatorCudzinca: string
  /**
   * Disclosure level code
   */
  stupenZverejneniaUdajovKod: number
  /**
   * Disclosure level
   */
  stupenZverejneniaUdajov: string
  /**
   * Year of birth
   */
  rokNarodenia: number
  /**
   * Relationship termination date
   */
  datumUkonceniaVztahu: string
  /**
   * Cause of invalidity
   */
  dovodNeplatnosti: string
  /**
   * Person of interest
   */
  zaujmovaOsoba: boolean
  /**
   * Given names
   */
  menaOsoby: Array<ResponseRfoGivenNamePropsDto>
  /**
   * Surnames
   */
  priezviskaOsoby: Array<ResponseRfoSurnamePropsDto>
  /**
   * Family names
   */
  rodnePriezviskaOsoby: Array<ResponseRfoFamilyNamePropsDto>
  /**
   * Family members
   */
  rodinniPrislusnici: Array<ResponseRfoFamilyMemberPropsDto>
  /**
   * Stays
   */
  pobytyOsoby: Array<ResponseRfoStayPropsDto>
  /**
   * Documents
   */
  doklady: Array<ResponseRfoDocPropsDto>
}
export interface ResponseRfoPersonListDto {
  /**
   * list of persons with same birthNumber or query properties
   */
  items: Array<ResponseRfoPersonDto>
}
export interface ResponseRfoStayPropsDto {
  /**
   * Type of stay
   */
  typPobytu: number
  /**
   * Type of state out of dial
   */
  typPobytuMimoCiselnik: string
  /**
   * Stay register date
   */
  datumPrihlaseniaPobytu: string
  /**
   * Stay termination date
   */
  datumUkonceniaPobytu: string
  /**
   * Municipality
   */
  nazovObce: string
  /**
   * Register number
   */
  supisneCislo: number
  /**
   * District
   */
  nazovCastiObce: string
  /**
   * Region
   */
  nazovOkresu: string
  /**
   * Street
   */
  nazovUlice: string
  /**
   * Country - code
   */
  statMimoSr: number
  /**
   * Country
   */
  nazovStatu: string
  /**
   * Address out of SR
   */
  adresaMimoSr: string
  /**
   * Region out of SR
   */
  okresMimoSr: string
  /**
   * Municipality out of SR
   */
  obecMimoSr: string
  /**
   * District out of SR
   */
  castObceMimoSr: string
  /**
   * Street out of SR
   */
  ulicaMimoSr: string
  /**
   * Orientation number out of SR
   */
  orientacneCisloMimoSr: number
  /**
   * Register number out of SR
   */
  supisneCisloMimoSr: number
  /**
   * Location inside the building out of SR
   */
  urcenieMiestaVRamciBudovyMimoSr: string
  /**
   * Stay out of SR
   */
  pobytMimoSr: boolean
  /**
   * Index of building
   */
  indexDomu: string
  /**
   * Location inside the building
   */
  urcenieMiestaVRamciBudovy: string
  /**
   * Address id from address register
   */
  identifikatorAdresyRa: string
  /**
   * Doorway
   */
  vchodDomu: number
  /**
   * House
   */
  dom: number
  /**
   * Street
   */
  ulica: number
  /**
   * District
   */
  castObce: number
  /**
   * Municipality
   */
  obec: number
  /**
   * Region
   */
  okres: number
  /**
   * Orientation number
   */
  orientacneCislo: number
  /**
   * Foreign regions
   */
  regionyMimoSr: ResponseRfoForeignRegionsPropsDto
}
export interface ResponseRfoSurnamePropsDto {
  /**
   * Surname
   */
  priezvisko: string
  /**
   * Order - surname
   */
  poradiePriezviska: number
}
export interface ResponseRpoLegalPersonDto {
  ico?: string
  dic?: string
  icDph?: string
  ipo: string
  datumVzniku?: string
  datumZaniku?: string
  technickyDatumZmenyZaznamu?: string
  datumCasVytvorenia?: string
  datumCasZmeny: string
  essa2010?: CodelistDto
  skNaceHlavnaCinnost?: CodelistDto
  pravneFormy?: Array<CodelistWithHistory>
  mena?: NamesPropsDto
  alternativneMena?: Array<ValueWithHistory>
  inePravneSkutocnosti?: Array<CodelistWithHistory>
  pravneStavy?: Array<CodelistWithHistory>
  zdroj?: SourcePropsDto
  telefonneAdresy?: Array<PhoneAddressDto>
  internetoveAdresy?: Array<string>
  adresy?: Array<PhysicalAddress>
  externeIds?: Array<IdWithHistory>
  statutarneOrgany?: Array<StatutoryPropsDto>
  zainteresovaneOsoby?: Array<StakeholderDto>
  vklady?: Array<DepositDto>
  akcie?: Array<ShareDto>
  predmetyCinnosti?: Array<Activity>
  pravnyNastupcovia?: Array<PredecessorSuccessor>
  pravnyPredchodcovia?: Array<PredecessorSuccessor>
  opravneniaKonat?: Array<ValueWithHistory>
  organizacneJednotky?: Array<OrganizationUnitDto>
  bankoveSpojenia?: Array<BankConnectionDto>
  zakladneImania?: Equity
  externeRpoId: string
}
export interface ResponseRsdStateDto {
  /**
   * Is found or not found
   */
  result: ResponseRsdStateDtoResultEnum
  /**
   * Is severally disabled from
   */
  disabledFrom?: string
  /**
   * Is accompanying person for severally disabled
   */
  accompanyingPerson: boolean
}

export const ResponseRsdStateDtoResultEnum = {
  Found: 'found',
  NotFound: 'not_found',
} as const

export type ResponseRsdStateDtoResultEnum =
  (typeof ResponseRsdStateDtoResultEnum)[keyof typeof ResponseRsdStateDtoResultEnum]

export interface SearchGet200ResponseDto {
  /**
   * Zoznam nájdených PO
   */
  results: Array<SearchGet200ResponseResultsInnerDto>
  /**
   * Licenčné informácie
   */
  license?: string
}
export interface SearchGet200ResponseResultsInnerDto {
  /**
   * Jedinedinečný identifikátor záznamu
   */
  id: number
  /**
   * IČO
   */
  identifiers: Array<TimedValueEntryDto>
  /**
   * Plný názov PO
   */
  fullNames: Array<TimedValueEntryDto>
  /**
   * Adresa sídla PO
   */
  addresses: Array<AddressDto>
  /**
   * Dátum vzniku
   */
  establishment?: string
  /**
   * Dátum zániku
   */
  termination?: string
  /**
   * Source register
   */
  sourceRegister?: SearchGet200ResponseResultsInnerSourceRegisterDto
  /**
   * Dátum poslednej aktualizácie údajov o PO v databáze, t.j. kedy začala byť aktuálna verzia záznamu dostupná cez toto API.
   */
  dbModificationDate?: string
}
export interface SearchGet200ResponseResultsInnerSourceRegisterDto {
  /**
   * Value
   */
  value?: CodeValueDto
  /**
   * Registrátor / registrový úrad
   */
  registrationOffices?: Array<TimedValueEntryDto>
  /**
   * Registračné číslo
   */
  registrationNumbers?: Array<TimedValueEntryDto>
}
export interface ShareDto {
  podoba: string
  forma: string
  menovitaHodnota: string
  mnozstvo: string
  prevoditelnost: string
  mena: CodelistDto
  druh: CodelistDto
}
export interface SourcePropsDto {
  zdrojovySystemId?: number
  zdrojovyRegister?: CodelistDto
  registratori?: string
  registracneCisla?: string
}
export interface StakeholderDto {
  osoba: PersonDto
  typ: CodelistDto
  vklady: Array<DepositDto>
  akcie: Array<ShareDto>
}
export interface StakeholderSusrDto {
  /**
   * Stakeholder type
   */
  stakeholderType?: CodeValueDto
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
  /**
   * Adresa
   */
  address?: AddressDto
  /**
   * Person name
   */
  personName?: PersonNameDto
  /**
   * IČO (vypĺňa sa v prípade, ak je zainteresovaná osoba PO alebo organizačná zložka)
   */
  identifier?: string
  /**
   * Plný názov PO (vypĺňa sa v prípade, ak je zainteresovaná osoba PO alebo organizačná zložka)
   */
  fullName?: string
  /**
   * Dátum vzniku
   */
  establishment?: string
  /**
   * Dátum zániku
   */
  termination?: string
}
export interface StatutaryBodyDto {
  /**
   * Stakeholder type
   */
  stakeholderType?: CodeValueDto
  /**
   * Statutary body member
   */
  statutoryBodyMember?: CodeValueDto
  /**
   * Platnosť od
   */
  validFrom?: string
  /**
   * Platnosť do
   */
  validTo?: string
  /**
   * Adresa
   */
  address?: AddressDto
  /**
   * Person name
   */
  personName?: PersonNameDto
  /**
   * IČO (vypĺňa sa v prípade, ak je štatutár PO alebo organizačná zložka)
   */
  identifier?: string
  /**
   * Plný názov PO (vypĺňa sa v prípade, ak je štatutár PO alebo organizačná zložka)
   */
  fullName?: string
  /**
   * Dátum vzniku
   */
  establishment?: string
  /**
   * Dátum zániku
   */
  termination?: string
}
export interface StatutoryPropsDto {
  osoba: PersonDto
  typ: CodelistDto
}
export interface SurnamePropsDto {
  priezvisko: string
  priznakPrimarnehoPriezviska: boolean
  prefix: string
}
export interface TimedCodeValueEntryDto {
  /**
   * Hodnota s kódom
   */
  value?: CodeValueDto
  /**
   * Platnosť hodnoty od
   */
  validFrom?: string
  /**
   * Platnosť hodnoty do
   */
  validTo?: string
}
export interface TimedValueEntryDto {
  /**
   * Hodnota
   */
  value?: string
  /**
   * Platnosť hodnoty od
   */
  validFrom?: string
  /**
   * Platnosť hodnoty do
   */
  validTo?: string
}
export interface TitlesPropsDto {
  typ: string
  titul: string
  pozicia: string
}
export interface UnprocessableEntityErrorDto {
  /**
   * Status code
   */
  statusCode: object
  /**
   *
   */
  state: string
  /**
   * Error name
   */
  errorName: UnprocessableEntityErrorDtoErrorNameEnum
  /**
   *
   */
  type: string
  /**
   * Additional info
   */
  message: object
}

export const UnprocessableEntityErrorDtoErrorNameEnum = {
  DcomRequestError: 'DCOM_REQUEST_ERROR',
  ParserError: 'PARSER_ERROR',
  DcomNotfound: 'DCOM_NOTFOUND',
  InternalServerError: 'INTERNAL_SERVER_ERROR',
  MarkPersonError: 'MARK_PERSON_ERROR',
  UnprocessableEntity: 'UNPROCESSABLE_ENTITY',
} as const

export type UnprocessableEntityErrorDtoErrorNameEnum =
  (typeof UnprocessableEntityErrorDtoErrorNameEnum)[keyof typeof UnprocessableEntityErrorDtoErrorNameEnum]

export interface ValueWithHistory {
  priznakAktualnehoZaznamu: boolean
  platnostOd: string
  platnostDo: string
  hodnota: string
}

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Update or create data in rpo by file
     * @summary Load data to RPO
     * @param {Array<any>} [files] Required array of file/files with RPO (zip) data inside
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerInsertOrUpdateDataInRpo: async (
      files?: Array<any>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/rpo/data`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication Admin required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      if (files) {
        files.forEach((element) => {
          localVarFormParams.append('files', element as any)
        })
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
  return {
    /**
     * Update or create data in rpo by file
     * @summary Load data to RPO
     * @param {Array<any>} [files] Required array of file/files with RPO (zip) data inside
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerInsertOrUpdateDataInRpo(
      files?: Array<any>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerInsertOrUpdateDataInRpo(files, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerInsertOrUpdateDataInRpo']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration)
  return {
    /**
     * Update or create data in rpo by file
     * @summary Load data to RPO
     * @param {Array<any>} [files] Required array of file/files with RPO (zip) data inside
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerInsertOrUpdateDataInRpo(
      files?: Array<any>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerInsertOrUpdateDataInRpo(files, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
  /**
   * Update or create data in rpo by file
   * @summary Load data to RPO
   * @param {Array<any>} [files] Required array of file/files with RPO (zip) data inside
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerInsertOrUpdateDataInRpo(
    files?: Array<any>,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerInsertOrUpdateDataInRpo(files, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealth(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealth(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.appControllerHealth']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponseDto> {
      return localVarFp.appControllerHealth(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public appControllerHealth(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DeveloperApi - axios parameter creator
 */
export const DeveloperApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Create new test data exchange for RPO in rabbitMQ
     * @summary Test RabbitMQ RPO
     * @param {object} [data]
     * @param {Array<any>} [files] Required array of file/files with RPO/ RFO/ RA data inside
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    developerControllerPushRpoExchangeData: async (
      data?: object,
      files?: Array<any>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/dev/create-exchange-data-rabbitmq`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication Developer required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      if (data !== undefined) {
        localVarFormParams.append(
          'data',
          new Blob([JSON.stringify(data)], { type: 'application/json' }),
        )
      }
      if (files) {
        files.forEach((element) => {
          localVarFormParams.append('files', element as any)
        })
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DeveloperApi - functional programming interface
 */
export const DeveloperApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DeveloperApiAxiosParamCreator(configuration)
  return {
    /**
     * Create new test data exchange for RPO in rabbitMQ
     * @summary Test RabbitMQ RPO
     * @param {object} [data]
     * @param {Array<any>} [files] Required array of file/files with RPO/ RFO/ RA data inside
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async developerControllerPushRpoExchangeData(
      data?: object,
      files?: Array<any>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.developerControllerPushRpoExchangeData(data, files, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DeveloperApi.developerControllerPushRpoExchangeData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DeveloperApi - factory interface
 */
export const DeveloperApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DeveloperApiFp(configuration)
  return {
    /**
     * Create new test data exchange for RPO in rabbitMQ
     * @summary Test RabbitMQ RPO
     * @param {object} [data]
     * @param {Array<any>} [files] Required array of file/files with RPO/ RFO/ RA data inside
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    developerControllerPushRpoExchangeData(
      data?: object,
      files?: Array<any>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .developerControllerPushRpoExchangeData(data, files, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DeveloperApi - object-oriented interface
 */
export class DeveloperApi extends BaseAPI {
  /**
   * Create new test data exchange for RPO in rabbitMQ
   * @summary Test RabbitMQ RPO
   * @param {object} [data]
   * @param {Array<any>} [files] Required array of file/files with RPO/ RFO/ RA data inside
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public developerControllerPushRpoExchangeData(
    data?: object,
    files?: Array<any>,
    options?: RawAxiosRequestConfig,
  ) {
    return DeveloperApiFp(this.configuration)
      .developerControllerPushRpoExchangeData(data, files, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * KNKatasterNehnutenostApi - axios parameter creator
 */
export const KNKatasterNehnutenostApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} urlPath path of general call to \&quot;kataster\&quot; in base64, for example \&quot;/odata/ParcelsE/\&quot; is in base64 \&quot;L29kYXRhL1BhcmNlbHNFLw&#x3D;&#x3D;\&quot;
     * @param {string} query query of general call to \&quot;kataster\&quot; in base64, for example \&quot;&amp;$filter&#x3D;Municipality/Code%20eq%20&lt;kodeObce&gt;\&quot; is in base64 \&quot;JiRmaWx0ZXI9TXVuaWNpcGFsaXR5L0NvZGUlMjBlcSUyMDxrb2RlT2JjZT4&#x3D;\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    knControllerGeneralAgenda: async (
      urlPath: string,
      query: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'urlPath' is not null or undefined
      assertParamExists('knControllerGeneralAgenda', 'urlPath', urlPath)
      // verify required parameter 'query' is not null or undefined
      assertParamExists('knControllerGeneralAgenda', 'query', query)
      const localVarPath = `/kn/general-agenda`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (urlPath !== undefined) {
        localVarQueryParameter['urlPath'] = urlPath
      }

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find owners by property district, municipality and register number
     * @summary Found owners of given properties
     * @param {string} districName Name of district
     * @param {string} municipalityName Name of municipality (village, city)
     * @param {string} registerNumber Register Number - Súpisné číslo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    knControllerGetOwner: async (
      districName: string,
      municipalityName: string,
      registerNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'districName' is not null or undefined
      assertParamExists('knControllerGetOwner', 'districName', districName)
      // verify required parameter 'municipalityName' is not null or undefined
      assertParamExists('knControllerGetOwner', 'municipalityName', municipalityName)
      // verify required parameter 'registerNumber' is not null or undefined
      assertParamExists('knControllerGetOwner', 'registerNumber', registerNumber)
      const localVarPath = `/kn/find-owners/property`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (districName !== undefined) {
        localVarQueryParameter['districName'] = districName
      }

      if (municipalityName !== undefined) {
        localVarQueryParameter['municipalityName'] = municipalityName
      }

      if (registerNumber !== undefined) {
        localVarQueryParameter['registerNumber'] = registerNumber
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find properties by name of municipality, name, surname, date of birth
     * @summary Found properties by owner
     * @param {string} municipalityName Name of municipality (village, city)
     * @param {string} firstName First name
     * @param {string} surname Surname
     * @param {string} dateOfBirth Date of birth. (yyyy-mm-dd)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    knControllerGetProperties: async (
      municipalityName: string,
      firstName: string,
      surname: string,
      dateOfBirth: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'municipalityName' is not null or undefined
      assertParamExists('knControllerGetProperties', 'municipalityName', municipalityName)
      // verify required parameter 'firstName' is not null or undefined
      assertParamExists('knControllerGetProperties', 'firstName', firstName)
      // verify required parameter 'surname' is not null or undefined
      assertParamExists('knControllerGetProperties', 'surname', surname)
      // verify required parameter 'dateOfBirth' is not null or undefined
      assertParamExists('knControllerGetProperties', 'dateOfBirth', dateOfBirth)
      const localVarPath = `/kn/find-properties/owner`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (municipalityName !== undefined) {
        localVarQueryParameter['municipalityName'] = municipalityName
      }

      if (firstName !== undefined) {
        localVarQueryParameter['firstName'] = firstName
      }

      if (surname !== undefined) {
        localVarQueryParameter['surname'] = surname
      }

      if (dateOfBirth !== undefined) {
        localVarQueryParameter['dateOfBirth'] = dateOfBirth
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * KNKatasterNehnutenostApi - functional programming interface
 */
export const KNKatasterNehnutenostApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = KNKatasterNehnutenostApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} urlPath path of general call to \&quot;kataster\&quot; in base64, for example \&quot;/odata/ParcelsE/\&quot; is in base64 \&quot;L29kYXRhL1BhcmNlbHNFLw&#x3D;&#x3D;\&quot;
     * @param {string} query query of general call to \&quot;kataster\&quot; in base64, for example \&quot;&amp;$filter&#x3D;Municipality/Code%20eq%20&lt;kodeObce&gt;\&quot; is in base64 \&quot;JiRmaWx0ZXI9TXVuaWNpcGFsaXR5L0NvZGUlMjBlcSUyMDxrb2RlT2JjZT4&#x3D;\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async knControllerGeneralAgenda(
      urlPath: string,
      query: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseKNGetOwnersDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.knControllerGeneralAgenda(
        urlPath,
        query,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['KNKatasterNehnutenostApi.knControllerGeneralAgenda']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Find owners by property district, municipality and register number
     * @summary Found owners of given properties
     * @param {string} districName Name of district
     * @param {string} municipalityName Name of municipality (village, city)
     * @param {string} registerNumber Register Number - Súpisné číslo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async knControllerGetOwner(
      districName: string,
      municipalityName: string,
      registerNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseKNGetOwnersDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.knControllerGetOwner(
        districName,
        municipalityName,
        registerNumber,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['KNKatasterNehnutenostApi.knControllerGetOwner']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Find properties by name of municipality, name, surname, date of birth
     * @summary Found properties by owner
     * @param {string} municipalityName Name of municipality (village, city)
     * @param {string} firstName First name
     * @param {string} surname Surname
     * @param {string} dateOfBirth Date of birth. (yyyy-mm-dd)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async knControllerGetProperties(
      municipalityName: string,
      firstName: string,
      surname: string,
      dateOfBirth: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseKNGetPropertiesDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.knControllerGetProperties(
        municipalityName,
        firstName,
        surname,
        dateOfBirth,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['KNKatasterNehnutenostApi.knControllerGetProperties']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * KNKatasterNehnutenostApi - factory interface
 */
export const KNKatasterNehnutenostApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = KNKatasterNehnutenostApiFp(configuration)
  return {
    /**
     *
     * @param {string} urlPath path of general call to \&quot;kataster\&quot; in base64, for example \&quot;/odata/ParcelsE/\&quot; is in base64 \&quot;L29kYXRhL1BhcmNlbHNFLw&#x3D;&#x3D;\&quot;
     * @param {string} query query of general call to \&quot;kataster\&quot; in base64, for example \&quot;&amp;$filter&#x3D;Municipality/Code%20eq%20&lt;kodeObce&gt;\&quot; is in base64 \&quot;JiRmaWx0ZXI9TXVuaWNpcGFsaXR5L0NvZGUlMjBlcSUyMDxrb2RlT2JjZT4&#x3D;\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    knControllerGeneralAgenda(
      urlPath: string,
      query: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseKNGetOwnersDto> {
      return localVarFp
        .knControllerGeneralAgenda(urlPath, query, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Find owners by property district, municipality and register number
     * @summary Found owners of given properties
     * @param {string} districName Name of district
     * @param {string} municipalityName Name of municipality (village, city)
     * @param {string} registerNumber Register Number - Súpisné číslo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    knControllerGetOwner(
      districName: string,
      municipalityName: string,
      registerNumber: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseKNGetOwnersDto> {
      return localVarFp
        .knControllerGetOwner(districName, municipalityName, registerNumber, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Find properties by name of municipality, name, surname, date of birth
     * @summary Found properties by owner
     * @param {string} municipalityName Name of municipality (village, city)
     * @param {string} firstName First name
     * @param {string} surname Surname
     * @param {string} dateOfBirth Date of birth. (yyyy-mm-dd)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    knControllerGetProperties(
      municipalityName: string,
      firstName: string,
      surname: string,
      dateOfBirth: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseKNGetPropertiesDto> {
      return localVarFp
        .knControllerGetProperties(municipalityName, firstName, surname, dateOfBirth, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * KNKatasterNehnutenostApi - object-oriented interface
 */
export class KNKatasterNehnutenostApi extends BaseAPI {
  /**
   *
   * @param {string} urlPath path of general call to \&quot;kataster\&quot; in base64, for example \&quot;/odata/ParcelsE/\&quot; is in base64 \&quot;L29kYXRhL1BhcmNlbHNFLw&#x3D;&#x3D;\&quot;
   * @param {string} query query of general call to \&quot;kataster\&quot; in base64, for example \&quot;&amp;$filter&#x3D;Municipality/Code%20eq%20&lt;kodeObce&gt;\&quot; is in base64 \&quot;JiRmaWx0ZXI9TXVuaWNpcGFsaXR5L0NvZGUlMjBlcSUyMDxrb2RlT2JjZT4&#x3D;\&quot;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public knControllerGeneralAgenda(
    urlPath: string,
    query: string,
    options?: RawAxiosRequestConfig,
  ) {
    return KNKatasterNehnutenostApiFp(this.configuration)
      .knControllerGeneralAgenda(urlPath, query, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find owners by property district, municipality and register number
   * @summary Found owners of given properties
   * @param {string} districName Name of district
   * @param {string} municipalityName Name of municipality (village, city)
   * @param {string} registerNumber Register Number - Súpisné číslo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public knControllerGetOwner(
    districName: string,
    municipalityName: string,
    registerNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return KNKatasterNehnutenostApiFp(this.configuration)
      .knControllerGetOwner(districName, municipalityName, registerNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find properties by name of municipality, name, surname, date of birth
   * @summary Found properties by owner
   * @param {string} municipalityName Name of municipality (village, city)
   * @param {string} firstName First name
   * @param {string} surname Surname
   * @param {string} dateOfBirth Date of birth. (yyyy-mm-dd)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public knControllerGetProperties(
    municipalityName: string,
    firstName: string,
    surname: string,
    dateOfBirth: string,
    options?: RawAxiosRequestConfig,
  ) {
    return KNKatasterNehnutenostApiFp(this.configuration)
      .knControllerGetProperties(municipalityName, firstName, surname, dateOfBirth, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * NEVNrodnEvidenciaVozidielApi - axios parameter creator
 */
export const NEVNrodnEvidenciaVozidielApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Find control by VI (Id of car)
     * @summary Found state of technical and emision control
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerTechnicalEmisionControl: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('nevControllerTechnicalEmisionControl', 'id', id)
      const localVarPath = `/nev/tkek/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Display details of vehicle given by ECV
     * @summary Found vehicle by ECV
     * @param {string} ecv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByECV: async (
      ecv: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ecv' is not null or undefined
      assertParamExists('nevControllerVehicleByECV', 'ecv', ecv)
      const localVarPath = `/nev/vozidlo/ecv/{ecv}`.replace(
        `{${'ecv'}}`,
        encodeURIComponent(String(ecv)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Display details of vehicles given by their holder\'s birth number
     * @summary Found vehicles by their holder\'s birth number
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByHolderBirthNumber: async (
      birthNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('nevControllerVehicleByHolderBirthNumber', 'birthNumber', birthNumber)
      const localVarPath = `/nev/vozidlo/drzitel/rodnecislo/{birthNumber}`.replace(
        `{${'birthNumber'}}`,
        encodeURIComponent(String(birthNumber)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Display details of vehicles given by their holder\'s business id
     * @summary Found vehicles by their holder\'s business id
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByHolderICO: async (
      ico: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ico' is not null or undefined
      assertParamExists('nevControllerVehicleByHolderICO', 'ico', ico)
      const localVarPath = `/nev/vozidlo/drzitel/ico/{ico}`.replace(
        `{${'ico'}}`,
        encodeURIComponent(String(ico)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Display details of vehicles given by their owner\'s birth number
     * @summary Found vehicles by their owner\'s birth number
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByOwnerBirthNumber: async (
      birthNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('nevControllerVehicleByOwnerBirthNumber', 'birthNumber', birthNumber)
      const localVarPath = `/nev/vozidlo/vlastnik/rodnecislo/{birthNumber}`.replace(
        `{${'birthNumber'}}`,
        encodeURIComponent(String(birthNumber)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Display details of vehicles given by their owner\'s business id
     * @summary Found vehicles by their owner\'s business id
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByOwnerICO: async (
      ico: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ico' is not null or undefined
      assertParamExists('nevControllerVehicleByOwnerICO', 'ico', ico)
      const localVarPath = `/nev/vozidlo/vlastnik/ico/{ico}`.replace(
        `{${'ico'}}`,
        encodeURIComponent(String(ico)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NEVNrodnEvidenciaVozidielApi - functional programming interface
 */
export const NEVNrodnEvidenciaVozidielApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = NEVNrodnEvidenciaVozidielApiAxiosParamCreator(configuration)
  return {
    /**
     * Find control by VI (Id of car)
     * @summary Found state of technical and emision control
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nevControllerTechnicalEmisionControl(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseNEVTkEkDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.nevControllerTechnicalEmisionControl(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NEVNrodnEvidenciaVozidielApi.nevControllerTechnicalEmisionControl']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Display details of vehicle given by ECV
     * @summary Found vehicle by ECV
     * @param {string} ecv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nevControllerVehicleByECV(
      ecv: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseNEVMainDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nevControllerVehicleByECV(
        ecv,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NEVNrodnEvidenciaVozidielApi.nevControllerVehicleByECV']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Display details of vehicles given by their holder\'s birth number
     * @summary Found vehicles by their holder\'s birth number
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nevControllerVehicleByHolderBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseNEVMainDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.nevControllerVehicleByHolderBirthNumber(
          birthNumber,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'NEVNrodnEvidenciaVozidielApi.nevControllerVehicleByHolderBirthNumber'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Display details of vehicles given by their holder\'s business id
     * @summary Found vehicles by their holder\'s business id
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nevControllerVehicleByHolderICO(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseNEVMainDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nevControllerVehicleByHolderICO(
        ico,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NEVNrodnEvidenciaVozidielApi.nevControllerVehicleByHolderICO']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Display details of vehicles given by their owner\'s birth number
     * @summary Found vehicles by their owner\'s birth number
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nevControllerVehicleByOwnerBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseNEVMainDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.nevControllerVehicleByOwnerBirthNumber(birthNumber, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NEVNrodnEvidenciaVozidielApi.nevControllerVehicleByOwnerBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Display details of vehicles given by their owner\'s business id
     * @summary Found vehicles by their owner\'s business id
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nevControllerVehicleByOwnerICO(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseNEVMainDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nevControllerVehicleByOwnerICO(
        ico,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NEVNrodnEvidenciaVozidielApi.nevControllerVehicleByOwnerICO']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * NEVNrodnEvidenciaVozidielApi - factory interface
 */
export const NEVNrodnEvidenciaVozidielApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = NEVNrodnEvidenciaVozidielApiFp(configuration)
  return {
    /**
     * Find control by VI (Id of car)
     * @summary Found state of technical and emision control
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerTechnicalEmisionControl(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseNEVTkEkDto> {
      return localVarFp
        .nevControllerTechnicalEmisionControl(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Display details of vehicle given by ECV
     * @summary Found vehicle by ECV
     * @param {string} ecv
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByECV(
      ecv: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseNEVMainDto> {
      return localVarFp
        .nevControllerVehicleByECV(ecv, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Display details of vehicles given by their holder\'s birth number
     * @summary Found vehicles by their holder\'s birth number
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByHolderBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseNEVMainDto> {
      return localVarFp
        .nevControllerVehicleByHolderBirthNumber(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Display details of vehicles given by their holder\'s business id
     * @summary Found vehicles by their holder\'s business id
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByHolderICO(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseNEVMainDto> {
      return localVarFp
        .nevControllerVehicleByHolderICO(ico, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Display details of vehicles given by their owner\'s birth number
     * @summary Found vehicles by their owner\'s birth number
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByOwnerBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseNEVMainDto> {
      return localVarFp
        .nevControllerVehicleByOwnerBirthNumber(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Display details of vehicles given by their owner\'s business id
     * @summary Found vehicles by their owner\'s business id
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nevControllerVehicleByOwnerICO(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseNEVMainDto> {
      return localVarFp
        .nevControllerVehicleByOwnerICO(ico, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * NEVNrodnEvidenciaVozidielApi - object-oriented interface
 */
export class NEVNrodnEvidenciaVozidielApi extends BaseAPI {
  /**
   * Find control by VI (Id of car)
   * @summary Found state of technical and emision control
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nevControllerTechnicalEmisionControl(id: string, options?: RawAxiosRequestConfig) {
    return NEVNrodnEvidenciaVozidielApiFp(this.configuration)
      .nevControllerTechnicalEmisionControl(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Display details of vehicle given by ECV
   * @summary Found vehicle by ECV
   * @param {string} ecv
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nevControllerVehicleByECV(ecv: string, options?: RawAxiosRequestConfig) {
    return NEVNrodnEvidenciaVozidielApiFp(this.configuration)
      .nevControllerVehicleByECV(ecv, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Display details of vehicles given by their holder\'s birth number
   * @summary Found vehicles by their holder\'s birth number
   * @param {string} birthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nevControllerVehicleByHolderBirthNumber(
    birthNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return NEVNrodnEvidenciaVozidielApiFp(this.configuration)
      .nevControllerVehicleByHolderBirthNumber(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Display details of vehicles given by their holder\'s business id
   * @summary Found vehicles by their holder\'s business id
   * @param {string} ico
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nevControllerVehicleByHolderICO(ico: string, options?: RawAxiosRequestConfig) {
    return NEVNrodnEvidenciaVozidielApiFp(this.configuration)
      .nevControllerVehicleByHolderICO(ico, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Display details of vehicles given by their owner\'s birth number
   * @summary Found vehicles by their owner\'s birth number
   * @param {string} birthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nevControllerVehicleByOwnerBirthNumber(
    birthNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return NEVNrodnEvidenciaVozidielApiFp(this.configuration)
      .nevControllerVehicleByOwnerBirthNumber(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Display details of vehicles given by their owner\'s business id
   * @summary Found vehicles by their owner\'s business id
   * @param {string} ico
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nevControllerVehicleByOwnerICO(ico: string, options?: RawAxiosRequestConfig) {
    return NEVNrodnEvidenciaVozidielApiFp(this.configuration)
      .nevControllerVehicleByOwnerICO(ico, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RARegisterAdriesApi - axios parameter creator
 */
export const RARegisterAdriesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Find address by id
     * @param {string} identifikatorAdresy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindAddress: async (
      identifikatorAdresy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'identifikatorAdresy' is not null or undefined
      assertParamExists('raControllerFindAddress', 'identifikatorAdresy', identifikatorAdresy)
      const localVarPath = `/ra/adresy/identifikatorAdresy/{identifikatorAdresy}`.replace(
        `{${'identifikatorAdresy'}}`,
        encodeURIComponent(String(identifikatorAdresy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find district by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindDistricByCode: async (
      kodPolozky: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'kodPolozky' is not null or undefined
      assertParamExists('raControllerFindDistricByCode', 'kodPolozky', kodPolozky)
      const localVarPath = `/ra/okresy/kodPolozky/{kodPolozky}`.replace(
        `{${'kodPolozky'}}`,
        encodeURIComponent(String(kodPolozky)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find district by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindDistrictByName: async (
      nazov: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nazov' is not null or undefined
      assertParamExists('raControllerFindDistrictByName', 'nazov', nazov)
      const localVarPath = `/ra/okresy/nazov/{nazov}`.replace(
        `{${'nazov'}}`,
        encodeURIComponent(String(nazov)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find municiaplity by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindMunicipalityByCode: async (
      kodPolozky: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'kodPolozky' is not null or undefined
      assertParamExists('raControllerFindMunicipalityByCode', 'kodPolozky', kodPolozky)
      const localVarPath = `/ra/obce/kodPolozky/{kodPolozky}`.replace(
        `{${'kodPolozky'}}`,
        encodeURIComponent(String(kodPolozky)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find municipality by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindMunicipalityByName: async (
      nazov: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nazov' is not null or undefined
      assertParamExists('raControllerFindMunicipalityByName', 'nazov', nazov)
      const localVarPath = `/ra/obce/nazov/{nazov}`.replace(
        `{${'nazov'}}`,
        encodeURIComponent(String(nazov)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find municiaplity part by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindMunicipalityPartByName: async (
      nazov: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nazov' is not null or undefined
      assertParamExists('raControllerFindMunicipalityPartByName', 'nazov', nazov)
      const localVarPath = `/ra/castObce/nazov/{nazov}`.replace(
        `{${'nazov'}}`,
        encodeURIComponent(String(nazov)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find region by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindRegionByCode: async (
      kodPolozky: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'kodPolozky' is not null or undefined
      assertParamExists('raControllerFindRegionByCode', 'kodPolozky', kodPolozky)
      const localVarPath = `/ra/kraje/kodPolozky/{kodPolozky}`.replace(
        `{${'kodPolozky'}}`,
        encodeURIComponent(String(kodPolozky)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find region by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindRegionByName: async (
      nazov: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nazov' is not null or undefined
      assertParamExists('raControllerFindRegionByName', 'nazov', nazov)
      const localVarPath = `/ra/kraje/nazov/{nazov}`.replace(
        `{${'nazov'}}`,
        encodeURIComponent(String(nazov)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Find street by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindStreetByName: async (
      nazov: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nazov' is not null or undefined
      assertParamExists('raControllerFindStreetByName', 'nazov', nazov)
      const localVarPath = `/ra/ulice/nazov/{nazov}`.replace(
        `{${'nazov'}}`,
        encodeURIComponent(String(nazov)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find addresses using text filter. Optionally, change number of returned records or set flag for detailed response. If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
     * @summary Find addresses from MINV RA API.
     * @param {string} text Address search filter.
     * @param {number} [size] Maximum number of returned records.
     * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerGetAddressList: async (
      text: string,
      size?: number,
      getDetail?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'text' is not null or undefined
      assertParamExists('raControllerGetAddressList', 'text', text)
      const localVarPath = `/ra/address`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (getDetail !== undefined) {
        localVarQueryParameter['getDetail'] = getDetail
      }

      if (text !== undefined) {
        localVarQueryParameter['text'] = text
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Find addresses from area given by point and radius. Optionally, change number of returned records or set flag for detailed response.If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
     * @summary Find addresses from MINV RA API using GPS location.
     * @param {number} lat Latitude.
     * @param {number} lon Longitude.
     * @param {number} [size] Maximum number of returned records.
     * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
     * @param {number} [tolerance] Radius of circle in meters with center at [lon, lat] coordinates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerGetAddressListFromPoint: async (
      lat: number,
      lon: number,
      size?: number,
      getDetail?: boolean,
      tolerance?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'lat' is not null or undefined
      assertParamExists('raControllerGetAddressListFromPoint', 'lat', lat)
      // verify required parameter 'lon' is not null or undefined
      assertParamExists('raControllerGetAddressListFromPoint', 'lon', lon)
      const localVarPath = `/ra/address-from-point`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (getDetail !== undefined) {
        localVarQueryParameter['getDetail'] = getDetail
      }

      if (lat !== undefined) {
        localVarQueryParameter['lat'] = lat
      }

      if (lon !== undefined) {
        localVarQueryParameter['lon'] = lon
      }

      if (tolerance !== undefined) {
        localVarQueryParameter['tolerance'] = tolerance
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Load all districts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadDistricts: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ra/okresy`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Load all municipalities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadMunicipalities: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ra/obce`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Load all municipality parts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadMunicipalityParts: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/ra/castObce`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Load all regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/ra/kraje`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RARegisterAdriesApi - functional programming interface
 */
export const RARegisterAdriesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RARegisterAdriesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Find address by id
     * @param {string} identifikatorAdresy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindAddress(
      identifikatorAdresy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaAddressDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindAddress(
        identifikatorAdresy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindAddress']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find district by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindDistricByCode(
      kodPolozky: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaDistrictDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindDistricByCode(
        kodPolozky,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindDistricByCode']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find district by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindDistrictByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaDistrictDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindDistrictByName(
        nazov,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindDistrictByName']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find municiaplity by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindMunicipalityByCode(
      kodPolozky: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaMunicipalityDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindMunicipalityByCode(
        kodPolozky,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindMunicipalityByCode']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find municipality by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindMunicipalityByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaMunicipalityDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindMunicipalityByName(
        nazov,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindMunicipalityByName']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find municiaplity part by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindMunicipalityPartByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaMunicipalityPartDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.raControllerFindMunicipalityPartByName(nazov, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindMunicipalityPartByName']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find region by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindRegionByCode(
      kodPolozky: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaRegionDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindRegionByCode(
        kodPolozky,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindRegionByCode']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find region by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindRegionByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaRegionDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindRegionByName(
        nazov,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindRegionByName']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Find street by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerFindStreetByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRaStreetDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerFindStreetByName(
        nazov,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerFindStreetByName']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Find addresses using text filter. Optionally, change number of returned records or set flag for detailed response. If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
     * @summary Find addresses from MINV RA API.
     * @param {string} text Address search filter.
     * @param {number} [size] Maximum number of returned records.
     * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerGetAddressList(
      text: string,
      size?: number,
      getDetail?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressDetailDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerGetAddressList(
        text,
        size,
        getDetail,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerGetAddressList']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Find addresses from area given by point and radius. Optionally, change number of returned records or set flag for detailed response.If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
     * @summary Find addresses from MINV RA API using GPS location.
     * @param {number} lat Latitude.
     * @param {number} lon Longitude.
     * @param {number} [size] Maximum number of returned records.
     * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
     * @param {number} [tolerance] Radius of circle in meters with center at [lon, lat] coordinates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerGetAddressListFromPoint(
      lat: number,
      lon: number,
      size?: number,
      getDetail?: boolean,
      tolerance?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressDetailDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerGetAddressListFromPoint(
        lat,
        lon,
        size,
        getDetail,
        tolerance,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerGetAddressListFromPoint']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Load all districts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerLoadDistricts(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseRaDistrictDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerLoadDistricts(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerLoadDistricts']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Load all municipalities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerLoadMunicipalities(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseRaMunicipalityDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.raControllerLoadMunicipalities(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerLoadMunicipalities']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Load all municipality parts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerLoadMunicipalityParts(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ResponseRaMunicipalityPartDto>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.raControllerLoadMunicipalityParts(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerLoadMunicipalityParts']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Load all regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async raControllerLoadRegions(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponseRaRegionDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.raControllerLoadRegions(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RARegisterAdriesApi.raControllerLoadRegions']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * RARegisterAdriesApi - factory interface
 */
export const RARegisterAdriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RARegisterAdriesApiFp(configuration)
  return {
    /**
     *
     * @summary Find address by id
     * @param {string} identifikatorAdresy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindAddress(
      identifikatorAdresy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaAddressDto> {
      return localVarFp
        .raControllerFindAddress(identifikatorAdresy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find district by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindDistricByCode(
      kodPolozky: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaDistrictDto> {
      return localVarFp
        .raControllerFindDistricByCode(kodPolozky, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find district by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindDistrictByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaDistrictDto> {
      return localVarFp
        .raControllerFindDistrictByName(nazov, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find municiaplity by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindMunicipalityByCode(
      kodPolozky: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaMunicipalityDto> {
      return localVarFp
        .raControllerFindMunicipalityByCode(kodPolozky, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find municipality by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindMunicipalityByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaMunicipalityDto> {
      return localVarFp
        .raControllerFindMunicipalityByName(nazov, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find municiaplity part by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindMunicipalityPartByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaMunicipalityPartDto> {
      return localVarFp
        .raControllerFindMunicipalityPartByName(nazov, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find region by code value
     * @param {string} kodPolozky
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindRegionByCode(
      kodPolozky: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaRegionDto> {
      return localVarFp
        .raControllerFindRegionByCode(kodPolozky, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find region by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindRegionByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaRegionDto> {
      return localVarFp
        .raControllerFindRegionByName(nazov, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Find street by name
     * @param {string} nazov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerFindStreetByName(
      nazov: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRaStreetDto> {
      return localVarFp
        .raControllerFindStreetByName(nazov, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Find addresses using text filter. Optionally, change number of returned records or set flag for detailed response. If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
     * @summary Find addresses from MINV RA API.
     * @param {string} text Address search filter.
     * @param {number} [size] Maximum number of returned records.
     * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerGetAddressList(
      text: string,
      size?: number,
      getDetail?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<AddressDetailDto>> {
      return localVarFp
        .raControllerGetAddressList(text, size, getDetail, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Find addresses from area given by point and radius. Optionally, change number of returned records or set flag for detailed response.If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
     * @summary Find addresses from MINV RA API using GPS location.
     * @param {number} lat Latitude.
     * @param {number} lon Longitude.
     * @param {number} [size] Maximum number of returned records.
     * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
     * @param {number} [tolerance] Radius of circle in meters with center at [lon, lat] coordinates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerGetAddressListFromPoint(
      lat: number,
      lon: number,
      size?: number,
      getDetail?: boolean,
      tolerance?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<AddressDetailDto>> {
      return localVarFp
        .raControllerGetAddressListFromPoint(lat, lon, size, getDetail, tolerance, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Load all districts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadDistricts(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ResponseRaDistrictDto>> {
      return localVarFp
        .raControllerLoadDistricts(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Load all municipalities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadMunicipalities(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ResponseRaMunicipalityDto>> {
      return localVarFp
        .raControllerLoadMunicipalities(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Load all municipality parts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadMunicipalityParts(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ResponseRaMunicipalityPartDto>> {
      return localVarFp
        .raControllerLoadMunicipalityParts(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Load all regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    raControllerLoadRegions(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ResponseRaRegionDto>> {
      return localVarFp.raControllerLoadRegions(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * RARegisterAdriesApi - object-oriented interface
 */
export class RARegisterAdriesApi extends BaseAPI {
  /**
   *
   * @summary Find address by id
   * @param {string} identifikatorAdresy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindAddress(identifikatorAdresy: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindAddress(identifikatorAdresy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find district by code value
   * @param {string} kodPolozky
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindDistricByCode(kodPolozky: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindDistricByCode(kodPolozky, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find district by name
   * @param {string} nazov
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindDistrictByName(nazov: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindDistrictByName(nazov, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find municiaplity by code value
   * @param {string} kodPolozky
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindMunicipalityByCode(kodPolozky: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindMunicipalityByCode(kodPolozky, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find municipality by name
   * @param {string} nazov
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindMunicipalityByName(nazov: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindMunicipalityByName(nazov, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find municiaplity part by name
   * @param {string} nazov
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindMunicipalityPartByName(nazov: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindMunicipalityPartByName(nazov, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find region by code value
   * @param {string} kodPolozky
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindRegionByCode(kodPolozky: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindRegionByCode(kodPolozky, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find region by name
   * @param {string} nazov
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindRegionByName(nazov: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindRegionByName(nazov, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Find street by name
   * @param {string} nazov
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerFindStreetByName(nazov: string, options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerFindStreetByName(nazov, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find addresses using text filter. Optionally, change number of returned records or set flag for detailed response. If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
   * @summary Find addresses from MINV RA API.
   * @param {string} text Address search filter.
   * @param {number} [size] Maximum number of returned records.
   * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerGetAddressList(
    text: string,
    size?: number,
    getDetail?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerGetAddressList(text, size, getDetail, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Find addresses from area given by point and radius. Optionally, change number of returned records or set flag for detailed response.If `getDetail` flag is set to `true` and service is unable to get address details, an error is thrown.
   * @summary Find addresses from MINV RA API using GPS location.
   * @param {number} lat Latitude.
   * @param {number} lon Longitude.
   * @param {number} [size] Maximum number of returned records.
   * @param {boolean} [getDetail] Controls if detailed information containing data such as postal code are returned.
   * @param {number} [tolerance] Radius of circle in meters with center at [lon, lat] coordinates.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerGetAddressListFromPoint(
    lat: number,
    lon: number,
    size?: number,
    getDetail?: boolean,
    tolerance?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerGetAddressListFromPoint(lat, lon, size, getDetail, tolerance, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Load all districts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerLoadDistricts(options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerLoadDistricts(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Load all municipalities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerLoadMunicipalities(options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerLoadMunicipalities(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Load all municipality parts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerLoadMunicipalityParts(options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerLoadMunicipalityParts(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Load all regions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public raControllerLoadRegions(options?: RawAxiosRequestConfig) {
    return RARegisterAdriesApiFp(this.configuration)
      .raControllerLoadRegions(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RFORegisterFyzickchOsbApi - axios parameter creator
 */
export const RFORegisterFyzickchOsbApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Information about a physical person given by birth number
     * @param {string} rodneCislo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetList: async (
      rodneCislo: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'rodneCislo' is not null or undefined
      assertParamExists('rfoControllerGetList', 'rodneCislo', rodneCislo)
      const localVarPath = `/rfo/rodneCislo/list/{rodneCislo}`.replace(
        `{${'rodneCislo'}}`,
        encodeURIComponent(String(rodneCislo)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a physical person given by birth number
     * @param {string} rodneCislo
     * @param {RfoControllerGetOneGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOne: async (
      rodneCislo: string,
      getFromDatabase?: RfoControllerGetOneGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneUpdateInDatabaseEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'rodneCislo' is not null or undefined
      assertParamExists('rfoControllerGetOne', 'rodneCislo', rodneCislo)
      const localVarPath = `/rfo/rodneCislo/{rodneCislo}`.replace(
        `{${'rodneCislo'}}`,
        encodeURIComponent(String(rodneCislo)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (getFromDatabase !== undefined) {
        localVarQueryParameter['getFromDatabase'] = getFromDatabase
      }

      if (updateInDatabase !== undefined) {
        localVarQueryParameter['updateInDatabase'] = updateInDatabase
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a physical person given by ifo
     * @param {string} ifo
     * @param {RfoControllerGetOneByIfoGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneByIfoUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneByIfo: async (
      ifo: string,
      getFromDatabase?: RfoControllerGetOneByIfoGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneByIfoUpdateInDatabaseEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ifo' is not null or undefined
      assertParamExists('rfoControllerGetOneByIfo', 'ifo', ifo)
      const localVarPath = `/rfo/ifo/{ifo}`.replace(`{${'ifo'}}`, encodeURIComponent(String(ifo)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (getFromDatabase !== undefined) {
        localVarQueryParameter['getFromDatabase'] = getFromDatabase
      }

      if (updateInDatabase !== undefined) {
        localVarQueryParameter['updateInDatabase'] = updateInDatabase
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a physical person based on name and birth date
     * @param {Array<string>} meno First name of the person
     * @param {Array<string>} priezvisko Second name of the person
     * @param {string} datumNarodenia Date of birth
     * @param {Array<string>} [rodnePriezvisko] Birth Second name of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneByListOfNames: async (
      meno: Array<string>,
      priezvisko: Array<string>,
      datumNarodenia: string,
      rodnePriezvisko?: Array<string>,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'meno' is not null or undefined
      assertParamExists('rfoControllerGetOneByListOfNames', 'meno', meno)
      // verify required parameter 'priezvisko' is not null or undefined
      assertParamExists('rfoControllerGetOneByListOfNames', 'priezvisko', priezvisko)
      // verify required parameter 'datumNarodenia' is not null or undefined
      assertParamExists('rfoControllerGetOneByListOfNames', 'datumNarodenia', datumNarodenia)
      const localVarPath = `/rfo/meno-priezvisko-datumnarodenia-list`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (rodnePriezvisko) {
        localVarQueryParameter['rodnePriezvisko'] = rodnePriezvisko
      }

      if (meno) {
        localVarQueryParameter['meno'] = meno
      }

      if (priezvisko) {
        localVarQueryParameter['priezvisko'] = priezvisko
      }

      if (datumNarodenia !== undefined) {
        localVarQueryParameter['datumNarodenia'] = datumNarodenia
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a physical person based on name and birth date
     * @param {string} meno
     * @param {string} priezvisko
     * @param {string} datumNarodenia
     * @param {RfoControllerGetOneByNameGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneByNameUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {string} [rodnePriezvisko]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneByName: async (
      meno: string,
      priezvisko: string,
      datumNarodenia: string,
      getFromDatabase?: RfoControllerGetOneByNameGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneByNameUpdateInDatabaseEnum,
      rodnePriezvisko?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'meno' is not null or undefined
      assertParamExists('rfoControllerGetOneByName', 'meno', meno)
      // verify required parameter 'priezvisko' is not null or undefined
      assertParamExists('rfoControllerGetOneByName', 'priezvisko', priezvisko)
      // verify required parameter 'datumNarodenia' is not null or undefined
      assertParamExists('rfoControllerGetOneByName', 'datumNarodenia', datumNarodenia)
      const localVarPath =
        `/rfo/meno-priezvisko-datumnarodenia/{meno}/{priezvisko}/{datumNarodenia}`
          .replace(`{${'meno'}}`, encodeURIComponent(String(meno)))
          .replace(`{${'priezvisko'}}`, encodeURIComponent(String(priezvisko)))
          .replace(`{${'datumNarodenia'}}`, encodeURIComponent(String(datumNarodenia)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (getFromDatabase !== undefined) {
        localVarQueryParameter['getFromDatabase'] = getFromDatabase
      }

      if (updateInDatabase !== undefined) {
        localVarQueryParameter['updateInDatabase'] = updateInDatabase
      }

      if (rodnePriezvisko !== undefined) {
        localVarQueryParameter['rodnePriezvisko'] = rodnePriezvisko
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a physical person based on birth number without cash database
     * @param {string} rodneCislo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneDcom: async (
      rodneCislo: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'rodneCislo' is not null or undefined
      assertParamExists('rfoControllerGetOneDcom', 'rodneCislo', rodneCislo)
      const localVarPath = `/rfo/rodneCislo/dcom/{rodneCislo}`.replace(
        `{${'rodneCislo'}}`,
        encodeURIComponent(String(rodneCislo)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Mark physical person as interesting based on ifo
     * @param {string} ifo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerMark: async (
      ifo: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ifo' is not null or undefined
      assertParamExists('rfoControllerMark', 'ifo', ifo)
      const localVarPath = `/rfo/oznacenie-zaujmovej-osoby/{ifo}`.replace(
        `{${'ifo'}}`,
        encodeURIComponent(String(ifo)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Unmark a physical person as interesting based on ifo
     * @param {string} ifo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerUnMark: async (
      ifo: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ifo' is not null or undefined
      assertParamExists('rfoControllerUnMark', 'ifo', ifo)
      const localVarPath = `/rfo/odznacenie-zaujmovej-ososby/{ifo}`.replace(
        `{${'ifo'}}`,
        encodeURIComponent(String(ifo)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RFORegisterFyzickchOsbApi - functional programming interface
 */
export const RFORegisterFyzickchOsbApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RFORegisterFyzickchOsbApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Information about a physical person given by birth number
     * @param {string} rodneCislo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerGetList(
      rodneCislo: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonListDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerGetList(
        rodneCislo,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerGetList']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a physical person given by birth number
     * @param {string} rodneCislo
     * @param {RfoControllerGetOneGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerGetOne(
      rodneCislo: string,
      getFromDatabase?: RfoControllerGetOneGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneUpdateInDatabaseEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerGetOne(
        rodneCislo,
        getFromDatabase,
        updateInDatabase,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerGetOne']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a physical person given by ifo
     * @param {string} ifo
     * @param {RfoControllerGetOneByIfoGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneByIfoUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerGetOneByIfo(
      ifo: string,
      getFromDatabase?: RfoControllerGetOneByIfoGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneByIfoUpdateInDatabaseEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerGetOneByIfo(
        ifo,
        getFromDatabase,
        updateInDatabase,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerGetOneByIfo']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a physical person based on name and birth date
     * @param {Array<string>} meno First name of the person
     * @param {Array<string>} priezvisko Second name of the person
     * @param {string} datumNarodenia Date of birth
     * @param {Array<string>} [rodnePriezvisko] Birth Second name of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerGetOneByListOfNames(
      meno: Array<string>,
      priezvisko: Array<string>,
      datumNarodenia: string,
      rodnePriezvisko?: Array<string>,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerGetOneByListOfNames(
        meno,
        priezvisko,
        datumNarodenia,
        rodnePriezvisko,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerGetOneByListOfNames']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a physical person based on name and birth date
     * @param {string} meno
     * @param {string} priezvisko
     * @param {string} datumNarodenia
     * @param {RfoControllerGetOneByNameGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneByNameUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {string} [rodnePriezvisko]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerGetOneByName(
      meno: string,
      priezvisko: string,
      datumNarodenia: string,
      getFromDatabase?: RfoControllerGetOneByNameGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneByNameUpdateInDatabaseEnum,
      rodnePriezvisko?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerGetOneByName(
        meno,
        priezvisko,
        datumNarodenia,
        getFromDatabase,
        updateInDatabase,
        rodnePriezvisko,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerGetOneByName']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a physical person based on birth number without cash database
     * @param {string} rodneCislo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerGetOneDcom(
      rodneCislo: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerGetOneDcom(
        rodneCislo,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerGetOneDcom']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Mark physical person as interesting based on ifo
     * @param {string} ifo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerMark(
      ifo: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerMark(ifo, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerMark']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Unmark a physical person as interesting based on ifo
     * @param {string} ifo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rfoControllerUnMark(
      ifo: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRfoPersonDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rfoControllerUnMark(ifo, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RFORegisterFyzickchOsbApi.rfoControllerUnMark']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * RFORegisterFyzickchOsbApi - factory interface
 */
export const RFORegisterFyzickchOsbApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RFORegisterFyzickchOsbApiFp(configuration)
  return {
    /**
     *
     * @summary Information about a physical person given by birth number
     * @param {string} rodneCislo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetList(
      rodneCislo: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonListDto> {
      return localVarFp
        .rfoControllerGetList(rodneCislo, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a physical person given by birth number
     * @param {string} rodneCislo
     * @param {RfoControllerGetOneGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOne(
      rodneCislo: string,
      getFromDatabase?: RfoControllerGetOneGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneUpdateInDatabaseEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonDto> {
      return localVarFp
        .rfoControllerGetOne(rodneCislo, getFromDatabase, updateInDatabase, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a physical person given by ifo
     * @param {string} ifo
     * @param {RfoControllerGetOneByIfoGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneByIfoUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneByIfo(
      ifo: string,
      getFromDatabase?: RfoControllerGetOneByIfoGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneByIfoUpdateInDatabaseEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonDto> {
      return localVarFp
        .rfoControllerGetOneByIfo(ifo, getFromDatabase, updateInDatabase, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a physical person based on name and birth date
     * @param {Array<string>} meno First name of the person
     * @param {Array<string>} priezvisko Second name of the person
     * @param {string} datumNarodenia Date of birth
     * @param {Array<string>} [rodnePriezvisko] Birth Second name of the person
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneByListOfNames(
      meno: Array<string>,
      priezvisko: Array<string>,
      datumNarodenia: string,
      rodnePriezvisko?: Array<string>,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonDto> {
      return localVarFp
        .rfoControllerGetOneByListOfNames(
          meno,
          priezvisko,
          datumNarodenia,
          rodnePriezvisko,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a physical person based on name and birth date
     * @param {string} meno
     * @param {string} priezvisko
     * @param {string} datumNarodenia
     * @param {RfoControllerGetOneByNameGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
     * @param {RfoControllerGetOneByNameUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
     * @param {string} [rodnePriezvisko]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneByName(
      meno: string,
      priezvisko: string,
      datumNarodenia: string,
      getFromDatabase?: RfoControllerGetOneByNameGetFromDatabaseEnum,
      updateInDatabase?: RfoControllerGetOneByNameUpdateInDatabaseEnum,
      rodnePriezvisko?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonDto> {
      return localVarFp
        .rfoControllerGetOneByName(
          meno,
          priezvisko,
          datumNarodenia,
          getFromDatabase,
          updateInDatabase,
          rodnePriezvisko,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a physical person based on birth number without cash database
     * @param {string} rodneCislo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerGetOneDcom(
      rodneCislo: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonDto> {
      return localVarFp
        .rfoControllerGetOneDcom(rodneCislo, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Mark physical person as interesting based on ifo
     * @param {string} ifo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerMark(
      ifo: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonDto> {
      return localVarFp.rfoControllerMark(ifo, options).then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Unmark a physical person as interesting based on ifo
     * @param {string} ifo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rfoControllerUnMark(
      ifo: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRfoPersonDto> {
      return localVarFp
        .rfoControllerUnMark(ifo, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RFORegisterFyzickchOsbApi - object-oriented interface
 */
export class RFORegisterFyzickchOsbApi extends BaseAPI {
  /**
   *
   * @summary Information about a physical person given by birth number
   * @param {string} rodneCislo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerGetList(rodneCislo: string, options?: RawAxiosRequestConfig) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerGetList(rodneCislo, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a physical person given by birth number
   * @param {string} rodneCislo
   * @param {RfoControllerGetOneGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
   * @param {RfoControllerGetOneUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerGetOne(
    rodneCislo: string,
    getFromDatabase?: RfoControllerGetOneGetFromDatabaseEnum,
    updateInDatabase?: RfoControllerGetOneUpdateInDatabaseEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerGetOne(rodneCislo, getFromDatabase, updateInDatabase, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a physical person given by ifo
   * @param {string} ifo
   * @param {RfoControllerGetOneByIfoGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
   * @param {RfoControllerGetOneByIfoUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerGetOneByIfo(
    ifo: string,
    getFromDatabase?: RfoControllerGetOneByIfoGetFromDatabaseEnum,
    updateInDatabase?: RfoControllerGetOneByIfoUpdateInDatabaseEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerGetOneByIfo(ifo, getFromDatabase, updateInDatabase, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a physical person based on name and birth date
   * @param {Array<string>} meno First name of the person
   * @param {Array<string>} priezvisko Second name of the person
   * @param {string} datumNarodenia Date of birth
   * @param {Array<string>} [rodnePriezvisko] Birth Second name of the person
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerGetOneByListOfNames(
    meno: Array<string>,
    priezvisko: Array<string>,
    datumNarodenia: string,
    rodnePriezvisko?: Array<string>,
    options?: RawAxiosRequestConfig,
  ) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerGetOneByListOfNames(meno, priezvisko, datumNarodenia, rodnePriezvisko, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a physical person based on name and birth date
   * @param {string} meno
   * @param {string} priezvisko
   * @param {string} datumNarodenia
   * @param {RfoControllerGetOneByNameGetFromDatabaseEnum} [getFromDatabase] check if exists in database, if yes, return him
   * @param {RfoControllerGetOneByNameUpdateInDatabaseEnum} [updateInDatabase] Check if is in persons if interests if not, add him and create in database, if yes, update in database
   * @param {string} [rodnePriezvisko]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerGetOneByName(
    meno: string,
    priezvisko: string,
    datumNarodenia: string,
    getFromDatabase?: RfoControllerGetOneByNameGetFromDatabaseEnum,
    updateInDatabase?: RfoControllerGetOneByNameUpdateInDatabaseEnum,
    rodnePriezvisko?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerGetOneByName(
        meno,
        priezvisko,
        datumNarodenia,
        getFromDatabase,
        updateInDatabase,
        rodnePriezvisko,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a physical person based on birth number without cash database
   * @param {string} rodneCislo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerGetOneDcom(rodneCislo: string, options?: RawAxiosRequestConfig) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerGetOneDcom(rodneCislo, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Mark physical person as interesting based on ifo
   * @param {string} ifo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerMark(ifo: string, options?: RawAxiosRequestConfig) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerMark(ifo, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Unmark a physical person as interesting based on ifo
   * @param {string} ifo
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rfoControllerUnMark(ifo: string, options?: RawAxiosRequestConfig) {
    return RFORegisterFyzickchOsbApiFp(this.configuration)
      .rfoControllerUnMark(ifo, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

export const RfoControllerGetOneGetFromDatabaseEnum = {
  True: 'true',
  False: 'false',
} as const
export type RfoControllerGetOneGetFromDatabaseEnum =
  (typeof RfoControllerGetOneGetFromDatabaseEnum)[keyof typeof RfoControllerGetOneGetFromDatabaseEnum]
export const RfoControllerGetOneUpdateInDatabaseEnum = {
  True: 'true',
  False: 'false',
} as const
export type RfoControllerGetOneUpdateInDatabaseEnum =
  (typeof RfoControllerGetOneUpdateInDatabaseEnum)[keyof typeof RfoControllerGetOneUpdateInDatabaseEnum]
export const RfoControllerGetOneByIfoGetFromDatabaseEnum = {
  True: 'true',
  False: 'false',
} as const
export type RfoControllerGetOneByIfoGetFromDatabaseEnum =
  (typeof RfoControllerGetOneByIfoGetFromDatabaseEnum)[keyof typeof RfoControllerGetOneByIfoGetFromDatabaseEnum]
export const RfoControllerGetOneByIfoUpdateInDatabaseEnum = {
  True: 'true',
  False: 'false',
} as const
export type RfoControllerGetOneByIfoUpdateInDatabaseEnum =
  (typeof RfoControllerGetOneByIfoUpdateInDatabaseEnum)[keyof typeof RfoControllerGetOneByIfoUpdateInDatabaseEnum]
export const RfoControllerGetOneByNameGetFromDatabaseEnum = {
  True: 'true',
  False: 'false',
} as const
export type RfoControllerGetOneByNameGetFromDatabaseEnum =
  (typeof RfoControllerGetOneByNameGetFromDatabaseEnum)[keyof typeof RfoControllerGetOneByNameGetFromDatabaseEnum]
export const RfoControllerGetOneByNameUpdateInDatabaseEnum = {
  True: 'true',
  False: 'false',
} as const
export type RfoControllerGetOneByNameUpdateInDatabaseEnum =
  (typeof RfoControllerGetOneByNameUpdateInDatabaseEnum)[keyof typeof RfoControllerGetOneByNameUpdateInDatabaseEnum]

/**
 * RPORegisterPrvnickchOsbApi - axios parameter creator
 */
export const RPORegisterPrvnickchOsbApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Returns array of legal persons (basic info) from SUSR RPO API.
     * @param {string} fullName FULLTEXT search, for more info please refer to: https://susrrpo.docs.apiary.io/#/reference/0/vyhladavanie-po
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rpoControllerFindLegalPersonsByFullNameFromApi: async (
      fullName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fullName' is not null or undefined
      assertParamExists('rpoControllerFindLegalPersonsByFullNameFromApi', 'fullName', fullName)
      const localVarPath = `/rpo/susr/search`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (fullName !== undefined) {
        localVarQueryParameter['fullName'] = fullName
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPerson: async (
      ico: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ico' is not null or undefined
      assertParamExists('rpoControllerGetLegalPerson', 'ico', ico)
      const localVarPath = `/rpo/{ico}`.replace(`{${'ico'}}`, encodeURIComponent(String(ico)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonBase: async (
      ico: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ico' is not null or undefined
      assertParamExists('rpoControllerGetLegalPersonBase', 'ico', ico)
      const localVarPath = `/rpo/base/{ico}`.replace(`{${'ico'}}`, encodeURIComponent(String(ico)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonBase_1: async (
      ico: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ico' is not null or undefined
      assertParamExists('rpoControllerGetLegalPersonBase_1', 'ico', ico)
      const localVarPath = `/rpo/base/ico/{ico}`.replace(
        `{${'ico'}}`,
        encodeURIComponent(String(ico)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Returns basic information and detail (optional) about a legal person from SUSR RPO API
     * @param {string} ico
     * @param {boolean} [returnDetail] If false, response won\&#39;t include detail of the legal person. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonByIcoFromApi: async (
      ico: string,
      returnDetail?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ico' is not null or undefined
      assertParamExists('rpoControllerGetLegalPersonByIcoFromApi', 'ico', ico)
      const localVarPath = `/rpo/susr/{ico}`.replace(`{${'ico'}}`, encodeURIComponent(String(ico)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (returnDetail !== undefined) {
        localVarQueryParameter['returnDetail'] = returnDetail
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Returns legal person detail (all info) from SUSR RPO API
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonDetailFromAPI: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('rpoControllerGetLegalPersonDetailFromAPI', 'id', id)
      const localVarPath = `/rpo/susr/detail/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPerson_2: async (
      ico: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'ico' is not null or undefined
      assertParamExists('rpoControllerGetLegalPerson_2', 'ico', ico)
      const localVarPath = `/rpo/ico/{ico}`.replace(`{${'ico'}}`, encodeURIComponent(String(ico)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RPORegisterPrvnickchOsbApi - functional programming interface
 */
export const RPORegisterPrvnickchOsbApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RPORegisterPrvnickchOsbApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Returns array of legal persons (basic info) from SUSR RPO API.
     * @param {string} fullName FULLTEXT search, for more info please refer to: https://susrrpo.docs.apiary.io/#/reference/0/vyhladavanie-po
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rpoControllerFindLegalPersonsByFullNameFromApi(
      fullName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchGet200ResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.rpoControllerFindLegalPersonsByFullNameFromApi(
          fullName,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'RPORegisterPrvnickchOsbApi.rpoControllerFindLegalPersonsByFullNameFromApi'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async rpoControllerGetLegalPerson(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRpoLegalPersonDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rpoControllerGetLegalPerson(
        ico,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RPORegisterPrvnickchOsbApi.rpoControllerGetLegalPerson']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async rpoControllerGetLegalPersonBase(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRpoLegalPersonDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rpoControllerGetLegalPersonBase(
        ico,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RPORegisterPrvnickchOsbApi.rpoControllerGetLegalPersonBase']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async rpoControllerGetLegalPersonBase_1(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRpoLegalPersonDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rpoControllerGetLegalPersonBase_1(
        ico,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RPORegisterPrvnickchOsbApi.rpoControllerGetLegalPersonBase_1']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Returns basic information and detail (optional) about a legal person from SUSR RPO API
     * @param {string} ico
     * @param {boolean} [returnDetail] If false, response won\&#39;t include detail of the legal person. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rpoControllerGetLegalPersonByIcoFromApi(
      ico: string,
      returnDetail?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindOneByIcoFromApiResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.rpoControllerGetLegalPersonByIcoFromApi(
          ico,
          returnDetail,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RPORegisterPrvnickchOsbApi.rpoControllerGetLegalPersonByIcoFromApi']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Returns legal person detail (all info) from SUSR RPO API
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rpoControllerGetLegalPersonDetailFromAPI(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityIdGet200ResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.rpoControllerGetLegalPersonDetailFromAPI(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RPORegisterPrvnickchOsbApi.rpoControllerGetLegalPersonDetailFromAPI']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async rpoControllerGetLegalPerson_2(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRpoLegalPersonDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rpoControllerGetLegalPerson_2(
        ico,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RPORegisterPrvnickchOsbApi.rpoControllerGetLegalPerson_2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * RPORegisterPrvnickchOsbApi - factory interface
 */
export const RPORegisterPrvnickchOsbApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RPORegisterPrvnickchOsbApiFp(configuration)
  return {
    /**
     *
     * @summary Returns array of legal persons (basic info) from SUSR RPO API.
     * @param {string} fullName FULLTEXT search, for more info please refer to: https://susrrpo.docs.apiary.io/#/reference/0/vyhladavanie-po
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rpoControllerFindLegalPersonsByFullNameFromApi(
      fullName: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SearchGet200ResponseDto> {
      return localVarFp
        .rpoControllerFindLegalPersonsByFullNameFromApi(fullName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPerson(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRpoLegalPersonDto> {
      return localVarFp
        .rpoControllerGetLegalPerson(ico, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonBase(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRpoLegalPersonDto> {
      return localVarFp
        .rpoControllerGetLegalPersonBase(ico, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonBase_1(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRpoLegalPersonDto> {
      return localVarFp
        .rpoControllerGetLegalPersonBase_1(ico, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Returns basic information and detail (optional) about a legal person from SUSR RPO API
     * @param {string} ico
     * @param {boolean} [returnDetail] If false, response won\&#39;t include detail of the legal person. Default: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonByIcoFromApi(
      ico: string,
      returnDetail?: boolean,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FindOneByIcoFromApiResponse> {
      return localVarFp
        .rpoControllerGetLegalPersonByIcoFromApi(ico, returnDetail, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Returns legal person detail (all info) from SUSR RPO API
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPersonDetailFromAPI(
      id: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<EntityIdGet200ResponseDto> {
      return localVarFp
        .rpoControllerGetLegalPersonDetailFromAPI(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about a legal person
     * @param {string} ico
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rpoControllerGetLegalPerson_2(
      ico: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRpoLegalPersonDto> {
      return localVarFp
        .rpoControllerGetLegalPerson_2(ico, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RPORegisterPrvnickchOsbApi - object-oriented interface
 */
export class RPORegisterPrvnickchOsbApi extends BaseAPI {
  /**
   *
   * @summary Returns array of legal persons (basic info) from SUSR RPO API.
   * @param {string} fullName FULLTEXT search, for more info please refer to: https://susrrpo.docs.apiary.io/#/reference/0/vyhladavanie-po
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rpoControllerFindLegalPersonsByFullNameFromApi(
    fullName: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RPORegisterPrvnickchOsbApiFp(this.configuration)
      .rpoControllerFindLegalPersonsByFullNameFromApi(fullName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a legal person
   * @param {string} ico
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public rpoControllerGetLegalPerson(ico: string, options?: RawAxiosRequestConfig) {
    return RPORegisterPrvnickchOsbApiFp(this.configuration)
      .rpoControllerGetLegalPerson(ico, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a legal person
   * @param {string} ico
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public rpoControllerGetLegalPersonBase(ico: string, options?: RawAxiosRequestConfig) {
    return RPORegisterPrvnickchOsbApiFp(this.configuration)
      .rpoControllerGetLegalPersonBase(ico, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a legal person
   * @param {string} ico
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public rpoControllerGetLegalPersonBase_1(ico: string, options?: RawAxiosRequestConfig) {
    return RPORegisterPrvnickchOsbApiFp(this.configuration)
      .rpoControllerGetLegalPersonBase_1(ico, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Returns basic information and detail (optional) about a legal person from SUSR RPO API
   * @param {string} ico
   * @param {boolean} [returnDetail] If false, response won\&#39;t include detail of the legal person. Default: true
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rpoControllerGetLegalPersonByIcoFromApi(
    ico: string,
    returnDetail?: boolean,
    options?: RawAxiosRequestConfig,
  ) {
    return RPORegisterPrvnickchOsbApiFp(this.configuration)
      .rpoControllerGetLegalPersonByIcoFromApi(ico, returnDetail, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Returns legal person detail (all info) from SUSR RPO API
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rpoControllerGetLegalPersonDetailFromAPI(id: number, options?: RawAxiosRequestConfig) {
    return RPORegisterPrvnickchOsbApiFp(this.configuration)
      .rpoControllerGetLegalPersonDetailFromAPI(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about a legal person
   * @param {string} ico
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public rpoControllerGetLegalPerson_2(ico: string, options?: RawAxiosRequestConfig) {
    return RPORegisterPrvnickchOsbApiFp(this.configuration)
      .rpoControllerGetLegalPerson_2(ico, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RSDRegisterSocilnychDvokApi - axios parameter creator
 */
export const RSDRegisterSocilnychDvokApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Information about type of contributions
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rsdControllerContributions: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/rsd/contributions`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Information about state of severely disabled
     * @param {string} firstName First name (if is not known then send \&quot;?\&quot;)
     * @param {string} surname Surname
     * @param {string} toDate Is person disable to date
     * @param {string} [dateOfBirth] Date of birth. (yyyy-mm-dd)
     * @param {string} [birthNumber] Birth number in format without slash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rsdControllerState: async (
      firstName: string,
      surname: string,
      toDate: string,
      dateOfBirth?: string,
      birthNumber?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'firstName' is not null or undefined
      assertParamExists('rsdControllerState', 'firstName', firstName)
      // verify required parameter 'surname' is not null or undefined
      assertParamExists('rsdControllerState', 'surname', surname)
      // verify required parameter 'toDate' is not null or undefined
      assertParamExists('rsdControllerState', 'toDate', toDate)
      const localVarPath = `/rsd/severely-disabled-state`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (firstName !== undefined) {
        localVarQueryParameter['firstName'] = firstName
      }

      if (surname !== undefined) {
        localVarQueryParameter['surname'] = surname
      }

      if (dateOfBirth !== undefined) {
        localVarQueryParameter['dateOfBirth'] = dateOfBirth
      }

      if (birthNumber !== undefined) {
        localVarQueryParameter['birthNumber'] = birthNumber
      }

      if (toDate !== undefined) {
        localVarQueryParameter['toDate'] = toDate
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RSDRegisterSocilnychDvokApi - functional programming interface
 */
export const RSDRegisterSocilnychDvokApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RSDRegisterSocilnychDvokApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Information about type of contributions
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async rsdControllerContributions(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rsdControllerContributions(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RSDRegisterSocilnychDvokApi.rsdControllerContributions']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Information about state of severely disabled
     * @param {string} firstName First name (if is not known then send \&quot;?\&quot;)
     * @param {string} surname Surname
     * @param {string} toDate Is person disable to date
     * @param {string} [dateOfBirth] Date of birth. (yyyy-mm-dd)
     * @param {string} [birthNumber] Birth number in format without slash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rsdControllerState(
      firstName: string,
      surname: string,
      toDate: string,
      dateOfBirth?: string,
      birthNumber?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRsdStateDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.rsdControllerState(
        firstName,
        surname,
        toDate,
        dateOfBirth,
        birthNumber,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RSDRegisterSocilnychDvokApi.rsdControllerState']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * RSDRegisterSocilnychDvokApi - factory interface
 */
export const RSDRegisterSocilnychDvokApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RSDRegisterSocilnychDvokApiFp(configuration)
  return {
    /**
     *
     * @summary Information about type of contributions
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    rsdControllerContributions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .rsdControllerContributions(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Information about state of severely disabled
     * @param {string} firstName First name (if is not known then send \&quot;?\&quot;)
     * @param {string} surname Surname
     * @param {string} toDate Is person disable to date
     * @param {string} [dateOfBirth] Date of birth. (yyyy-mm-dd)
     * @param {string} [birthNumber] Birth number in format without slash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rsdControllerState(
      firstName: string,
      surname: string,
      toDate: string,
      dateOfBirth?: string,
      birthNumber?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseRsdStateDto> {
      return localVarFp
        .rsdControllerState(firstName, surname, toDate, dateOfBirth, birthNumber, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RSDRegisterSocilnychDvokApi - object-oriented interface
 */
export class RSDRegisterSocilnychDvokApi extends BaseAPI {
  /**
   *
   * @summary Information about type of contributions
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public rsdControllerContributions(options?: RawAxiosRequestConfig) {
    return RSDRegisterSocilnychDvokApiFp(this.configuration)
      .rsdControllerContributions(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Information about state of severely disabled
   * @param {string} firstName First name (if is not known then send \&quot;?\&quot;)
   * @param {string} surname Surname
   * @param {string} toDate Is person disable to date
   * @param {string} [dateOfBirth] Date of birth. (yyyy-mm-dd)
   * @param {string} [birthNumber] Birth number in format without slash
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public rsdControllerState(
    firstName: string,
    surname: string,
    toDate: string,
    dateOfBirth?: string,
    birthNumber?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RSDRegisterSocilnychDvokApiFp(this.configuration)
      .rsdControllerState(firstName, surname, toDate, dateOfBirth, birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
