diff --git a/node_modules/@rjsf/utils/dist/index.js b/node_modules/@rjsf/utils/dist/index.js
index 83872b9..cba9057 100644
--- a/node_modules/@rjsf/utils/dist/index.js
+++ b/node_modules/@rjsf/utils/dist/index.js
@@ -1181,35 +1181,39 @@ function computeDefaults(validator, rawSchema, {
   }
   switch (getSchemaType(schema)) {
     case "object": {
-      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc, key) => {
-        const computedDefault = computeDefaults(validator, (0, import_get7.default)(schema, [PROPERTIES_KEY, key]), {
-          rootSchema,
-          _recurseList,
-          experimental_defaultFormStateBehavior,
-          includeUndefinedValues: includeUndefinedValues === true,
-          parentDefaults: (0, import_get7.default)(defaults, [key]),
-          rawFormData: (0, import_get7.default)(formData, [key]),
-          required: schema.required?.includes(key)
-        });
-        maybeAddDefaultToObject(
-          acc,
-          key,
-          computedDefault,
-          includeUndefinedValues,
-          required,
-          schema.required,
-          experimental_defaultFormStateBehavior
-        );
-        return acc;
-      }, {});
-      if (schema.additionalProperties) {
-        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};
+      const retrievedSchema = ALL_OF_KEY in schema ? retrieveSchema(validator, schema, rootSchema, formData) : schema;
+      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(
+        (acc, key) => {
+          const computedDefault = computeDefaults(validator, (0, import_get7.default)(retrievedSchema, [PROPERTIES_KEY, key]), {
+            rootSchema,
+            _recurseList,
+            experimental_defaultFormStateBehavior,
+            includeUndefinedValues: includeUndefinedValues === true,
+            parentDefaults: (0, import_get7.default)(defaults, [key]),
+            rawFormData: (0, import_get7.default)(formData, [key]),
+            required: retrievedSchema.required?.includes(key)
+          });
+          maybeAddDefaultToObject(
+            acc,
+            key,
+            computedDefault,
+            includeUndefinedValues,
+            required,
+            retrievedSchema.required,
+            experimental_defaultFormStateBehavior
+          );
+          return acc;
+        },
+        {}
+      );
+      if (retrievedSchema.additionalProperties) {
+        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties) ? retrievedSchema.additionalProperties : {};
         const keys = /* @__PURE__ */ new Set();
         if (isObject(defaults)) {
-          Object.keys(defaults).filter((key) => !schema.properties || !schema.properties[key]).forEach((key) => keys.add(key));
+          Object.keys(defaults).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => keys.add(key));
         }
         const formDataRequired = [];
-        Object.keys(formData).filter((key) => !schema.properties || !schema.properties[key]).forEach((key) => {
+        Object.keys(formData).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => {
           keys.add(key);
           formDataRequired.push(key);
         });
@@ -1221,7 +1225,7 @@ function computeDefaults(validator, rawSchema, {
             includeUndefinedValues: includeUndefinedValues === true,
             parentDefaults: (0, import_get7.default)(defaults, [key]),
             rawFormData: (0, import_get7.default)(formData, [key]),
-            required: schema.required?.includes(key)
+            required: retrievedSchema.required?.includes(key)
           });
           maybeAddDefaultToObject(
             objectDefaults,
@@ -1236,8 +1240,9 @@ function computeDefaults(validator, rawSchema, {
       return objectDefaults;
     }
     case "array": {
-      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "never";
-      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "requiredOnly";
+      const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+      const neverPopulate = arrayMinItems?.populate === "never";
+      const ignoreMinItemsFlagSet = arrayMinItems?.populate === "requiredOnly";
       if (Array.isArray(defaults)) {
         defaults = defaults.map((item, idx) => {
           const schemaItem = getInnerSchemaForArrayItem(schema, 2 /* Fallback */, idx);
@@ -1308,7 +1313,8 @@ function getDefaultFormState(validator, theSchema, formData, rootSchema, include
   if (formData === void 0 || formData === null || typeof formData === "number" && isNaN(formData)) {
     return defaults;
   }
-  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+  const { mergeExtraDefaults } = arrayMinItems || {};
   if (isObject(formData)) {
     return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
   }
diff --git a/node_modules/@rjsf/utils/dist/index.js.map b/node_modules/@rjsf/utils/dist/index.js.map
index 435c6bd..b783e50 100644
--- a/node_modules/@rjsf/utils/dist/index.js.map
+++ b/node_modules/@rjsf/utils/dist/index.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../src/index.ts", "../src/isObject.ts", "../src/allowAdditionalItems.ts", "../src/asNumber.ts", "../src/constants.ts", "../src/getUiOptions.ts", "../src/canExpand.ts", "../src/createErrorHandler.ts", "../src/deepEquals.ts", "../src/schema/getDefaultFormState.ts", "../src/findSchemaDefinition.ts", "../src/schema/getClosestMatchingOption.ts", "../src/schema/getMatchingOption.ts", "../src/getOptionMatchingSimpleDiscriminator.ts", "../src/schema/getFirstMatchingOption.ts", "../src/schema/retrieveSchema.ts", "../src/getDiscriminatorFieldFromSchema.ts", "../src/guessType.ts", "../src/mergeSchemas.ts", "../src/getSchemaType.ts", "../src/isFixedItems.ts", "../src/mergeDefaultsWithFormData.ts", "../src/mergeObjects.ts", "../src/isConstant.ts", "../src/schema/isSelect.ts", "../src/schema/isMultiSelect.ts", "../src/isCustomWidget.ts", "../src/schema/isFilesArray.ts", "../src/schema/getDisplayLabel.ts", "../src/schema/mergeValidationData.ts", "../src/schema/sanitizeDataForNewSchema.ts", "../src/schema/toIdSchema.ts", "../src/schema/toPathSchema.ts", "../src/createSchemaUtils.ts", "../src/dataURItoBlob.ts", "../src/replaceStringParameters.ts", "../src/englishStringTranslator.ts", "../src/enumOptionsDeselectValue.ts", "../src/enumOptionsValueForIndex.ts", "../src/enumOptionsIsSelected.ts", "../src/enumOptionsIndexForValue.ts", "../src/enumOptionsSelectValue.ts", "../src/ErrorSchemaBuilder.ts", "../src/rangeSpec.ts", "../src/getInputProps.ts", "../src/getSubmitButtonOptions.ts", "../src/getTemplate.ts", "../src/getWidget.tsx", "../src/hashForSchema.ts", "../src/hasWidget.ts", "../src/idGenerators.ts", "../src/labelValue.ts", "../src/localToUTC.ts", "../src/toConstant.ts", "../src/optionsList.ts", "../src/orderProperties.ts", "../src/pad.ts", "../src/parseDateString.ts", "../src/schemaRequiresTrueValue.ts", "../src/shouldRender.ts", "../src/toDateString.ts", "../src/toErrorList.ts", "../src/toErrorSchema.ts", "../src/unwrapErrorHandler.ts", "../src/utcToLocal.ts", "../src/validationDataMerge.ts", "../src/withIdRefPrefix.ts", "../src/enums.ts", "../src/parser/schemaParser.ts", "../src/parser/ParserValidator.ts"],
-  "sourcesContent": ["import allowAdditionalItems from './allowAdditionalItems';\nimport asNumber from './asNumber';\nimport canExpand from './canExpand';\nimport createErrorHandler from './createErrorHandler';\nimport createSchemaUtils from './createSchemaUtils';\nimport dataURItoBlob from './dataURItoBlob';\nimport deepEquals from './deepEquals';\nimport englishStringTranslator from './englishStringTranslator';\nimport enumOptionsDeselectValue from './enumOptionsDeselectValue';\nimport enumOptionsIndexForValue from './enumOptionsIndexForValue';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\nimport enumOptionsSelectValue from './enumOptionsSelectValue';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\nimport findSchemaDefinition from './findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from './getDiscriminatorFieldFromSchema';\nimport getInputProps from './getInputProps';\nimport getSchemaType from './getSchemaType';\nimport getSubmitButtonOptions from './getSubmitButtonOptions';\nimport getTemplate from './getTemplate';\nimport getUiOptions from './getUiOptions';\nimport getWidget from './getWidget';\nimport guessType from './guessType';\nimport hashForSchema from './hashForSchema';\nimport hasWidget from './hasWidget';\nimport { ariaDescribedByIds, descriptionId, errorId, examplesId, helpId, optionId, titleId } from './idGenerators';\nimport isConstant from './isConstant';\nimport isCustomWidget from './isCustomWidget';\nimport isFixedItems from './isFixedItems';\nimport isObject from './isObject';\nimport labelValue from './labelValue';\nimport localToUTC from './localToUTC';\nimport mergeDefaultsWithFormData from './mergeDefaultsWithFormData';\nimport mergeObjects from './mergeObjects';\nimport mergeSchemas from './mergeSchemas';\nimport optionsList from './optionsList';\nimport orderProperties from './orderProperties';\nimport pad from './pad';\nimport parseDateString from './parseDateString';\nimport rangeSpec from './rangeSpec';\nimport replaceStringParameters from './replaceStringParameters';\nimport schemaRequiresTrueValue from './schemaRequiresTrueValue';\nimport shouldRender from './shouldRender';\nimport toConstant from './toConstant';\nimport toDateString from './toDateString';\nimport toErrorList from './toErrorList';\nimport toErrorSchema from './toErrorSchema';\nimport unwrapErrorHandler from './unwrapErrorHandler';\nimport utcToLocal from './utcToLocal';\nimport validationDataMerge from './validationDataMerge';\nimport withIdRefPrefix from './withIdRefPrefix';\nimport getOptionMatchingSimpleDiscriminator from './getOptionMatchingSimpleDiscriminator';\n\nexport * from './types';\nexport * from './enums';\n\nexport * from './constants';\nexport * from './parser';\nexport * from './schema';\n\nexport {\n  allowAdditionalItems,\n  ariaDescribedByIds,\n  asNumber,\n  canExpand,\n  createErrorHandler,\n  createSchemaUtils,\n  dataURItoBlob,\n  deepEquals,\n  descriptionId,\n  englishStringTranslator,\n  enumOptionsDeselectValue,\n  enumOptionsIndexForValue,\n  enumOptionsIsSelected,\n  enumOptionsSelectValue,\n  enumOptionsValueForIndex,\n  errorId,\n  examplesId,\n  ErrorSchemaBuilder,\n  findSchemaDefinition,\n  getDiscriminatorFieldFromSchema,\n  getInputProps,\n  getOptionMatchingSimpleDiscriminator,\n  getSchemaType,\n  getSubmitButtonOptions,\n  getTemplate,\n  getUiOptions,\n  getWidget,\n  guessType,\n  hasWidget,\n  hashForSchema,\n  helpId,\n  isConstant,\n  isCustomWidget,\n  isFixedItems,\n  isObject,\n  labelValue,\n  localToUTC,\n  mergeDefaultsWithFormData,\n  mergeObjects,\n  mergeSchemas,\n  optionId,\n  optionsList,\n  orderProperties,\n  pad,\n  parseDateString,\n  rangeSpec,\n  replaceStringParameters,\n  schemaRequiresTrueValue,\n  shouldRender,\n  titleId,\n  toConstant,\n  toDateString,\n  toErrorList,\n  toErrorSchema,\n  unwrapErrorHandler,\n  utcToLocal,\n  validationDataMerge,\n  withIdRefPrefix,\n};\n", "/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const IF_KEY = 'if';\nexport const ITEMS_KEY = 'items';\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\n\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n *\n * @param formData - The form data around which the error handler is created\n * @returns - A `FormValidation` object based on the `formData` structure\n */\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\n  const handler: FieldValidation = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // 'errors' (see `utils.toErrorSchema`).\n    [ERRORS_KEY]: [],\n    addError(message: string) {\n      this[ERRORS_KEY]!.push(message);\n    },\n  };\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  if (isPlainObject(formData)) {\n    const formObject: GenericObjectType = formData as GenericObjectType;\n    return Object.keys(formObject).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\n    }, handler as FormValidation<T>);\n  }\n  return handler as FormValidation<T>;\n}\n", "import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n", "import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY } from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc: GenericObjectType, key: string) => {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        const computedDefault = computeDefaults<T, S, F>(validator, get(schema, [PROPERTIES_KEY, key]), {\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          includeUndefinedValues: includeUndefinedValues === true,\n          parentDefaults: get(defaults, [key]),\n          rawFormData: get(formData, [key]),\n          required: schema.required?.includes(key),\n        });\n        maybeAddDefaultToObject<T>(\n          acc,\n          key,\n          computedDefault,\n          includeUndefinedValues,\n          required,\n          schema.required,\n          experimental_defaultFormStateBehavior\n        );\n        return acc;\n      }, {}) as T;\n      if (schema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !schema.properties || !schema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !schema.properties || !schema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: schema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? [];\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n", "import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n", "import get from 'lodash/get';\nimport { PROPERTIES_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\n *\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or undefined if there is no match\n */\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  formData: T | undefined,\n  options: S[],\n  discriminatorField?: string\n): number | undefined {\n  if (formData && discriminatorField) {\n    const value = get(formData, discriminatorField);\n\n    if (value === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < options.length; i++) {\n      const option = options[i];\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\n        continue;\n      }\n\n      if (discriminator.const === value) {\n        return i;\n      }\n\n      if (discriminator.enum?.includes(value)) {\n        return i;\n      }\n    }\n  }\n\n  return;\n}\n", "import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        result[key] = resolveAllReferences(value as S, rootSchema, recurseList);\n      },\n      {} as RJSFSchema\n    );\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n", "import get from 'lodash/get';\nimport isString from 'lodash/isString';\n\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\n *\n * @param schema - The schema from which the discriminator is potentially obtained\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\n */\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  let discriminator: string | undefined;\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\n  if (isString(maybeString)) {\n    discriminator = maybeString;\n  } else if (maybeString !== undefined) {\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\n  }\n  return discriminator;\n}\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n", "import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n", "import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type)) {\n    if (type.length === 2 && type.includes('null')) {\n      type = type.find((type) => type !== 'null');\n    } else {\n      type = type[0];\n    }\n  }\n\n  return type;\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n", "import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\n *     which case the extras are appended onto the end of the form data\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults?: T,\n  formData?: T,\n  mergeExtraArrayDefaults = false\n): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\n      }\n      return value;\n    });\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\n      mapped.push(...defaultsArray.slice(mapped.length));\n    }\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key),\n        mergeExtraArrayDefaults\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n", "import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n", "import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n", "import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n", "import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n", "import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n *        removed in the next major release.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...data,\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  idPrefix: string,\n  idSeparator: string,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        idPrefix,\n        idSeparator,\n        id,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal<T, S, F>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      idPrefix,\n      idSeparator,\n      id,\n      rootSchema,\n      formData,\n      _recurseList\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        idPrefix,\n        idSeparator,\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        _recurseList\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach((element, i: number) => {\n      pathSchema[i] = toPathSchemaInternal<T, S, F>(\n        validator,\n        schema.items as S,\n        `${name}.${i}`,\n        rootSchema,\n        element,\n        _recurseList\n      );\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n", "import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\n  ) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior = {}\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator ||\n      !deepEquals(this.rootSchema, rootSchema) ||\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues,\n      this.experimental_defaultFormStateBehavior\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number {\n    return getClosestMatchingOption<T, S, F>(\n      this.validator,\n      this.rootSchema,\n      formData,\n      options,\n      selectedOption,\n      discriminatorField\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  experimental_defaultFormStateBehavior = {}\n): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\n}\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n", "import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport { isNil } from 'lodash';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n", "import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n", "import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n", "import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** JS has no built-in hashing function, so rolling our own\n *  based on Java's hashing fn:\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\n *\n * @param string - The string for which to get the hash\n * @returns - The resulting hash of the string in hex format\n */\nfunction hashString(string: string): string {\n  let hash = 0;\n  for (let i = 0; i < string.length; i += 1) {\n    const chr = string.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n}\n\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\n * in consistent order before stringify to prevent different hash ids for the same schema.\n *\n * @param schema - The schema for which the hash is desired\n * @returns - The string obtained from the hash of the stringified schema\n */\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const allKeys = new Set<string>();\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\n}\n", "import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n", "import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n", "import { ReactElement } from 'react';\n\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\n * themes require may `false` and others may require an empty string.\n *\n * @param [label] - The label string or component to render when not hidden\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\n */\nexport function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: ''): undefined | string;\nexport default function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: false | '') {\n  return hideLabel ? fallback : label;\n}\n", "/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n", "import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n", "import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n", "import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n", "import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n", "import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n", "import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\n\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n *\n * @param errorSchema - The `ErrorSchema` instance to convert\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\n */\nexport default function toErrorList<T = any>(\n  errorSchema?: ErrorSchema<T>,\n  fieldPath: string[] = []\n): RJSFValidationError[] {\n  if (!errorSchema) {\n    return [];\n  }\n  let errorList: RJSFValidationError[] = [];\n  if (ERRORS_KEY in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\n        const property = `.${fieldPath.join('.')}`;\n        return {\n          property,\n          message,\n          stack: `${property} ${message}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== ERRORS_KEY) {\n      const childSchema = (errorSchema as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\n      }\n    }\n    return acc;\n  }, errorList);\n}\n", "import toPath from 'lodash/toPath';\n\nimport { ErrorSchema, RJSFValidationError } from './types';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\n  const builder = new ErrorSchemaBuilder<T>();\n  if (errors.length) {\n    errors.forEach((error) => {\n      const { property, message } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\n\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\n *\n * @param errorHandler - The `FormValidation` error handling structure\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\n */\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === 'addError') {\n      return acc;\n    } else {\n      const childSchema = (errorHandler as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        return {\n          ...acc,\n          [key]: unwrapErrorHandler(childSchema),\n        };\n      }\n      return { ...acc, [key]: childSchema };\n    }\n  }, {} as ErrorSchema<T>);\n}\n", "import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from './mergeObjects';\nimport toErrorList from './toErrorList';\nimport { ErrorSchema, ValidationData } from './types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function validationDataMerge<T = any>(\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\nimport isObject from 'lodash/isObject';\n\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\n  for (const key in node) {\n    const realObj: { [k: string]: any } = node;\n    const value = realObj[key];\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\n    } else {\n      realObj[key] = withIdRefPrefix<S>(value);\n    }\n  }\n  return node;\n}\n\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\n  for (let i = 0; i < node.length; i++) {\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\n  }\n  return node;\n}\n\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\n * This is used in isValid to make references to the rootSchema\n *\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n * @returns - A copy of the `schemaNode` with updated `$ref`s\n */\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(schemaNode: S): S | S[] {\n  if (Array.isArray(schemaNode)) {\n    return withIdRefPrefixArray<S>([...schemaNode]);\n  }\n  if (isObject(schemaNode)) {\n    return withIdRefPrefixObject<S>({ ...schemaNode });\n  }\n  return schemaNode;\n}\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** File preview label, used by FileWidget */\n  PreviewLabel = 'Preview',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\n}\n", "import forEach from 'lodash/forEach';\nimport isEqual from 'lodash/isEqual';\n\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport ParserValidator, { SchemaMap } from './ParserValidator';\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\n\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\n *\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\n * @param rootSchema - The root schema from which the schema parsing began\n * @param schema - The current schema element being parsed\n */\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ParserValidator<T, S, F>,\n  recurseList: S[],\n  rootSchema: S,\n  schema: S\n) {\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\n  schemas.forEach((schema) => {\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\n    if (sameSchemaIndex === -1) {\n      recurseList.push(schema);\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\n      allOptions.forEach((s) => {\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\n          forEach(schema[PROPERTIES_KEY], (value) => {\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\n          });\n        }\n      });\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\n      }\n    }\n  });\n}\n\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\n * the hash of the schema to schema/sub-schema.\n *\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\n * @returns - The `SchemaMap` of all schemas that were parsed\n */\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  rootSchema: S\n): SchemaMap<S> {\n  const validator = new ParserValidator<T, S, F>(rootSchema);\n  const recurseList: S[] = [];\n\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\n\n  return validator.getSchemaMap();\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ID_KEY } from '../constants';\nimport hashForSchema from '../hashForSchema';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from '../types';\n\n/** The type of the map of schema hash to schema\n */\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\n  [hash: string]: S;\n};\n\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\n */\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The rootSchema provided during construction of the class */\n  readonly rootSchema: S;\n\n  /** The map of schemas encountered by the ParserValidator */\n  schemaMap: SchemaMap<S> = {};\n\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\n   * first.\n   *\n   * @param rootSchema - The root schema against which this validator will be executed\n   */\n  constructor(rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\n  }\n\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\n   * associated with it's `hash` for future use (by a schema compiler).\n   *\n   * @param schema - The schema which is to be added to the map\n   * @param hash - The hash value at which to map the schema\n   */\n  addSchema(schema: S, hash: string) {\n    const key = get(schema, ID_KEY, hash);\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\n    const existing = this.schemaMap[key];\n    if (!existing) {\n      this.schemaMap[key] = identifiedSchema;\n    } else if (!isEqual(existing, identifiedSchema)) {\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\n      throw new Error(\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\n      );\n    }\n  }\n\n  /** Returns the current `schemaMap` to the caller\n   */\n  getSchemaMap() {\n    return this.schemaMap;\n  }\n\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\n   * the `rootSchema` is not the same as the root schema provided during construction.\n   *\n   * @param schema - The schema to record in the `schemaMap`\n   * @param _formData - The formData parameter that is ignored\n   * @param rootSchema - The root schema associated with the schema\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\n   */\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\n    if (!isEqual(rootSchema, this.rootSchema)) {\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\n    }\n    this.addSchema(schema, hashForSchema<S>(schema));\n\n    return false;\n  }\n\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\n   *\n   * @param _schema - The schema parameter that is ignored\n   * @param _formData - The formData parameter that is ignored\n   */\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\n   *\n   * @param _errorSchema - The error schema parameter that is ignored\n   * @param _fieldPath - The field path parameter that is ignored\n   */\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\n   * called\n   *\n   * @param _formData - The formData parameter that is ignored\n   * @param _schema - The schema parameter that is ignored\n   * @param _customValidate - The customValidate parameter that is ignored\n   * @param _transformErrors - The transformErrors parameter that is ignored\n   * @param _uiSchema - The uiSchema parameter that is ignored\n   */\n  validateFormData(\n    _formData: T,\n    _schema: S,\n    _customValidate?: CustomValidator<T, S, F>,\n    _transformErrors?: ErrorTransformer<T, S, F>,\n    _uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\n  }\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["import allowAdditionalItems from './allowAdditionalItems';\nimport asNumber from './asNumber';\nimport canExpand from './canExpand';\nimport createErrorHandler from './createErrorHandler';\nimport createSchemaUtils from './createSchemaUtils';\nimport dataURItoBlob from './dataURItoBlob';\nimport deepEquals from './deepEquals';\nimport englishStringTranslator from './englishStringTranslator';\nimport enumOptionsDeselectValue from './enumOptionsDeselectValue';\nimport enumOptionsIndexForValue from './enumOptionsIndexForValue';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\nimport enumOptionsSelectValue from './enumOptionsSelectValue';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\nimport findSchemaDefinition from './findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from './getDiscriminatorFieldFromSchema';\nimport getInputProps from './getInputProps';\nimport getSchemaType from './getSchemaType';\nimport getSubmitButtonOptions from './getSubmitButtonOptions';\nimport getTemplate from './getTemplate';\nimport getUiOptions from './getUiOptions';\nimport getWidget from './getWidget';\nimport guessType from './guessType';\nimport hashForSchema from './hashForSchema';\nimport hasWidget from './hasWidget';\nimport { ariaDescribedByIds, descriptionId, errorId, examplesId, helpId, optionId, titleId } from './idGenerators';\nimport isConstant from './isConstant';\nimport isCustomWidget from './isCustomWidget';\nimport isFixedItems from './isFixedItems';\nimport isObject from './isObject';\nimport labelValue from './labelValue';\nimport localToUTC from './localToUTC';\nimport mergeDefaultsWithFormData from './mergeDefaultsWithFormData';\nimport mergeObjects from './mergeObjects';\nimport mergeSchemas from './mergeSchemas';\nimport optionsList from './optionsList';\nimport orderProperties from './orderProperties';\nimport pad from './pad';\nimport parseDateString from './parseDateString';\nimport rangeSpec from './rangeSpec';\nimport replaceStringParameters from './replaceStringParameters';\nimport schemaRequiresTrueValue from './schemaRequiresTrueValue';\nimport shouldRender from './shouldRender';\nimport toConstant from './toConstant';\nimport toDateString from './toDateString';\nimport toErrorList from './toErrorList';\nimport toErrorSchema from './toErrorSchema';\nimport unwrapErrorHandler from './unwrapErrorHandler';\nimport utcToLocal from './utcToLocal';\nimport validationDataMerge from './validationDataMerge';\nimport withIdRefPrefix from './withIdRefPrefix';\nimport getOptionMatchingSimpleDiscriminator from './getOptionMatchingSimpleDiscriminator';\n\nexport * from './types';\nexport * from './enums';\n\nexport * from './constants';\nexport * from './parser';\nexport * from './schema';\n\nexport {\n  allowAdditionalItems,\n  ariaDescribedByIds,\n  asNumber,\n  canExpand,\n  createErrorHandler,\n  createSchemaUtils,\n  dataURItoBlob,\n  deepEquals,\n  descriptionId,\n  englishStringTranslator,\n  enumOptionsDeselectValue,\n  enumOptionsIndexForValue,\n  enumOptionsIsSelected,\n  enumOptionsSelectValue,\n  enumOptionsValueForIndex,\n  errorId,\n  examplesId,\n  ErrorSchemaBuilder,\n  findSchemaDefinition,\n  getDiscriminatorFieldFromSchema,\n  getInputProps,\n  getOptionMatchingSimpleDiscriminator,\n  getSchemaType,\n  getSubmitButtonOptions,\n  getTemplate,\n  getUiOptions,\n  getWidget,\n  guessType,\n  hasWidget,\n  hashForSchema,\n  helpId,\n  isConstant,\n  isCustomWidget,\n  isFixedItems,\n  isObject,\n  labelValue,\n  localToUTC,\n  mergeDefaultsWithFormData,\n  mergeObjects,\n  mergeSchemas,\n  optionId,\n  optionsList,\n  orderProperties,\n  pad,\n  parseDateString,\n  rangeSpec,\n  replaceStringParameters,\n  schemaRequiresTrueValue,\n  shouldRender,\n  titleId,\n  toConstant,\n  toDateString,\n  toErrorList,\n  toErrorSchema,\n  unwrapErrorHandler,\n  utcToLocal,\n  validationDataMerge,\n  withIdRefPrefix,\n};\n", "/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\r\n * the type `object` but is NOT null, an array or a File.\r\n *\r\n * @param thing - The thing to check to see whether it is an object\r\n * @returns - True if it is a non-null, non-array, non-File object\r\n */\r\nexport default function isObject(thing: any) {\r\n  if (typeof File !== 'undefined' && thing instanceof File) {\r\n    return false;\r\n  }\r\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\r\n    return false;\r\n  }\r\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\r\n}\r\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\r\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\r\n *\r\n * @param schema - The schema object to check\r\n * @returns - True if additional items is allowed, otherwise false\r\n */\r\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (schema.additionalItems === true) {\r\n    console.warn('additionalItems=true is currently not supported');\r\n  }\r\n  return isObject(schema.additionalItems);\r\n}\r\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\r\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\r\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\r\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\r\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\r\n *\r\n * @param value - The string or null value to convert to a number\r\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\r\n */\r\nexport default function asNumber(value: string | null) {\r\n  if (value === '') {\r\n    return undefined;\r\n  }\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n  if (/\\.$/.test(value)) {\r\n    // '3.' can't really be considered a number even if it parses in js. The\r\n    // user is most likely entering a float.\r\n    return value;\r\n  }\r\n  if (/\\.0$/.test(value)) {\r\n    // we need to return this as a string here, to allow for input like 3.07\r\n    return value;\r\n  }\r\n\r\n  if (/\\.\\d*0$/.test(value)) {\r\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\r\n    // with the user when entering dollar amounts or other values (such as those with\r\n    // specific precision or number of significant digits)\r\n    return value;\r\n  }\r\n\r\n  const n = Number(value);\r\n  const valid = typeof n === 'number' && !Number.isNaN(n);\r\n\r\n  return valid ? n : value;\r\n}\r\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\r\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\r\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\r\n * utility.\r\n */\r\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\r\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\r\nexport const ALL_OF_KEY = 'allOf';\r\nexport const ANY_OF_KEY = 'anyOf';\r\nexport const CONST_KEY = 'const';\r\nexport const DEFAULT_KEY = 'default';\r\nexport const DEFINITIONS_KEY = 'definitions';\r\nexport const DEPENDENCIES_KEY = 'dependencies';\r\nexport const ENUM_KEY = 'enum';\r\nexport const ERRORS_KEY = '__errors';\r\nexport const ID_KEY = '$id';\r\nexport const IF_KEY = 'if';\r\nexport const ITEMS_KEY = 'items';\r\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\r\nexport const NAME_KEY = '$name';\r\nexport const ONE_OF_KEY = 'oneOf';\r\nexport const PROPERTIES_KEY = 'properties';\r\nexport const REQUIRED_KEY = 'required';\r\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\r\nexport const REF_KEY = '$ref';\r\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\r\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\r\nexport const UI_FIELD_KEY = 'ui:field';\r\nexport const UI_WIDGET_KEY = 'ui:widget';\r\nexport const UI_OPTIONS_KEY = 'ui:options';\r\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\r\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\r\nimport isObject from './isObject';\r\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\r\n\r\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\r\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\r\n *\r\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\r\n */\r\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  globalOptions: GlobalUISchemaOptions = {}\r\n): UIOptionsType<T, S, F> {\r\n  return Object.keys(uiSchema)\r\n    .filter((key) => key.indexOf('ui:') === 0)\r\n    .reduce(\r\n      (options, key) => {\r\n        const value = uiSchema[key];\r\n        if (key === UI_WIDGET_KEY && isObject(value)) {\r\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\r\n          return options;\r\n        }\r\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\r\n          return { ...options, ...value };\r\n        }\r\n        return { ...options, [key.substring(3)]: value };\r\n      },\r\n      { ...globalOptions }\r\n    );\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\nimport getUiOptions from './getUiOptions';\r\n\r\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\r\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\r\n * `formData` object doesn't already have `schema.maxProperties` elements.\r\n *\r\n * @param schema - The schema for the field that is being checked\r\n * @param [uiSchema={}] - The uiSchema for the field\r\n * @param [formData] - The formData for the field\r\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\r\n */\r\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  formData?: T\r\n) {\r\n  if (!schema.additionalProperties) {\r\n    return false;\r\n  }\r\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\r\n  if (expandable === false) {\r\n    return expandable;\r\n  }\r\n  // if ui:options.expandable was not explicitly set to false, we can add\r\n  // another property if we have not exceeded maxProperties yet\r\n  if (schema.maxProperties !== undefined && formData) {\r\n    return Object.keys(formData).length < schema.maxProperties;\r\n  }\r\n  return true;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\r\n *\r\n * @param formData - The form data around which the error handler is created\r\n * @returns - A `FormValidation` object based on the `formData` structure\r\n */\r\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\r\n  const handler: FieldValidation = {\r\n    // We store the list of errors for this node in a property named __errors\r\n    // to avoid name collision with a possible sub schema field named\r\n    // 'errors' (see `utils.toErrorSchema`).\r\n    [ERRORS_KEY]: [],\r\n    addError(message: string) {\r\n      this[ERRORS_KEY]!.push(message);\r\n    },\r\n  };\r\n  if (Array.isArray(formData)) {\r\n    return formData.reduce((acc, value, key) => {\r\n      return { ...acc, [key]: createErrorHandler(value) };\r\n    }, handler);\r\n  }\r\n  if (isPlainObject(formData)) {\r\n    const formObject: GenericObjectType = formData as GenericObjectType;\r\n    return Object.keys(formObject).reduce((acc, key) => {\r\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\r\n    }, handler as FormValidation<T>);\r\n  }\r\n  return handler as FormValidation<T>;\r\n}\r\n", "import isEqualWith from 'lodash/isEqualWith';\r\n\r\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\r\n * assumes all functions are equivalent.\r\n *\r\n * @param a - The first element to compare\r\n * @param b - The second element to compare\r\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\r\n */\r\nexport default function deepEquals(a: any, b: any): boolean {\r\n  return isEqualWith(a, b, (obj: any, other: any) => {\r\n    if (typeof obj === 'function' && typeof other === 'function') {\r\n      // Assume all functions are equivalent\r\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\r\n      return true;\r\n    }\r\n    return undefined; // fallback to default isEquals behavior\r\n  });\r\n}\r\n", "import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  ALL_OF_KEY,\n} from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_ArrayMinItems,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\ndeclare module 'json-schema' {\n  export interface JSONSchema7 {\n    overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;\n  }\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      // This is a custom addition that fixes this issue:\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\n      const retrievedSchema =\n        ALL_OF_KEY in schema ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData) : schema;\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          maybeAddDefaultToObject<T>(\n            acc,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            retrievedSchema.required,\n            experimental_defaultFormStateBehavior\n          );\n          return acc;\n        },\n        {}\n      ) as T;\n      if (retrievedSchema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\n          ? retrievedSchema.additionalProperties\n          : {};\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      // On a case by case basis, we may want to override the default behavior of populating array items.\n      const arrayMinItems =\n        schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\n      const neverPopulate = arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = arrayMinItems?.populate === 'requiredOnly';\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? [];\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  // On a case by case basis, we may want to override the default behavior of populating array items.\n  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\n\n  const { mergeExtraDefaults } = arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n", "import jsonpointer from 'jsonpointer';\r\nimport omit from 'lodash/omit';\r\n\r\nimport { REF_KEY } from './constants';\r\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\r\n * location, the `object` minus the `key: value` and in the second location the `value`.\r\n *\r\n * @param key - The key from the object to extract\r\n * @param object - The object from which to extract the element\r\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\r\n *      value from `object[key]`\r\n */\r\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\r\n  const value = object[key];\r\n  const remaining = omit(object, [key]);\r\n  return [remaining, value];\r\n}\r\n\r\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\r\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\r\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\r\n *\r\n * @param $ref - The ref string for which the schema definition is desired\r\n * @param [rootSchema={}] - The root schema in which to search for the definition\r\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\r\n * @throws - Error indicating that no schema for that reference exists\r\n */\r\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\r\n  $ref?: string,\r\n  rootSchema: S = {} as S\r\n): S {\r\n  let ref = $ref || '';\r\n  if (ref.startsWith('#')) {\r\n    // Decode URI fragment representation.\r\n    ref = decodeURIComponent(ref.substring(1));\r\n  } else {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  const current: S = jsonpointer.get(rootSchema, ref);\r\n  if (current === undefined) {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  if (current[REF_KEY]) {\r\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\r\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\r\n    if (Object.keys(remaining).length > 0) {\r\n      return { ...remaining, ...subSchema };\r\n    }\r\n    return subSchema;\r\n  }\r\n  return current;\r\n}\r\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n", "import get from 'lodash/get';\nimport { PROPERTIES_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\n *\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or undefined if there is no match\n */\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  formData: T | undefined,\n  options: S[],\n  discriminatorField?: string\n): number | undefined {\n  if (formData && discriminatorField) {\n    const value = get(formData, discriminatorField);\n\n    if (value === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < options.length; i++) {\n      const option = options[i];\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\n        continue;\n      }\n\n      if (discriminator.const === value) {\n        return i;\n      }\n\n      if (discriminator.enum?.includes(value)) {\n        return i;\n      }\n    }\n  }\n\n  return;\n}\n", "import getMatchingOption from './getMatchingOption';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n * Always returns the first option if there is nothing that matches.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the first matched option or 0 if none is available\r\n */\r\nexport default function getFirstMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\r\n}\r\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        result[key] = resolveAllReferences(value as S, rootSchema, recurseList);\n      },\n      {} as RJSFSchema\n    );\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n", "import get from 'lodash/get';\r\nimport isString from 'lodash/isString';\r\n\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\r\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\r\n *\r\n * @param schema - The schema from which the discriminator is potentially obtained\r\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\r\n */\r\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  let discriminator: string | undefined;\r\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\r\n  if (isString(maybeString)) {\r\n    discriminator = maybeString;\r\n  } else if (maybeString !== undefined) {\r\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\r\n  }\r\n  return discriminator;\r\n}\r\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\r\n *  create a schema, it is useful to know what type to use based on the data we are defining.\r\n *\r\n * @param value - The value from which to guess the type\r\n * @returns - The best guess for the object type\r\n */\r\nexport default function guessType(value: any) {\r\n  if (Array.isArray(value)) {\r\n    return 'array';\r\n  }\r\n  if (typeof value === 'string') {\r\n    return 'string';\r\n  }\r\n  if (value == null) {\r\n    return 'null';\r\n  }\r\n  if (typeof value === 'boolean') {\r\n    return 'boolean';\r\n  }\r\n  if (!isNaN(value)) {\r\n    return 'number';\r\n  }\r\n  if (typeof value === 'object') {\r\n    return 'object';\r\n  }\r\n  // Default to string if we can't figure it out\r\n  return 'string';\r\n}\r\n", "import union from 'lodash/union';\r\n\r\nimport { REQUIRED_KEY } from './constants';\r\nimport getSchemaType from './getSchemaType';\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\r\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\r\n * duplicate values.\r\n *\r\n * @param obj1 - The first schema object to merge\r\n * @param obj2 - The second schema object to merge\r\n * @returns - The merged schema object\r\n */\r\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\r\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeSchemas(left, right);\r\n    } else if (\r\n      obj1 &&\r\n      obj2 &&\r\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\r\n      key === REQUIRED_KEY &&\r\n      Array.isArray(left) &&\r\n      Array.isArray(right)\r\n    ) {\r\n      // Don't include duplicate values when merging 'required' fields.\r\n      acc[key] = union(left, right);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, acc);\r\n}\r\n", "import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type)) {\n    if (type.length === 2 && type.includes('null')) {\n      type = type.find((type) => type !== 'null');\n    } else {\n      type = type[0];\n    }\n  }\n\n  return type;\n}\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\r\n * that only contains objects.\r\n *\r\n * @param schema - The schema in which to check for fixed items\r\n * @returns - True if there are fixed items in the schema, false otherwise\r\n */\r\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\r\n}\r\n", "import get from 'lodash/get';\r\n\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from '../src';\r\n\r\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\r\n *\r\n * When merging defaults and form data, we want to merge in this specific way:\r\n * - objects are deeply merged\r\n * - arrays are merged in such a way that:\r\n *   - when the array is set in form data, only array entries set in form data\r\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\r\n *     which case the extras are appended onto the end of the form data\r\n *   - when the array is not set in form data, the default is copied over\r\n * - scalars are overwritten/set by form data\r\n *\r\n * @param [defaults] - The defaults to merge\r\n * @param [formData] - The form data into which the defaults will be merged\r\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\r\n * @returns - The resulting merged form data with defaults\r\n */\r\nexport default function mergeDefaultsWithFormData<T = any>(\r\n  defaults?: T,\r\n  formData?: T,\r\n  mergeExtraArrayDefaults = false\r\n): T | undefined {\r\n  if (Array.isArray(formData)) {\r\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\r\n    const mapped = formData.map((value, idx) => {\r\n      if (defaultsArray[idx]) {\r\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\r\n      }\r\n      return value;\r\n    });\r\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\r\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\r\n      mapped.push(...defaultsArray.slice(mapped.length));\r\n    }\r\n    return mapped as unknown as T;\r\n  }\r\n  if (isObject(formData)) {\r\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\r\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\r\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\r\n        defaults ? get(defaults, key) : {},\r\n        get(formData, key),\r\n        mergeExtraArrayDefaults\r\n      );\r\n      return acc;\r\n    }, acc);\r\n  }\r\n  return formData;\r\n}\r\n", "import isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested objects.\r\n *\r\n * @param obj1 - The first object to merge\r\n * @param obj2 - The second object to merge\r\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\r\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\r\n *          NOTE: Uses shallow comparison for the duplicate checking.\r\n * @returns - A new object that is the merge of the two given objects\r\n */\r\nexport default function mergeObjects(\r\n  obj1: GenericObjectType,\r\n  obj2: GenericObjectType,\r\n  concatArrays: boolean | 'preventDuplicates' = false\r\n) {\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeObjects(left, right, concatArrays);\r\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\r\n      let toMerge = right;\r\n      if (concatArrays === 'preventDuplicates') {\r\n        toMerge = right.reduce((result, value) => {\r\n          if (!left.includes(value)) {\r\n            result.push(value);\r\n          }\r\n          return result;\r\n        }, []);\r\n      }\r\n      acc[key] = left.concat(toMerge);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\r\n}\r\n", "import { CONST_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\r\n * an `enum` array with a single value or there is a `const` defined.\r\n *\r\n * @param schema - The schema for a field\r\n * @returns - True if the `schema` has a single constant value, false otherwise\r\n */\r\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\r\n}\r\n", "import isConstant from '../isConstant';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` combination represents a select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which check for a select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a select, otherwise false\r\n */\r\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  rootSchema: S = {} as S\r\n) {\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  if (Array.isArray(schema.enum)) {\r\n    return true;\r\n  }\r\n  if (Array.isArray(altSchemas)) {\r\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\r\n  }\r\n  return false;\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\nimport isSelect from './isSelect';\r\n\r\n/** Checks to see if the `schema` combination represents a multi-select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for a multi-select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a multi-select, otherwise false\r\n */\r\nexport default function isMultiSelect<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\r\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\r\n    return false;\r\n  }\r\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\r\n}\r\n", "import getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\n\r\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\r\n *\r\n * @param uiSchema - The UI Schema from which to detect if it is customized\r\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\r\n */\r\nexport default function isCustomWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}) {\r\n  return (\r\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\r\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\r\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\r\n  );\r\n}\r\n", "import { UI_WIDGET_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for array of files flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to check the widget\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n */\r\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S\r\n) {\r\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\r\n    return true;\r\n  }\r\n  if (schema.items) {\r\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\r\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\r\n  }\r\n  return false;\r\n}\r\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\r\nimport getSchemaType from '../getSchemaType';\r\nimport getUiOptions from '../getUiOptions';\r\nimport isCustomWidget from '../isCustomWidget';\r\nimport {\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isFilesArray from './isFilesArray';\r\nimport isMultiSelect from './isMultiSelect';\r\n\r\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n * should be displayed in a UI.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the display label flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - True if the label should be displayed or false if it should not\r\n */\r\nexport default function getDisplayLabel<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S,\r\n  globalOptions?: GlobalUISchemaOptions\r\n): boolean {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\r\n  const { label = true } = uiOptions;\r\n  let displayLabel = !!label;\r\n  const schemaType = getSchemaType<S>(schema);\r\n\r\n  if (schemaType === 'array') {\r\n    displayLabel =\r\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\r\n      isCustomWidget(uiSchema);\r\n  }\r\n\r\n  if (schemaType === 'object') {\r\n    displayLabel = false;\r\n  }\r\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  if (uiSchema[UI_FIELD_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  return displayLabel;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from '../mergeObjects';\r\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n *        removed in the next major release.\r\n */\r\nexport default function mergeValidationData<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = validator.toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\n\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\nconst NO_VALUE = Symbol('no Value');\r\n\r\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\r\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\r\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\r\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\r\n *\r\n * - If the new schema is an object that contains a `properties` object then:\r\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\r\n *   - Create an empty `nestedData` object for use in the key filtering below:\r\n *   - Iterate over each key in the `newSchema.properties` as follows:\r\n *     - Get the `formValue` of the key from the `data`\r\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\r\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\r\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\r\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\r\n *       - If type of the key in the new schema is `object`:\r\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\r\n *       - Otherwise, check for default or const values:\r\n *         - Get the old and new `default` values from the schema and check:\r\n *           - If the new `default` value does not match the form value:\r\n *             - If the old `default` value DOES match the form value, then:\r\n *               - Replace `removeOldSchemaData[key]` with the new `default`\r\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\r\n *         - Get the old and new `const` values from the schema and check:\r\n *           - If the new `const` value does not match the form value:\r\n *           - If the old `const` value DOES match the form value, then:\r\n *             - Replace `removeOldSchemaData[key]` with the new `const`\r\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\r\n *   - Once all keys have been processed, return an object built as follows:\r\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\r\n * - If the new and old schema types are array and the `data` is an array then:\r\n *   - If the type of the old and new schema `items` are a non-array objects:\r\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\r\n *     - If the `type`s of both items are the same (or the old does not have a type):\r\n *       - If the type is \"object\", then:\r\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\r\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\r\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\r\n * - Otherwise return `undefined`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param [newSchema] - The new schema for which the data is being sanitized\r\n * @param [oldSchema] - The old schema from which the data originated\r\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n */\r\nexport default function sanitizeDataForNewSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\r\n  // By default, we will clear the form data\r\n  let newFormData;\r\n  // If the new schema is of type object and that object contains a list of properties\r\n  if (has(newSchema, PROPERTIES_KEY)) {\r\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\r\n    const removeOldSchemaData: GenericObjectType = {};\r\n    if (has(oldSchema, PROPERTIES_KEY)) {\r\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\r\n      Object.keys(properties).forEach((key) => {\r\n        if (has(data, key)) {\r\n          removeOldSchemaData[key] = undefined;\r\n        }\r\n      });\r\n    }\r\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\r\n    // Create a place to store nested data that will be a side-effect of the filter\r\n    const nestedData: GenericObjectType = {};\r\n    keys.forEach((key) => {\r\n      const formValue = get(data, key);\r\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\r\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\r\n      // Resolve the refs if they exist\r\n      if (has(oldKeyedSchema, REF_KEY)) {\r\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\r\n      }\r\n      if (has(newKeyedSchema, REF_KEY)) {\r\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\r\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\r\n        if (has(removeOldSchemaData, key)) {\r\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\r\n          delete removeOldSchemaData[key];\r\n        }\r\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\r\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\r\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\r\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\r\n            validator,\r\n            rootSchema,\r\n            newKeyedSchema,\r\n            oldKeyedSchema,\r\n            formValue\r\n          );\r\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\r\n            // only put undefined values for the array type and not the object type\r\n            nestedData[key] = itemData;\r\n          }\r\n        } else {\r\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\r\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\r\n          // value to be properly selected\r\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\r\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\r\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\r\n            if (oldOptionDefault === formValue) {\r\n              // If the old default matches the formValue, we'll update the new value to match the new default\r\n              removeOldSchemaData[key] = newOptionDefault;\r\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\r\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\r\n              removeOldSchemaData[key] = undefined;\r\n            }\r\n          }\r\n\r\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\r\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\r\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\r\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\r\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    newFormData = {\r\n      ...data,\r\n      ...removeOldSchemaData,\r\n      ...nestedData,\r\n    };\r\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\r\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\r\n    let oldSchemaItems = get(oldSchema, 'items');\r\n    let newSchemaItems = get(newSchema, 'items');\r\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\r\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\r\n    if (\r\n      typeof oldSchemaItems === 'object' &&\r\n      typeof newSchemaItems === 'object' &&\r\n      !Array.isArray(oldSchemaItems) &&\r\n      !Array.isArray(newSchemaItems)\r\n    ) {\r\n      if (has(oldSchemaItems, REF_KEY)) {\r\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      if (has(newSchemaItems, REF_KEY)) {\r\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaType = get(oldSchemaItems, 'type');\r\n      const newSchemaType = get(newSchemaItems, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\r\n        const maxItems = get(newSchema, 'maxItems', -1);\r\n        if (newSchemaType === 'object') {\r\n          newFormData = data.reduce((newValue, aValue) => {\r\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\r\n              validator,\r\n              rootSchema,\r\n              newSchemaItems as S,\r\n              oldSchemaItems as S,\r\n              aValue\r\n            );\r\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\r\n              newValue.push(itemValue);\r\n            }\r\n            return newValue;\r\n          }, []);\r\n        } else {\r\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\r\n        }\r\n      }\r\n    } else if (\r\n      typeof oldSchemaItems === 'boolean' &&\r\n      typeof newSchemaItems === 'boolean' &&\r\n      oldSchemaItems === newSchemaItems\r\n    ) {\r\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\r\n      newFormData = data;\r\n    }\r\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\r\n  }\r\n  return newFormData as T;\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport isObject from '../isObject';\r\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\nimport getSchemaType from '../getSchemaType';\r\n\r\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param idPrefix - The prefix to use for the id\r\n * @param idSeparator - The separator to use for the path segments in the id\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  idPrefix: string,\r\n  idSeparator: string,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): IdSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        idPrefix,\r\n        idSeparator,\r\n        id,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\r\n    return toIdSchemaInternal<T, S, F>(\r\n      validator,\r\n      get(schema, ITEMS_KEY) as S,\r\n      idPrefix,\r\n      idSeparator,\r\n      id,\r\n      rootSchema,\r\n      formData,\r\n      _recurseList\r\n    );\r\n  }\r\n  const $id = id || idPrefix;\r\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\r\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\r\n    for (const name in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, name]);\r\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\r\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        isObject(field) ? field : {},\r\n        idPrefix,\r\n        idSeparator,\r\n        fieldId,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [name]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return idSchema as IdSchema<T>;\r\n}\r\n\r\n/** Generates an `IdSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [idPrefix='root'] - The prefix to use for the id\r\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  idPrefix = 'root',\r\n  idSeparator = '_'\r\n): IdSchema<T> {\r\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\nimport set from 'lodash/set';\r\n\r\nimport {\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  DEPENDENCIES_KEY,\r\n  ITEMS_KEY,\r\n  NAME_KEY,\r\n  ONE_OF_KEY,\r\n  PROPERTIES_KEY,\r\n  REF_KEY,\r\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\r\n} from '../constants';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name: string,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): PathSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        name,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n\r\n  let pathSchema: PathSchema = {\r\n    [NAME_KEY]: name.replace(/^\\./, ''),\r\n  } as PathSchema;\r\n\r\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\r\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\r\n    const _schema: S = xxxOf![index] as S;\r\n    pathSchema = {\r\n      ...pathSchema,\r\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\r\n    };\r\n  }\r\n\r\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\r\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\r\n  }\r\n\r\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\r\n    formData.forEach((element, i: number) => {\r\n      pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        schema.items as S,\r\n        `${name}.${i}`,\r\n        rootSchema,\r\n        element,\r\n        _recurseList\r\n      );\r\n    });\r\n  } else if (PROPERTIES_KEY in schema) {\r\n    for (const property in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, property]);\r\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        field,\r\n        `${name}.${property}`,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [property]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return pathSchema as PathSchema<T>;\r\n}\r\n\r\n/** Generates an `PathSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name = '',\r\n  rootSchema?: S,\r\n  formData?: T\r\n): PathSchema<T> {\r\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\r\n}\r\n", "import deepEquals from './deepEquals';\r\nimport {\r\n  ErrorSchema,\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  IdSchema,\r\n  PathSchema,\r\n  RJSFSchema,\r\n  SchemaUtilsType,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from './types';\r\nimport {\r\n  getDefaultFormState,\r\n  getDisplayLabel,\r\n  getClosestMatchingOption,\r\n  getFirstMatchingOption,\r\n  getMatchingOption,\r\n  isFilesArray,\r\n  isMultiSelect,\r\n  isSelect,\r\n  mergeValidationData,\r\n  retrieveSchema,\r\n  sanitizeDataForNewSchema,\r\n  toIdSchema,\r\n  toPathSchema,\r\n} from './schema';\r\n\r\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\r\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\r\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\r\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\r\n */\r\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements SchemaUtilsType<T, S, F>\r\n{\r\n  rootSchema: S;\r\n  validator: ValidatorType<T, S, F>;\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\r\n\r\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\r\n   */\r\n  constructor(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\r\n  ) {\r\n    this.rootSchema = rootSchema;\r\n    this.validator = validator;\r\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\r\n  }\r\n\r\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\r\n   *\r\n   * @returns - The `ValidatorType`\r\n   */\r\n  getValidator() {\r\n    return this.validator;\r\n  }\r\n\r\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\r\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\r\n   * of a new `SchemaUtilsType` with incomplete properties.\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\r\n   * @param rootSchema - The root schema that will be compared against the current one\r\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\r\n   */\r\n  doesSchemaUtilsDiffer(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior = {}\r\n  ): boolean {\r\n    if (!validator || !rootSchema) {\r\n      return false;\r\n    }\r\n    return (\r\n      this.validator !== validator ||\r\n      !deepEquals(this.rootSchema, rootSchema) ||\r\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\r\n    );\r\n  }\r\n\r\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n   * computed to have defaults provided in the `schema`.\r\n   *\r\n   * @param schema - The schema for which the default state is desired\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\r\n   *          object properties.\r\n   * @returns - The resulting `formData` with all the defaults provided\r\n   */\r\n  getDefaultFormState(\r\n    schema: S,\r\n    formData?: T,\r\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\r\n  ): T | T[] | undefined {\r\n    return getDefaultFormState<T, S, F>(\r\n      this.validator,\r\n      schema,\r\n      formData,\r\n      this.rootSchema,\r\n      includeUndefinedValues,\r\n      this.experimental_defaultFormStateBehavior\r\n    );\r\n  }\r\n\r\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n   * should be displayed in a UI.\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\r\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n   * @returns - True if the label should be displayed or false if it should not\r\n   */\r\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\r\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\r\n  }\r\n\r\n  /** Determines which of the given `options` provided most closely matches the `formData`.\r\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\r\n   *\r\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\r\n   * matching readOnly, default, or const values.\r\n   *\r\n   * @param formData - The form data associated with the schema\r\n   * @param options - The list of options that can be selected from\r\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n   */\r\n  getClosestMatchingOption(\r\n    formData: T | undefined,\r\n    options: S[],\r\n    selectedOption?: number,\r\n    discriminatorField?: string\r\n  ): number {\r\n    return getClosestMatchingOption<T, S, F>(\r\n      this.validator,\r\n      this.rootSchema,\r\n      formData,\r\n      options,\r\n      selectedOption,\r\n      discriminatorField\r\n    );\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n   * Always returns the first option if there is nothing that matches.\r\n   *\r\n   * @param formData - The current formData, if any, used to figure out a match\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The firstindex of the matched option or 0 if none is available\r\n   */\r\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\r\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n   * Deprecated, use `getFirstMatchingOption()` instead.\r\n   *\r\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the matched option or 0 if none is available\r\n   * @deprecated\r\n   */\r\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\r\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n   *\r\n   * @param schema - The schema for which check for array of files flag is desired\r\n   * @param [uiSchema] - The UI schema from which to check the widget\r\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n   */\r\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\r\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a multi-select\r\n   *\r\n   * @param schema - The schema for which check for a multi-select flag is desired\r\n   * @returns - True if schema contains a multi-select, otherwise false\r\n   */\r\n  isMultiSelect(schema: S) {\r\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a select\r\n   *\r\n   * @param schema - The schema for which check for a select flag is desired\r\n   * @returns - True if schema contains a select, otherwise false\r\n   */\r\n  isSelect(schema: S) {\r\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\r\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\r\n   * then `validationData` is returned.\r\n   *\r\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n   * @param [additionalErrorSchema] - The additional set of errors\r\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n   *        removed in the next major release.\r\n   */\r\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\r\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\r\n  }\r\n\r\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\r\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\r\n   * recursive resolution.\r\n   *\r\n   * @param schema - The schema for which retrieving a schema is desired\r\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n   */\r\n  retrieveSchema(schema: S, rawFormData?: T) {\r\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\r\n  }\r\n\r\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\r\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\r\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\r\n   * old schemas that are non-existent in the new schema are set to `undefined`.\r\n   *\r\n   * @param [newSchema] - The new schema for which the data is being sanitized\r\n   * @param [oldSchema] - The old schema from which the data originated\r\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n   */\r\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\r\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\r\n  }\r\n\r\n  /** Generates an `IdSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [id] - The base id for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [idPrefix='root'] - The prefix to use for the id\r\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n   * @returns - The `IdSchema` object for the `schema`\r\n   */\r\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\r\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\r\n  }\r\n\r\n  /** Generates an `PathSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [name] - The base name for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @returns - The `PathSchema` object for the `schema`\r\n   */\r\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\r\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\r\n  }\r\n}\r\n\r\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\r\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - An implementation of a `SchemaUtilsType` interface\r\n */\r\nexport default function createSchemaUtils<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  experimental_defaultFormStateBehavior = {}\r\n): SchemaUtilsType<T, S, F> {\r\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\r\n}\r\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\r\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\r\n *\r\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\r\n * @returns - an object containing a Blob and its name, extracted from the URI\r\n */\r\nexport default function dataURItoBlob(dataURI: string) {\r\n  // Split metadata from data\r\n  const splitted: string[] = dataURI.split(',');\r\n  // Split params\r\n  const params: string[] = splitted[0].split(';');\r\n  // Get mime-type from params\r\n  const type: string = params[0].replace('data:', '');\r\n  // Filter the name property from params\r\n  const properties = params.filter((param) => {\r\n    return param.split('=')[0] === 'name';\r\n  });\r\n  // Look for the name and use unknown if no name property.\r\n  let name: string;\r\n  if (properties.length !== 1) {\r\n    name = 'unknown';\r\n  } else {\r\n    // Because we filtered out the other property,\r\n    // we only have the name case here, which we decode to make it human-readable\r\n    name = decodeURI(properties[0].split('=')[1]);\r\n  }\r\n\r\n  // Built the Uint8Array Blob parameter from the base64 string.\r\n  try {\r\n    const binary = atob(splitted[1]);\r\n    const array = [];\r\n    for (let i = 0; i < binary.length; i++) {\r\n      array.push(binary.charCodeAt(i));\r\n    }\r\n    // Create the blob object\r\n    const blob = new window.Blob([new Uint8Array(array)], { type });\r\n\r\n    return { blob, name };\r\n  } catch (error) {\r\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\r\n  }\r\n}\r\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\r\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\r\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\r\n *\r\n * @param inputString - The string which will be potentially updated with replacement parameters\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The updated string with any replacement specifiers replaced\r\n */\r\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\r\n  let output = inputString;\r\n  if (Array.isArray(params)) {\r\n    const parts = output.split(/(%\\d)/);\r\n    params.forEach((param, index) => {\r\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\r\n      if (partIndex >= 0) {\r\n        parts[partIndex] = param;\r\n      }\r\n    });\r\n    output = parts.join('');\r\n  }\r\n  return output;\r\n}\r\n", "import { TranslatableString } from './enums';\r\nimport replaceStringParameters from './replaceStringParameters';\r\n\r\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\r\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\r\n * `%2`, etc. replacement specifiers.\r\n *\r\n * @param stringToTranslate - The `TranslatableString` value to convert to english\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\r\n */\r\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\r\n  return replaceStringParameters(stringToTranslate, params);\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\n\r\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\r\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\r\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\r\n * is returned, otherwise the `selected` value is returned.\r\n *\r\n * @param valueIndex - The index of the value to be removed from the selected list or single value\r\n * @param selected - The current (list of) selected value(s)\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\r\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\r\n *        undefined, otherwise `selected`.\r\n */\r\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (Array.isArray(selected)) {\r\n    return selected.filter((v) => !isEqual(v, value));\r\n  }\r\n  return isEqual(value, selected) ? undefined : selected;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\r\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\r\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\r\n * valid values or in the worst case, an empty array.\r\n *\r\n * @param valueIndex - The index(es) of the value(s) that should be returned\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\r\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\r\n *        `emptyValue` or an empty list.\r\n */\r\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number | Array<string | number>,\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  emptyValue?: EnumOptionsType<S>['value']\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  if (Array.isArray(valueIndex)) {\r\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\r\n  }\r\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\r\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\r\n  const option = allEnumOptions[index];\r\n  return option ? option.value : emptyValue;\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Determines whether the given `value` is (one of) the `selected` value(s).\r\n *\r\n * @param value - The value being checked to see if it is selected\r\n * @param selected - The current selected value or list of values\r\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\r\n */\r\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'],\r\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\r\n) {\r\n  if (Array.isArray(selected)) {\r\n    return selected.some((sel) => isEqual(sel, value));\r\n  }\r\n  return isEqual(selected, value);\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\r\n\r\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\r\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\r\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\r\n * returned.\r\n *\r\n * @param value - The single value or list of values for which indexes are desired\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\r\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\r\n *        of indexes for (each of) the value(s) in `value`.\r\n */\r\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  multiple = false\r\n): string | string[] | undefined {\r\n  const selectedIndexes: string[] = allEnumOptions\r\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\r\n    .filter((opt) => typeof opt !== 'undefined') as string[];\r\n  if (!multiple) {\r\n    return selectedIndexes[0];\r\n  }\r\n  return selectedIndexes;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\nimport { isNil } from 'lodash';\r\n\r\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\r\n * `allEnumOptions`\r\n *\r\n * @param valueIndex - The index of the value that should be selected\r\n * @param selected - The current list of selected values\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\r\n */\r\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected: EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n) {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (!isNil(value)) {\r\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\r\n    const all = allEnumOptions.map(({ value: val }) => val);\r\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\r\n    // As inserting values at predefined index positions doesn't work with empty\r\n    // arrays, we need to reorder the updated selection to match the initial order\r\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\r\n  }\r\n  return selected;\r\n}\r\n", "import cloneDeep from 'lodash/cloneDeep';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { ErrorSchema } from './types';\r\nimport { ERRORS_KEY } from './constants';\r\n\r\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\r\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\r\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\r\n * get the result and/or reset all the errors back to an initial set and start again.\r\n */\r\nexport default class ErrorSchemaBuilder<T = any> {\r\n  /** The error schema being built\r\n   *\r\n   * @private\r\n   */\r\n  private errorSchema: ErrorSchema<T> = {};\r\n\r\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   */\r\n  constructor(initialSchema?: ErrorSchema<T>) {\r\n    this.resetAllErrors(initialSchema);\r\n  }\r\n\r\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\r\n   */\r\n  get ErrorSchema() {\r\n    return this.errorSchema;\r\n  }\r\n\r\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The error block for the given `pathOfError` or the root if not provided\r\n   * @private\r\n   */\r\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\r\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\r\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\r\n    if (!errorBlock && pathOfError) {\r\n      errorBlock = {};\r\n      set(this.errorSchema, pathOfError, errorBlock);\r\n    }\r\n    return errorBlock;\r\n  }\r\n\r\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\r\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\r\n    return this;\r\n  }\r\n\r\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\r\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    let errorsList = get(errorBlock, ERRORS_KEY);\r\n    if (!Array.isArray(errorsList)) {\r\n      errorsList = [];\r\n      errorBlock[ERRORS_KEY] = errorsList;\r\n    }\r\n\r\n    if (Array.isArray(errorOrList)) {\r\n      errorsList.push(...errorOrList);\r\n    } else {\r\n      errorsList.push(errorOrList);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\r\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\r\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\r\n    set(errorBlock, ERRORS_KEY, listToAdd);\r\n    return this;\r\n  }\r\n\r\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\r\n   * the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  clearErrors(pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    set(errorBlock, ERRORS_KEY, []);\r\n    return this;\r\n  }\r\n}\r\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\r\nimport { RJSFSchema } from './types';\r\n\r\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\r\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\r\n *\r\n * @param schema - The schema from which to extract the range spec\r\n * @returns - A range specification from the schema\r\n */\r\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const spec: RangeSpecType = {};\r\n  if (schema.multipleOf) {\r\n    spec.step = schema.multipleOf;\r\n  }\r\n  if (schema.minimum || schema.minimum === 0) {\r\n    spec.min = schema.minimum;\r\n  }\r\n  if (schema.maximum || schema.maximum === 0) {\r\n    spec.max = schema.maximum;\r\n  }\r\n  return spec;\r\n}\r\n", "import rangeSpec from './rangeSpec';\r\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\r\n\r\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\r\n *\r\n * @param schema - The schema for the field provided by the widget\r\n * @param [defaultType] - The default type, if any, for the field provided by the widget\r\n * @param [options={}] - The UI Options for the field provided by the widget\r\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\r\n * @returns - The extracted `InputPropsType` object\r\n */\r\nexport default function getInputProps<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  schema: RJSFSchema,\r\n  defaultType?: string,\r\n  options: UIOptionsType<T, S, F> = {},\r\n  autoDefaultStepAny = true\r\n): InputPropsType {\r\n  const inputProps: InputPropsType = {\r\n    type: defaultType || 'text',\r\n    ...rangeSpec(schema),\r\n  };\r\n\r\n  // If options.inputType is set use that as the input type\r\n  if (options.inputType) {\r\n    inputProps.type = options.inputType;\r\n  } else if (!defaultType) {\r\n    // If the schema is of type number or integer, set the input type to number\r\n    if (schema.type === 'number') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\r\n      if (autoDefaultStepAny && inputProps.step === undefined) {\r\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\r\n        // allowed in number inputs\r\n        inputProps.step = 'any';\r\n      }\r\n    } else if (schema.type === 'integer') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined\r\n      if (inputProps.step === undefined) {\r\n        // Since this is integer, you always want to step up or down in multiples of 1\r\n        inputProps.step = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (options.autocomplete) {\r\n    inputProps.autoComplete = options.autocomplete;\r\n  }\r\n\r\n  return inputProps;\r\n}\r\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\r\nimport getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\r\n\r\n/** The default submit button options, exported for testing purposes\r\n */\r\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\r\n  props: {\r\n    disabled: false,\r\n  },\r\n  submitText: 'Submit',\r\n  norender: false,\r\n};\r\n\r\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\r\n *\r\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\r\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\r\n */\r\nexport default function getSubmitButtonOptions<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\r\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\r\n    return { ...DEFAULT_OPTIONS, ...options };\r\n  }\r\n\r\n  return DEFAULT_OPTIONS;\r\n}\r\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\r\n\r\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\r\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\r\n *\r\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\r\n * @param registry - The `Registry` from which to read the template\r\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\r\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\r\n */\r\nexport default function getTemplate<\r\n  Name extends keyof TemplatesType<T, S, F>,\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\r\n  const { templates } = registry;\r\n  if (name === 'ButtonTemplates') {\r\n    return templates[name];\r\n  }\r\n  return (\r\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\r\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\r\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\r\n  );\r\n}\r\n", "import { createElement } from 'react';\r\nimport ReactIs from 'react-is';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\r\nimport getSchemaType from './getSchemaType';\r\n\r\n/** The map of schema types to widget type to widget name\r\n */\r\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\r\n  boolean: {\r\n    checkbox: 'CheckboxWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  string: {\r\n    text: 'TextWidget',\r\n    password: 'PasswordWidget',\r\n    email: 'EmailWidget',\r\n    hostname: 'TextWidget',\r\n    ipv4: 'TextWidget',\r\n    ipv6: 'TextWidget',\r\n    uri: 'URLWidget',\r\n    'data-url': 'FileWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    textarea: 'TextareaWidget',\r\n    hidden: 'HiddenWidget',\r\n    date: 'DateWidget',\r\n    datetime: 'DateTimeWidget',\r\n    'date-time': 'DateTimeWidget',\r\n    'alt-date': 'AltDateWidget',\r\n    'alt-datetime': 'AltDateTimeWidget',\r\n    time: 'TimeWidget',\r\n    color: 'ColorWidget',\r\n    file: 'FileWidget',\r\n  },\r\n  number: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  integer: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  array: {\r\n    select: 'SelectWidget',\r\n    checkboxes: 'CheckboxesWidget',\r\n    files: 'FileWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n};\r\n\r\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\r\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\r\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\r\n *\r\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\r\n * @returns - The wrapper widget\r\n */\r\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  AWidget: Widget<T, S, F>\r\n) {\r\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\r\n  // cache return value as property of widget for proper react reconciliation\r\n  if (!MergedWidget) {\r\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\r\n    MergedWidget = ({ options, ...props }) => {\r\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\r\n    };\r\n    set(AWidget, 'MergedWidget', MergedWidget);\r\n  }\r\n  return MergedWidget;\r\n}\r\n\r\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\r\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\r\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\r\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\r\n *\r\n * @param schema - The schema for the field\r\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - The `Widget` component to use\r\n * @throws - An error if there is no `Widget` component that can be returned\r\n */\r\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget?: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n): Widget<T, S, F> {\r\n  const type = getSchemaType(schema);\r\n\r\n  if (\r\n    typeof widget === 'function' ||\r\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\r\n    ReactIs.isMemo(widget)\r\n  ) {\r\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\r\n  }\r\n\r\n  if (typeof widget !== 'string') {\r\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\r\n  }\r\n\r\n  if (widget in registeredWidgets) {\r\n    const registeredWidget = registeredWidgets[widget];\r\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    if (!(type in widgetMap)) {\r\n      throw new Error(`No widget for type '${type}'`);\r\n    }\r\n\r\n    if (widget in widgetMap[type]) {\r\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\r\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n    }\r\n  }\r\n\r\n  throw new Error(`No widget '${widget}' for type '${type}'`);\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** JS has no built-in hashing function, so rolling our own\r\n *  based on Java's hashing fn:\r\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\r\n *\r\n * @param string - The string for which to get the hash\r\n * @returns - The resulting hash of the string in hex format\r\n */\r\nfunction hashString(string: string): string {\r\n  let hash = 0;\r\n  for (let i = 0; i < string.length; i += 1) {\r\n    const chr = string.charCodeAt(i);\r\n    hash = (hash << 5) - hash + chr;\r\n    hash = hash & hash; // Convert to 32bit integer\r\n  }\r\n  return hash.toString(16);\r\n}\r\n\r\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\r\n * in consistent order before stringify to prevent different hash ids for the same schema.\r\n *\r\n * @param schema - The schema for which the hash is desired\r\n * @returns - The string obtained from the hash of the stringified schema\r\n */\r\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const allKeys = new Set<string>();\r\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\r\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\r\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\r\n}\r\n", "import getWidget from './getWidget';\r\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\r\n\r\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\r\n * does, or false if it doesn't.\r\n *\r\n * @param schema - The schema for the field\r\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - True if the widget exists, false otherwise\r\n */\r\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n) {\r\n  try {\r\n    getWidget(schema, widget, registeredWidgets);\r\n    return true;\r\n  } catch (e) {\r\n    const err: Error = e as Error;\r\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\r\n      return false;\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n", "import isString from 'lodash/isString';\r\n\r\nimport { IdSchema } from './types';\r\nimport { ID_KEY } from './constants';\r\n\r\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param suffix - The suffix to append to the id\r\n */\r\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\r\n  const theId = isString(id) ? id : id[ID_KEY];\r\n  return `${theId}__${suffix}`;\r\n}\r\n/** Return a consistent `id` for the field description element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field description element from the given `id`\r\n */\r\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'description');\r\n}\r\n\r\n/** Return a consistent `id` for the field error element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field error element from the given `id`\r\n */\r\nexport function errorId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'error');\r\n}\r\n\r\n/** Return a consistent `id` for the field examples element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field examples element from the given `id`\r\n */\r\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'examples');\r\n}\r\n\r\n/** Return a consistent `id` for the field help element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field help element from the given `id`\r\n */\r\nexport function helpId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'help');\r\n}\r\n\r\n/** Return a consistent `id` for the field title element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field title element from the given `id`\r\n */\r\nexport function titleId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'title');\r\n}\r\n\r\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\r\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\r\n * element.\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\r\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\r\n */\r\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\r\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\r\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\r\n}\r\n\r\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\r\n *\r\n * @param id - The id of the parent component for the option\r\n * @param optionIndex - The index of the option for which the id is desired\r\n * @returns - An id for the option index based on the parent `id`\r\n */\r\nexport function optionId(id: string, optionIndex: number) {\r\n  return `${id}-${optionIndex}`;\r\n}\r\n", "import { ReactElement } from 'react';\r\n\r\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\r\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\r\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\r\n * themes require may `false` and others may require an empty string.\r\n *\r\n * @param [label] - The label string or component to render when not hidden\r\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\r\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\r\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\r\n */\r\nexport function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: ''): undefined | string;\r\nexport default function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: false | '') {\r\n  return hideLabel ? fallback : label;\r\n}\r\n", "/** Converts a local Date string into a UTC date string\r\n *\r\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\r\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\r\n */\r\nexport default function localToUTC(dateString: string) {\r\n  return dateString ? new Date(dateString).toJSON() : undefined;\r\n}\r\n", "import { CONST_KEY, ENUM_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\r\n * throws an error.\r\n *\r\n * @param schema - The schema from which to obtain the constant value\r\n * @returns - The constant value for the schema\r\n * @throws - Error when the schema does not have a constant value\r\n */\r\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\r\n    return schema.enum[0];\r\n  }\r\n  if (CONST_KEY in schema) {\r\n    return schema.const;\r\n  }\r\n  throw new Error('schema cannot be inferred as a constant');\r\n}\r\n", "import toConstant from './toConstant';\r\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\r\n\r\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\r\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\r\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\r\n * `const` values from the schema and the label is either the `schema.title` or the value.\r\n *\r\n * @param schema - The schema from which to extract the options list\r\n * @returns - The list of options from the schema\r\n */\r\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S\r\n): EnumOptionsType<S>[] | undefined {\r\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\r\n  // Cast the type to include enumNames so the feature still works.\r\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\r\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\r\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\r\n  }\r\n  if (schema.enum) {\r\n    return schema.enum.map((value, i) => {\r\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\r\n      return { label, value };\r\n    });\r\n  }\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  return (\r\n    altSchemas &&\r\n    altSchemas.map((aSchemaDef) => {\r\n      const aSchema = aSchemaDef as S;\r\n      const value = toConstant(aSchema);\r\n      const label = aSchema.title || String(value);\r\n      return {\r\n        schema: aSchema,\r\n        label,\r\n        value,\r\n      };\r\n    })\r\n  );\r\n}\r\n", "import { GenericObjectType } from './types';\r\n\r\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\r\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\r\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\r\n * places in the location of the `*`.\r\n *\r\n * @param properties - The list of property keys to be ordered\r\n * @param order - An array of property keys to be ordered first, with an optional '*' property\r\n * @returns - A list with the `properties` ordered\r\n * @throws - Error when the properties cannot be ordered correctly\r\n */\r\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\r\n  if (!Array.isArray(order)) {\r\n    return properties;\r\n  }\r\n\r\n  const arrayToHash = (arr: string[]) =>\r\n    arr.reduce((prev: GenericObjectType, curr) => {\r\n      prev[curr] = true;\r\n      return prev;\r\n    }, {});\r\n  const errorPropList = (arr: string[]) =>\r\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\r\n  const propertyHash = arrayToHash(properties);\r\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\r\n  const orderHash = arrayToHash(orderFiltered);\r\n\r\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\r\n  const restIndex = orderFiltered.indexOf('*');\r\n  if (restIndex === -1) {\r\n    if (rest.length) {\r\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\r\n    }\r\n    return orderFiltered;\r\n  }\r\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\r\n    throw new Error('uiSchema order list contains more than one wildcard item');\r\n  }\r\n\r\n  const complete = [...orderFiltered];\r\n  complete.splice(restIndex, 1, ...rest);\r\n  return complete;\r\n}\r\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\r\n *\r\n * @param num - The number to pad\r\n * @param width - The width of the string at which no lead padding is necessary\r\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\r\n */\r\nexport default function pad(num: number, width: number) {\r\n  let s = String(num);\r\n  while (s.length < width) {\r\n    s = '0' + s;\r\n  }\r\n  return s;\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\r\n *\r\n * @param dateString - The date string to parse into a DateObject\r\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\r\n * @returns - The date string converted to a `DateObject`\r\n * @throws - Error when the date cannot be parsed from the string\r\n */\r\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\r\n  if (!dateString) {\r\n    return {\r\n      year: -1,\r\n      month: -1,\r\n      day: -1,\r\n      hour: includeTime ? -1 : 0,\r\n      minute: includeTime ? -1 : 0,\r\n      second: includeTime ? -1 : 0,\r\n    };\r\n  }\r\n  const date = new Date(dateString);\r\n  if (Number.isNaN(date.getTime())) {\r\n    throw new Error('Unable to parse date ' + dateString);\r\n  }\r\n  return {\r\n    year: date.getUTCFullYear(),\r\n    month: date.getUTCMonth() + 1, // oh you, javascript.\r\n    day: date.getUTCDate(),\r\n    hour: includeTime ? date.getUTCHours() : 0,\r\n    minute: includeTime ? date.getUTCMinutes() : 0,\r\n    second: includeTime ? date.getUTCSeconds() : 0,\r\n  };\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\r\n * - `schema.const` is truthy\r\n * - `schema.enum` == `[true]`\r\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\r\n * - `schema.allOf` has at least one value which recursively returns true\r\n *\r\n * @param schema - The schema to check\r\n * @returns - True if the schema specifies a value that must be true, false otherwise\r\n */\r\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\r\n  // Check if const is a truthy value\r\n  if (schema.const) {\r\n    return true;\r\n  }\r\n\r\n  // Check if an enum has a single value of true\r\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\r\n    return true;\r\n  }\r\n\r\n  // If anyOf has a single value, evaluate the subschema\r\n  if (schema.anyOf && schema.anyOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\r\n  }\r\n\r\n  // If oneOf has a single value, evaluate the subschema\r\n  if (schema.oneOf && schema.oneOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\r\n  }\r\n\r\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\r\n  if (schema.allOf) {\r\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\r\n    return schema.allOf.some(schemaSome);\r\n  }\r\n\r\n  return false;\r\n}\r\n", "import React from 'react';\r\n\r\nimport deepEquals from './deepEquals';\r\n\r\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\r\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\r\n *\r\n * @param component - A React component being checked\r\n * @param nextProps - The next set of props against which to check\r\n * @param nextState - The next set of state against which to check\r\n * @returns - True if the component should be re-rendered, false otherwise\r\n */\r\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\r\n  const { props, state } = component;\r\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\r\n * removed.\r\n *\r\n * @param dateObject - The `DateObject` to convert to a date string\r\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\r\n * @returns - The UTC date string\r\n */\r\nexport default function toDateString(dateObject: DateObject, time = true) {\r\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\r\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\r\n  const datetime = new Date(utcTime).toJSON();\r\n  return time ? datetime : datetime.slice(0, 10);\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\r\n\r\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\r\n *\r\n * @param errorSchema - The `ErrorSchema` instance to convert\r\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\r\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\r\n */\r\nexport default function toErrorList<T = any>(\r\n  errorSchema?: ErrorSchema<T>,\r\n  fieldPath: string[] = []\r\n): RJSFValidationError[] {\r\n  if (!errorSchema) {\r\n    return [];\r\n  }\r\n  let errorList: RJSFValidationError[] = [];\r\n  if (ERRORS_KEY in errorSchema) {\r\n    errorList = errorList.concat(\r\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\r\n        const property = `.${fieldPath.join('.')}`;\r\n        return {\r\n          property,\r\n          message,\r\n          stack: `${property} ${message}`,\r\n        };\r\n      })\r\n    );\r\n  }\r\n  return Object.keys(errorSchema).reduce((acc, key) => {\r\n    if (key !== ERRORS_KEY) {\r\n      const childSchema = (errorSchema as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\r\n      }\r\n    }\r\n    return acc;\r\n  }, errorList);\r\n}\r\n", "import toPath from 'lodash/toPath';\r\n\r\nimport { ErrorSchema, RJSFValidationError } from './types';\r\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\r\n\r\n/** Transforms a rjsf validation errors list:\r\n * [\r\n *   {property: '.level1.level2[2].level3', message: 'err a'},\r\n *   {property: '.level1.level2[2].level3', message: 'err b'},\r\n *   {property: '.level1.level2[4].level3', message: 'err b'},\r\n * ]\r\n * Into an error tree:\r\n * {\r\n *   level1: {\r\n *     level2: {\r\n *       2: {level3: {errors: ['err a', 'err b']}},\r\n *       4: {level3: {errors: ['err b']}},\r\n *     }\r\n *   }\r\n * };\r\n *\r\n * @param errors - The list of RJSFValidationError objects\r\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\r\n */\r\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\r\n  const builder = new ErrorSchemaBuilder<T>();\r\n  if (errors.length) {\r\n    errors.forEach((error) => {\r\n      const { property, message } = error;\r\n      // When the property is the root element, just use an empty array for the path\r\n      const path = property === '.' ? [] : toPath(property);\r\n      // If the property is at the root (.level1) then toPath creates\r\n      // an empty array element at the first index. Remove it.\r\n      if (path.length > 0 && path[0] === '') {\r\n        path.splice(0, 1);\r\n      }\r\n      if (message) {\r\n        builder.addErrors(message, path);\r\n      }\r\n    });\r\n  }\r\n  return builder.ErrorSchema;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\r\n *\r\n * @param errorHandler - The `FormValidation` error handling structure\r\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\r\n */\r\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\r\n  return Object.keys(errorHandler).reduce((acc, key) => {\r\n    if (key === 'addError') {\r\n      return acc;\r\n    } else {\r\n      const childSchema = (errorHandler as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        return {\r\n          ...acc,\r\n          [key]: unwrapErrorHandler(childSchema),\r\n        };\r\n      }\r\n      return { ...acc, [key]: childSchema };\r\n    }\r\n  }, {} as ErrorSchema<T>);\r\n}\r\n", "import pad from './pad';\r\n\r\n/** Converts a UTC date string into a local Date format\r\n *\r\n * @param jsonDate - A UTC date string\r\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\r\n */\r\nexport default function utcToLocal(jsonDate: string) {\r\n  if (!jsonDate) {\r\n    return '';\r\n  }\r\n\r\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\r\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\r\n  // > should be a _valid local date and time string_ (not GMT)\r\n\r\n  // Note - date constructor passed local ISO-8601 does not correctly\r\n  // change time to UTC in node pre-8\r\n  const date = new Date(jsonDate);\r\n\r\n  const yyyy = pad(date.getFullYear(), 4);\r\n  const MM = pad(date.getMonth() + 1, 2);\r\n  const dd = pad(date.getDate(), 2);\r\n  const hh = pad(date.getHours(), 2);\r\n  const mm = pad(date.getMinutes(), 2);\r\n  const ss = pad(date.getSeconds(), 2);\r\n  const SSS = pad(date.getMilliseconds(), 3);\r\n\r\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from './mergeObjects';\r\nimport toErrorList from './toErrorList';\r\nimport { ErrorSchema, ValidationData } from './types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n */\r\nexport default function validationDataMerge<T = any>(\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\nimport isObject from 'lodash/isObject';\r\n\r\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\r\n  for (const key in node) {\r\n    const realObj: { [k: string]: any } = node;\r\n    const value = realObj[key];\r\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\r\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\r\n    } else {\r\n      realObj[key] = withIdRefPrefix<S>(value);\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\r\n  for (let i = 0; i < node.length; i++) {\r\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\r\n * This is used in isValid to make references to the rootSchema\r\n *\r\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n * @returns - A copy of the `schemaNode` with updated `$ref`s\r\n */\r\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(schemaNode: S): S | S[] {\r\n  if (Array.isArray(schemaNode)) {\r\n    return withIdRefPrefixArray<S>([...schemaNode]);\r\n  }\r\n  if (isObject(schemaNode)) {\r\n    return withIdRefPrefixObject<S>({ ...schemaNode });\r\n  }\r\n  return schemaNode;\r\n}\r\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\r\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\r\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\r\n * parameters is important because some languages may choose to put the second parameter before the first in its\r\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\r\n */\r\nexport enum TranslatableString {\r\n  /** Fallback title of an array item, used by ArrayField */\r\n  ArrayItemTitle = 'Item',\r\n  /** Missing items reason, used by ArrayField */\r\n  MissingItems = 'Missing items definition',\r\n  /** Yes label, used by BooleanField */\r\n  YesLabel = 'Yes',\r\n  /** No label, used by BooleanField */\r\n  NoLabel = 'No',\r\n  /** Close label, used by ErrorList */\r\n  CloseLabel = 'Close',\r\n  /** Errors label, used by ErrorList */\r\n  ErrorsLabel = 'Errors',\r\n  /** New additionalProperties string default value, used by ObjectField */\r\n  NewStringDefault = 'New Value',\r\n  /** Add button title, used by AddButton */\r\n  AddButton = 'Add',\r\n  /** Add button title, used by AddButton */\r\n  AddItemButton = 'Add Item',\r\n  /** Copy button title, used by IconButton */\r\n  CopyButton = 'Copy',\r\n  /** Move down button title, used by IconButton */\r\n  MoveDownButton = 'Move down',\r\n  /** Move up button title, used by IconButton */\r\n  MoveUpButton = 'Move up',\r\n  /** Remove button title, used by IconButton */\r\n  RemoveButton = 'Remove',\r\n  /** Now label, used by AltDateWidget */\r\n  NowLabel = 'Now',\r\n  /** Clear label, used by AltDateWidget */\r\n  ClearLabel = 'Clear',\r\n  /** Aria date label, used by DateWidget */\r\n  AriaDateLabel = 'Select a date',\r\n  /** File preview label, used by FileWidget */\r\n  PreviewLabel = 'Preview',\r\n  /** Decrement button aria label, used by UpDownWidget */\r\n  DecrementAriaLabel = 'Decrease value by 1',\r\n  /** Increment button aria label, used by UpDownWidget */\r\n  IncrementAriaLabel = 'Increase value by 1',\r\n  // Strings with replaceable parameters\r\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\r\n  UnknownFieldType = 'Unknown field type %1',\r\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\r\n  OptionPrefix = 'Option %1',\r\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\r\n   * MultiSchemaField\r\n   */\r\n  TitleOptionPrefix = '%1 option %2',\r\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\r\n  KeyLabel = '%1 Key',\r\n  // Strings with replaceable parameters AND/OR that support markdown and html\r\n  /** Invalid object field configuration as provided by the ObjectField */\r\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\r\n  /** Unsupported field schema, used by UnsupportedField */\r\n  UnsupportedField = 'Unsupported field schema.',\r\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\r\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\r\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\r\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\r\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\r\n   * as provided by UnsupportedField\r\n   */\r\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\r\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\r\n   * provided by FileWidget\r\n   */\r\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\r\n}\r\n", "import forEach from 'lodash/forEach';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\r\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\r\nimport ParserValidator, { SchemaMap } from './ParserValidator';\r\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\r\n\r\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\r\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\r\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\r\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\r\n *\r\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\r\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\r\n * @param rootSchema - The root schema from which the schema parsing began\r\n * @param schema - The current schema element being parsed\r\n */\r\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ParserValidator<T, S, F>,\r\n  recurseList: S[],\r\n  rootSchema: S,\r\n  schema: S\r\n) {\r\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\r\n  schemas.forEach((schema) => {\r\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\r\n    if (sameSchemaIndex === -1) {\r\n      recurseList.push(schema);\r\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\r\n      allOptions.forEach((s) => {\r\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\r\n          forEach(schema[PROPERTIES_KEY], (value) => {\r\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\r\n          });\r\n        }\r\n      });\r\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\r\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\r\n * the hash of the schema to schema/sub-schema.\r\n *\r\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\r\n * @returns - The `SchemaMap` of all schemas that were parsed\r\n */\r\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  rootSchema: S\r\n): SchemaMap<S> {\r\n  const validator = new ParserValidator<T, S, F>(rootSchema);\r\n  const recurseList: S[] = [];\r\n\r\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\r\n\r\n  return validator.getSchemaMap();\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ID_KEY } from '../constants';\r\nimport hashForSchema from '../hashForSchema';\r\nimport {\r\n  CustomValidator,\r\n  ErrorSchema,\r\n  ErrorTransformer,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  RJSFValidationError,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from '../types';\r\n\r\n/** The type of the map of schema hash to schema\r\n */\r\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\r\n  [hash: string]: S;\r\n};\r\n\r\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\r\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\r\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\r\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\r\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\r\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\r\n */\r\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements ValidatorType<T, S, F>\r\n{\r\n  /** The rootSchema provided during construction of the class */\r\n  readonly rootSchema: S;\r\n\r\n  /** The map of schemas encountered by the ParserValidator */\r\n  schemaMap: SchemaMap<S> = {};\r\n\r\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\r\n   * first.\r\n   *\r\n   * @param rootSchema - The root schema against which this validator will be executed\r\n   */\r\n  constructor(rootSchema: S) {\r\n    this.rootSchema = rootSchema;\r\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\r\n  }\r\n\r\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\r\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\r\n   * associated with it's `hash` for future use (by a schema compiler).\r\n   *\r\n   * @param schema - The schema which is to be added to the map\r\n   * @param hash - The hash value at which to map the schema\r\n   */\r\n  addSchema(schema: S, hash: string) {\r\n    const key = get(schema, ID_KEY, hash);\r\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\r\n    const existing = this.schemaMap[key];\r\n    if (!existing) {\r\n      this.schemaMap[key] = identifiedSchema;\r\n    } else if (!isEqual(existing, identifiedSchema)) {\r\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\r\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\r\n      throw new Error(\r\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\r\n      );\r\n    }\r\n  }\r\n\r\n  /** Returns the current `schemaMap` to the caller\r\n   */\r\n  getSchemaMap() {\r\n    return this.schemaMap;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\r\n   * the `rootSchema` is not the same as the root schema provided during construction.\r\n   *\r\n   * @param schema - The schema to record in the `schemaMap`\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param rootSchema - The root schema associated with the schema\r\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\r\n   */\r\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\r\n    if (!isEqual(rootSchema, this.rootSchema)) {\r\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\r\n    }\r\n    this.addSchema(schema, hashForSchema<S>(schema));\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _formData - The formData parameter that is ignored\r\n   */\r\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\r\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _errorSchema - The error schema parameter that is ignored\r\n   * @param _fieldPath - The field path parameter that is ignored\r\n   */\r\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\r\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\r\n   * called\r\n   *\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _customValidate - The customValidate parameter that is ignored\r\n   * @param _transformErrors - The transformErrors parameter that is ignored\r\n   * @param _uiSchema - The uiSchema parameter that is ignored\r\n   */\r\n  validateFormData(\r\n    _formData: T,\r\n    _schema: S,\r\n    _customValidate?: CustomValidator<T, S, F>,\r\n    _transformErrors?: ErrorTransformer<T, S, F>,\r\n    _uiSchema?: UiSchema<T, S, F>\r\n  ): ValidationData<T> {\r\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\r\n  }\r\n}\r\n"],
+  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACMe,SAAR,SAA0B,OAAY;AAC3C,MAAI,OAAO,SAAS,eAAe,iBAAiB,MAAM;AACxD,WAAO;AAAA,EACT;AACA,MAAI,OAAO,SAAS,eAAe,iBAAiB,MAAM;AACxD,WAAO;AAAA,EACT;AACA,SAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK;AAC5E;;;ACLe,SAAR,qBAA+E,QAAW;AAC/F,MAAI,OAAO,oBAAoB,MAAM;AACnC,YAAQ,KAAK,iDAAiD;AAAA,EAChE;AACA,SAAO,SAAS,OAAO,eAAe;AACxC;;;ACLe,SAAR,SAA0B,OAAsB;AACrD,MAAI,UAAU,IAAI;AAChB,WAAO;AAAA,EACT;AACA,MAAI,UAAU,MAAM;AAClB,WAAO;AAAA,EACT;AACA,MAAI,MAAM,KAAK,KAAK,GAAG;AAGrB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,KAAK,KAAK,GAAG;AAEtB,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,KAAK,KAAK,GAAG;AAIzB,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,OAAO,KAAK;AACtB,QAAM,QAAQ,OAAO,MAAM,YAAY,CAAC,OAAO,MAAM,CAAC;AAEtD,SAAO,QAAQ,IAAI;AACrB;;;AChCO,IAAM,2BAA2B;AACjC,IAAM,4BAA4B;AAClC,IAAM,aAAa;AACnB,IAAM,aAAa;AACnB,IAAM,YAAY;AAClB,IAAM,cAAc;AACpB,IAAM,kBAAkB;AACxB,IAAM,mBAAmB;AACzB,IAAM,WAAW;AACjB,IAAM,aAAa;AACnB,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,iBAAiB;AACvB,IAAM,WAAW;AACjB,IAAM,aAAa;AACnB,IAAM,iBAAiB;AACvB,IAAM,eAAe;AACrB,IAAM,yBAAyB;AAC/B,IAAM,UAAU;AAChB,IAAM,iCAAiC;AACvC,IAAM,qBAAqB;AAC3B,IAAM,eAAe;AACrB,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AACvB,IAAM,wBAAwB;;;ACnBtB,SAAR,aACL,WAA8B,CAAC,GAC/B,gBAAuC,CAAC,GAChB;AACxB,SAAO,OAAO,KAAK,QAAQ,EACxB,OAAO,CAAC,QAAQ,IAAI,QAAQ,KAAK,MAAM,CAAC,EACxC;AAAA,IACC,CAAC,SAAS,QAAQ;AAChB,YAAM,QAAQ,SAAS,GAAG;AAC1B,UAAI,QAAQ,iBAAiB,SAAS,KAAK,GAAG;AAC5C,gBAAQ,MAAM,qFAAqF;AACnG,eAAO;AAAA,MACT;AACA,UAAI,QAAQ,kBAAkB,SAAS,KAAK,GAAG;AAC7C,eAAO,EAAE,GAAG,SAAS,GAAG,MAAM;AAAA,MAChC;AACA,aAAO,EAAE,GAAG,SAAS,CAAC,IAAI,UAAU,CAAC,CAAC,GAAG,MAAM;AAAA,IACjD;AAAA,IACA,EAAE,GAAG,cAAc;AAAA,EACrB;AACJ;;;ACnBe,SAAR,UACL,QACA,WAA8B,CAAC,GAC/B,UACA;AACA,MAAI,CAAC,OAAO,sBAAsB;AAChC,WAAO;AAAA,EACT;AACA,QAAM,EAAE,aAAa,KAAK,IAAI,aAAsB,QAAQ;AAC5D,MAAI,eAAe,OAAO;AACxB,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,kBAAkB,UAAa,UAAU;AAClD,WAAO,OAAO,KAAK,QAAQ,EAAE,SAAS,OAAO;AAAA,EAC/C;AACA,SAAO;AACT;;;AC9BA,2BAA0B;AAUX,SAAR,mBAA6C,UAAgC;AAClF,QAAM,UAA2B;AAAA;AAAA;AAAA;AAAA,IAI/B,CAAC,UAAU,GAAG,CAAC;AAAA,IACf,SAAS,SAAiB;AACxB,WAAK,UAAU,EAAG,KAAK,OAAO;AAAA,IAChC;AAAA,EACF;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,OAAO,CAAC,KAAK,OAAO,QAAQ;AAC1C,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,mBAAmB,KAAK,EAAE;AAAA,IACpD,GAAG,OAAO;AAAA,EACZ;AACA,UAAI,qBAAAA,SAAc,QAAQ,GAAG;AAC3B,UAAM,aAAgC;AACtC,WAAO,OAAO,KAAK,UAAU,EAAE,OAAO,CAAC,KAAK,QAAQ;AAClD,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,mBAAmB,WAAW,GAAG,CAAC,EAAE;AAAA,IAC9D,GAAG,OAA4B;AAAA,EACjC;AACA,SAAO;AACT;;;AChCA,yBAAwB;AAST,SAAR,WAA4B,GAAQ,GAAiB;AAC1D,aAAO,mBAAAC,SAAY,GAAG,GAAG,CAAC,KAAU,UAAe;AACjD,QAAI,OAAO,QAAQ,cAAc,OAAO,UAAU,YAAY;AAG5D,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACH;;;AClBA,IAAAC,cAAgB;AAChB,qBAAoB;;;ACDpB,yBAAwB;AACxB,kBAAiB;AAaV,SAAS,0BAA0B,KAAa,QAA2B;AAChF,QAAM,QAAQ,OAAO,GAAG;AACxB,QAAM,gBAAY,YAAAC,SAAK,QAAQ,CAAC,GAAG,CAAC;AACpC,SAAO,CAAC,WAAW,KAAK;AAC1B;AAWe,SAAR,qBACL,MACA,aAAgB,CAAC,GACd;AACH,MAAI,MAAM,QAAQ;AAClB,MAAI,IAAI,WAAW,GAAG,GAAG;AAEvB,UAAM,mBAAmB,IAAI,UAAU,CAAC,CAAC;AAAA,EAC3C,OAAO;AACL,UAAM,IAAI,MAAM,mCAAmC,IAAI,GAAG;AAAA,EAC5D;AACA,QAAM,UAAa,mBAAAC,QAAY,IAAI,YAAY,GAAG;AAClD,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI,MAAM,mCAAmC,IAAI,GAAG;AAAA,EAC5D;AACA,MAAI,QAAQ,OAAO,GAAG;AACpB,UAAM,CAAC,WAAW,MAAM,IAAI,0BAA0B,SAAS,OAAO;AACtE,UAAM,YAAY,qBAAwB,QAAQ,UAAU;AAC5D,QAAI,OAAO,KAAK,SAAS,EAAE,SAAS,GAAG;AACrC,aAAO,EAAE,GAAG,WAAW,GAAG,UAAU;AAAA,IACtC;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;ACrDA,IAAAC,cAAgB;AAChB,IAAAC,cAAgB;AAChB,IAAAC,mBAAqB;AACrB,IAAAC,mBAAqB;AACrB,IAAAC,mBAAqB;AACrB,oBAAmB;AACnB,IAAAC,gBAAkB;;;ACNlB,IAAAC,cAAgB;AAChB,iBAAgB;AAChB,sBAAqB;;;ACFrB,iBAAgB;AAcD,SAAR,qCACL,UACA,SACA,oBACoB;AACpB,MAAI,YAAY,oBAAoB;AAClC,UAAM,YAAQ,WAAAC,SAAI,UAAU,kBAAkB;AAE9C,QAAI,UAAU,QAAW;AACvB;AAAA,IACF;AAEA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAM,SAAS,QAAQ,CAAC;AACxB,YAAM,oBAAgB,WAAAA,SAAI,QAAQ,CAAC,gBAAgB,kBAAkB,GAAG,CAAC,CAAC;AAE1E,UAAI,cAAc,SAAS,YAAY,cAAc,SAAS,SAAS;AACrE;AAAA,MACF;AAEA,UAAI,cAAc,UAAU,OAAO;AACjC,eAAO;AAAA,MACT;AAEA,UAAI,cAAc,MAAM,SAAS,KAAK,GAAG;AACvC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA;AACF;;;ADzBe,SAAR,kBAKL,WACA,UACA,SACA,YACA,oBACQ;AAGR,MAAI,aAAa,QAAW;AAC1B,WAAO;AAAA,EACT;AAEA,QAAM,2BAA2B,qCAAqC,UAAU,SAAS,kBAAkB;AAC3G,UAAI,gBAAAC,SAAS,wBAAwB,GAAG;AACtC,WAAO;AAAA,EACT;AAEA,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,UAAM,SAAS,QAAQ,CAAC;AAGxB,QAAI,0BAAsB,WAAAC,SAAI,QAAQ,CAAC,gBAAgB,kBAAkB,CAAC,GAAG;AAC3E,YAAM,YAAQ,YAAAC,SAAI,UAAU,kBAAkB;AAC9C,YAAM,oBAAgB,YAAAA,SAAI,QAAQ,CAAC,gBAAgB,kBAAkB,GAAG,CAAC,CAAC;AAC1E,UAAI,UAAU,QAAQ,eAAe,OAAO,UAAU,GAAG;AACvD,eAAO;AAAA,MACT;AAAA,IACF,WAAW,OAAO,cAAc,GAAG;AAWjC,YAAM,gBAAgB;AAAA,QACpB,OAAO,OAAO,KAAK,OAAO,cAAc,CAAC,EAAE,IAAI,CAAC,SAAS;AAAA,UACvD,UAAU,CAAC,GAAG;AAAA,QAChB,EAAE;AAAA,MACJ;AAEA,UAAI;AAGJ,UAAI,OAAO,OAAO;AAEhB,cAAM,EAAE,GAAG,aAAa,IAAI;AAE5B,YAAI,CAAC,aAAa,OAAO;AACvB,uBAAa,QAAQ,CAAC;AAAA,QACxB,OAAO;AAEL,uBAAa,QAAQ,aAAa,MAAM,MAAM;AAAA,QAChD;AAEA,qBAAa,MAAM,KAAK,aAAa;AAErC,0BAAkB;AAAA,MACpB,OAAO;AACL,0BAAkB,OAAO,OAAO,CAAC,GAAG,QAAQ,aAAa;AAAA,MAC3D;AAIA,aAAO,gBAAgB;AAEvB,UAAI,UAAU,QAAQ,iBAAiB,UAAU,UAAU,GAAG;AAC5D,eAAO;AAAA,MACT;AAAA,IACF,WAAW,UAAU,QAAQ,QAAQ,UAAU,UAAU,GAAG;AAC1D,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;AExFe,SAAR,uBAKL,WACA,UACA,SACA,YACA,oBACQ;AACR,SAAO,kBAA2B,WAAW,UAAU,SAAS,YAAY,kBAAkB;AAChG;;;AC1BA,IAAAC,cAAgB;AAChB,qBAAoB;AACpB,iBAAgB;AAChB,mBAAkB;AAClB,uBAAsB;AACtB,qCAAoC;;;ACLpC,IAAAC,cAAgB;AAChB,sBAAqB;AAUN,SAAR,gCAA0F,QAAW;AAC1G,MAAI;AACJ,QAAM,kBAAc,YAAAC,SAAI,QAAQ,8BAA8B,MAAS;AACvE,UAAI,gBAAAC,SAAS,WAAW,GAAG;AACzB,oBAAgB;AAAA,EAClB,WAAW,gBAAgB,QAAW;AACpC,YAAQ,KAAK,gDAAgD,OAAO,WAAW,WAAW;AAAA,EAC5F;AACA,SAAO;AACT;;;ACde,SAAR,UAA2B,OAAY;AAC5C,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AACA,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,CAAC,MAAM,KAAK,GAAG;AACjB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AC3BA,mBAAkB;;;ACcH,SAAR,cACL,QAC+B;AAC/B,MAAI,EAAE,KAAK,IAAI;AAEf,MAAI,CAAC,QAAQ,OAAO,OAAO;AACzB,WAAO,UAAU,OAAO,KAAK;AAAA,EAC/B;AAEA,MAAI,CAAC,QAAQ,OAAO,MAAM;AACxB,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,SAAS,OAAO,cAAc,OAAO,uBAAuB;AAC/D,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,QAAI,KAAK,WAAW,KAAK,KAAK,SAAS,MAAM,GAAG;AAC9C,aAAO,KAAK,KAAK,CAACC,UAASA,UAAS,MAAM;AAAA,IAC5C,OAAO;AACL,aAAO,KAAK,CAAC;AAAA,IACf;AAAA,EACF;AAEA,SAAO;AACT;;;ADzBe,SAAR,aAA8B,MAAyB,MAAyB;AACrF,QAAM,MAAM,OAAO,OAAO,CAAC,GAAG,IAAI;AAClC,SAAO,OAAO,KAAK,IAAI,EAAE,OAAO,CAACC,MAAK,QAAQ;AAC5C,UAAM,OAAO,OAAO,KAAK,GAAG,IAAI,CAAC,GAC/B,QAAQ,KAAK,GAAG;AAClB,QAAI,QAAQ,OAAO,QAAQ,SAAS,KAAK,GAAG;AAC1C,MAAAA,KAAI,GAAG,IAAI,aAAa,MAAM,KAAK;AAAA,IACrC,WACE,QACA,SACC,cAAc,IAAI,MAAM,YAAY,cAAc,IAAI,MAAM,aAC7D,QAAQ,gBACR,MAAM,QAAQ,IAAI,KAClB,MAAM,QAAQ,KAAK,GACnB;AAEA,MAAAA,KAAI,GAAG,QAAI,aAAAC,SAAM,MAAM,KAAK;AAAA,IAC9B,OAAO;AACL,MAAAD,KAAI,GAAG,IAAI;AAAA,IACb;AACA,WAAOA;AAAA,EACT,GAAG,GAAG;AACR;;;AHAe,SAAR,eAIL,WAAmC,QAAW,aAAgB,CAAC,GAAQ,aAAoB;AAC3F,SAAO,uBAAgC,WAAW,QAAQ,YAAY,WAAW,EAAE,CAAC;AACtF;AAeO,SAAS,iBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,EAAE,IAAI,YAAY,MAAM,MAAM,WAAW,GAAG,8BAA8B,IAAI;AAEpF,QAAM,iBAAiB,UAAU,QAAQ,YAAiB,YAAa,CAAC,GAAS,UAAU;AAC3F,MAAI,kBAAkB,CAAC,6BAAkC;AACzD,MAAI,UAAe,CAAC;AACpB,MAAI,mBAAmB;AACrB,QAAI,QAAQ,OAAO,SAAS,WAAW;AACrC,gBAAU,QAAQ;AAAA,QAChB,uBAAgC,WAAW,MAAW,YAAY,UAAU,mBAAmB,WAAW;AAAA,MAC5G;AAAA,IACF;AACA,QAAI,aAAa,OAAO,cAAc,WAAW;AAC/C,gBAAU,QAAQ;AAAA,QAChB,uBAAgC,WAAW,WAAgB,YAAY,UAAU,mBAAmB,WAAW;AAAA,MACjH;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,oBAAoB,iBAAiB,OAAO;AAClD,QAAI,qBAAqB,OAAO,sBAAsB,WAAW;AAC/D,gBAAU,QAAQ;AAAA,QAChB;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,QAAQ,QAAQ;AAClB,sBAAkB,QAAQ,IAAI,CAAC,MAAM,aAAa,+BAA+B,CAAC,CAAM;AAAA,EAC1F;AACA,SAAO,gBAAgB;AAAA,IAAQ,CAAC,MAC9B,uBAAgC,WAAW,GAAG,YAAY,UAAU,mBAAmB,WAAW;AAAA,EACpG;AACF;AAgBO,SAAS,0BAAmE,aAAoB;AACrG,QAAM,kBAAyB,YAAY;AAAA,IACzC,CAAC,cAAc,SAAS;AAEtB,UAAI,KAAK,SAAS,GAAG;AACnB,eAAO,KAAK,QAAQ,CAAC,gBAAY,aAAAE,SAAM,aAAa,QAAQ,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,EAAE,OAAO,OAAO,CAAC,CAAC;AAAA,MAC1G;AAEA,mBAAa,QAAQ,CAAC,gBAAgB,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC;AAC/D,aAAO;AAAA,IACT;AAAA,IACA,CAAC,CAAC,CAAC;AAAA;AAAA,EACL;AAEA,SAAO;AACT;AAeO,SAAS,cACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,MAAI,eAAe,SAAS,KAAK,eAAe,CAAC,MAAM,QAAQ;AAG7D,WAAO;AAAA,EACT;AACA,MAAI,oBAAoB,QAAQ;AAC9B,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,gBAAgB,QAAQ,CAAC,MAAM;AACpC,aAAO,uBAAgC,WAAW,GAAG,YAAY,UAAU,mBAAmB,WAAW;AAAA,IAC3G,CAAC;AAAA,EACH;AACA,MAAI,cAAc,UAAU,MAAM,QAAQ,OAAO,KAAK,GAAG;AACvD,UAAM,sBAA6B,OAAO,MAAM;AAAA,MAAI,CAAC,mBACnD;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,kBAAkB,0BAA6B,mBAAmB;AACxE,WAAO,gBAAgB,IAAI,CAAC,iBAAiB,EAAE,GAAG,QAAQ,OAAO,YAAY,EAAE;AAAA,EACjF;AAEA,SAAO,CAAC,MAAM;AAChB;AAeO,SAAS,iBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,gBAAgB,qBAAwB,QAAQ,YAAY,WAAW;AAC7E,MAAI,kBAAkB,QAAQ;AAE5B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,SAAO,CAAC,MAAM;AAChB;AASO,SAAS,qBACd,QACA,YACA,aACG;AACH,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAO;AAAA,EACT;AACA,MAAI,iBAAoB;AAExB,MAAI,WAAW,gBAAgB;AAC7B,UAAM,EAAE,MAAM,GAAG,YAAY,IAAI;AAEjC,QAAI,YAAY,SAAS,IAAK,GAAG;AAC/B,aAAO;AAAA,IACT;AACA,gBAAY,KAAK,IAAK;AAEtB,UAAM,YAAY,qBAAwB,MAAM,UAAU;AAC1D,qBAAiB,EAAE,GAAG,WAAW,GAAG,YAAY;AAAA,EAClD;AAEA,MAAI,kBAAkB,gBAAgB;AACpC,UAAM,mBAAe,iBAAAC;AAAA,MACnB,eAAe,cAAc;AAAA,MAC7B,CAAC,QAAQ,OAAO,QAAgB;AAC9B,eAAO,GAAG,IAAI,qBAAqB,OAAY,YAAY,WAAW;AAAA,MACxE;AAAA,MACA,CAAC;AAAA,IACH;AACA,qBAAiB,EAAE,GAAG,gBAAgB,CAAC,cAAc,GAAG,aAAa;AAAA,EACvE;AAEA,MACE,aAAa,kBACb,CAAC,MAAM,QAAQ,eAAe,KAAK,KACnC,OAAO,eAAe,UAAU,WAChC;AACA,qBAAiB;AAAA,MACf,GAAG;AAAA,MACH,OAAO,qBAAqB,eAAe,OAAY,YAAY,WAAW;AAAA,IAChF;AAAA,EACF;AAEA,aAAO,eAAAC,SAAQ,QAAQ,cAAc,IAAI,SAAS;AACpD;AAUO,SAAS,iCAId,WAAmC,WAAc,YAAgB,WAAkB;AAEnF,QAAM,SAAS;AAAA,IACb,GAAG;AAAA,IACH,YAAY,EAAE,GAAG,UAAU,WAAW;AAAA,EACxC;AAGA,QAAM,WAA8B,aAAa,SAAS,SAAS,IAAI,YAAY,CAAC;AACpF,SAAO,KAAK,QAAQ,EAAE,QAAQ,CAAC,QAAQ;AACrC,QAAI,OAAO,OAAO,YAAY;AAE5B;AAAA,IACF;AAEA,QAAI,uBAAkD,CAAC;AACvD,QAAI,OAAO,OAAO,yBAAyB,WAAW;AACpD,UAAI,WAAW,OAAO,sBAAuB;AAC3C,+BAAuB;AAAA,UACrB;AAAA,UACA,EAAE,UAAM,YAAAC,SAAI,OAAO,sBAAsB,CAAC,OAAO,CAAC,EAAE;AAAA,UACpD;AAAA,UACA;AAAA,QACF;AAAA,MACF,WAAW,UAAU,OAAO,sBAAuB;AACjD,+BAAuB,EAAE,GAAG,OAAO,qBAAqB;AAAA,MAC1D,WAAW,cAAc,OAAO,wBAAyB,cAAc,OAAO,sBAAuB;AACnG,+BAAuB;AAAA,UACrB,MAAM;AAAA,UACN,GAAG,OAAO;AAAA,QACZ;AAAA,MACF,OAAO;AACL,+BAAuB,EAAE,MAAM,cAAU,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;AAAA,MACjE;AAAA,IACF,OAAO;AACL,6BAAuB,EAAE,MAAM,cAAU,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;AAAA,IACjE;AAGA,WAAO,WAAW,GAAG,IAAI;AAEzB,mBAAAC,SAAI,OAAO,YAAY,CAAC,KAAK,wBAAwB,GAAG,IAAI;AAAA,EAC9D,CAAC;AAED,SAAO;AACT;AAiBO,SAAS,uBAKd,WACA,QACA,YACA,aACA,oBAAoB,OACpB,cAAwB,CAAC,GACpB;AACL,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAO,CAAC,CAAC,CAAM;AAAA,EACjB;AACA,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,gBAAgB,QAAQ,CAAC,MAAS;AACvC,QAAI,iBAAiB;AACrB,QAAI,UAAU,gBAAgB;AAC5B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,cAAc,gBAAgB;AAEhC,UAAI,mBAAmB;AACrB,cAAM,EAAE,OAAO,GAAG,aAAa,IAAI;AACnC,eAAO,CAAC,GAAI,OAAe,YAAiB;AAAA,MAC9C;AACA,UAAI;AACF,6BAAiB,+BAAAC,SAAW,gBAAgB;AAAA,UAC1C,MAAM;AAAA,QACR,CAAY;AAAA,MACd,SAAS,GAAG;AACV,gBAAQ,KAAK,0CAA0C,CAAC;AACxD,cAAM,EAAE,OAAO,GAAG,2BAA2B,IAAI;AACjD,eAAO;AAAA,MACT;AAAA,IACF;AACA,UAAM,0BACJ,6BAA6B,kBAAkB,eAAe,yBAAyB;AACzF,QAAI,yBAAyB;AAC3B,aAAO,iCAA0C,WAAW,gBAAgB,YAAY,WAAgB;AAAA,IAC1G;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAcO,SAAS,yBAId,WAAmC,QAAW,YAAe,mBAA4B,aAAiB;AAC1G,MAAI;AACJ,QAAM,EAAE,OAAO,OAAO,GAAG,UAAU,IAAI;AACvC,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,iBAAa;AAAA,EACf,WAAW,MAAM,QAAQ,KAAK,GAAG;AAC/B,iBAAa;AAAA,EACf;AACA,MAAI,YAAY;AAEd,UAAM,WAAW,gBAAgB,UAAa,oBAAqB,CAAC,IAAU;AAC9E,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,iBAAa,WAAW,IAAI,CAAC,MAAM;AAGjC,aAAO,qBAAqB,GAAG,YAAY,CAAC,CAAC;AAAA,IAC/C,CAAC;AAED,UAAM,SAAS,uBAAgC,WAAW,UAAU,YAAY,YAAY,aAAa;AACzG,QAAI,mBAAmB;AACrB,aAAO,WAAW,IAAI,CAAC,SAAS,aAAa,WAAW,IAAI,CAAM;AAAA,IACpE;AACA,aAAS,aAAa,WAAW,WAAW,MAAM,CAAC;AAAA,EACrD;AACA,SAAO,CAAC,MAAM;AAChB;AAcO,SAAS,oBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AAEL,QAAM,EAAE,cAAc,GAAG,gBAAgB,IAAI;AAC7C,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,gBAAgB;AAAA,IAAQ,CAAC,mBAC9B;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAeO,SAAS,oBACd,WACA,cACA,gBACA,YACA,mBACA,aACA,UACK;AACL,MAAI,UAAU,CAAC,cAAc;AAE7B,aAAW,iBAAiB,cAAc;AAExC,QAAI,CAAC,yBAAqB,YAAAF,SAAI,UAAU,CAAC,aAAa,CAAC,MAAM,QAAW;AACtE;AAAA,IACF;AAEA,QAAI,eAAe,cAAc,EAAE,iBAAiB,eAAe,aAAa;AAC9E;AAAA,IACF;AACA,UAAM,CAAC,uBAAuB,eAAe,IAAI;AAAA,MAC/C;AAAA,MACA;AAAA,IACF;AACA,QAAI,MAAM,QAAQ,eAAe,GAAG;AAClC,cAAQ,CAAC,IAAI,wBAA2B,gBAAgB,eAAe;AAAA,IACzE,WAAW,SAAS,eAAe,GAAG;AACpC,gBAAU;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,QAAQ;AAAA,MAAQ,CAAC,WACtB;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAQO,SAAS,wBACd,QACA,sBACA;AACA,MAAI,CAAC,sBAAsB;AACzB,WAAO;AAAA,EACT;AACA,QAAM,WAAW,MAAM,QAAQ,OAAO,QAAQ,IAC1C,MAAM,KAAK,oBAAI,IAAI,CAAC,GAAG,OAAO,UAAU,GAAG,oBAAoB,CAAC,CAAC,IACjE;AACJ,SAAO,EAAE,GAAG,QAAQ,SAAmB;AACzC;AAgBO,SAAS,oBACd,WACA,QACA,YACA,eACA,iBACA,mBACA,aACA,UACK;AACL,QAAM,mBAAmB;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,iBAAiB,QAAQ,CAAC,cAAc;AAC7C,UAAM,EAAE,OAAO,GAAG,gBAAgB,IAAI;AACtC,aAAS,aAAa,QAAQ,eAAe;AAE7C,QAAI,UAAU,QAAW;AACvB,aAAO;AAAA,IACT;AAEA,UAAM,iBAAiB,MAAM,IAAI,CAAC,cAAc;AAC9C,UAAI,OAAO,cAAc,aAAa,EAAE,WAAW,YAAY;AAC7D,eAAO,CAAC,SAAc;AAAA,MACxB;AACA,aAAO,iBAA0B,WAAW,WAAgB,YAAY,mBAAmB,aAAa,QAAQ;AAAA,IAClH,CAAC;AACD,UAAM,kBAAkB,0BAA0B,cAAc;AAChE,WAAO,gBAAgB;AAAA,MAAQ,CAAC,kBAC9B;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAiBO,SAAS,wBAKd,WACA,QACA,YACA,eACA,OACA,mBACA,aACA,UACK;AACL,QAAM,kBAAkB,MAAO,OAAO,CAAC,cAAc;AACnD,QAAI,OAAO,cAAc,aAAa,CAAC,aAAa,CAAC,UAAU,YAAY;AACzE,aAAO;AAAA,IACT;AACA,UAAM,EAAE,CAAC,aAAa,GAAG,wBAAwB,IAAI,UAAU;AAC/D,QAAI,yBAAyB;AAC3B,YAAM,kBAAqB;AAAA,QACzB,MAAM;AAAA,QACN,YAAY;AAAA,UACV,CAAC,aAAa,GAAG;AAAA,QACnB;AAAA,MACF;AACA,aAAO,UAAU,QAAQ,iBAAiB,UAAU,UAAU,KAAK;AAAA,IACrE;AACA,WAAO;AAAA,EACT,CAAC;AAED,MAAI,CAAC,qBAAqB,gBAAiB,WAAW,GAAG;AACvD,YAAQ,KAAK,wFAAwF;AACrG,WAAO,CAAC,MAAM;AAAA,EAChB;AACA,SAAO,gBAAgB,QAAQ,CAAC,MAAM;AACpC,UAAM,YAAe;AACrB,UAAM,CAAC,kBAAkB,IAAI,0BAA0B,eAAe,UAAU,UAA+B;AAC/G,UAAM,kBAAkB,EAAE,GAAG,WAAW,YAAY,mBAAmB;AACvE,UAAM,UAAU;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,QAAQ,IAAI,CAACG,OAAM,aAAa,QAAQA,EAAC,CAAM;AAAA,EACxD,CAAC;AACH;;;AJ/rBO,IAAM,cAAgC;AAAA,EAC3C,MAAM;AAAA,EACN,KAAK;AAAA,EACL,YAAY;AAAA,IACV,sBAAsB;AAAA,MACpB,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAsBO,SAAS,oBACd,WACA,YACA,QACA,WAAgB,CAAC,GACT;AACR,MAAI,aAAa;AACjB,MAAI,QAAQ;AACV,YAAI,iBAAAC,SAAS,OAAO,UAAU,GAAG;AAC/B,wBAAc,cAAAC;AAAA,QACZ,OAAO;AAAA,QACP,CAAC,OAAO,OAAO,QAAQ;AACrB,gBAAM,gBAAY,YAAAC,SAAI,UAAU,GAAG;AACnC,cAAI,OAAO,UAAU,WAAW;AAC9B,mBAAO;AAAA,UACT;AACA,kBAAI,YAAAC,SAAI,OAAO,OAAO,GAAG;AACvB,kBAAM,YAAY,eAAwB,WAAW,OAAY,YAAY,SAAS;AACtF,mBAAO,QAAQ,oBAA6B,WAAW,YAAY,WAAW,aAAa,CAAC,CAAC;AAAA,UAC/F;AACA,mBAAK,YAAAA,SAAI,OAAO,UAAU,SAAK,YAAAA,SAAI,OAAO,UAAU,MAAM,WAAW;AACnE,kBAAMC,WAAM,YAAAD,SAAI,OAAO,UAAU,IAAI,aAAa;AAClD,kBAAM,gBAAgB,gCAAmC,KAAU;AACnE,mBACE,QACA;AAAA,cACE;AAAA,cACA;AAAA,cACA;AAAA,kBACA,YAAAD,SAAI,OAAOE,IAAG;AAAA,cACd;AAAA,cACA;AAAA,YACF;AAAA,UAEJ;AACA,cAAI,MAAM,SAAS,UAAU;AAC3B,mBAAO,QAAQ,oBAA6B,WAAW,YAAY,OAAY,aAAa,CAAC,CAAC;AAAA,UAChG;AACA,cAAI,MAAM,SAAS,UAAU,SAAS,GAAG;AAEvC,gBAAI,WAAW,QAAQ;AACvB,gBAAI,MAAM,SAAS;AAGjB,0BAAY,cAAc,MAAM,UAAU,IAAI;AAAA,YAChD,WAAW,MAAM,OAAO;AAGtB,0BAAY,cAAc,MAAM,QAAQ,IAAI;AAAA,YAC9C;AAEA,mBAAO;AAAA,UACT;AACA,iBAAO;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAAA,IACF,eAAW,iBAAAC,SAAS,OAAO,IAAI,KAAK,OAAO,SAAS,UAAU,QAAQ,GAAG;AACvE,oBAAc;AAAA,IAChB;AAAA,EACF;AACA,SAAO;AACT;AAwBe,SAAR,yBAKL,WACA,YACA,UACA,SACA,iBAAiB,IACjB,oBACQ;AAER,QAAM,kBAAkB,QAAQ,IAAI,CAAC,WAAW;AAC9C,WAAO,qBAAwB,QAAQ,YAAY,CAAC,CAAC;AAAA,EACvD,CAAC;AAED,QAAM,2BAA2B,qCAAqC,UAAU,SAAS,kBAAkB;AAC3G,UAAI,iBAAAC,SAAS,wBAAwB,GAAG;AACtC,WAAO;AAAA,EACT;AAGA,QAAM,kBAAkB,gBAAgB,OAAO,CAAC,WAAqB,QAAQ,UAAkB;AAC7F,UAAM,cAAmB,CAAC,aAAkB,MAAM;AAClD,UAAM,QAAQ,uBAAgC,WAAW,UAAU,aAAa,YAAY,kBAAkB;AAE9G,QAAI,UAAU,GAAG;AACf,gBAAU,KAAK,KAAK;AAAA,IACtB;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AAGL,MAAI,gBAAgB,WAAW,GAAG;AAChC,WAAO,gBAAgB,CAAC;AAAA,EAC1B;AACA,MAAI,CAAC,gBAAgB,QAAQ;AAE3B,sBAAAC,SAAM,gBAAgB,QAAQ,CAAC,MAAM,gBAAgB,KAAK,CAAC,CAAC;AAAA,EAC9D;AAEA,QAAM,aAAa,oBAAI,IAAY;AAEnC,QAAM,EAAE,UAAU,IAAc,gBAAgB;AAAA,IAC9C,CAAC,WAAqB,UAAkB;AACtC,YAAM,EAAE,UAAU,IAAI;AACtB,YAAM,SAAS,gBAAgB,KAAK;AACpC,YAAM,QAAQ,oBAAoB,WAAW,YAAY,QAAQ,QAAQ;AACzE,iBAAW,IAAI,KAAK;AACpB,UAAI,QAAQ,WAAW;AACrB,eAAO,EAAE,WAAW,OAAO,WAAW,MAAM;AAAA,MAC9C;AACA,aAAO;AAAA,IACT;AAAA,IACA,EAAE,WAAW,gBAAgB,WAAW,EAAE;AAAA,EAC5C;AAEA,MAAI,WAAW,SAAS,KAAK,kBAAkB,GAAG;AAChD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AS7Le,SAAR,aAAuE,QAAW;AACvF,SAAO,MAAM,QAAQ,OAAO,KAAK,KAAK,OAAO,MAAM,SAAS,KAAK,OAAO,MAAM,MAAM,CAAC,SAAS,SAAS,IAAI,CAAC;AAC9G;;;ACXA,IAAAC,cAAgB;AAqBD,SAAR,0BACL,UACA,UACA,0BAA0B,OACX;AACf,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,UAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,WAAW,CAAC;AAC5D,UAAM,SAAS,SAAS,IAAI,CAAC,OAAO,QAAQ;AAC1C,UAAI,cAAc,GAAG,GAAG;AACtB,eAAO,0BAA+B,cAAc,GAAG,GAAG,OAAO,uBAAuB;AAAA,MAC1F;AACA,aAAO;AAAA,IACT,CAAC;AAED,QAAI,2BAA2B,OAAO,SAAS,cAAc,QAAQ;AACnE,aAAO,KAAK,GAAG,cAAc,MAAM,OAAO,MAAM,CAAC;AAAA,IACnD;AACA,WAAO;AAAA,EACT;AACA,MAAI,SAAS,QAAQ,GAAG;AACtB,UAAM,MAAiC,OAAO,OAAO,CAAC,GAAG,QAAQ;AACjE,WAAO,OAAO,KAAK,QAA6B,EAAE,OAAO,CAACC,MAAK,QAAQ;AACrE,MAAAA,KAAI,GAAc,IAAI;AAAA,QACpB,eAAW,YAAAC,SAAI,UAAU,GAAG,IAAI,CAAC;AAAA,YACjC,YAAAA,SAAI,UAAU,GAAG;AAAA,QACjB;AAAA,MACF;AACA,aAAOD;AAAA,IACT,GAAG,GAAG;AAAA,EACR;AACA,SAAO;AACT;;;ACxCe,SAAR,aACL,MACA,MACA,eAA8C,OAC9C;AACA,SAAO,OAAO,KAAK,IAAI,EAAE,OAAO,CAAC,KAAK,QAAQ;AAC5C,UAAM,OAAO,OAAO,KAAK,GAAG,IAAI,CAAC,GAC/B,QAAQ,KAAK,GAAG;AAClB,QAAI,QAAQ,OAAO,QAAQ,SAAS,KAAK,GAAG;AAC1C,UAAI,GAAG,IAAI,aAAa,MAAM,OAAO,YAAY;AAAA,IACnD,WAAW,gBAAgB,MAAM,QAAQ,IAAI,KAAK,MAAM,QAAQ,KAAK,GAAG;AACtE,UAAI,UAAU;AACd,UAAI,iBAAiB,qBAAqB;AACxC,kBAAU,MAAM,OAAO,CAAC,QAAQ,UAAU;AACxC,cAAI,CAAC,KAAK,SAAS,KAAK,GAAG;AACzB,mBAAO,KAAK,KAAK;AAAA,UACnB;AACA,iBAAO;AAAA,QACT,GAAG,CAAC,CAAC;AAAA,MACP;AACA,UAAI,GAAG,IAAI,KAAK,OAAO,OAAO;AAAA,IAChC,OAAO;AACL,UAAI,GAAG,IAAI;AAAA,IACb;AACA,WAAO;AAAA,EACT,GAAG,OAAO,OAAO,CAAC,GAAG,IAAI,CAAC;AAC5B;;;AC7Be,SAAR,WAAqE,QAAW;AACrF,SAAQ,MAAM,QAAQ,OAAO,IAAI,KAAK,OAAO,KAAK,WAAW,KAAM,aAAa;AAClF;;;ACAe,SAAR,SACL,WACA,WACA,aAAgB,CAAC,GACjB;AACA,QAAM,SAAS,eAAwB,WAAW,WAAW,YAAY,MAAS;AAClF,QAAM,aAAa,OAAO,SAAS,OAAO;AAC1C,MAAI,MAAM,QAAQ,OAAO,IAAI,GAAG;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,WAAW,MAAM,CAACE,gBAAe,OAAOA,gBAAe,aAAa,WAAWA,WAAU,CAAC;AAAA,EACnG;AACA,SAAO;AACT;;;ACde,SAAR,cAIL,WAAmC,QAAW,YAAgB;AAC9D,MAAI,CAAC,OAAO,eAAe,CAAC,OAAO,SAAS,OAAO,OAAO,UAAU,WAAW;AAC7E,WAAO;AAAA,EACT;AACA,SAAO,SAAkB,WAAW,OAAO,OAAY,UAAU;AACnE;;;AhB0CO,SAAS,2BACd,QACA,kBAA2C,gBAC3C,MAAM,IACH;AACH,MAAI,OAAO,GAAG;AACZ,QAAI,MAAM,QAAQ,OAAO,KAAK,KAAK,MAAM,OAAO,MAAM,QAAQ;AAC5D,YAAM,OAAO,OAAO,MAAM,GAAG;AAC7B,UAAI,OAAO,SAAS,WAAW;AAC7B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,WAAW,OAAO,SAAS,CAAC,MAAM,QAAQ,OAAO,KAAK,KAAK,OAAO,OAAO,UAAU,WAAW;AAC5F,WAAO,OAAO;AAAA,EAChB;AACA,MAAI,oBAAoB,kBAAkC,SAAS,OAAO,eAAe,GAAG;AAC1F,WAAO,OAAO;AAAA,EAChB;AACA,SAAO,CAAC;AACV;AAqBA,SAAS,wBACP,KACA,KACA,iBACA,wBACA,kBACA,iBAA2B,CAAC,GAC5B,wCAA+E,CAAC,GAChF;AACA,QAAM,EAAE,oBAAoB,sBAAsB,IAAI;AACtD,MAAI,wBAAwB;AAC1B,QAAI,GAAG,IAAI;AAAA,EACb,WAAW,sBAAsB,gBAAgB;AAC/C,QAAI,SAAS,eAAe,GAAG;AAG7B,YAAM,yBAAyB,qBAAqB,SAAY,eAAe,SAAS,GAAG,IAAI;AAI/F,WACG,KAAC,eAAAC,SAAQ,eAAe,KAAK,eAAe,SAAS,GAAG,OACxD,0BAA0B,sBAAsB,6BACjD;AACA,YAAI,GAAG,IAAI;AAAA,MACb;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,MAIE,oBAAoB,WACnB,sBAAsB,yBAAyB,eAAe,SAAS,GAAG;AAAA,MAC3E;AACA,UAAI,GAAG,IAAI;AAAA,IACb;AAAA,EACF;AACF;AA6BO,SAAS,gBACd,WACA,WACA;AAAA,EACE;AAAA,EACA;AAAA,EACA,aAAa,CAAC;AAAA,EACd,yBAAyB;AAAA,EACzB,eAAe,CAAC;AAAA,EAChB,wCAAwC;AAAA,EACxC;AACF,IAAgC,CAAC,GACZ;AACrB,QAAM,WAAe,SAAS,WAAW,IAAI,cAAc,CAAC;AAC5D,QAAM,SAAY,SAAS,SAAS,IAAI,YAAa,CAAC;AAEtD,MAAI,WAAgC;AAEpC,MAAI,kBAA4B;AAChC,MAAI,qBAAqB;AAEzB,MAAI,SAAS,QAAQ,KAAK,SAAS,OAAO,OAAO,GAAG;AAGlD,eAAW,aAAa,UAAW,OAAO,OAA4B;AAAA,EACxE,WAAW,eAAe,QAAQ;AAChC,eAAW,OAAO;AAAA,EACpB,WAAW,WAAW,QAAQ;AAC5B,UAAM,UAAU,OAAO,OAAO;AAE9B,QAAI,CAAC,aAAa,SAAS,OAAQ,GAAG;AACpC,2BAAqB,aAAa,OAAO,OAAQ;AACjD,wBAAkB,qBAAwB,SAAS,UAAU;AAAA,IAC/D;AAAA,EACF,WAAW,oBAAoB,QAAQ;AACrC,UAAM,iBAAiB,oBAA6B,WAAW,QAAQ,YAAY,OAAO,CAAC,GAAG,QAAQ;AACtG,sBAAkB,eAAe,CAAC;AAAA,EACpC,WAAW,aAAa,MAAM,GAAG;AAC/B,eAAY,OAAO,MAAe;AAAA,MAAI,CAAC,YAAe,QACpD,gBAAsB,WAAW,YAAY;AAAA,QAC3C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB,MAAM,QAAQ,cAAc,IAAI,eAAe,GAAG,IAAI;AAAA,QACtE,aAAa;AAAA,QACb;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,WAAW,cAAc,QAAQ;AAC/B,UAAM,EAAE,OAAO,GAAG,UAAU,IAAI;AAChC,QAAI,MAAO,WAAW,GAAG;AACvB,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,sBAAkB,MAChB;AAAA,MACE;AAAA,MACA;AAAA,UACA,eAAAA,SAAQ,QAAQ,IAAI,SAAY;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CACF;AACA,sBAAkB,aAAa,WAAW,eAAe;AAAA,EAC3D,WAAW,cAAc,QAAQ;AAC/B,UAAM,EAAE,OAAO,GAAG,UAAU,IAAI;AAChC,QAAI,MAAO,WAAW,GAAG;AACvB,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,sBAAkB,MAChB;AAAA,MACE;AAAA,MACA;AAAA,UACA,eAAAA,SAAQ,QAAQ,IAAI,SAAY;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CACF;AACA,sBAAkB,aAAa,WAAW,eAAe;AAAA,EAC3D;AAEA,MAAI,iBAAiB;AACnB,WAAO,gBAAyB,WAAW,iBAAiB;AAAA,MAC1D;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd;AAAA,MACA,gBAAgB;AAAA,MAChB,aAAa;AAAA,MACb;AAAA,IACF,CAAC;AAAA,EACH;AAGA,MAAI,aAAa,QAAW;AAC1B,eAAW,OAAO;AAAA,EACpB;AAEA,UAAQ,cAAiB,MAAM,GAAG;AAAA,IAEhC,KAAK,UAAU;AAGb,YAAM,kBACJ,cAAc,SAAS,eAAwB,WAAW,QAAQ,YAAY,QAAQ,IAAI;AAC5F,YAAM,iBAAiB,OAAO,KAAK,gBAAgB,cAAc,CAAC,CAAC,EAAE;AAAA,QACnE,CAAC,KAAwB,QAAgB;AAGvC,gBAAM,kBAAkB,gBAAyB,eAAW,YAAAC,SAAI,iBAAiB,CAAC,gBAAgB,GAAG,CAAC,GAAG;AAAA,YACvG;AAAA,YACA;AAAA,YACA;AAAA,YACA,wBAAwB,2BAA2B;AAAA,YACnD,oBAAgB,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YACnC,iBAAa,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YAChC,UAAU,gBAAgB,UAAU,SAAS,GAAG;AAAA,UAClD,CAAC;AACD;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB;AAAA,YAChB;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AACA,UAAI,gBAAgB,sBAAsB;AAExC,cAAM,6BAA6B,SAAS,gBAAgB,oBAAoB,IAC5E,gBAAgB,uBAChB,CAAC;AACL,cAAM,OAAO,oBAAI,IAAY;AAC7B,YAAI,SAAS,QAAQ,GAAG;AACtB,iBAAO,KAAK,QAA6B,EACtC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,cAAc,CAAC,gBAAgB,WAAW,GAAG,CAAC,EAC/E,QAAQ,CAAC,QAAQ,KAAK,IAAI,GAAG,CAAC;AAAA,QACnC;AACA,cAAM,mBAA6B,CAAC;AACpC,eAAO,KAAK,QAA6B,EACtC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,cAAc,CAAC,gBAAgB,WAAW,GAAG,CAAC,EAC/E,QAAQ,CAAC,QAAQ;AAChB,eAAK,IAAI,GAAG;AACZ,2BAAiB,KAAK,GAAG;AAAA,QAC3B,CAAC;AACH,aAAK,QAAQ,CAAC,QAAQ;AACpB,gBAAM,kBAAkB,gBAAgB,WAAW,4BAAiC;AAAA,YAClF;AAAA,YACA;AAAA,YACA;AAAA,YACA,wBAAwB,2BAA2B;AAAA,YACnD,oBAAgB,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YACnC,iBAAa,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YAChC,UAAU,gBAAgB,UAAU,SAAS,GAAG;AAAA,UAClD,CAAC;AAED;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK,SAAS;AAEZ,YAAM,gBACJ,OAAO,kCAAkC,uCAAuC;AAClF,YAAM,gBAAgB,eAAe,aAAa;AAClD,YAAM,wBAAwB,eAAe,aAAa;AAG1D,UAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,mBAAW,SAAS,IAAI,CAAC,MAAM,QAAQ;AACrC,gBAAM,aAAgB,2BAA8B,QAAQ,kBAAkC,GAAG;AACjG,iBAAO,gBAAyB,WAAW,YAAY;AAAA,YACrD;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB;AAAA,YAChB;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAGA,UAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,cAAM,aAAgB,2BAA8B,MAAM;AAC1D,YAAI,eAAe;AACjB,qBAAW;AAAA,QACb,OAAO;AACL,qBAAW,YAAY,IAAI,CAAC,MAAS,QAAgB;AACnD,mBAAO,gBAAyB,WAAW,YAAY;AAAA,cACrD;AAAA,cACA;AAAA,cACA;AAAA,cACA,aAAa;AAAA,cACb,oBAAgB,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,cACnC;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF;AAEA,UAAI,eAAe;AACjB,eAAO,YAAY,CAAC;AAAA,MACtB;AACA,UAAI,yBAAyB,CAAC,UAAU;AAGtC,eAAO,WAAW,WAAW;AAAA,MAC/B;AAEA,YAAM,iBAAiB,MAAM,QAAQ,QAAQ,IAAI,SAAS,SAAS;AACnE,UACE,CAAC,OAAO,YACR,cAAuB,WAAW,QAAQ,UAAU,KACpD,OAAO,YAAY,gBACnB;AACA,eAAO,WAAW,WAAW,CAAC;AAAA,MAChC;AAEA,YAAM,iBAAuB,YAAY,CAAC;AAC1C,YAAM,eAAkB,2BAA8B,QAAQ,cAA8B;AAC5F,YAAM,gBAAgB,aAAa;AAGnC,YAAM,gBAAqB,IAAI,MAAM,OAAO,WAAW,cAAc,EAAE;AAAA,QACrE,gBAA2B,WAAW,cAAc;AAAA,UAClD,gBAAgB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO,eAAe,OAAO,aAAa;AAAA,IAC5C;AAAA,EACF;AAEA,SAAO;AACT;AAee,SAAR,oBAKL,WACA,WACA,UACA,YACA,yBAA4D,OAC5D,uCACA;AACA,MAAI,CAAC,SAAS,SAAS,GAAG;AACxB,UAAM,IAAI,MAAM,qBAAqB,SAAS;AAAA,EAChD;AACA,QAAM,SAAS,eAAwB,WAAW,WAAW,YAAY,QAAQ;AACjF,QAAM,WAAW,gBAAyB,WAAW,QAAQ;AAAA,IAC3D;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa;AAAA,EACf,CAAC;AACD,MAAI,aAAa,UAAa,aAAa,QAAS,OAAO,aAAa,YAAY,MAAM,QAAQ,GAAI;AAEpG,WAAO;AAAA,EACT;AAEA,QAAM,gBAAgB,OAAO,kCAAkC,uCAAuC;AAEtG,QAAM,EAAE,mBAAmB,IAAI,iBAAiB,CAAC;AACjD,MAAI,SAAS,QAAQ,GAAG;AACtB,WAAO,0BAA6B,UAAe,UAAU,kBAAkB;AAAA,EACjF;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,0BAA+B,UAAiB,UAAU,kBAAkB;AAAA,EACrF;AACA,SAAO;AACT;;;AiBjde,SAAR,eAIL,WAA8B,CAAC,GAAG;AAClC;AAAA;AAAA;AAAA,IAGE,YAAY,aAAsB,QAAQ,KAAK,aAAsB,QAAQ,EAAE,QAAQ,MAAM;AAAA;AAEjG;;;ACNe,SAAR,aACL,WACA,QACA,WAA8B,CAAC,GAC/B,YACA;AACA,MAAI,SAAS,aAAa,MAAM,SAAS;AACvC,WAAO;AAAA,EACT;AACA,MAAI,OAAO,OAAO;AAChB,UAAM,cAAc,eAAwB,WAAW,OAAO,OAAY,UAAU;AACpF,WAAO,YAAY,SAAS,YAAY,YAAY,WAAW;AAAA,EACjE;AACA,SAAO;AACT;;;ACDe,SAAR,gBAKL,WACA,QACA,WAA8B,CAAC,GAC/B,YACA,eACS;AACT,QAAM,YAAY,aAAsB,UAAU,aAAa;AAC/D,QAAM,EAAE,QAAQ,KAAK,IAAI;AACzB,MAAI,eAAe,CAAC,CAAC;AACrB,QAAM,aAAa,cAAiB,MAAM;AAE1C,MAAI,eAAe,SAAS;AAC1B,mBACE,cAAuB,WAAW,QAAQ,UAAU,KACpD,aAAsB,WAAW,QAAQ,UAAU,UAAU,KAC7D,eAAe,QAAQ;AAAA,EAC3B;AAEA,MAAI,eAAe,UAAU;AAC3B,mBAAe;AAAA,EACjB;AACA,MAAI,eAAe,aAAa,CAAC,SAAS,aAAa,GAAG;AACxD,mBAAe;AAAA,EACjB;AACA,MAAI,SAAS,YAAY,GAAG;AAC1B,mBAAe;AAAA,EACjB;AACA,SAAO;AACT;;;AC1DA,IAAAC,kBAAoB;AAiBL,SAAR,oBAKL,WACA,gBACA,uBACmB;AACnB,MAAI,CAAC,uBAAuB;AAC1B,WAAO;AAAA,EACT;AACA,QAAM,EAAE,QAAQ,WAAW,aAAa,eAAe,IAAI;AAC3D,MAAI,SAAS,UAAU,YAAY,qBAAqB;AACxD,MAAI,cAAc;AAClB,MAAI,KAAC,gBAAAC,SAAQ,cAAc,GAAG;AAC5B,kBAAc,aAAa,gBAAgB,uBAAuB,IAAI;AACtE,aAAS,CAAC,GAAG,SAAS,EAAE,OAAO,MAAM;AAAA,EACvC;AACA,SAAO,EAAE,aAAa,OAAO;AAC/B;;;ACrCA,IAAAC,cAAgB;AAChB,IAAAC,cAAgB;AAMhB,IAAM,WAAW,OAAO,UAAU;AAiDnB,SAAR,yBAIL,WAAmC,YAAe,WAAe,WAAe,OAAY,CAAC,GAAM;AAEnG,MAAI;AAEJ,UAAI,YAAAC,SAAI,WAAW,cAAc,GAAG;AAElC,UAAM,sBAAyC,CAAC;AAChD,YAAI,YAAAA,SAAI,WAAW,cAAc,GAAG;AAClC,YAAM,iBAAa,YAAAC,SAAI,WAAW,gBAAgB,CAAC,CAAC;AACpD,aAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AACvC,gBAAI,YAAAD,SAAI,MAAM,GAAG,GAAG;AAClB,8BAAoB,GAAG,IAAI;AAAA,QAC7B;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM,OAAiB,OAAO,SAAK,YAAAC,SAAI,WAAW,gBAAgB,CAAC,CAAC,CAAC;AAErE,UAAM,aAAgC,CAAC;AACvC,SAAK,QAAQ,CAAC,QAAQ;AACpB,YAAM,gBAAY,YAAAA,SAAI,MAAM,GAAG;AAC/B,UAAI,qBAAoB,YAAAA,SAAI,WAAW,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;AAChE,UAAI,qBAAoB,YAAAA,SAAI,WAAW,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;AAEhE,cAAI,YAAAD,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAgB,YAAY,SAAS;AAAA,MAC3F;AACA,cAAI,YAAAA,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAgB,YAAY,SAAS;AAAA,MAC3F;AAEA,YAAM,0BAAsB,YAAAC,SAAI,gBAAgB,MAAM;AACtD,YAAM,0BAAsB,YAAAA,SAAI,gBAAgB,MAAM;AAEtD,UAAI,CAAC,uBAAuB,wBAAwB,qBAAqB;AACvE,gBAAI,YAAAD,SAAI,qBAAqB,GAAG,GAAG;AAEjC,iBAAO,oBAAoB,GAAG;AAAA,QAChC;AAEA,YAAI,wBAAwB,YAAa,wBAAwB,WAAW,MAAM,QAAQ,SAAS,GAAI;AAErG,gBAAM,WAAW;AAAA,YACf;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,cAAI,aAAa,UAAa,wBAAwB,SAAS;AAE7D,uBAAW,GAAG,IAAI;AAAA,UACpB;AAAA,QACF,OAAO;AAIL,gBAAM,uBAAmB,YAAAC,SAAI,gBAAgB,WAAW,QAAQ;AAChE,gBAAM,uBAAmB,YAAAA,SAAI,gBAAgB,WAAW,QAAQ;AAChE,cAAI,qBAAqB,YAAY,qBAAqB,WAAW;AACnE,gBAAI,qBAAqB,WAAW;AAElC,kCAAoB,GAAG,IAAI;AAAA,YAC7B,eAAW,YAAAA,SAAI,gBAAgB,UAAU,MAAM,MAAM;AAEnD,kCAAoB,GAAG,IAAI;AAAA,YAC7B;AAAA,UACF;AAEA,gBAAM,qBAAiB,YAAAA,SAAI,gBAAgB,SAAS,QAAQ;AAC5D,gBAAM,qBAAiB,YAAAA,SAAI,gBAAgB,SAAS,QAAQ;AAC5D,cAAI,mBAAmB,YAAY,mBAAmB,WAAW;AAE/D,gCAAoB,GAAG,IAAI,mBAAmB,YAAY,iBAAiB;AAAA,UAC7E;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,kBAAc;AAAA,MACZ,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EAEF,eAAW,YAAAA,SAAI,WAAW,MAAM,MAAM,eAAW,YAAAA,SAAI,WAAW,MAAM,MAAM,WAAW,MAAM,QAAQ,IAAI,GAAG;AAC1G,QAAI,qBAAiB,YAAAA,SAAI,WAAW,OAAO;AAC3C,QAAI,qBAAiB,YAAAA,SAAI,WAAW,OAAO;AAG3C,QACE,OAAO,mBAAmB,YAC1B,OAAO,mBAAmB,YAC1B,CAAC,MAAM,QAAQ,cAAc,KAC7B,CAAC,MAAM,QAAQ,cAAc,GAC7B;AACA,cAAI,YAAAD,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAqB,YAAY,IAAS;AAAA,MAChG;AACA,cAAI,YAAAA,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAqB,YAAY,IAAS;AAAA,MAChG;AAEA,YAAM,oBAAgB,YAAAC,SAAI,gBAAgB,MAAM;AAChD,YAAM,oBAAgB,YAAAA,SAAI,gBAAgB,MAAM;AAEhD,UAAI,CAAC,iBAAiB,kBAAkB,eAAe;AACrD,cAAM,eAAW,YAAAA,SAAI,WAAW,YAAY,EAAE;AAC9C,YAAI,kBAAkB,UAAU;AAC9B,wBAAc,KAAK,OAAO,CAAC,UAAU,WAAW;AAC9C,kBAAM,YAAY;AAAA,cAChB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACA,gBAAI,cAAc,WAAc,WAAW,KAAK,SAAS,SAAS,WAAW;AAC3E,uBAAS,KAAK,SAAS;AAAA,YACzB;AACA,mBAAO;AAAA,UACT,GAAG,CAAC,CAAC;AAAA,QACP,OAAO;AACL,wBAAc,WAAW,KAAK,KAAK,SAAS,WAAW,KAAK,MAAM,GAAG,QAAQ,IAAI;AAAA,QACnF;AAAA,MACF;AAAA,IACF,WACE,OAAO,mBAAmB,aAC1B,OAAO,mBAAmB,aAC1B,mBAAmB,gBACnB;AAEA,oBAAc;AAAA,IAChB;AAAA,EAEF;AACA,SAAO;AACT;;;ACpMA,IAAAC,cAAgB;AAChB,IAAAC,kBAAoB;AAqBpB,SAAS,mBACP,WACA,QACA,UACA,aACA,IACA,YACA,UACA,eAAoB,CAAC,GACR;AACb,MAAI,WAAW,UAAU,oBAAoB,UAAU,cAAc,QAAQ;AAC3E,UAAM,UAAU,eAAwB,WAAW,QAAQ,YAAY,QAAQ;AAC/E,UAAM,kBAAkB,aAAa,UAAU,CAAC,aAAS,gBAAAC,SAAQ,MAAM,OAAO,CAAC;AAC/E,QAAI,oBAAoB,IAAI;AAC1B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa,OAAO,OAAO;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACA,MAAI,aAAa,UAAU,KAAC,YAAAC,SAAI,QAAQ,CAAC,WAAW,OAAO,CAAC,GAAG;AAC7D,WAAO;AAAA,MACL;AAAA,UACA,YAAAA,SAAI,QAAQ,SAAS;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,QAAM,MAAM,MAAM;AAClB,QAAM,WAAqB,EAAE,IAAI;AACjC,MAAI,cAAiB,MAAM,MAAM,YAAY,kBAAkB,QAAQ;AACrE,eAAW,QAAQ,OAAO,YAAY;AACpC,YAAM,YAAQ,YAAAA,SAAI,QAAQ,CAAC,gBAAgB,IAAI,CAAC;AAChD,YAAM,UAAU,SAAS,MAAM,IAAI,cAAc;AACjD,eAAS,IAAI,IAAI;AAAA,QACf;AAAA,QACA,SAAS,KAAK,IAAI,QAAQ,CAAC;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAAA,YAGA,YAAAA,SAAI,UAAU,CAAC,IAAI,CAAC;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAae,SAAR,WACL,WACA,QACA,IACA,YACA,UACA,WAAW,QACX,cAAc,KACD;AACb,SAAO,mBAA4B,WAAW,QAAQ,UAAU,aAAa,IAAI,YAAY,QAAQ;AACvG;;;ACxGA,IAAAC,eAAgB;AAChB,IAAAC,kBAAoB;AACpB,IAAAC,cAAgB;AA8BhB,SAAS,qBACP,WACA,QACA,MACA,YACA,UACA,eAAoB,CAAC,GACN;AACf,MAAI,WAAW,UAAU,oBAAoB,UAAU,cAAc,QAAQ;AAC3E,UAAM,UAAU,eAAwB,WAAW,QAAQ,YAAY,QAAQ;AAC/E,UAAM,kBAAkB,aAAa,UAAU,CAAC,aAAS,gBAAAC,SAAQ,MAAM,OAAO,CAAC;AAC/E,QAAI,oBAAoB,IAAI;AAC1B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa,OAAO,OAAO;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,aAAyB;AAAA,IAC3B,CAAC,QAAQ,GAAG,KAAK,QAAQ,OAAO,EAAE;AAAA,EACpC;AAEA,MAAI,cAAc,UAAU,cAAc,QAAQ;AAChD,UAAM,QAAa,cAAc,SAAU,OAAO,QAAiB,OAAO;AAC1E,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,UAAM,QAAQ,yBAAkC,WAAW,YAAa,UAAU,OAAO,GAAG,aAAa;AACzG,UAAM,UAAa,MAAO,KAAK;AAC/B,iBAAa;AAAA,MACX,GAAG;AAAA,MACH,GAAG,qBAA8B,WAAW,SAAS,MAAM,YAAY,UAAU,YAAY;AAAA,IAC/F;AAAA,EACF;AAEA,MAAI,6BAA6B,UAAU,OAAO,yBAAyB,MAAM,OAAO;AACtF,oBAAAC,SAAI,YAAY,gCAAgC,IAAI;AAAA,EACtD;AAEA,MAAI,aAAa,UAAU,MAAM,QAAQ,QAAQ,GAAG;AAClD,aAAS,QAAQ,CAAC,SAAS,MAAc;AACvC,iBAAW,CAAC,IAAI;AAAA,QACd;AAAA,QACA,OAAO;AAAA,QACP,GAAG,IAAI,IAAI,CAAC;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,WAAW,kBAAkB,QAAQ;AACnC,eAAW,YAAY,OAAO,YAAY;AACxC,YAAM,YAAQ,aAAAC,SAAI,QAAQ,CAAC,gBAAgB,QAAQ,CAAC;AACpD,iBAAW,QAAQ,IAAI;AAAA,QACrB;AAAA,QACA;AAAA,QACA,GAAG,IAAI,IAAI,QAAQ;AAAA,QACnB;AAAA;AAAA;AAAA,YAGA,aAAAA,SAAI,UAAU,CAAC,QAAQ,CAAC;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAWe,SAAR,aACL,WACA,QACA,OAAO,IACP,YACA,UACe;AACf,SAAO,qBAAqB,WAAW,QAAQ,MAAM,YAAY,QAAQ;AAC3E;;;ACpFA,IAAM,cAAN,MAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWE,YACE,WACA,YACA,uCACA;AACA,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,wCAAwC;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe;AACb,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,sBACE,WACA,YACA,wCAAwC,CAAC,GAChC;AACT,QAAI,CAAC,aAAa,CAAC,YAAY;AAC7B,aAAO;AAAA,IACT;AACA,WACE,KAAK,cAAc,aACnB,CAAC,WAAW,KAAK,YAAY,UAAU,KACvC,CAAC,WAAW,KAAK,uCAAuC,qCAAqC;AAAA,EAEjG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,oBACE,QACA,UACA,yBAA4D,OACvC;AACrB,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,gBAAgB,QAAW,UAA8B,eAAuC;AAC9F,WAAO,gBAAyB,KAAK,WAAW,QAAQ,UAAU,KAAK,YAAY,aAAa;AAAA,EAClG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,yBACE,UACA,SACA,gBACA,oBACQ;AACR,WAAO;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,uBAAuB,UAAyB,SAAc,oBAAqC;AACjG,WAAO,uBAAgC,KAAK,WAAW,UAAU,SAAS,KAAK,YAAY,kBAAkB;AAAA,EAC/G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,kBAAkB,UAAyB,SAAc,oBAA6B;AACpF,WAAO,kBAA2B,KAAK,WAAW,UAAU,SAAS,KAAK,YAAY,kBAAkB;AAAA,EAC1G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,QAAW,UAA8B;AACpD,WAAO,aAAsB,KAAK,WAAW,QAAQ,UAAU,KAAK,UAAU;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,QAAW;AACvB,WAAO,cAAuB,KAAK,WAAW,QAAQ,KAAK,UAAU;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,QAAW;AAClB,WAAO,SAAkB,KAAK,WAAW,QAAQ,KAAK,UAAU;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,oBAAoB,gBAAmC,uBAA2D;AAChH,WAAO,oBAA6B,KAAK,WAAW,gBAAgB,qBAAqB;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,eAAe,QAAW,aAAiB;AACzC,WAAO,eAAwB,KAAK,WAAW,QAAQ,KAAK,YAAY,WAAW;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,yBAAyB,WAAe,WAAe,MAAe;AACpE,WAAO,yBAAyB,KAAK,WAAW,KAAK,YAAY,WAAW,WAAW,IAAI;AAAA,EAC7F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,WAAW,QAAW,IAAoB,UAAc,WAAW,QAAQ,cAAc,KAAkB;AACzG,WAAO,WAAoB,KAAK,WAAW,QAAQ,IAAI,KAAK,YAAY,UAAU,UAAU,WAAW;AAAA,EACzG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAa,QAAW,MAAe,UAA6B;AAClE,WAAO,aAAsB,KAAK,WAAW,QAAQ,MAAM,KAAK,YAAY,QAAQ;AAAA,EACtF;AACF;AAUe,SAAR,kBAKL,WACA,YACA,wCAAwC,CAAC,GACf;AAC1B,SAAO,IAAI,YAAqB,WAAW,YAAY,qCAAqC;AAC9F;;;ACnSe,SAAR,cAA+B,SAAiB;AAErD,QAAM,WAAqB,QAAQ,MAAM,GAAG;AAE5C,QAAM,SAAmB,SAAS,CAAC,EAAE,MAAM,GAAG;AAE9C,QAAM,OAAe,OAAO,CAAC,EAAE,QAAQ,SAAS,EAAE;AAElD,QAAM,aAAa,OAAO,OAAO,CAAC,UAAU;AAC1C,WAAO,MAAM,MAAM,GAAG,EAAE,CAAC,MAAM;AAAA,EACjC,CAAC;AAED,MAAI;AACJ,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT,OAAO;AAGL,WAAO,UAAU,WAAW,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC;AAAA,EAC9C;AAGA,MAAI;AACF,UAAM,SAAS,KAAK,SAAS,CAAC,CAAC;AAC/B,UAAM,QAAQ,CAAC;AACf,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,KAAK,OAAO,WAAW,CAAC,CAAC;AAAA,IACjC;AAEA,UAAM,OAAO,IAAI,OAAO,KAAK,CAAC,IAAI,WAAW,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC;AAE9D,WAAO,EAAE,MAAM,KAAK;AAAA,EACtB,SAAS,OAAO;AACd,WAAO,EAAE,MAAM,EAAE,MAAM,GAAG,MAAO,MAAgB,QAAQ,GAAG,MAAM,QAAQ;AAAA,EAC5E;AACF;;;ACjCe,SAAR,wBAAyC,aAAqB,QAAmB;AACtF,MAAI,SAAS;AACb,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,UAAM,QAAQ,OAAO,MAAM,OAAO;AAClC,WAAO,QAAQ,CAAC,OAAO,UAAU;AAC/B,YAAM,YAAY,MAAM,UAAU,CAAC,SAAS,SAAS,IAAI,QAAQ,CAAC,EAAE;AACpE,UAAI,aAAa,GAAG;AAClB,cAAM,SAAS,IAAI;AAAA,MACrB;AAAA,IACF,CAAC;AACD,aAAS,MAAM,KAAK,EAAE;AAAA,EACxB;AACA,SAAO;AACT;;;ACVe,SAAR,wBAAyC,mBAAuC,QAA2B;AAChH,SAAO,wBAAwB,mBAAmB,MAAM;AAC1D;;;ACbA,IAAAC,kBAAoB;;;ACaL,SAAR,yBACL,YACA,iBAAuC,CAAC,GACxC,YACyE;AACzE,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,WAAW,IAAI,CAACC,WAAU,yBAAyBA,QAAO,cAAc,CAAC,EAAE,OAAO,CAAC,QAAQ,GAAG;AAAA,EACvG;AAEA,QAAM,QAAQ,eAAe,MAAM,eAAe,OAAO,KAAK,OAAO,UAAU;AAC/E,QAAM,SAAS,eAAe,KAAK;AACnC,SAAO,SAAS,OAAO,QAAQ;AACjC;;;ADRe,SAAR,yBACL,YACA,UACA,iBAAuC,CAAC,GACiC;AACzE,QAAM,QAAQ,yBAA4B,YAAY,cAAc;AACpE,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,OAAO,CAAC,MAAM,KAAC,gBAAAC,SAAQ,GAAG,KAAK,CAAC;AAAA,EAClD;AACA,aAAO,gBAAAA,SAAQ,OAAO,QAAQ,IAAI,SAAY;AAChD;;;AE3BA,IAAAC,kBAAoB;AAUL,SAAR,sBACL,OACA,UACA;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,KAAK,CAAC,YAAQ,gBAAAC,SAAQ,KAAK,KAAK,CAAC;AAAA,EACnD;AACA,aAAO,gBAAAA,SAAQ,UAAU,KAAK;AAChC;;;ACJe,SAAR,yBACL,OACA,iBAAuC,CAAC,GACxC,WAAW,OACoB;AAC/B,QAAM,kBAA4B,eAC/B,IAAI,CAAC,KAAK,UAAW,sBAAsB,IAAI,OAAO,KAAK,IAAI,OAAO,KAAK,IAAI,MAAU,EACzF,OAAO,CAAC,QAAQ,OAAO,QAAQ,WAAW;AAC7C,MAAI,CAAC,UAAU;AACb,WAAO,gBAAgB,CAAC;AAAA,EAC1B;AACA,SAAO;AACT;;;ACxBA,oBAAsB;AAUP,SAAR,uBACL,YACA,UACA,iBAAuC,CAAC,GACxC;AACA,QAAM,QAAQ,yBAA4B,YAAY,cAAc;AACpE,MAAI,KAAC,qBAAM,KAAK,GAAG;AACjB,UAAM,QAAQ,eAAe,UAAU,CAAC,QAAQ,UAAU,IAAI,KAAK;AACnE,UAAM,MAAM,eAAe,IAAI,CAAC,EAAE,OAAO,IAAI,MAAM,GAAG;AACtD,UAAM,UAAU,SAAS,MAAM,GAAG,KAAK,EAAE,OAAO,OAAO,SAAS,MAAM,KAAK,CAAC;AAG5E,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,OAAO,IAAI,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,CAAC,CAAC;AAAA,EACvE;AACA,SAAO;AACT;;;AC3BA,uBAAsB;AACtB,IAAAC,eAAgB;AAChB,IAAAC,cAAgB;AAUhB,IAAqB,qBAArB,MAAiD;AAAA;AAAA;AAAA;AAAA;AAAA,EAW/C,YAAY,eAAgC;AAN5C;AAAA;AAAA;AAAA;AAAA,SAAQ,cAA8B,CAAC;AAOrC,SAAK,eAAe,aAAa;AAAA,EACnC;AAAA;AAAA;AAAA,EAIA,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,sBAAsB,aAAiC;AAC7D,UAAM,UAAW,MAAM,QAAQ,WAAW,KAAK,YAAY,SAAS,KAAM,OAAO,gBAAgB;AACjG,QAAI,aAA0B,cAAU,aAAAC,SAAI,KAAK,aAAa,WAAW,IAAI,KAAK;AAClF,QAAI,CAAC,cAAc,aAAa;AAC9B,mBAAa,CAAC;AACd,sBAAAC,SAAI,KAAK,aAAa,aAAa,UAAU;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe,eAAgC;AAC7C,SAAK,cAAc,oBAAgB,iBAAAC,SAAU,aAAa,IAAI,CAAC;AAC/D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,aAAgC,aAAiC;AACzE,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AACtE,QAAI,iBAAa,aAAAF,SAAI,YAAY,UAAU;AAC3C,QAAI,CAAC,MAAM,QAAQ,UAAU,GAAG;AAC9B,mBAAa,CAAC;AACd,iBAAW,UAAU,IAAI;AAAA,IAC3B;AAEA,QAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,iBAAW,KAAK,GAAG,WAAW;AAAA,IAChC,OAAO;AACL,iBAAW,KAAK,WAAW;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,aAAgC,aAAiC;AACzE,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AAEtE,UAAM,YAAY,MAAM,QAAQ,WAAW,IAAI,CAAC,GAAG,WAAW,IAAI,CAAC,WAAW;AAC9E,oBAAAC,SAAI,YAAY,YAAY,SAAS;AACrC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY,aAAiC;AAC3C,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AACtE,oBAAAA,SAAI,YAAY,YAAY,CAAC,CAAC;AAC9B,WAAO;AAAA,EACT;AACF;;;ACtGe,SAAR,UAAoE,QAAW;AACpF,QAAM,OAAsB,CAAC;AAC7B,MAAI,OAAO,YAAY;AACrB,SAAK,OAAO,OAAO;AAAA,EACrB;AACA,MAAI,OAAO,WAAW,OAAO,YAAY,GAAG;AAC1C,SAAK,MAAM,OAAO;AAAA,EACpB;AACA,MAAI,OAAO,WAAW,OAAO,YAAY,GAAG;AAC1C,SAAK,MAAM,OAAO;AAAA,EACpB;AACA,SAAO;AACT;;;ACVe,SAAR,cAKL,QACA,aACA,UAAkC,CAAC,GACnC,qBAAqB,MACL;AAChB,QAAM,aAA6B;AAAA,IACjC,MAAM,eAAe;AAAA,IACrB,GAAG,UAAU,MAAM;AAAA,EACrB;AAGA,MAAI,QAAQ,WAAW;AACrB,eAAW,OAAO,QAAQ;AAAA,EAC5B,WAAW,CAAC,aAAa;AAEvB,QAAI,OAAO,SAAS,UAAU;AAC5B,iBAAW,OAAO;AAElB,UAAI,sBAAsB,WAAW,SAAS,QAAW;AAGvD,mBAAW,OAAO;AAAA,MACpB;AAAA,IACF,WAAW,OAAO,SAAS,WAAW;AACpC,iBAAW,OAAO;AAElB,UAAI,WAAW,SAAS,QAAW;AAEjC,mBAAW,OAAO;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAEA,MAAI,QAAQ,cAAc;AACxB,eAAW,eAAe,QAAQ;AAAA,EACpC;AAEA,SAAO;AACT;;;AChDO,IAAM,kBAA+C;AAAA,EAC1D,OAAO;AAAA,IACL,UAAU;AAAA,EACZ;AAAA,EACA,YAAY;AAAA,EACZ,UAAU;AACZ;AAOe,SAAR,uBAIL,WAA8B,CAAC,GAAgC;AAC/D,QAAM,YAAY,aAAsB,QAAQ;AAChD,MAAI,aAAa,UAAU,sBAAsB,GAAG;AAClD,UAAM,UAAU,UAAU,sBAAsB;AAChD,WAAO,EAAE,GAAG,iBAAiB,GAAG,QAAQ;AAAA,EAC1C;AAEA,SAAO;AACT;;;ACrBe,SAAR,YAKL,MAAY,UAA6B,YAAoC,CAAC,GAAiC;AAC/G,QAAM,EAAE,UAAU,IAAI;AACtB,MAAI,SAAS,mBAAmB;AAC9B,WAAO,UAAU,IAAI;AAAA,EACvB;AACA;AAAA;AAAA;AAAA,IAGI,UAAkB,IAAI,KAAsC,UAAU,IAAI;AAAA;AAEhF;;;ACzBA,mBAA8B;AAC9B,sBAAoB;AACpB,IAAAE,eAAgB;AAChB,IAAAC,cAAgB;AA2EH;AApEb,IAAM,YAAsD;AAAA,EAC1D,SAAS;AAAA,IACP,UAAU;AAAA,IACV,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,IACP,UAAU;AAAA,IACV,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA,IACL,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,gBAAgB;AAAA,IAChB,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAAA,EACA,SAAS;AAAA,IACP,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAAA,EACA,OAAO;AAAA,IACL,QAAQ;AAAA,IACR,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AACF;AASA,SAAS,mBACP,SACA;AACA,MAAI,mBAA4C,aAAAC,SAAI,SAAS,cAAc;AAE3E,MAAI,CAAC,cAAc;AACjB,UAAM,iBAAkB,QAAQ,gBAAgB,QAAQ,aAAa,WAAY,CAAC;AAClF,mBAAe,CAAC,EAAE,SAAS,GAAG,MAAM,MAAM;AACxC,aAAO,4CAAC,WAAQ,SAAS,EAAE,GAAG,gBAAgB,GAAG,QAAQ,GAAI,GAAG,OAAO;AAAA,IACzE;AACA,oBAAAC,SAAI,SAAS,gBAAgB,YAAY;AAAA,EAC3C;AACA,SAAO;AACT;AAae,SAAR,UACL,QACA,QACA,oBAAkD,CAAC,GAClC;AACjB,QAAM,OAAO,cAAc,MAAM;AAEjC,MACE,OAAO,WAAW,cACjB,UAAU,gBAAAC,QAAQ,iBAAa,4BAAc,MAAM,CAAC,KACrD,gBAAAA,QAAQ,OAAO,MAAM,GACrB;AACA,WAAO,mBAA4B,MAAyB;AAAA,EAC9D;AAEA,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,MAAM,kCAAkC,OAAO,MAAM,EAAE;AAAA,EACnE;AAEA,MAAI,UAAU,mBAAmB;AAC/B,UAAM,mBAAmB,kBAAkB,MAAM;AACjD,WAAO,UAAmB,QAAQ,kBAAkB,iBAAiB;AAAA,EACvE;AAEA,MAAI,OAAO,SAAS,UAAU;AAC5B,QAAI,EAAE,QAAQ,YAAY;AACxB,YAAM,IAAI,MAAM,uBAAuB,IAAI,GAAG;AAAA,IAChD;AAEA,QAAI,UAAU,UAAU,IAAI,GAAG;AAC7B,YAAM,mBAAmB,kBAAkB,UAAU,IAAI,EAAE,MAAM,CAAC;AAClE,aAAO,UAAmB,QAAQ,kBAAkB,iBAAiB;AAAA,IACvE;AAAA,EACF;AAEA,QAAM,IAAI,MAAM,cAAc,MAAM,eAAe,IAAI,GAAG;AAC5D;;;AC3HA,SAAS,WAAW,QAAwB;AAC1C,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACzC,UAAM,MAAM,OAAO,WAAW,CAAC;AAC/B,YAAQ,QAAQ,KAAK,OAAO;AAC5B,WAAO,OAAO;AAAA,EAChB;AACA,SAAO,KAAK,SAAS,EAAE;AACzB;AAQe,SAAR,cAAwE,QAAW;AACxF,QAAM,UAAU,oBAAI,IAAY;AAEhC,OAAK,UAAU,QAAQ,CAAC,KAAK,WAAW,QAAQ,IAAI,GAAG,GAAG,MAAM;AAChE,SAAO,WAAW,KAAK,UAAU,QAAQ,MAAM,KAAK,OAAO,EAAE,KAAK,CAAC,CAAC;AACtE;;;ACnBe,SAAR,UACL,QACA,QACA,oBAAkD,CAAC,GACnD;AACA,MAAI;AACF,cAAU,QAAQ,QAAQ,iBAAiB;AAC3C,WAAO;AAAA,EACT,SAAS,GAAG;AACV,UAAM,MAAa;AACnB,QAAI,IAAI,YAAY,IAAI,QAAQ,WAAW,WAAW,KAAK,IAAI,QAAQ,WAAW,oBAAoB,IAAI;AACxG,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;;;AC1BA,IAAAC,mBAAqB;AAUrB,SAAS,YAAqB,IAA0B,QAAgB;AACtE,QAAM,YAAQ,iBAAAC,SAAS,EAAE,IAAI,KAAK,GAAG,MAAM;AAC3C,SAAO,GAAG,KAAK,KAAK,MAAM;AAC5B;AAMO,SAAS,cAAuB,IAA0B;AAC/D,SAAO,YAAe,IAAI,aAAa;AACzC;AAOO,SAAS,QAAiB,IAA0B;AACzD,SAAO,YAAe,IAAI,OAAO;AACnC;AAOO,SAAS,WAAoB,IAA0B;AAC5D,SAAO,YAAe,IAAI,UAAU;AACtC;AAOO,SAAS,OAAgB,IAA0B;AACxD,SAAO,YAAe,IAAI,MAAM;AAClC;AAOO,SAAS,QAAiB,IAA0B;AACzD,SAAO,YAAe,IAAI,OAAO;AACnC;AAUO,SAAS,mBAA4B,IAA0B,kBAAkB,OAAO;AAC7F,QAAM,WAAW,kBAAkB,IAAI,WAAc,EAAE,CAAC,KAAK;AAC7D,SAAO,GAAG,QAAW,EAAE,CAAC,IAAI,cAAiB,EAAE,CAAC,IAAI,OAAU,EAAE,CAAC,GAAG,QAAQ;AAC9E;AAQO,SAAS,SAAS,IAAY,aAAqB;AACxD,SAAO,GAAG,EAAE,IAAI,WAAW;AAC7B;;;ACnEe,SAAR,WAA4B,OAA+B,WAAqB,UAAuB;AAC5G,SAAO,YAAY,WAAW;AAChC;;;ACVe,SAAR,WAA4B,YAAoB;AACrD,SAAO,aAAa,IAAI,KAAK,UAAU,EAAE,OAAO,IAAI;AACtD;;;ACGe,SAAR,WAAqE,QAAW;AACrF,MAAI,YAAY,UAAU,MAAM,QAAQ,OAAO,IAAI,KAAK,OAAO,KAAK,WAAW,GAAG;AAChF,WAAO,OAAO,KAAK,CAAC;AAAA,EACtB;AACA,MAAI,aAAa,QAAQ;AACvB,WAAO,OAAO;AAAA,EAChB;AACA,QAAM,IAAI,MAAM,yCAAyC;AAC3D;;;ACPe,SAAR,YACL,QACkC;AAGlC,QAAM,sBAAsB;AAC5B,MAAI,oBAAoB,aAAa,MAAuC;AAC1E,YAAQ,KAAK,oFAAoF;AAAA,EACnG;AACA,MAAI,OAAO,MAAM;AACf,WAAO,OAAO,KAAK,IAAI,CAAC,OAAO,MAAM;AACnC,YAAM,QAAS,oBAAoB,aAAa,oBAAoB,UAAU,CAAC,KAAM,OAAO,KAAK;AACjG,aAAO,EAAE,OAAO,MAAM;AAAA,IACxB,CAAC;AAAA,EACH;AACA,QAAM,aAAa,OAAO,SAAS,OAAO;AAC1C,SACE,cACA,WAAW,IAAI,CAAC,eAAe;AAC7B,UAAM,UAAU;AAChB,UAAM,QAAQ,WAAW,OAAO;AAChC,UAAM,QAAQ,QAAQ,SAAS,OAAO,KAAK;AAC3C,WAAO;AAAA,MACL,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AAEL;;;AC5Be,SAAR,gBAAiC,YAAsB,OAA4B;AACxF,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAO;AAAA,EACT;AAEA,QAAM,cAAc,CAAC,QACnB,IAAI,OAAO,CAAC,MAAyB,SAAS;AAC5C,SAAK,IAAI,IAAI;AACb,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP,QAAM,gBAAgB,CAAC,QACrB,IAAI,SAAS,IAAI,eAAe,IAAI,KAAK,MAAM,CAAC,MAAM,aAAa,IAAI,CAAC,CAAC;AAC3E,QAAM,eAAe,YAAY,UAAU;AAC3C,QAAM,gBAAgB,MAAM,OAAO,CAAC,SAAS,SAAS,OAAO,aAAa,IAAI,CAAC;AAC/E,QAAM,YAAY,YAAY,aAAa;AAE3C,QAAM,OAAO,WAAW,OAAO,CAAC,SAAiB,CAAC,UAAU,IAAI,CAAC;AACjE,QAAM,YAAY,cAAc,QAAQ,GAAG;AAC3C,MAAI,cAAc,IAAI;AACpB,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,wCAAwC,cAAc,IAAI,CAAC,EAAE;AAAA,IAC/E;AACA,WAAO;AAAA,EACT;AACA,MAAI,cAAc,cAAc,YAAY,GAAG,GAAG;AAChD,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC5E;AAEA,QAAM,WAAW,CAAC,GAAG,aAAa;AAClC,WAAS,OAAO,WAAW,GAAG,GAAG,IAAI;AACrC,SAAO;AACT;;;ACrCe,SAAR,IAAqB,KAAa,OAAe;AACtD,MAAI,IAAI,OAAO,GAAG;AAClB,SAAO,EAAE,SAAS,OAAO;AACvB,QAAI,MAAM;AAAA,EACZ;AACA,SAAO;AACT;;;ACHe,SAAR,gBAAiC,YAAqB,cAAc,MAAkB;AAC3F,MAAI,CAAC,YAAY;AACf,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM,cAAc,KAAK;AAAA,MACzB,QAAQ,cAAc,KAAK;AAAA,MAC3B,QAAQ,cAAc,KAAK;AAAA,IAC7B;AAAA,EACF;AACA,QAAM,OAAO,IAAI,KAAK,UAAU;AAChC,MAAI,OAAO,MAAM,KAAK,QAAQ,CAAC,GAAG;AAChC,UAAM,IAAI,MAAM,0BAA0B,UAAU;AAAA,EACtD;AACA,SAAO;AAAA,IACL,MAAM,KAAK,eAAe;AAAA,IAC1B,OAAO,KAAK,YAAY,IAAI;AAAA;AAAA,IAC5B,KAAK,KAAK,WAAW;AAAA,IACrB,MAAM,cAAc,KAAK,YAAY,IAAI;AAAA,IACzC,QAAQ,cAAc,KAAK,cAAc,IAAI;AAAA,IAC7C,QAAQ,cAAc,KAAK,cAAc,IAAI;AAAA,EAC/C;AACF;;;ACrBe,SAAR,wBAAkF,QAAoB;AAE3G,MAAI,OAAO,OAAO;AAChB,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,QAAQ,OAAO,KAAK,WAAW,KAAK,OAAO,KAAK,CAAC,MAAM,MAAM;AACtE,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,SAAS,OAAO,MAAM,WAAW,GAAG;AAC7C,WAAO,wBAAwB,OAAO,MAAM,CAAC,CAAM;AAAA,EACrD;AAGA,MAAI,OAAO,SAAS,OAAO,MAAM,WAAW,GAAG;AAC7C,WAAO,wBAAwB,OAAO,MAAM,CAAC,CAAM;AAAA,EACrD;AAGA,MAAI,OAAO,OAAO;AAChB,UAAM,aAAa,CAAC,cAAyC,wBAAwB,SAAc;AACnG,WAAO,OAAO,MAAM,KAAK,UAAU;AAAA,EACrC;AAEA,SAAO;AACT;;;AC3Be,SAAR,aAA8B,WAA4B,WAAgB,WAAgB;AAC/F,QAAM,EAAE,OAAO,MAAM,IAAI;AACzB,SAAO,CAAC,WAAW,OAAO,SAAS,KAAK,CAAC,WAAW,OAAO,SAAS;AACtE;;;ACNe,SAAR,aAA8B,YAAwB,OAAO,MAAM;AACxE,QAAM,EAAE,MAAM,OAAO,KAAK,OAAO,GAAG,SAAS,GAAG,SAAS,EAAE,IAAI;AAC/D,QAAM,UAAU,KAAK,IAAI,MAAM,QAAQ,GAAG,KAAK,MAAM,QAAQ,MAAM;AACnE,QAAM,WAAW,IAAI,KAAK,OAAO,EAAE,OAAO;AAC1C,SAAO,OAAO,WAAW,SAAS,MAAM,GAAG,EAAE;AAC/C;;;ACdA,IAAAC,wBAA0B;AAWX,SAAR,YACL,aACA,YAAsB,CAAC,GACA;AACvB,MAAI,CAAC,aAAa;AAChB,WAAO,CAAC;AAAA,EACV;AACA,MAAI,YAAmC,CAAC;AACxC,MAAI,cAAc,aAAa;AAC7B,gBAAY,UAAU;AAAA,MACpB,YAAY,UAAU,EAAG,IAAI,CAAC,YAAoB;AAChD,cAAM,WAAW,IAAI,UAAU,KAAK,GAAG,CAAC;AACxC,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA,OAAO,GAAG,QAAQ,IAAI,OAAO;AAAA,QAC/B;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACA,SAAO,OAAO,KAAK,WAAW,EAAE,OAAO,CAAC,KAAK,QAAQ;AACnD,QAAI,QAAQ,YAAY;AACtB,YAAM,cAAe,YAAkC,GAAG;AAC1D,cAAI,sBAAAC,SAAc,WAAW,GAAG;AAC9B,cAAM,IAAI,OAAO,YAAY,aAAa,CAAC,GAAG,WAAW,GAAG,CAAC,CAAC;AAAA,MAChE;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,SAAS;AACd;;;ACxCA,oBAAmB;AAwBJ,SAAR,cAAwC,QAA+C;AAC5F,QAAM,UAAU,IAAI,mBAAsB;AAC1C,MAAI,OAAO,QAAQ;AACjB,WAAO,QAAQ,CAAC,UAAU;AACxB,YAAM,EAAE,UAAU,QAAQ,IAAI;AAE9B,YAAM,OAAO,aAAa,MAAM,CAAC,QAAI,cAAAC,SAAO,QAAQ;AAGpD,UAAI,KAAK,SAAS,KAAK,KAAK,CAAC,MAAM,IAAI;AACrC,aAAK,OAAO,GAAG,CAAC;AAAA,MAClB;AACA,UAAI,SAAS;AACX,gBAAQ,UAAU,SAAS,IAAI;AAAA,MACjC;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO,QAAQ;AACjB;;;AC1CA,IAAAC,wBAA0B;AASX,SAAR,mBAA6C,cAAiD;AACnG,SAAO,OAAO,KAAK,YAAY,EAAE,OAAO,CAAC,KAAK,QAAQ;AACpD,QAAI,QAAQ,YAAY;AACtB,aAAO;AAAA,IACT,OAAO;AACL,YAAM,cAAe,aAAmC,GAAG;AAC3D,cAAI,sBAAAC,SAAc,WAAW,GAAG;AAC9B,eAAO;AAAA,UACL,GAAG;AAAA,UACH,CAAC,GAAG,GAAG,mBAAmB,WAAW;AAAA,QACvC;AAAA,MACF;AACA,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,YAAY;AAAA,IACtC;AAAA,EACF,GAAG,CAAC,CAAmB;AACzB;;;ACjBe,SAAR,WAA4B,UAAkB;AACnD,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAQA,QAAM,OAAO,IAAI,KAAK,QAAQ;AAE9B,QAAM,OAAO,IAAI,KAAK,YAAY,GAAG,CAAC;AACtC,QAAM,KAAK,IAAI,KAAK,SAAS,IAAI,GAAG,CAAC;AACrC,QAAM,KAAK,IAAI,KAAK,QAAQ,GAAG,CAAC;AAChC,QAAM,KAAK,IAAI,KAAK,SAAS,GAAG,CAAC;AACjC,QAAM,KAAK,IAAI,KAAK,WAAW,GAAG,CAAC;AACnC,QAAM,KAAK,IAAI,KAAK,WAAW,GAAG,CAAC;AACnC,QAAM,MAAM,IAAI,KAAK,gBAAgB,GAAG,CAAC;AAEzC,SAAO,GAAG,IAAI,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,GAAG;AACrD;;;AC7BA,IAAAC,kBAAoB;AAeL,SAAR,oBACL,gBACA,uBACmB;AACnB,MAAI,CAAC,uBAAuB;AAC1B,WAAO;AAAA,EACT;AACA,QAAM,EAAE,QAAQ,WAAW,aAAa,eAAe,IAAI;AAC3D,MAAI,SAAS,YAAY,qBAAqB;AAC9C,MAAI,cAAc;AAClB,MAAI,KAAC,gBAAAC,SAAQ,cAAc,GAAG;AAC5B,kBAAc,aAAa,gBAAgB,uBAAuB,IAAI;AACtE,aAAS,CAAC,GAAG,SAAS,EAAE,OAAO,MAAM;AAAA,EACvC;AACA,SAAO,EAAE,aAAa,OAAO;AAC/B;;;AC5BA,IAAAC,oBAAqB;AAOrB,SAAS,sBAA+D,MAAY;AAClF,aAAW,OAAO,MAAM;AACtB,UAAM,UAAgC;AACtC,UAAM,QAAQ,QAAQ,GAAG;AACzB,QAAI,QAAQ,WAAW,OAAO,UAAU,YAAY,MAAM,WAAW,GAAG,GAAG;AACzE,cAAQ,GAAG,IAAI,qBAAqB;AAAA,IACtC,OAAO;AACL,cAAQ,GAAG,IAAI,gBAAmB,KAAK;AAAA,IACzC;AAAA,EACF;AACA,SAAO;AACT;AAOA,SAAS,qBAA8D,MAAgB;AACrF,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,SAAK,CAAC,IAAI,gBAAmB,KAAK,CAAC,CAAC;AAAA,EACtC;AACA,SAAO;AACT;AAQe,SAAR,gBAA0E,YAAwB;AACvG,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,qBAAwB,CAAC,GAAG,UAAU,CAAC;AAAA,EAChD;AACA,UAAI,kBAAAC,SAAS,UAAU,GAAG;AACxB,WAAO,sBAAyB,EAAE,GAAG,WAAW,CAAC;AAAA,EACnD;AACA,SAAO;AACT;;;AC1CO,IAAK,qBAAL,kBAAKC,wBAAL;AAEL,EAAAA,oBAAA,oBAAiB;AAEjB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,cAAW;AAEX,EAAAA,oBAAA,aAAU;AAEV,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,iBAAc;AAEd,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,eAAY;AAEZ,EAAAA,oBAAA,mBAAgB;AAEhB,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,oBAAiB;AAEjB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,cAAW;AAEX,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,mBAAgB;AAEhB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,wBAAqB;AAErB,EAAAA,oBAAA,wBAAqB;AAGrB,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,kBAAe;AAIf,EAAAA,oBAAA,uBAAoB;AAEpB,EAAAA,oBAAA,cAAW;AAGX,EAAAA,oBAAA,wBAAqB;AAErB,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,4BAAyB;AAEzB,EAAAA,oBAAA,gCAA6B;AAI7B,EAAAA,oBAAA,qCAAkC;AAIlC,EAAAA,oBAAA,eAAY;AAlEF,SAAAA;AAAA,GAAA;;;ACNZ,qBAAoB;AACpB,IAAAC,kBAAoB;;;ACDpB,IAAAC,eAAgB;AAChB,IAAAC,kBAAoB;AA8BpB,IAAqB,kBAArB,MAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,YAAY,YAAe;AAP3B;AAAA,qBAA0B,CAAC;AAQzB,SAAK,aAAa;AAClB,SAAK,UAAU,YAAY,cAAiB,UAAU,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,QAAW,MAAc;AACjC,UAAM,UAAM,aAAAC,SAAI,QAAQ,QAAQ,IAAI;AACpC,UAAM,mBAAmB,EAAE,GAAG,QAAQ,CAAC,MAAM,GAAG,IAAI;AACpD,UAAM,WAAW,KAAK,UAAU,GAAG;AACnC,QAAI,CAAC,UAAU;AACb,WAAK,UAAU,GAAG,IAAI;AAAA,IACxB,WAAW,KAAC,gBAAAC,SAAQ,UAAU,gBAAgB,GAAG;AAC/C,cAAQ,MAAM,oBAAoB,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC;AACnE,cAAQ,MAAM,eAAe,KAAK,UAAU,kBAAkB,MAAM,CAAC,CAAC;AACtE,YAAM,IAAI;AAAA,QACR,iDAAiD,GAAG;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,eAAe;AACb,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,QAAQ,QAAW,WAAc,YAAwB;AACvD,QAAI,KAAC,gBAAAA,SAAQ,YAAY,KAAK,UAAU,GAAG;AACzC,YAAM,IAAI,MAAM,gGAAgG;AAAA,IAClH;AACA,SAAK,UAAU,QAAQ,cAAiB,MAAM,CAAC;AAE/C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAA4B,SAAY,WAA+D;AACrG,UAAM,IAAI,MAAM,yEAAyE;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,cAA+B,YAA8C;AACvF,UAAM,IAAI,MAAM,uEAAuE;AAAA,EACzF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,iBACE,WACA,SACA,iBACA,kBACA,WACmB;AACnB,UAAM,IAAI,MAAM,4EAA4E;AAAA,EAC9F;AACF;;;ADjHA,SAAS,YACP,WACA,aACA,YACA,QACA;AACA,QAAM,UAAU,uBAAgC,WAAW,QAAQ,YAAY,QAAW,IAAI;AAC9F,UAAQ,QAAQ,CAACC,YAAW;AAC1B,UAAM,kBAAkB,YAAY,UAAU,CAAC,aAAS,gBAAAC,SAAQ,MAAMD,OAAM,CAAC;AAC7E,QAAI,oBAAoB,IAAI;AAC1B,kBAAY,KAAKA,OAAM;AACvB,YAAM,aAAa,yBAAkC,WAAWA,SAAQ,YAAY,IAAI;AACxF,iBAAW,QAAQ,CAAC,MAAM;AACxB,YAAI,kBAAkB,KAAK,EAAE,cAAc,GAAG;AAC5C,6BAAAE,SAAQF,QAAO,cAAc,GAAG,CAAC,UAAU;AACzC,wBAAqB,WAAW,aAAa,YAAY,KAAU;AAAA,UACrE,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AACD,UAAI,aAAaA,WAAU,CAAC,MAAM,QAAQA,QAAO,KAAK,KAAK,OAAOA,QAAO,UAAU,WAAW;AAC5F,oBAAqB,WAAW,aAAa,YAAYA,QAAO,KAAU;AAAA,MAC5E;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAQe,SAAR,aACL,YACc;AACd,QAAM,YAAY,IAAI,gBAAyB,UAAU;AACzD,QAAM,cAAmB,CAAC;AAE1B,cAAY,WAAW,aAAa,YAAY,UAAU;AAE1D,SAAO,UAAU,aAAa;AAChC;",
   "names": ["isPlainObject", "isEqualWith", "import_get", "omit", "jsonpointer", "import_get", "import_has", "import_isNumber", "import_isObject", "import_isString", "import_times", "import_get", "get", "isNumber", "has", "get", "import_get", "import_get", "get", "isString", "type", "acc", "union", "times", "transform", "isEqual", "get", "set", "mergeAllOf", "s", "isObject", "reduce", "get", "has", "key", "isString", "isNumber", "times", "import_get", "acc", "get", "altSchemas", "isEmpty", "get", "import_isEmpty", "isEmpty", "import_get", "import_has", "has", "get", "import_get", "import_isEqual", "isEqual", "get", "import_get", "import_isEqual", "import_set", "isEqual", "set", "get", "import_isEqual", "index", "isEqual", "import_isEqual", "isEqual", "import_get", "import_set", "get", "set", "cloneDeep", "import_get", "import_set", "get", "set", "ReactIs", "import_isString", "isString", "import_isPlainObject", "isPlainObject", "toPath", "import_isPlainObject", "isPlainObject", "import_isEmpty", "isEmpty", "import_isObject", "isObject", "TranslatableString", "import_isEqual", "import_get", "import_isEqual", "get", "isEqual", "schema", "isEqual", "forEach"]
 }
diff --git a/node_modules/@rjsf/utils/dist/utils.esm.js b/node_modules/@rjsf/utils/dist/utils.esm.js
index 3f8abcc..c10091a 100644
--- a/node_modules/@rjsf/utils/dist/utils.esm.js
+++ b/node_modules/@rjsf/utils/dist/utils.esm.js
@@ -1047,35 +1047,39 @@ function computeDefaults(validator, rawSchema, {
   }
   switch (getSchemaType(schema)) {
     case "object": {
-      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc, key) => {
-        const computedDefault = computeDefaults(validator, get7(schema, [PROPERTIES_KEY, key]), {
-          rootSchema,
-          _recurseList,
-          experimental_defaultFormStateBehavior,
-          includeUndefinedValues: includeUndefinedValues === true,
-          parentDefaults: get7(defaults, [key]),
-          rawFormData: get7(formData, [key]),
-          required: schema.required?.includes(key)
-        });
-        maybeAddDefaultToObject(
-          acc,
-          key,
-          computedDefault,
-          includeUndefinedValues,
-          required,
-          schema.required,
-          experimental_defaultFormStateBehavior
-        );
-        return acc;
-      }, {});
-      if (schema.additionalProperties) {
-        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};
+      const retrievedSchema = ALL_OF_KEY in schema ? retrieveSchema(validator, schema, rootSchema, formData) : schema;
+      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(
+        (acc, key) => {
+          const computedDefault = computeDefaults(validator, get7(retrievedSchema, [PROPERTIES_KEY, key]), {
+            rootSchema,
+            _recurseList,
+            experimental_defaultFormStateBehavior,
+            includeUndefinedValues: includeUndefinedValues === true,
+            parentDefaults: get7(defaults, [key]),
+            rawFormData: get7(formData, [key]),
+            required: retrievedSchema.required?.includes(key)
+          });
+          maybeAddDefaultToObject(
+            acc,
+            key,
+            computedDefault,
+            includeUndefinedValues,
+            required,
+            retrievedSchema.required,
+            experimental_defaultFormStateBehavior
+          );
+          return acc;
+        },
+        {}
+      );
+      if (retrievedSchema.additionalProperties) {
+        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties) ? retrievedSchema.additionalProperties : {};
         const keys = /* @__PURE__ */ new Set();
         if (isObject(defaults)) {
-          Object.keys(defaults).filter((key) => !schema.properties || !schema.properties[key]).forEach((key) => keys.add(key));
+          Object.keys(defaults).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => keys.add(key));
         }
         const formDataRequired = [];
-        Object.keys(formData).filter((key) => !schema.properties || !schema.properties[key]).forEach((key) => {
+        Object.keys(formData).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => {
           keys.add(key);
           formDataRequired.push(key);
         });
@@ -1087,7 +1091,7 @@ function computeDefaults(validator, rawSchema, {
             includeUndefinedValues: includeUndefinedValues === true,
             parentDefaults: get7(defaults, [key]),
             rawFormData: get7(formData, [key]),
-            required: schema.required?.includes(key)
+            required: retrievedSchema.required?.includes(key)
           });
           maybeAddDefaultToObject(
             objectDefaults,
@@ -1102,8 +1106,9 @@ function computeDefaults(validator, rawSchema, {
       return objectDefaults;
     }
     case "array": {
-      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "never";
-      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "requiredOnly";
+      const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+      const neverPopulate = arrayMinItems?.populate === "never";
+      const ignoreMinItemsFlagSet = arrayMinItems?.populate === "requiredOnly";
       if (Array.isArray(defaults)) {
         defaults = defaults.map((item, idx) => {
           const schemaItem = getInnerSchemaForArrayItem(schema, 2 /* Fallback */, idx);
@@ -1174,7 +1179,8 @@ function getDefaultFormState(validator, theSchema, formData, rootSchema, include
   if (formData === void 0 || formData === null || typeof formData === "number" && isNaN(formData)) {
     return defaults;
   }
-  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+  const { mergeExtraDefaults } = arrayMinItems || {};
   if (isObject(formData)) {
     return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
   }
diff --git a/node_modules/@rjsf/utils/dist/utils.esm.js.map b/node_modules/@rjsf/utils/dist/utils.esm.js.map
index 78a325c..30bacb1 100644
--- a/node_modules/@rjsf/utils/dist/utils.esm.js.map
+++ b/node_modules/@rjsf/utils/dist/utils.esm.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../src/isObject.ts", "../src/allowAdditionalItems.ts", "../src/asNumber.ts", "../src/constants.ts", "../src/getUiOptions.ts", "../src/canExpand.ts", "../src/createErrorHandler.ts", "../src/deepEquals.ts", "../src/schema/getDefaultFormState.ts", "../src/findSchemaDefinition.ts", "../src/schema/getClosestMatchingOption.ts", "../src/schema/getMatchingOption.ts", "../src/getOptionMatchingSimpleDiscriminator.ts", "../src/schema/getFirstMatchingOption.ts", "../src/schema/retrieveSchema.ts", "../src/getDiscriminatorFieldFromSchema.ts", "../src/guessType.ts", "../src/mergeSchemas.ts", "../src/getSchemaType.ts", "../src/isFixedItems.ts", "../src/mergeDefaultsWithFormData.ts", "../src/mergeObjects.ts", "../src/isConstant.ts", "../src/schema/isSelect.ts", "../src/schema/isMultiSelect.ts", "../src/isCustomWidget.ts", "../src/schema/isFilesArray.ts", "../src/schema/getDisplayLabel.ts", "../src/schema/mergeValidationData.ts", "../src/schema/sanitizeDataForNewSchema.ts", "../src/schema/toIdSchema.ts", "../src/schema/toPathSchema.ts", "../src/createSchemaUtils.ts", "../src/dataURItoBlob.ts", "../src/replaceStringParameters.ts", "../src/englishStringTranslator.ts", "../src/enumOptionsDeselectValue.ts", "../src/enumOptionsValueForIndex.ts", "../src/enumOptionsIsSelected.ts", "../src/enumOptionsIndexForValue.ts", "../src/enumOptionsSelectValue.ts", "../src/ErrorSchemaBuilder.ts", "../src/rangeSpec.ts", "../src/getInputProps.ts", "../src/getSubmitButtonOptions.ts", "../src/getTemplate.ts", "../src/getWidget.tsx", "../src/hashForSchema.ts", "../src/hasWidget.ts", "../src/idGenerators.ts", "../src/labelValue.ts", "../src/localToUTC.ts", "../src/toConstant.ts", "../src/optionsList.ts", "../src/orderProperties.ts", "../src/pad.ts", "../src/parseDateString.ts", "../src/schemaRequiresTrueValue.ts", "../src/shouldRender.ts", "../src/toDateString.ts", "../src/toErrorList.ts", "../src/toErrorSchema.ts", "../src/unwrapErrorHandler.ts", "../src/utcToLocal.ts", "../src/validationDataMerge.ts", "../src/withIdRefPrefix.ts", "../src/enums.ts", "../src/parser/schemaParser.ts", "../src/parser/ParserValidator.ts"],
-  "sourcesContent": ["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const IF_KEY = 'if';\nexport const ITEMS_KEY = 'items';\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\n\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n *\n * @param formData - The form data around which the error handler is created\n * @returns - A `FormValidation` object based on the `formData` structure\n */\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\n  const handler: FieldValidation = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // 'errors' (see `utils.toErrorSchema`).\n    [ERRORS_KEY]: [],\n    addError(message: string) {\n      this[ERRORS_KEY]!.push(message);\n    },\n  };\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  if (isPlainObject(formData)) {\n    const formObject: GenericObjectType = formData as GenericObjectType;\n    return Object.keys(formObject).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\n    }, handler as FormValidation<T>);\n  }\n  return handler as FormValidation<T>;\n}\n", "import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n", "import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY } from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc: GenericObjectType, key: string) => {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        const computedDefault = computeDefaults<T, S, F>(validator, get(schema, [PROPERTIES_KEY, key]), {\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          includeUndefinedValues: includeUndefinedValues === true,\n          parentDefaults: get(defaults, [key]),\n          rawFormData: get(formData, [key]),\n          required: schema.required?.includes(key),\n        });\n        maybeAddDefaultToObject<T>(\n          acc,\n          key,\n          computedDefault,\n          includeUndefinedValues,\n          required,\n          schema.required,\n          experimental_defaultFormStateBehavior\n        );\n        return acc;\n      }, {}) as T;\n      if (schema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !schema.properties || !schema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !schema.properties || !schema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: schema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? [];\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n", "import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n", "import get from 'lodash/get';\nimport { PROPERTIES_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\n *\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or undefined if there is no match\n */\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  formData: T | undefined,\n  options: S[],\n  discriminatorField?: string\n): number | undefined {\n  if (formData && discriminatorField) {\n    const value = get(formData, discriminatorField);\n\n    if (value === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < options.length; i++) {\n      const option = options[i];\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\n        continue;\n      }\n\n      if (discriminator.const === value) {\n        return i;\n      }\n\n      if (discriminator.enum?.includes(value)) {\n        return i;\n      }\n    }\n  }\n\n  return;\n}\n", "import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        result[key] = resolveAllReferences(value as S, rootSchema, recurseList);\n      },\n      {} as RJSFSchema\n    );\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n", "import get from 'lodash/get';\nimport isString from 'lodash/isString';\n\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\n *\n * @param schema - The schema from which the discriminator is potentially obtained\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\n */\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  let discriminator: string | undefined;\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\n  if (isString(maybeString)) {\n    discriminator = maybeString;\n  } else if (maybeString !== undefined) {\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\n  }\n  return discriminator;\n}\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n", "import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n", "import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type)) {\n    if (type.length === 2 && type.includes('null')) {\n      type = type.find((type) => type !== 'null');\n    } else {\n      type = type[0];\n    }\n  }\n\n  return type;\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n", "import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\n *     which case the extras are appended onto the end of the form data\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults?: T,\n  formData?: T,\n  mergeExtraArrayDefaults = false\n): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\n      }\n      return value;\n    });\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\n      mapped.push(...defaultsArray.slice(mapped.length));\n    }\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key),\n        mergeExtraArrayDefaults\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n", "import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n", "import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n", "import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n", "import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n", "import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n *        removed in the next major release.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...data,\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  idPrefix: string,\n  idSeparator: string,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        idPrefix,\n        idSeparator,\n        id,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal<T, S, F>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      idPrefix,\n      idSeparator,\n      id,\n      rootSchema,\n      formData,\n      _recurseList\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        idPrefix,\n        idSeparator,\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        _recurseList\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    formData.forEach((element, i: number) => {\n      pathSchema[i] = toPathSchemaInternal<T, S, F>(\n        validator,\n        schema.items as S,\n        `${name}.${i}`,\n        rootSchema,\n        element,\n        _recurseList\n      );\n    });\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n", "import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\n  ) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior = {}\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator ||\n      !deepEquals(this.rootSchema, rootSchema) ||\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues,\n      this.experimental_defaultFormStateBehavior\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number {\n    return getClosestMatchingOption<T, S, F>(\n      this.validator,\n      this.rootSchema,\n      formData,\n      options,\n      selectedOption,\n      discriminatorField\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  experimental_defaultFormStateBehavior = {}\n): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\n}\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n", "import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport { isNil } from 'lodash';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n", "import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n", "import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n", "import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** JS has no built-in hashing function, so rolling our own\n *  based on Java's hashing fn:\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\n *\n * @param string - The string for which to get the hash\n * @returns - The resulting hash of the string in hex format\n */\nfunction hashString(string: string): string {\n  let hash = 0;\n  for (let i = 0; i < string.length; i += 1) {\n    const chr = string.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n}\n\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\n * in consistent order before stringify to prevent different hash ids for the same schema.\n *\n * @param schema - The schema for which the hash is desired\n * @returns - The string obtained from the hash of the stringified schema\n */\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const allKeys = new Set<string>();\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\n}\n", "import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n", "import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n", "import { ReactElement } from 'react';\n\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\n * themes require may `false` and others may require an empty string.\n *\n * @param [label] - The label string or component to render when not hidden\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\n */\nexport function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: ''): undefined | string;\nexport default function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: false | '') {\n  return hideLabel ? fallback : label;\n}\n", "/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n", "import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n", "import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n", "import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n", "import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n", "import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n", "import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\n\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n *\n * @param errorSchema - The `ErrorSchema` instance to convert\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\n */\nexport default function toErrorList<T = any>(\n  errorSchema?: ErrorSchema<T>,\n  fieldPath: string[] = []\n): RJSFValidationError[] {\n  if (!errorSchema) {\n    return [];\n  }\n  let errorList: RJSFValidationError[] = [];\n  if (ERRORS_KEY in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\n        const property = `.${fieldPath.join('.')}`;\n        return {\n          property,\n          message,\n          stack: `${property} ${message}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== ERRORS_KEY) {\n      const childSchema = (errorSchema as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\n      }\n    }\n    return acc;\n  }, errorList);\n}\n", "import toPath from 'lodash/toPath';\n\nimport { ErrorSchema, RJSFValidationError } from './types';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\n  const builder = new ErrorSchemaBuilder<T>();\n  if (errors.length) {\n    errors.forEach((error) => {\n      const { property, message } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\n\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\n *\n * @param errorHandler - The `FormValidation` error handling structure\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\n */\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === 'addError') {\n      return acc;\n    } else {\n      const childSchema = (errorHandler as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        return {\n          ...acc,\n          [key]: unwrapErrorHandler(childSchema),\n        };\n      }\n      return { ...acc, [key]: childSchema };\n    }\n  }, {} as ErrorSchema<T>);\n}\n", "import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from './mergeObjects';\nimport toErrorList from './toErrorList';\nimport { ErrorSchema, ValidationData } from './types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function validationDataMerge<T = any>(\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\nimport isObject from 'lodash/isObject';\n\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\n  for (const key in node) {\n    const realObj: { [k: string]: any } = node;\n    const value = realObj[key];\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\n    } else {\n      realObj[key] = withIdRefPrefix<S>(value);\n    }\n  }\n  return node;\n}\n\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\n  for (let i = 0; i < node.length; i++) {\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\n  }\n  return node;\n}\n\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\n * This is used in isValid to make references to the rootSchema\n *\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n * @returns - A copy of the `schemaNode` with updated `$ref`s\n */\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(schemaNode: S): S | S[] {\n  if (Array.isArray(schemaNode)) {\n    return withIdRefPrefixArray<S>([...schemaNode]);\n  }\n  if (isObject(schemaNode)) {\n    return withIdRefPrefixObject<S>({ ...schemaNode });\n  }\n  return schemaNode;\n}\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** File preview label, used by FileWidget */\n  PreviewLabel = 'Preview',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\n}\n", "import forEach from 'lodash/forEach';\nimport isEqual from 'lodash/isEqual';\n\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport ParserValidator, { SchemaMap } from './ParserValidator';\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\n\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\n *\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\n * @param rootSchema - The root schema from which the schema parsing began\n * @param schema - The current schema element being parsed\n */\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ParserValidator<T, S, F>,\n  recurseList: S[],\n  rootSchema: S,\n  schema: S\n) {\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\n  schemas.forEach((schema) => {\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\n    if (sameSchemaIndex === -1) {\n      recurseList.push(schema);\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\n      allOptions.forEach((s) => {\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\n          forEach(schema[PROPERTIES_KEY], (value) => {\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\n          });\n        }\n      });\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\n      }\n    }\n  });\n}\n\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\n * the hash of the schema to schema/sub-schema.\n *\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\n * @returns - The `SchemaMap` of all schemas that were parsed\n */\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  rootSchema: S\n): SchemaMap<S> {\n  const validator = new ParserValidator<T, S, F>(rootSchema);\n  const recurseList: S[] = [];\n\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\n\n  return validator.getSchemaMap();\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ID_KEY } from '../constants';\nimport hashForSchema from '../hashForSchema';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from '../types';\n\n/** The type of the map of schema hash to schema\n */\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\n  [hash: string]: S;\n};\n\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\n */\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The rootSchema provided during construction of the class */\n  readonly rootSchema: S;\n\n  /** The map of schemas encountered by the ParserValidator */\n  schemaMap: SchemaMap<S> = {};\n\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\n   * first.\n   *\n   * @param rootSchema - The root schema against which this validator will be executed\n   */\n  constructor(rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\n  }\n\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\n   * associated with it's `hash` for future use (by a schema compiler).\n   *\n   * @param schema - The schema which is to be added to the map\n   * @param hash - The hash value at which to map the schema\n   */\n  addSchema(schema: S, hash: string) {\n    const key = get(schema, ID_KEY, hash);\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\n    const existing = this.schemaMap[key];\n    if (!existing) {\n      this.schemaMap[key] = identifiedSchema;\n    } else if (!isEqual(existing, identifiedSchema)) {\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\n      throw new Error(\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\n      );\n    }\n  }\n\n  /** Returns the current `schemaMap` to the caller\n   */\n  getSchemaMap() {\n    return this.schemaMap;\n  }\n\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\n   * the `rootSchema` is not the same as the root schema provided during construction.\n   *\n   * @param schema - The schema to record in the `schemaMap`\n   * @param _formData - The formData parameter that is ignored\n   * @param rootSchema - The root schema associated with the schema\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\n   */\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\n    if (!isEqual(rootSchema, this.rootSchema)) {\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\n    }\n    this.addSchema(schema, hashForSchema<S>(schema));\n\n    return false;\n  }\n\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\n   *\n   * @param _schema - The schema parameter that is ignored\n   * @param _formData - The formData parameter that is ignored\n   */\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\n   *\n   * @param _errorSchema - The error schema parameter that is ignored\n   * @param _fieldPath - The field path parameter that is ignored\n   */\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\n   * called\n   *\n   * @param _formData - The formData parameter that is ignored\n   * @param _schema - The schema parameter that is ignored\n   * @param _customValidate - The customValidate parameter that is ignored\n   * @param _transformErrors - The transformErrors parameter that is ignored\n   * @param _uiSchema - The uiSchema parameter that is ignored\n   */\n  validateFormData(\n    _formData: T,\n    _schema: S,\n    _customValidate?: CustomValidator<T, S, F>,\n    _transformErrors?: ErrorTransformer<T, S, F>,\n    _uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\n  }\n}\n"],
-  "mappings": ";AAMe,SAAR,SAA0B,OAAY;AAC3C,MAAI,OAAO,SAAS,eAAe,iBAAiB,MAAM;AACxD,WAAO;AAAA,EACT;AACA,MAAI,OAAO,SAAS,eAAe,iBAAiB,MAAM;AACxD,WAAO;AAAA,EACT;AACA,SAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK;AAC5E;;;ACLe,SAAR,qBAA+E,QAAW;AAC/F,MAAI,OAAO,oBAAoB,MAAM;AACnC,YAAQ,KAAK,iDAAiD;AAAA,EAChE;AACA,SAAO,SAAS,OAAO,eAAe;AACxC;;;ACLe,SAAR,SAA0B,OAAsB;AACrD,MAAI,UAAU,IAAI;AAChB,WAAO;AAAA,EACT;AACA,MAAI,UAAU,MAAM;AAClB,WAAO;AAAA,EACT;AACA,MAAI,MAAM,KAAK,KAAK,GAAG;AAGrB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,KAAK,KAAK,GAAG;AAEtB,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,KAAK,KAAK,GAAG;AAIzB,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,OAAO,KAAK;AACtB,QAAM,QAAQ,OAAO,MAAM,YAAY,CAAC,OAAO,MAAM,CAAC;AAEtD,SAAO,QAAQ,IAAI;AACrB;;;AChCO,IAAM,2BAA2B;AACjC,IAAM,4BAA4B;AAClC,IAAM,aAAa;AACnB,IAAM,aAAa;AACnB,IAAM,YAAY;AAClB,IAAM,cAAc;AACpB,IAAM,kBAAkB;AACxB,IAAM,mBAAmB;AACzB,IAAM,WAAW;AACjB,IAAM,aAAa;AACnB,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,iBAAiB;AACvB,IAAM,WAAW;AACjB,IAAM,aAAa;AACnB,IAAM,iBAAiB;AACvB,IAAM,eAAe;AACrB,IAAM,yBAAyB;AAC/B,IAAM,UAAU;AAChB,IAAM,iCAAiC;AACvC,IAAM,qBAAqB;AAC3B,IAAM,eAAe;AACrB,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AACvB,IAAM,wBAAwB;;;ACnBtB,SAAR,aACL,WAA8B,CAAC,GAC/B,gBAAuC,CAAC,GAChB;AACxB,SAAO,OAAO,KAAK,QAAQ,EACxB,OAAO,CAAC,QAAQ,IAAI,QAAQ,KAAK,MAAM,CAAC,EACxC;AAAA,IACC,CAAC,SAAS,QAAQ;AAChB,YAAM,QAAQ,SAAS,GAAG;AAC1B,UAAI,QAAQ,iBAAiB,SAAS,KAAK,GAAG;AAC5C,gBAAQ,MAAM,qFAAqF;AACnG,eAAO;AAAA,MACT;AACA,UAAI,QAAQ,kBAAkB,SAAS,KAAK,GAAG;AAC7C,eAAO,EAAE,GAAG,SAAS,GAAG,MAAM;AAAA,MAChC;AACA,aAAO,EAAE,GAAG,SAAS,CAAC,IAAI,UAAU,CAAC,CAAC,GAAG,MAAM;AAAA,IACjD;AAAA,IACA,EAAE,GAAG,cAAc;AAAA,EACrB;AACJ;;;ACnBe,SAAR,UACL,QACA,WAA8B,CAAC,GAC/B,UACA;AACA,MAAI,CAAC,OAAO,sBAAsB;AAChC,WAAO;AAAA,EACT;AACA,QAAM,EAAE,aAAa,KAAK,IAAI,aAAsB,QAAQ;AAC5D,MAAI,eAAe,OAAO;AACxB,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,kBAAkB,UAAa,UAAU;AAClD,WAAO,OAAO,KAAK,QAAQ,EAAE,SAAS,OAAO;AAAA,EAC/C;AACA,SAAO;AACT;;;AC9BA,OAAO,mBAAmB;AAUX,SAAR,mBAA6C,UAAgC;AAClF,QAAM,UAA2B;AAAA;AAAA;AAAA;AAAA,IAI/B,CAAC,UAAU,GAAG,CAAC;AAAA,IACf,SAAS,SAAiB;AACxB,WAAK,UAAU,EAAG,KAAK,OAAO;AAAA,IAChC;AAAA,EACF;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,OAAO,CAAC,KAAK,OAAO,QAAQ;AAC1C,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,mBAAmB,KAAK,EAAE;AAAA,IACpD,GAAG,OAAO;AAAA,EACZ;AACA,MAAI,cAAc,QAAQ,GAAG;AAC3B,UAAM,aAAgC;AACtC,WAAO,OAAO,KAAK,UAAU,EAAE,OAAO,CAAC,KAAK,QAAQ;AAClD,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,mBAAmB,WAAW,GAAG,CAAC,EAAE;AAAA,IAC9D,GAAG,OAA4B;AAAA,EACjC;AACA,SAAO;AACT;;;AChCA,OAAO,iBAAiB;AAST,SAAR,WAA4B,GAAQ,GAAiB;AAC1D,SAAO,YAAY,GAAG,GAAG,CAAC,KAAU,UAAe;AACjD,QAAI,OAAO,QAAQ,cAAc,OAAO,UAAU,YAAY;AAG5D,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACH;;;AClBA,OAAOA,UAAS;AAChB,OAAO,aAAa;;;ACDpB,OAAO,iBAAiB;AACxB,OAAO,UAAU;AAaV,SAAS,0BAA0B,KAAa,QAA2B;AAChF,QAAM,QAAQ,OAAO,GAAG;AACxB,QAAM,YAAY,KAAK,QAAQ,CAAC,GAAG,CAAC;AACpC,SAAO,CAAC,WAAW,KAAK;AAC1B;AAWe,SAAR,qBACL,MACA,aAAgB,CAAC,GACd;AACH,MAAI,MAAM,QAAQ;AAClB,MAAI,IAAI,WAAW,GAAG,GAAG;AAEvB,UAAM,mBAAmB,IAAI,UAAU,CAAC,CAAC;AAAA,EAC3C,OAAO;AACL,UAAM,IAAI,MAAM,mCAAmC,IAAI,GAAG;AAAA,EAC5D;AACA,QAAM,UAAa,YAAY,IAAI,YAAY,GAAG;AAClD,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI,MAAM,mCAAmC,IAAI,GAAG;AAAA,EAC5D;AACA,MAAI,QAAQ,OAAO,GAAG;AACpB,UAAM,CAAC,WAAW,MAAM,IAAI,0BAA0B,SAAS,OAAO;AACtE,UAAM,YAAY,qBAAwB,QAAQ,UAAU;AAC5D,QAAI,OAAO,KAAK,SAAS,EAAE,SAAS,GAAG;AACrC,aAAO,EAAE,GAAG,WAAW,GAAG,UAAU;AAAA,IACtC;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;ACrDA,OAAOC,UAAS;AAChB,OAAOC,UAAS;AAChB,OAAOC,eAAc;AACrB,OAAOC,eAAc;AACrB,OAAOC,eAAc;AACrB,OAAO,YAAY;AACnB,OAAOC,YAAW;;;ACNlB,OAAOC,UAAS;AAChB,OAAO,SAAS;AAChB,OAAO,cAAc;;;ACFrB,OAAO,SAAS;AAcD,SAAR,qCACL,UACA,SACA,oBACoB;AACpB,MAAI,YAAY,oBAAoB;AAClC,UAAM,QAAQ,IAAI,UAAU,kBAAkB;AAE9C,QAAI,UAAU,QAAW;AACvB;AAAA,IACF;AAEA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAM,SAAS,QAAQ,CAAC;AACxB,YAAM,gBAAgB,IAAI,QAAQ,CAAC,gBAAgB,kBAAkB,GAAG,CAAC,CAAC;AAE1E,UAAI,cAAc,SAAS,YAAY,cAAc,SAAS,SAAS;AACrE;AAAA,MACF;AAEA,UAAI,cAAc,UAAU,OAAO;AACjC,eAAO;AAAA,MACT;AAEA,UAAI,cAAc,MAAM,SAAS,KAAK,GAAG;AACvC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA;AACF;;;ADzBe,SAAR,kBAKL,WACA,UACA,SACA,YACA,oBACQ;AAGR,MAAI,aAAa,QAAW;AAC1B,WAAO;AAAA,EACT;AAEA,QAAM,2BAA2B,qCAAqC,UAAU,SAAS,kBAAkB;AAC3G,MAAI,SAAS,wBAAwB,GAAG;AACtC,WAAO;AAAA,EACT;AAEA,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,UAAM,SAAS,QAAQ,CAAC;AAGxB,QAAI,sBAAsB,IAAI,QAAQ,CAAC,gBAAgB,kBAAkB,CAAC,GAAG;AAC3E,YAAM,QAAQC,KAAI,UAAU,kBAAkB;AAC9C,YAAM,gBAAgBA,KAAI,QAAQ,CAAC,gBAAgB,kBAAkB,GAAG,CAAC,CAAC;AAC1E,UAAI,UAAU,QAAQ,eAAe,OAAO,UAAU,GAAG;AACvD,eAAO;AAAA,MACT;AAAA,IACF,WAAW,OAAO,cAAc,GAAG;AAWjC,YAAM,gBAAgB;AAAA,QACpB,OAAO,OAAO,KAAK,OAAO,cAAc,CAAC,EAAE,IAAI,CAAC,SAAS;AAAA,UACvD,UAAU,CAAC,GAAG;AAAA,QAChB,EAAE;AAAA,MACJ;AAEA,UAAI;AAGJ,UAAI,OAAO,OAAO;AAEhB,cAAM,EAAE,GAAG,aAAa,IAAI;AAE5B,YAAI,CAAC,aAAa,OAAO;AACvB,uBAAa,QAAQ,CAAC;AAAA,QACxB,OAAO;AAEL,uBAAa,QAAQ,aAAa,MAAM,MAAM;AAAA,QAChD;AAEA,qBAAa,MAAM,KAAK,aAAa;AAErC,0BAAkB;AAAA,MACpB,OAAO;AACL,0BAAkB,OAAO,OAAO,CAAC,GAAG,QAAQ,aAAa;AAAA,MAC3D;AAIA,aAAO,gBAAgB;AAEvB,UAAI,UAAU,QAAQ,iBAAiB,UAAU,UAAU,GAAG;AAC5D,eAAO;AAAA,MACT;AAAA,IACF,WAAW,UAAU,QAAQ,QAAQ,UAAU,UAAU,GAAG;AAC1D,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;AExFe,SAAR,uBAKL,WACA,UACA,SACA,YACA,oBACQ;AACR,SAAO,kBAA2B,WAAW,UAAU,SAAS,YAAY,kBAAkB;AAChG;;;AC1BA,OAAOC,UAAS;AAChB,OAAO,aAAa;AACpB,OAAO,SAAS;AAChB,OAAO,WAAW;AAClB,OAAO,eAAe;AACtB,OAAO,gBAA6B;;;ACLpC,OAAOC,UAAS;AAChB,OAAO,cAAc;AAUN,SAAR,gCAA0F,QAAW;AAC1G,MAAI;AACJ,QAAM,cAAcA,KAAI,QAAQ,8BAA8B,MAAS;AACvE,MAAI,SAAS,WAAW,GAAG;AACzB,oBAAgB;AAAA,EAClB,WAAW,gBAAgB,QAAW;AACpC,YAAQ,KAAK,gDAAgD,OAAO,WAAW,WAAW;AAAA,EAC5F;AACA,SAAO;AACT;;;ACde,SAAR,UAA2B,OAAY;AAC5C,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AACA,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,CAAC,MAAM,KAAK,GAAG;AACjB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AC3BA,OAAO,WAAW;;;ACcH,SAAR,cACL,QAC+B;AAC/B,MAAI,EAAE,KAAK,IAAI;AAEf,MAAI,CAAC,QAAQ,OAAO,OAAO;AACzB,WAAO,UAAU,OAAO,KAAK;AAAA,EAC/B;AAEA,MAAI,CAAC,QAAQ,OAAO,MAAM;AACxB,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,SAAS,OAAO,cAAc,OAAO,uBAAuB;AAC/D,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,QAAI,KAAK,WAAW,KAAK,KAAK,SAAS,MAAM,GAAG;AAC9C,aAAO,KAAK,KAAK,CAACC,UAASA,UAAS,MAAM;AAAA,IAC5C,OAAO;AACL,aAAO,KAAK,CAAC;AAAA,IACf;AAAA,EACF;AAEA,SAAO;AACT;;;ADzBe,SAAR,aAA8B,MAAyB,MAAyB;AACrF,QAAM,MAAM,OAAO,OAAO,CAAC,GAAG,IAAI;AAClC,SAAO,OAAO,KAAK,IAAI,EAAE,OAAO,CAACC,MAAK,QAAQ;AAC5C,UAAM,OAAO,OAAO,KAAK,GAAG,IAAI,CAAC,GAC/B,QAAQ,KAAK,GAAG;AAClB,QAAI,QAAQ,OAAO,QAAQ,SAAS,KAAK,GAAG;AAC1C,MAAAA,KAAI,GAAG,IAAI,aAAa,MAAM,KAAK;AAAA,IACrC,WACE,QACA,SACC,cAAc,IAAI,MAAM,YAAY,cAAc,IAAI,MAAM,aAC7D,QAAQ,gBACR,MAAM,QAAQ,IAAI,KAClB,MAAM,QAAQ,KAAK,GACnB;AAEA,MAAAA,KAAI,GAAG,IAAI,MAAM,MAAM,KAAK;AAAA,IAC9B,OAAO;AACL,MAAAA,KAAI,GAAG,IAAI;AAAA,IACb;AACA,WAAOA;AAAA,EACT,GAAG,GAAG;AACR;;;AHAe,SAAR,eAIL,WAAmC,QAAW,aAAgB,CAAC,GAAQ,aAAoB;AAC3F,SAAO,uBAAgC,WAAW,QAAQ,YAAY,WAAW,EAAE,CAAC;AACtF;AAeO,SAAS,iBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,EAAE,IAAI,YAAY,MAAM,MAAM,WAAW,GAAG,8BAA8B,IAAI;AAEpF,QAAM,iBAAiB,UAAU,QAAQ,YAAiB,YAAa,CAAC,GAAS,UAAU;AAC3F,MAAI,kBAAkB,CAAC,6BAAkC;AACzD,MAAI,UAAe,CAAC;AACpB,MAAI,mBAAmB;AACrB,QAAI,QAAQ,OAAO,SAAS,WAAW;AACrC,gBAAU,QAAQ;AAAA,QAChB,uBAAgC,WAAW,MAAW,YAAY,UAAU,mBAAmB,WAAW;AAAA,MAC5G;AAAA,IACF;AACA,QAAI,aAAa,OAAO,cAAc,WAAW;AAC/C,gBAAU,QAAQ;AAAA,QAChB,uBAAgC,WAAW,WAAgB,YAAY,UAAU,mBAAmB,WAAW;AAAA,MACjH;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,oBAAoB,iBAAiB,OAAO;AAClD,QAAI,qBAAqB,OAAO,sBAAsB,WAAW;AAC/D,gBAAU,QAAQ;AAAA,QAChB;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,QAAQ,QAAQ;AAClB,sBAAkB,QAAQ,IAAI,CAAC,MAAM,aAAa,+BAA+B,CAAC,CAAM;AAAA,EAC1F;AACA,SAAO,gBAAgB;AAAA,IAAQ,CAAC,MAC9B,uBAAgC,WAAW,GAAG,YAAY,UAAU,mBAAmB,WAAW;AAAA,EACpG;AACF;AAgBO,SAAS,0BAAmE,aAAoB;AACrG,QAAM,kBAAyB,YAAY;AAAA,IACzC,CAAC,cAAc,SAAS;AAEtB,UAAI,KAAK,SAAS,GAAG;AACnB,eAAO,KAAK,QAAQ,CAAC,YAAY,MAAM,aAAa,QAAQ,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,EAAE,OAAO,OAAO,CAAC,CAAC;AAAA,MAC1G;AAEA,mBAAa,QAAQ,CAAC,gBAAgB,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC;AAC/D,aAAO;AAAA,IACT;AAAA,IACA,CAAC,CAAC,CAAC;AAAA;AAAA,EACL;AAEA,SAAO;AACT;AAeO,SAAS,cACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,MAAI,eAAe,SAAS,KAAK,eAAe,CAAC,MAAM,QAAQ;AAG7D,WAAO;AAAA,EACT;AACA,MAAI,oBAAoB,QAAQ;AAC9B,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,gBAAgB,QAAQ,CAAC,MAAM;AACpC,aAAO,uBAAgC,WAAW,GAAG,YAAY,UAAU,mBAAmB,WAAW;AAAA,IAC3G,CAAC;AAAA,EACH;AACA,MAAI,cAAc,UAAU,MAAM,QAAQ,OAAO,KAAK,GAAG;AACvD,UAAM,sBAA6B,OAAO,MAAM;AAAA,MAAI,CAAC,mBACnD;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,kBAAkB,0BAA6B,mBAAmB;AACxE,WAAO,gBAAgB,IAAI,CAAC,iBAAiB,EAAE,GAAG,QAAQ,OAAO,YAAY,EAAE;AAAA,EACjF;AAEA,SAAO,CAAC,MAAM;AAChB;AAeO,SAAS,iBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,gBAAgB,qBAAwB,QAAQ,YAAY,WAAW;AAC7E,MAAI,kBAAkB,QAAQ;AAE5B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,SAAO,CAAC,MAAM;AAChB;AASO,SAAS,qBACd,QACA,YACA,aACG;AACH,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAO;AAAA,EACT;AACA,MAAI,iBAAoB;AAExB,MAAI,WAAW,gBAAgB;AAC7B,UAAM,EAAE,MAAM,GAAG,YAAY,IAAI;AAEjC,QAAI,YAAY,SAAS,IAAK,GAAG;AAC/B,aAAO;AAAA,IACT;AACA,gBAAY,KAAK,IAAK;AAEtB,UAAM,YAAY,qBAAwB,MAAM,UAAU;AAC1D,qBAAiB,EAAE,GAAG,WAAW,GAAG,YAAY;AAAA,EAClD;AAEA,MAAI,kBAAkB,gBAAgB;AACpC,UAAM,eAAe;AAAA,MACnB,eAAe,cAAc;AAAA,MAC7B,CAAC,QAAQ,OAAO,QAAgB;AAC9B,eAAO,GAAG,IAAI,qBAAqB,OAAY,YAAY,WAAW;AAAA,MACxE;AAAA,MACA,CAAC;AAAA,IACH;AACA,qBAAiB,EAAE,GAAG,gBAAgB,CAAC,cAAc,GAAG,aAAa;AAAA,EACvE;AAEA,MACE,aAAa,kBACb,CAAC,MAAM,QAAQ,eAAe,KAAK,KACnC,OAAO,eAAe,UAAU,WAChC;AACA,qBAAiB;AAAA,MACf,GAAG;AAAA,MACH,OAAO,qBAAqB,eAAe,OAAY,YAAY,WAAW;AAAA,IAChF;AAAA,EACF;AAEA,SAAO,QAAQ,QAAQ,cAAc,IAAI,SAAS;AACpD;AAUO,SAAS,iCAId,WAAmC,WAAc,YAAgB,WAAkB;AAEnF,QAAM,SAAS;AAAA,IACb,GAAG;AAAA,IACH,YAAY,EAAE,GAAG,UAAU,WAAW;AAAA,EACxC;AAGA,QAAM,WAA8B,aAAa,SAAS,SAAS,IAAI,YAAY,CAAC;AACpF,SAAO,KAAK,QAAQ,EAAE,QAAQ,CAAC,QAAQ;AACrC,QAAI,OAAO,OAAO,YAAY;AAE5B;AAAA,IACF;AAEA,QAAI,uBAAkD,CAAC;AACvD,QAAI,OAAO,OAAO,yBAAyB,WAAW;AACpD,UAAI,WAAW,OAAO,sBAAuB;AAC3C,+BAAuB;AAAA,UACrB;AAAA,UACA,EAAE,MAAMC,KAAI,OAAO,sBAAsB,CAAC,OAAO,CAAC,EAAE;AAAA,UACpD;AAAA,UACA;AAAA,QACF;AAAA,MACF,WAAW,UAAU,OAAO,sBAAuB;AACjD,+BAAuB,EAAE,GAAG,OAAO,qBAAqB;AAAA,MAC1D,WAAW,cAAc,OAAO,wBAAyB,cAAc,OAAO,sBAAuB;AACnG,+BAAuB;AAAA,UACrB,MAAM;AAAA,UACN,GAAG,OAAO;AAAA,QACZ;AAAA,MACF,OAAO;AACL,+BAAuB,EAAE,MAAM,UAAUA,KAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;AAAA,MACjE;AAAA,IACF,OAAO;AACL,6BAAuB,EAAE,MAAM,UAAUA,KAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;AAAA,IACjE;AAGA,WAAO,WAAW,GAAG,IAAI;AAEzB,QAAI,OAAO,YAAY,CAAC,KAAK,wBAAwB,GAAG,IAAI;AAAA,EAC9D,CAAC;AAED,SAAO;AACT;AAiBO,SAAS,uBAKd,WACA,QACA,YACA,aACA,oBAAoB,OACpB,cAAwB,CAAC,GACpB;AACL,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAO,CAAC,CAAC,CAAM;AAAA,EACjB;AACA,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,gBAAgB,QAAQ,CAAC,MAAS;AACvC,QAAI,iBAAiB;AACrB,QAAI,UAAU,gBAAgB;AAC5B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,cAAc,gBAAgB;AAEhC,UAAI,mBAAmB;AACrB,cAAM,EAAE,OAAO,GAAG,aAAa,IAAI;AACnC,eAAO,CAAC,GAAI,OAAe,YAAiB;AAAA,MAC9C;AACA,UAAI;AACF,yBAAiB,WAAW,gBAAgB;AAAA,UAC1C,MAAM;AAAA,QACR,CAAY;AAAA,MACd,SAAS,GAAG;AACV,gBAAQ,KAAK,0CAA0C,CAAC;AACxD,cAAM,EAAE,OAAO,GAAG,2BAA2B,IAAI;AACjD,eAAO;AAAA,MACT;AAAA,IACF;AACA,UAAM,0BACJ,6BAA6B,kBAAkB,eAAe,yBAAyB;AACzF,QAAI,yBAAyB;AAC3B,aAAO,iCAA0C,WAAW,gBAAgB,YAAY,WAAgB;AAAA,IAC1G;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAcO,SAAS,yBAId,WAAmC,QAAW,YAAe,mBAA4B,aAAiB;AAC1G,MAAI;AACJ,QAAM,EAAE,OAAO,OAAO,GAAG,UAAU,IAAI;AACvC,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,iBAAa;AAAA,EACf,WAAW,MAAM,QAAQ,KAAK,GAAG;AAC/B,iBAAa;AAAA,EACf;AACA,MAAI,YAAY;AAEd,UAAM,WAAW,gBAAgB,UAAa,oBAAqB,CAAC,IAAU;AAC9E,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,iBAAa,WAAW,IAAI,CAAC,MAAM;AAGjC,aAAO,qBAAqB,GAAG,YAAY,CAAC,CAAC;AAAA,IAC/C,CAAC;AAED,UAAM,SAAS,uBAAgC,WAAW,UAAU,YAAY,YAAY,aAAa;AACzG,QAAI,mBAAmB;AACrB,aAAO,WAAW,IAAI,CAAC,SAAS,aAAa,WAAW,IAAI,CAAM;AAAA,IACpE;AACA,aAAS,aAAa,WAAW,WAAW,MAAM,CAAC;AAAA,EACrD;AACA,SAAO,CAAC,MAAM;AAChB;AAcO,SAAS,oBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AAEL,QAAM,EAAE,cAAc,GAAG,gBAAgB,IAAI;AAC7C,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,gBAAgB;AAAA,IAAQ,CAAC,mBAC9B;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAeO,SAAS,oBACd,WACA,cACA,gBACA,YACA,mBACA,aACA,UACK;AACL,MAAI,UAAU,CAAC,cAAc;AAE7B,aAAW,iBAAiB,cAAc;AAExC,QAAI,CAAC,qBAAqBA,KAAI,UAAU,CAAC,aAAa,CAAC,MAAM,QAAW;AACtE;AAAA,IACF;AAEA,QAAI,eAAe,cAAc,EAAE,iBAAiB,eAAe,aAAa;AAC9E;AAAA,IACF;AACA,UAAM,CAAC,uBAAuB,eAAe,IAAI;AAAA,MAC/C;AAAA,MACA;AAAA,IACF;AACA,QAAI,MAAM,QAAQ,eAAe,GAAG;AAClC,cAAQ,CAAC,IAAI,wBAA2B,gBAAgB,eAAe;AAAA,IACzE,WAAW,SAAS,eAAe,GAAG;AACpC,gBAAU;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,QAAQ;AAAA,MAAQ,CAAC,WACtB;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAQO,SAAS,wBACd,QACA,sBACA;AACA,MAAI,CAAC,sBAAsB;AACzB,WAAO;AAAA,EACT;AACA,QAAM,WAAW,MAAM,QAAQ,OAAO,QAAQ,IAC1C,MAAM,KAAK,oBAAI,IAAI,CAAC,GAAG,OAAO,UAAU,GAAG,oBAAoB,CAAC,CAAC,IACjE;AACJ,SAAO,EAAE,GAAG,QAAQ,SAAmB;AACzC;AAgBO,SAAS,oBACd,WACA,QACA,YACA,eACA,iBACA,mBACA,aACA,UACK;AACL,QAAM,mBAAmB;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,iBAAiB,QAAQ,CAAC,cAAc;AAC7C,UAAM,EAAE,OAAO,GAAG,gBAAgB,IAAI;AACtC,aAAS,aAAa,QAAQ,eAAe;AAE7C,QAAI,UAAU,QAAW;AACvB,aAAO;AAAA,IACT;AAEA,UAAM,iBAAiB,MAAM,IAAI,CAAC,cAAc;AAC9C,UAAI,OAAO,cAAc,aAAa,EAAE,WAAW,YAAY;AAC7D,eAAO,CAAC,SAAc;AAAA,MACxB;AACA,aAAO,iBAA0B,WAAW,WAAgB,YAAY,mBAAmB,aAAa,QAAQ;AAAA,IAClH,CAAC;AACD,UAAM,kBAAkB,0BAA0B,cAAc;AAChE,WAAO,gBAAgB;AAAA,MAAQ,CAAC,kBAC9B;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAiBO,SAAS,wBAKd,WACA,QACA,YACA,eACA,OACA,mBACA,aACA,UACK;AACL,QAAM,kBAAkB,MAAO,OAAO,CAAC,cAAc;AACnD,QAAI,OAAO,cAAc,aAAa,CAAC,aAAa,CAAC,UAAU,YAAY;AACzE,aAAO;AAAA,IACT;AACA,UAAM,EAAE,CAAC,aAAa,GAAG,wBAAwB,IAAI,UAAU;AAC/D,QAAI,yBAAyB;AAC3B,YAAM,kBAAqB;AAAA,QACzB,MAAM;AAAA,QACN,YAAY;AAAA,UACV,CAAC,aAAa,GAAG;AAAA,QACnB;AAAA,MACF;AACA,aAAO,UAAU,QAAQ,iBAAiB,UAAU,UAAU,KAAK;AAAA,IACrE;AACA,WAAO;AAAA,EACT,CAAC;AAED,MAAI,CAAC,qBAAqB,gBAAiB,WAAW,GAAG;AACvD,YAAQ,KAAK,wFAAwF;AACrG,WAAO,CAAC,MAAM;AAAA,EAChB;AACA,SAAO,gBAAgB,QAAQ,CAAC,MAAM;AACpC,UAAM,YAAe;AACrB,UAAM,CAAC,kBAAkB,IAAI,0BAA0B,eAAe,UAAU,UAA+B;AAC/G,UAAM,kBAAkB,EAAE,GAAG,WAAW,YAAY,mBAAmB;AACvE,UAAM,UAAU;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,QAAQ,IAAI,CAACC,OAAM,aAAa,QAAQA,EAAC,CAAM;AAAA,EACxD,CAAC;AACH;;;AJ/rBO,IAAM,cAAgC;AAAA,EAC3C,MAAM;AAAA,EACN,KAAK;AAAA,EACL,YAAY;AAAA,IACV,sBAAsB;AAAA,MACpB,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAsBO,SAAS,oBACd,WACA,YACA,QACA,WAAgB,CAAC,GACT;AACR,MAAI,aAAa;AACjB,MAAI,QAAQ;AACV,QAAIC,UAAS,OAAO,UAAU,GAAG;AAC/B,oBAAc;AAAA,QACZ,OAAO;AAAA,QACP,CAAC,OAAO,OAAO,QAAQ;AACrB,gBAAM,YAAYC,KAAI,UAAU,GAAG;AACnC,cAAI,OAAO,UAAU,WAAW;AAC9B,mBAAO;AAAA,UACT;AACA,cAAIC,KAAI,OAAO,OAAO,GAAG;AACvB,kBAAM,YAAY,eAAwB,WAAW,OAAY,YAAY,SAAS;AACtF,mBAAO,QAAQ,oBAA6B,WAAW,YAAY,WAAW,aAAa,CAAC,CAAC;AAAA,UAC/F;AACA,eAAKA,KAAI,OAAO,UAAU,KAAKA,KAAI,OAAO,UAAU,MAAM,WAAW;AACnE,kBAAMC,OAAMD,KAAI,OAAO,UAAU,IAAI,aAAa;AAClD,kBAAM,gBAAgB,gCAAmC,KAAU;AACnE,mBACE,QACA;AAAA,cACE;AAAA,cACA;AAAA,cACA;AAAA,cACAD,KAAI,OAAOE,IAAG;AAAA,cACd;AAAA,cACA;AAAA,YACF;AAAA,UAEJ;AACA,cAAI,MAAM,SAAS,UAAU;AAC3B,mBAAO,QAAQ,oBAA6B,WAAW,YAAY,OAAY,aAAa,CAAC,CAAC;AAAA,UAChG;AACA,cAAI,MAAM,SAAS,UAAU,SAAS,GAAG;AAEvC,gBAAI,WAAW,QAAQ;AACvB,gBAAI,MAAM,SAAS;AAGjB,0BAAY,cAAc,MAAM,UAAU,IAAI;AAAA,YAChD,WAAW,MAAM,OAAO;AAGtB,0BAAY,cAAc,MAAM,QAAQ,IAAI;AAAA,YAC9C;AAEA,mBAAO;AAAA,UACT;AACA,iBAAO;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAAA,IACF,WAAWC,UAAS,OAAO,IAAI,KAAK,OAAO,SAAS,UAAU,QAAQ,GAAG;AACvE,oBAAc;AAAA,IAChB;AAAA,EACF;AACA,SAAO;AACT;AAwBe,SAAR,yBAKL,WACA,YACA,UACA,SACA,iBAAiB,IACjB,oBACQ;AAER,QAAM,kBAAkB,QAAQ,IAAI,CAAC,WAAW;AAC9C,WAAO,qBAAwB,QAAQ,YAAY,CAAC,CAAC;AAAA,EACvD,CAAC;AAED,QAAM,2BAA2B,qCAAqC,UAAU,SAAS,kBAAkB;AAC3G,MAAIC,UAAS,wBAAwB,GAAG;AACtC,WAAO;AAAA,EACT;AAGA,QAAM,kBAAkB,gBAAgB,OAAO,CAAC,WAAqB,QAAQ,UAAkB;AAC7F,UAAM,cAAmB,CAAC,aAAkB,MAAM;AAClD,UAAM,QAAQ,uBAAgC,WAAW,UAAU,aAAa,YAAY,kBAAkB;AAE9G,QAAI,UAAU,GAAG;AACf,gBAAU,KAAK,KAAK;AAAA,IACtB;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AAGL,MAAI,gBAAgB,WAAW,GAAG;AAChC,WAAO,gBAAgB,CAAC;AAAA,EAC1B;AACA,MAAI,CAAC,gBAAgB,QAAQ;AAE3B,IAAAC,OAAM,gBAAgB,QAAQ,CAAC,MAAM,gBAAgB,KAAK,CAAC,CAAC;AAAA,EAC9D;AAEA,QAAM,aAAa,oBAAI,IAAY;AAEnC,QAAM,EAAE,UAAU,IAAc,gBAAgB;AAAA,IAC9C,CAAC,WAAqB,UAAkB;AACtC,YAAM,EAAE,UAAU,IAAI;AACtB,YAAM,SAAS,gBAAgB,KAAK;AACpC,YAAM,QAAQ,oBAAoB,WAAW,YAAY,QAAQ,QAAQ;AACzE,iBAAW,IAAI,KAAK;AACpB,UAAI,QAAQ,WAAW;AACrB,eAAO,EAAE,WAAW,OAAO,WAAW,MAAM;AAAA,MAC9C;AACA,aAAO;AAAA,IACT;AAAA,IACA,EAAE,WAAW,gBAAgB,WAAW,EAAE;AAAA,EAC5C;AAEA,MAAI,WAAW,SAAS,KAAK,kBAAkB,GAAG;AAChD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AS7Le,SAAR,aAAuE,QAAW;AACvF,SAAO,MAAM,QAAQ,OAAO,KAAK,KAAK,OAAO,MAAM,SAAS,KAAK,OAAO,MAAM,MAAM,CAAC,SAAS,SAAS,IAAI,CAAC;AAC9G;;;ACXA,OAAOC,UAAS;AAqBD,SAAR,0BACL,UACA,UACA,0BAA0B,OACX;AACf,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,UAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,WAAW,CAAC;AAC5D,UAAM,SAAS,SAAS,IAAI,CAAC,OAAO,QAAQ;AAC1C,UAAI,cAAc,GAAG,GAAG;AACtB,eAAO,0BAA+B,cAAc,GAAG,GAAG,OAAO,uBAAuB;AAAA,MAC1F;AACA,aAAO;AAAA,IACT,CAAC;AAED,QAAI,2BAA2B,OAAO,SAAS,cAAc,QAAQ;AACnE,aAAO,KAAK,GAAG,cAAc,MAAM,OAAO,MAAM,CAAC;AAAA,IACnD;AACA,WAAO;AAAA,EACT;AACA,MAAI,SAAS,QAAQ,GAAG;AACtB,UAAM,MAAiC,OAAO,OAAO,CAAC,GAAG,QAAQ;AACjE,WAAO,OAAO,KAAK,QAA6B,EAAE,OAAO,CAACC,MAAK,QAAQ;AACrE,MAAAA,KAAI,GAAc,IAAI;AAAA,QACpB,WAAWC,KAAI,UAAU,GAAG,IAAI,CAAC;AAAA,QACjCA,KAAI,UAAU,GAAG;AAAA,QACjB;AAAA,MACF;AACA,aAAOD;AAAA,IACT,GAAG,GAAG;AAAA,EACR;AACA,SAAO;AACT;;;ACxCe,SAAR,aACL,MACA,MACA,eAA8C,OAC9C;AACA,SAAO,OAAO,KAAK,IAAI,EAAE,OAAO,CAAC,KAAK,QAAQ;AAC5C,UAAM,OAAO,OAAO,KAAK,GAAG,IAAI,CAAC,GAC/B,QAAQ,KAAK,GAAG;AAClB,QAAI,QAAQ,OAAO,QAAQ,SAAS,KAAK,GAAG;AAC1C,UAAI,GAAG,IAAI,aAAa,MAAM,OAAO,YAAY;AAAA,IACnD,WAAW,gBAAgB,MAAM,QAAQ,IAAI,KAAK,MAAM,QAAQ,KAAK,GAAG;AACtE,UAAI,UAAU;AACd,UAAI,iBAAiB,qBAAqB;AACxC,kBAAU,MAAM,OAAO,CAAC,QAAQ,UAAU;AACxC,cAAI,CAAC,KAAK,SAAS,KAAK,GAAG;AACzB,mBAAO,KAAK,KAAK;AAAA,UACnB;AACA,iBAAO;AAAA,QACT,GAAG,CAAC,CAAC;AAAA,MACP;AACA,UAAI,GAAG,IAAI,KAAK,OAAO,OAAO;AAAA,IAChC,OAAO;AACL,UAAI,GAAG,IAAI;AAAA,IACb;AACA,WAAO;AAAA,EACT,GAAG,OAAO,OAAO,CAAC,GAAG,IAAI,CAAC;AAC5B;;;AC7Be,SAAR,WAAqE,QAAW;AACrF,SAAQ,MAAM,QAAQ,OAAO,IAAI,KAAK,OAAO,KAAK,WAAW,KAAM,aAAa;AAClF;;;ACAe,SAAR,SACL,WACA,WACA,aAAgB,CAAC,GACjB;AACA,QAAM,SAAS,eAAwB,WAAW,WAAW,YAAY,MAAS;AAClF,QAAM,aAAa,OAAO,SAAS,OAAO;AAC1C,MAAI,MAAM,QAAQ,OAAO,IAAI,GAAG;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,WAAW,MAAM,CAACE,gBAAe,OAAOA,gBAAe,aAAa,WAAWA,WAAU,CAAC;AAAA,EACnG;AACA,SAAO;AACT;;;ACde,SAAR,cAIL,WAAmC,QAAW,YAAgB;AAC9D,MAAI,CAAC,OAAO,eAAe,CAAC,OAAO,SAAS,OAAO,OAAO,UAAU,WAAW;AAC7E,WAAO;AAAA,EACT;AACA,SAAO,SAAkB,WAAW,OAAO,OAAY,UAAU;AACnE;;;AhB2BO,SAAS,2BACd,QACA,kBAA2C,gBAC3C,MAAM,IACH;AACH,MAAI,OAAO,GAAG;AACZ,QAAI,MAAM,QAAQ,OAAO,KAAK,KAAK,MAAM,OAAO,MAAM,QAAQ;AAC5D,YAAM,OAAO,OAAO,MAAM,GAAG;AAC7B,UAAI,OAAO,SAAS,WAAW;AAC7B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,WAAW,OAAO,SAAS,CAAC,MAAM,QAAQ,OAAO,KAAK,KAAK,OAAO,OAAO,UAAU,WAAW;AAC5F,WAAO,OAAO;AAAA,EAChB;AACA,MAAI,oBAAoB,kBAAkC,SAAS,OAAO,eAAe,GAAG;AAC1F,WAAO,OAAO;AAAA,EAChB;AACA,SAAO,CAAC;AACV;AAqBA,SAAS,wBACP,KACA,KACA,iBACA,wBACA,kBACA,iBAA2B,CAAC,GAC5B,wCAA+E,CAAC,GAChF;AACA,QAAM,EAAE,oBAAoB,sBAAsB,IAAI;AACtD,MAAI,wBAAwB;AAC1B,QAAI,GAAG,IAAI;AAAA,EACb,WAAW,sBAAsB,gBAAgB;AAC/C,QAAI,SAAS,eAAe,GAAG;AAG7B,YAAM,yBAAyB,qBAAqB,SAAY,eAAe,SAAS,GAAG,IAAI;AAI/F,WACG,CAAC,QAAQ,eAAe,KAAK,eAAe,SAAS,GAAG,OACxD,0BAA0B,sBAAsB,6BACjD;AACA,YAAI,GAAG,IAAI;AAAA,MACb;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,MAIE,oBAAoB,WACnB,sBAAsB,yBAAyB,eAAe,SAAS,GAAG;AAAA,MAC3E;AACA,UAAI,GAAG,IAAI;AAAA,IACb;AAAA,EACF;AACF;AA6BO,SAAS,gBACd,WACA,WACA;AAAA,EACE;AAAA,EACA;AAAA,EACA,aAAa,CAAC;AAAA,EACd,yBAAyB;AAAA,EACzB,eAAe,CAAC;AAAA,EAChB,wCAAwC;AAAA,EACxC;AACF,IAAgC,CAAC,GACZ;AACrB,QAAM,WAAe,SAAS,WAAW,IAAI,cAAc,CAAC;AAC5D,QAAM,SAAY,SAAS,SAAS,IAAI,YAAa,CAAC;AAEtD,MAAI,WAAgC;AAEpC,MAAI,kBAA4B;AAChC,MAAI,qBAAqB;AAEzB,MAAI,SAAS,QAAQ,KAAK,SAAS,OAAO,OAAO,GAAG;AAGlD,eAAW,aAAa,UAAW,OAAO,OAA4B;AAAA,EACxE,WAAW,eAAe,QAAQ;AAChC,eAAW,OAAO;AAAA,EACpB,WAAW,WAAW,QAAQ;AAC5B,UAAM,UAAU,OAAO,OAAO;AAE9B,QAAI,CAAC,aAAa,SAAS,OAAQ,GAAG;AACpC,2BAAqB,aAAa,OAAO,OAAQ;AACjD,wBAAkB,qBAAwB,SAAS,UAAU;AAAA,IAC/D;AAAA,EACF,WAAW,oBAAoB,QAAQ;AACrC,UAAM,iBAAiB,oBAA6B,WAAW,QAAQ,YAAY,OAAO,CAAC,GAAG,QAAQ;AACtG,sBAAkB,eAAe,CAAC;AAAA,EACpC,WAAW,aAAa,MAAM,GAAG;AAC/B,eAAY,OAAO,MAAe;AAAA,MAAI,CAAC,YAAe,QACpD,gBAAsB,WAAW,YAAY;AAAA,QAC3C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB,MAAM,QAAQ,cAAc,IAAI,eAAe,GAAG,IAAI;AAAA,QACtE,aAAa;AAAA,QACb;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,WAAW,cAAc,QAAQ;AAC/B,UAAM,EAAE,OAAO,GAAG,UAAU,IAAI;AAChC,QAAI,MAAO,WAAW,GAAG;AACvB,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,sBAAkB,MAChB;AAAA,MACE;AAAA,MACA;AAAA,MACA,QAAQ,QAAQ,IAAI,SAAY;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CACF;AACA,sBAAkB,aAAa,WAAW,eAAe;AAAA,EAC3D,WAAW,cAAc,QAAQ;AAC/B,UAAM,EAAE,OAAO,GAAG,UAAU,IAAI;AAChC,QAAI,MAAO,WAAW,GAAG;AACvB,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,sBAAkB,MAChB;AAAA,MACE;AAAA,MACA;AAAA,MACA,QAAQ,QAAQ,IAAI,SAAY;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CACF;AACA,sBAAkB,aAAa,WAAW,eAAe;AAAA,EAC3D;AAEA,MAAI,iBAAiB;AACnB,WAAO,gBAAyB,WAAW,iBAAiB;AAAA,MAC1D;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd;AAAA,MACA,gBAAgB;AAAA,MAChB,aAAa;AAAA,MACb;AAAA,IACF,CAAC;AAAA,EACH;AAGA,MAAI,aAAa,QAAW;AAC1B,eAAW,OAAO;AAAA,EACpB;AAEA,UAAQ,cAAiB,MAAM,GAAG;AAAA,IAEhC,KAAK,UAAU;AACb,YAAM,iBAAiB,OAAO,KAAK,OAAO,cAAc,CAAC,CAAC,EAAE,OAAO,CAAC,KAAwB,QAAgB;AAG1G,cAAM,kBAAkB,gBAAyB,WAAWC,KAAI,QAAQ,CAAC,gBAAgB,GAAG,CAAC,GAAG;AAAA,UAC9F;AAAA,UACA;AAAA,UACA;AAAA,UACA,wBAAwB,2BAA2B;AAAA,UACnD,gBAAgBA,KAAI,UAAU,CAAC,GAAG,CAAC;AAAA,UACnC,aAAaA,KAAI,UAAU,CAAC,GAAG,CAAC;AAAA,UAChC,UAAU,OAAO,UAAU,SAAS,GAAG;AAAA,QACzC,CAAC;AACD;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,OAAO;AAAA,UACP;AAAA,QACF;AACA,eAAO;AAAA,MACT,GAAG,CAAC,CAAC;AACL,UAAI,OAAO,sBAAsB;AAE/B,cAAM,6BAA6B,SAAS,OAAO,oBAAoB,IAAI,OAAO,uBAAuB,CAAC;AAC1G,cAAM,OAAO,oBAAI,IAAY;AAC7B,YAAI,SAAS,QAAQ,GAAG;AACtB,iBAAO,KAAK,QAA6B,EACtC,OAAO,CAAC,QAAQ,CAAC,OAAO,cAAc,CAAC,OAAO,WAAW,GAAG,CAAC,EAC7D,QAAQ,CAAC,QAAQ,KAAK,IAAI,GAAG,CAAC;AAAA,QACnC;AACA,cAAM,mBAA6B,CAAC;AACpC,eAAO,KAAK,QAA6B,EACtC,OAAO,CAAC,QAAQ,CAAC,OAAO,cAAc,CAAC,OAAO,WAAW,GAAG,CAAC,EAC7D,QAAQ,CAAC,QAAQ;AAChB,eAAK,IAAI,GAAG;AACZ,2BAAiB,KAAK,GAAG;AAAA,QAC3B,CAAC;AACH,aAAK,QAAQ,CAAC,QAAQ;AACpB,gBAAM,kBAAkB,gBAAgB,WAAW,4BAAiC;AAAA,YAClF;AAAA,YACA;AAAA,YACA;AAAA,YACA,wBAAwB,2BAA2B;AAAA,YACnD,gBAAgBA,KAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YACnC,aAAaA,KAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YAChC,UAAU,OAAO,UAAU,SAAS,GAAG;AAAA,UACzC,CAAC;AAED;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK,SAAS;AACZ,YAAM,gBAAgB,uCAAuC,eAAe,aAAa;AACzF,YAAM,wBAAwB,uCAAuC,eAAe,aAAa;AAGjG,UAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,mBAAW,SAAS,IAAI,CAAC,MAAM,QAAQ;AACrC,gBAAM,aAAgB,2BAA8B,QAAQ,kBAAkC,GAAG;AACjG,iBAAO,gBAAyB,WAAW,YAAY;AAAA,YACrD;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB;AAAA,YAChB;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAGA,UAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,cAAM,aAAgB,2BAA8B,MAAM;AAC1D,YAAI,eAAe;AACjB,qBAAW;AAAA,QACb,OAAO;AACL,qBAAW,YAAY,IAAI,CAAC,MAAS,QAAgB;AACnD,mBAAO,gBAAyB,WAAW,YAAY;AAAA,cACrD;AAAA,cACA;AAAA,cACA;AAAA,cACA,aAAa;AAAA,cACb,gBAAgBA,KAAI,UAAU,CAAC,GAAG,CAAC;AAAA,cACnC;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF;AAEA,UAAI,eAAe;AACjB,eAAO,YAAY,CAAC;AAAA,MACtB;AACA,UAAI,yBAAyB,CAAC,UAAU;AAGtC,eAAO,WAAW,WAAW;AAAA,MAC/B;AAEA,YAAM,iBAAiB,MAAM,QAAQ,QAAQ,IAAI,SAAS,SAAS;AACnE,UACE,CAAC,OAAO,YACR,cAAuB,WAAW,QAAQ,UAAU,KACpD,OAAO,YAAY,gBACnB;AACA,eAAO,WAAW,WAAW,CAAC;AAAA,MAChC;AAEA,YAAM,iBAAuB,YAAY,CAAC;AAC1C,YAAM,eAAkB,2BAA8B,QAAQ,cAA8B;AAC5F,YAAM,gBAAgB,aAAa;AAGnC,YAAM,gBAAqB,IAAI,MAAM,OAAO,WAAW,cAAc,EAAE;AAAA,QACrE,gBAA2B,WAAW,cAAc;AAAA,UAClD,gBAAgB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO,eAAe,OAAO,aAAa;AAAA,IAC5C;AAAA,EACF;AAEA,SAAO;AACT;AAee,SAAR,oBAKL,WACA,WACA,UACA,YACA,yBAA4D,OAC5D,uCACA;AACA,MAAI,CAAC,SAAS,SAAS,GAAG;AACxB,UAAM,IAAI,MAAM,qBAAqB,SAAS;AAAA,EAChD;AACA,QAAM,SAAS,eAAwB,WAAW,WAAW,YAAY,QAAQ;AACjF,QAAM,WAAW,gBAAyB,WAAW,QAAQ;AAAA,IAC3D;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa;AAAA,EACf,CAAC;AACD,MAAI,aAAa,UAAa,aAAa,QAAS,OAAO,aAAa,YAAY,MAAM,QAAQ,GAAI;AAEpG,WAAO;AAAA,EACT;AACA,QAAM,EAAE,mBAAmB,IAAI,uCAAuC,iBAAiB,CAAC;AACxF,MAAI,SAAS,QAAQ,GAAG;AACtB,WAAO,0BAA6B,UAAe,UAAU,kBAAkB;AAAA,EACjF;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,0BAA+B,UAAiB,UAAU,kBAAkB;AAAA,EACrF;AACA,SAAO;AACT;;;AiBnbe,SAAR,eAIL,WAA8B,CAAC,GAAG;AAClC;AAAA;AAAA;AAAA,IAGE,YAAY,aAAsB,QAAQ,KAAK,aAAsB,QAAQ,EAAE,QAAQ,MAAM;AAAA;AAEjG;;;ACNe,SAAR,aACL,WACA,QACA,WAA8B,CAAC,GAC/B,YACA;AACA,MAAI,SAAS,aAAa,MAAM,SAAS;AACvC,WAAO;AAAA,EACT;AACA,MAAI,OAAO,OAAO;AAChB,UAAM,cAAc,eAAwB,WAAW,OAAO,OAAY,UAAU;AACpF,WAAO,YAAY,SAAS,YAAY,YAAY,WAAW;AAAA,EACjE;AACA,SAAO;AACT;;;ACDe,SAAR,gBAKL,WACA,QACA,WAA8B,CAAC,GAC/B,YACA,eACS;AACT,QAAM,YAAY,aAAsB,UAAU,aAAa;AAC/D,QAAM,EAAE,QAAQ,KAAK,IAAI;AACzB,MAAI,eAAe,CAAC,CAAC;AACrB,QAAM,aAAa,cAAiB,MAAM;AAE1C,MAAI,eAAe,SAAS;AAC1B,mBACE,cAAuB,WAAW,QAAQ,UAAU,KACpD,aAAsB,WAAW,QAAQ,UAAU,UAAU,KAC7D,eAAe,QAAQ;AAAA,EAC3B;AAEA,MAAI,eAAe,UAAU;AAC3B,mBAAe;AAAA,EACjB;AACA,MAAI,eAAe,aAAa,CAAC,SAAS,aAAa,GAAG;AACxD,mBAAe;AAAA,EACjB;AACA,MAAI,SAAS,YAAY,GAAG;AAC1B,mBAAe;AAAA,EACjB;AACA,SAAO;AACT;;;AC1DA,OAAOC,cAAa;AAiBL,SAAR,oBAKL,WACA,gBACA,uBACmB;AACnB,MAAI,CAAC,uBAAuB;AAC1B,WAAO;AAAA,EACT;AACA,QAAM,EAAE,QAAQ,WAAW,aAAa,eAAe,IAAI;AAC3D,MAAI,SAAS,UAAU,YAAY,qBAAqB;AACxD,MAAI,cAAc;AAClB,MAAI,CAACC,SAAQ,cAAc,GAAG;AAC5B,kBAAc,aAAa,gBAAgB,uBAAuB,IAAI;AACtE,aAAS,CAAC,GAAG,SAAS,EAAE,OAAO,MAAM;AAAA,EACvC;AACA,SAAO,EAAE,aAAa,OAAO;AAC/B;;;ACrCA,OAAOC,UAAS;AAChB,OAAOC,UAAS;AAMhB,IAAM,WAAW,OAAO,UAAU;AAiDnB,SAAR,yBAIL,WAAmC,YAAe,WAAe,WAAe,OAAY,CAAC,GAAM;AAEnG,MAAI;AAEJ,MAAIC,KAAI,WAAW,cAAc,GAAG;AAElC,UAAM,sBAAyC,CAAC;AAChD,QAAIA,KAAI,WAAW,cAAc,GAAG;AAClC,YAAM,aAAaC,KAAI,WAAW,gBAAgB,CAAC,CAAC;AACpD,aAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AACvC,YAAID,KAAI,MAAM,GAAG,GAAG;AAClB,8BAAoB,GAAG,IAAI;AAAA,QAC7B;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM,OAAiB,OAAO,KAAKC,KAAI,WAAW,gBAAgB,CAAC,CAAC,CAAC;AAErE,UAAM,aAAgC,CAAC;AACvC,SAAK,QAAQ,CAAC,QAAQ;AACpB,YAAM,YAAYA,KAAI,MAAM,GAAG;AAC/B,UAAI,iBAAoBA,KAAI,WAAW,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;AAChE,UAAI,iBAAoBA,KAAI,WAAW,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;AAEhE,UAAID,KAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAgB,YAAY,SAAS;AAAA,MAC3F;AACA,UAAIA,KAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAgB,YAAY,SAAS;AAAA,MAC3F;AAEA,YAAM,sBAAsBC,KAAI,gBAAgB,MAAM;AACtD,YAAM,sBAAsBA,KAAI,gBAAgB,MAAM;AAEtD,UAAI,CAAC,uBAAuB,wBAAwB,qBAAqB;AACvE,YAAID,KAAI,qBAAqB,GAAG,GAAG;AAEjC,iBAAO,oBAAoB,GAAG;AAAA,QAChC;AAEA,YAAI,wBAAwB,YAAa,wBAAwB,WAAW,MAAM,QAAQ,SAAS,GAAI;AAErG,gBAAM,WAAW;AAAA,YACf;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,cAAI,aAAa,UAAa,wBAAwB,SAAS;AAE7D,uBAAW,GAAG,IAAI;AAAA,UACpB;AAAA,QACF,OAAO;AAIL,gBAAM,mBAAmBC,KAAI,gBAAgB,WAAW,QAAQ;AAChE,gBAAM,mBAAmBA,KAAI,gBAAgB,WAAW,QAAQ;AAChE,cAAI,qBAAqB,YAAY,qBAAqB,WAAW;AACnE,gBAAI,qBAAqB,WAAW;AAElC,kCAAoB,GAAG,IAAI;AAAA,YAC7B,WAAWA,KAAI,gBAAgB,UAAU,MAAM,MAAM;AAEnD,kCAAoB,GAAG,IAAI;AAAA,YAC7B;AAAA,UACF;AAEA,gBAAM,iBAAiBA,KAAI,gBAAgB,SAAS,QAAQ;AAC5D,gBAAM,iBAAiBA,KAAI,gBAAgB,SAAS,QAAQ;AAC5D,cAAI,mBAAmB,YAAY,mBAAmB,WAAW;AAE/D,gCAAoB,GAAG,IAAI,mBAAmB,YAAY,iBAAiB;AAAA,UAC7E;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,kBAAc;AAAA,MACZ,GAAG;AAAA,MACH,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EAEF,WAAWA,KAAI,WAAW,MAAM,MAAM,WAAWA,KAAI,WAAW,MAAM,MAAM,WAAW,MAAM,QAAQ,IAAI,GAAG;AAC1G,QAAI,iBAAiBA,KAAI,WAAW,OAAO;AAC3C,QAAI,iBAAiBA,KAAI,WAAW,OAAO;AAG3C,QACE,OAAO,mBAAmB,YAC1B,OAAO,mBAAmB,YAC1B,CAAC,MAAM,QAAQ,cAAc,KAC7B,CAAC,MAAM,QAAQ,cAAc,GAC7B;AACA,UAAID,KAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAqB,YAAY,IAAS;AAAA,MAChG;AACA,UAAIA,KAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAqB,YAAY,IAAS;AAAA,MAChG;AAEA,YAAM,gBAAgBC,KAAI,gBAAgB,MAAM;AAChD,YAAM,gBAAgBA,KAAI,gBAAgB,MAAM;AAEhD,UAAI,CAAC,iBAAiB,kBAAkB,eAAe;AACrD,cAAM,WAAWA,KAAI,WAAW,YAAY,EAAE;AAC9C,YAAI,kBAAkB,UAAU;AAC9B,wBAAc,KAAK,OAAO,CAAC,UAAU,WAAW;AAC9C,kBAAM,YAAY;AAAA,cAChB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACA,gBAAI,cAAc,WAAc,WAAW,KAAK,SAAS,SAAS,WAAW;AAC3E,uBAAS,KAAK,SAAS;AAAA,YACzB;AACA,mBAAO;AAAA,UACT,GAAG,CAAC,CAAC;AAAA,QACP,OAAO;AACL,wBAAc,WAAW,KAAK,KAAK,SAAS,WAAW,KAAK,MAAM,GAAG,QAAQ,IAAI;AAAA,QACnF;AAAA,MACF;AAAA,IACF,WACE,OAAO,mBAAmB,aAC1B,OAAO,mBAAmB,aAC1B,mBAAmB,gBACnB;AAEA,oBAAc;AAAA,IAChB;AAAA,EAEF;AACA,SAAO;AACT;;;ACpMA,OAAOC,UAAS;AAChB,OAAOC,cAAa;AAqBpB,SAAS,mBACP,WACA,QACA,UACA,aACA,IACA,YACA,UACA,eAAoB,CAAC,GACR;AACb,MAAI,WAAW,UAAU,oBAAoB,UAAU,cAAc,QAAQ;AAC3E,UAAM,UAAU,eAAwB,WAAW,QAAQ,YAAY,QAAQ;AAC/E,UAAM,kBAAkB,aAAa,UAAU,CAAC,SAASC,SAAQ,MAAM,OAAO,CAAC;AAC/E,QAAI,oBAAoB,IAAI;AAC1B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa,OAAO,OAAO;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACA,MAAI,aAAa,UAAU,CAACC,KAAI,QAAQ,CAAC,WAAW,OAAO,CAAC,GAAG;AAC7D,WAAO;AAAA,MACL;AAAA,MACAA,KAAI,QAAQ,SAAS;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,QAAM,MAAM,MAAM;AAClB,QAAM,WAAqB,EAAE,IAAI;AACjC,MAAI,cAAiB,MAAM,MAAM,YAAY,kBAAkB,QAAQ;AACrE,eAAW,QAAQ,OAAO,YAAY;AACpC,YAAM,QAAQA,KAAI,QAAQ,CAAC,gBAAgB,IAAI,CAAC;AAChD,YAAM,UAAU,SAAS,MAAM,IAAI,cAAc;AACjD,eAAS,IAAI,IAAI;AAAA,QACf;AAAA,QACA,SAAS,KAAK,IAAI,QAAQ,CAAC;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAAA,QAGAA,KAAI,UAAU,CAAC,IAAI,CAAC;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAae,SAAR,WACL,WACA,QACA,IACA,YACA,UACA,WAAW,QACX,cAAc,KACD;AACb,SAAO,mBAA4B,WAAW,QAAQ,UAAU,aAAa,IAAI,YAAY,QAAQ;AACvG;;;ACxGA,OAAOC,WAAS;AAChB,OAAOC,cAAa;AACpB,OAAOC,UAAS;AA8BhB,SAAS,qBACP,WACA,QACA,MACA,YACA,UACA,eAAoB,CAAC,GACN;AACf,MAAI,WAAW,UAAU,oBAAoB,UAAU,cAAc,QAAQ;AAC3E,UAAM,UAAU,eAAwB,WAAW,QAAQ,YAAY,QAAQ;AAC/E,UAAM,kBAAkB,aAAa,UAAU,CAAC,SAASC,SAAQ,MAAM,OAAO,CAAC;AAC/E,QAAI,oBAAoB,IAAI;AAC1B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa,OAAO,OAAO;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,aAAyB;AAAA,IAC3B,CAAC,QAAQ,GAAG,KAAK,QAAQ,OAAO,EAAE;AAAA,EACpC;AAEA,MAAI,cAAc,UAAU,cAAc,QAAQ;AAChD,UAAM,QAAa,cAAc,SAAU,OAAO,QAAiB,OAAO;AAC1E,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,UAAM,QAAQ,yBAAkC,WAAW,YAAa,UAAU,OAAO,GAAG,aAAa;AACzG,UAAM,UAAa,MAAO,KAAK;AAC/B,iBAAa;AAAA,MACX,GAAG;AAAA,MACH,GAAG,qBAA8B,WAAW,SAAS,MAAM,YAAY,UAAU,YAAY;AAAA,IAC/F;AAAA,EACF;AAEA,MAAI,6BAA6B,UAAU,OAAO,yBAAyB,MAAM,OAAO;AACtF,IAAAC,KAAI,YAAY,gCAAgC,IAAI;AAAA,EACtD;AAEA,MAAI,aAAa,UAAU,MAAM,QAAQ,QAAQ,GAAG;AAClD,aAAS,QAAQ,CAAC,SAAS,MAAc;AACvC,iBAAW,CAAC,IAAI;AAAA,QACd;AAAA,QACA,OAAO;AAAA,QACP,GAAG,IAAI,IAAI,CAAC;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH,WAAW,kBAAkB,QAAQ;AACnC,eAAW,YAAY,OAAO,YAAY;AACxC,YAAM,QAAQC,MAAI,QAAQ,CAAC,gBAAgB,QAAQ,CAAC;AACpD,iBAAW,QAAQ,IAAI;AAAA,QACrB;AAAA,QACA;AAAA,QACA,GAAG,IAAI,IAAI,QAAQ;AAAA,QACnB;AAAA;AAAA;AAAA,QAGAA,MAAI,UAAU,CAAC,QAAQ,CAAC;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAWe,SAAR,aACL,WACA,QACA,OAAO,IACP,YACA,UACe;AACf,SAAO,qBAAqB,WAAW,QAAQ,MAAM,YAAY,QAAQ;AAC3E;;;ACpFA,IAAM,cAAN,MAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWE,YACE,WACA,YACA,uCACA;AACA,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,wCAAwC;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe;AACb,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,sBACE,WACA,YACA,wCAAwC,CAAC,GAChC;AACT,QAAI,CAAC,aAAa,CAAC,YAAY;AAC7B,aAAO;AAAA,IACT;AACA,WACE,KAAK,cAAc,aACnB,CAAC,WAAW,KAAK,YAAY,UAAU,KACvC,CAAC,WAAW,KAAK,uCAAuC,qCAAqC;AAAA,EAEjG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,oBACE,QACA,UACA,yBAA4D,OACvC;AACrB,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,gBAAgB,QAAW,UAA8B,eAAuC;AAC9F,WAAO,gBAAyB,KAAK,WAAW,QAAQ,UAAU,KAAK,YAAY,aAAa;AAAA,EAClG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,yBACE,UACA,SACA,gBACA,oBACQ;AACR,WAAO;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,uBAAuB,UAAyB,SAAc,oBAAqC;AACjG,WAAO,uBAAgC,KAAK,WAAW,UAAU,SAAS,KAAK,YAAY,kBAAkB;AAAA,EAC/G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,kBAAkB,UAAyB,SAAc,oBAA6B;AACpF,WAAO,kBAA2B,KAAK,WAAW,UAAU,SAAS,KAAK,YAAY,kBAAkB;AAAA,EAC1G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,QAAW,UAA8B;AACpD,WAAO,aAAsB,KAAK,WAAW,QAAQ,UAAU,KAAK,UAAU;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,QAAW;AACvB,WAAO,cAAuB,KAAK,WAAW,QAAQ,KAAK,UAAU;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,QAAW;AAClB,WAAO,SAAkB,KAAK,WAAW,QAAQ,KAAK,UAAU;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,oBAAoB,gBAAmC,uBAA2D;AAChH,WAAO,oBAA6B,KAAK,WAAW,gBAAgB,qBAAqB;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,eAAe,QAAW,aAAiB;AACzC,WAAO,eAAwB,KAAK,WAAW,QAAQ,KAAK,YAAY,WAAW;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,yBAAyB,WAAe,WAAe,MAAe;AACpE,WAAO,yBAAyB,KAAK,WAAW,KAAK,YAAY,WAAW,WAAW,IAAI;AAAA,EAC7F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,WAAW,QAAW,IAAoB,UAAc,WAAW,QAAQ,cAAc,KAAkB;AACzG,WAAO,WAAoB,KAAK,WAAW,QAAQ,IAAI,KAAK,YAAY,UAAU,UAAU,WAAW;AAAA,EACzG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAa,QAAW,MAAe,UAA6B;AAClE,WAAO,aAAsB,KAAK,WAAW,QAAQ,MAAM,KAAK,YAAY,QAAQ;AAAA,EACtF;AACF;AAUe,SAAR,kBAKL,WACA,YACA,wCAAwC,CAAC,GACf;AAC1B,SAAO,IAAI,YAAqB,WAAW,YAAY,qCAAqC;AAC9F;;;ACnSe,SAAR,cAA+B,SAAiB;AAErD,QAAM,WAAqB,QAAQ,MAAM,GAAG;AAE5C,QAAM,SAAmB,SAAS,CAAC,EAAE,MAAM,GAAG;AAE9C,QAAM,OAAe,OAAO,CAAC,EAAE,QAAQ,SAAS,EAAE;AAElD,QAAM,aAAa,OAAO,OAAO,CAAC,UAAU;AAC1C,WAAO,MAAM,MAAM,GAAG,EAAE,CAAC,MAAM;AAAA,EACjC,CAAC;AAED,MAAI;AACJ,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT,OAAO;AAGL,WAAO,UAAU,WAAW,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC;AAAA,EAC9C;AAGA,MAAI;AACF,UAAM,SAAS,KAAK,SAAS,CAAC,CAAC;AAC/B,UAAM,QAAQ,CAAC;AACf,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,KAAK,OAAO,WAAW,CAAC,CAAC;AAAA,IACjC;AAEA,UAAM,OAAO,IAAI,OAAO,KAAK,CAAC,IAAI,WAAW,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC;AAE9D,WAAO,EAAE,MAAM,KAAK;AAAA,EACtB,SAAS,OAAO;AACd,WAAO,EAAE,MAAM,EAAE,MAAM,GAAG,MAAO,MAAgB,QAAQ,GAAG,MAAM,QAAQ;AAAA,EAC5E;AACF;;;ACjCe,SAAR,wBAAyC,aAAqB,QAAmB;AACtF,MAAI,SAAS;AACb,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,UAAM,QAAQ,OAAO,MAAM,OAAO;AAClC,WAAO,QAAQ,CAAC,OAAO,UAAU;AAC/B,YAAM,YAAY,MAAM,UAAU,CAAC,SAAS,SAAS,IAAI,QAAQ,CAAC,EAAE;AACpE,UAAI,aAAa,GAAG;AAClB,cAAM,SAAS,IAAI;AAAA,MACrB;AAAA,IACF,CAAC;AACD,aAAS,MAAM,KAAK,EAAE;AAAA,EACxB;AACA,SAAO;AACT;;;ACVe,SAAR,wBAAyC,mBAAuC,QAA2B;AAChH,SAAO,wBAAwB,mBAAmB,MAAM;AAC1D;;;ACbA,OAAOC,cAAa;;;ACaL,SAAR,yBACL,YACA,iBAAuC,CAAC,GACxC,YACyE;AACzE,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,WAAW,IAAI,CAACC,WAAU,yBAAyBA,QAAO,cAAc,CAAC,EAAE,OAAO,CAAC,QAAQ,GAAG;AAAA,EACvG;AAEA,QAAM,QAAQ,eAAe,MAAM,eAAe,OAAO,KAAK,OAAO,UAAU;AAC/E,QAAM,SAAS,eAAe,KAAK;AACnC,SAAO,SAAS,OAAO,QAAQ;AACjC;;;ADRe,SAAR,yBACL,YACA,UACA,iBAAuC,CAAC,GACiC;AACzE,QAAM,QAAQ,yBAA4B,YAAY,cAAc;AACpE,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,OAAO,CAAC,MAAM,CAACC,SAAQ,GAAG,KAAK,CAAC;AAAA,EAClD;AACA,SAAOA,SAAQ,OAAO,QAAQ,IAAI,SAAY;AAChD;;;AE3BA,OAAOC,cAAa;AAUL,SAAR,sBACL,OACA,UACA;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,KAAK,CAAC,QAAQA,SAAQ,KAAK,KAAK,CAAC;AAAA,EACnD;AACA,SAAOA,SAAQ,UAAU,KAAK;AAChC;;;ACJe,SAAR,yBACL,OACA,iBAAuC,CAAC,GACxC,WAAW,OACoB;AAC/B,QAAM,kBAA4B,eAC/B,IAAI,CAAC,KAAK,UAAW,sBAAsB,IAAI,OAAO,KAAK,IAAI,OAAO,KAAK,IAAI,MAAU,EACzF,OAAO,CAAC,QAAQ,OAAO,QAAQ,WAAW;AAC7C,MAAI,CAAC,UAAU;AACb,WAAO,gBAAgB,CAAC;AAAA,EAC1B;AACA,SAAO;AACT;;;ACxBA,SAAS,aAAa;AAUP,SAAR,uBACL,YACA,UACA,iBAAuC,CAAC,GACxC;AACA,QAAM,QAAQ,yBAA4B,YAAY,cAAc;AACpE,MAAI,CAAC,MAAM,KAAK,GAAG;AACjB,UAAM,QAAQ,eAAe,UAAU,CAAC,QAAQ,UAAU,IAAI,KAAK;AACnE,UAAM,MAAM,eAAe,IAAI,CAAC,EAAE,OAAO,IAAI,MAAM,GAAG;AACtD,UAAM,UAAU,SAAS,MAAM,GAAG,KAAK,EAAE,OAAO,OAAO,SAAS,MAAM,KAAK,CAAC;AAG5E,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,OAAO,IAAI,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,CAAC,CAAC;AAAA,EACvE;AACA,SAAO;AACT;;;AC3BA,OAAO,eAAe;AACtB,OAAOC,WAAS;AAChB,OAAOC,UAAS;AAUhB,IAAqB,qBAArB,MAAiD;AAAA;AAAA;AAAA;AAAA;AAAA,EAW/C,YAAY,eAAgC;AAN5C;AAAA;AAAA;AAAA;AAAA,SAAQ,cAA8B,CAAC;AAOrC,SAAK,eAAe,aAAa;AAAA,EACnC;AAAA;AAAA;AAAA,EAIA,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,sBAAsB,aAAiC;AAC7D,UAAM,UAAW,MAAM,QAAQ,WAAW,KAAK,YAAY,SAAS,KAAM,OAAO,gBAAgB;AACjG,QAAI,aAA0B,UAAUC,MAAI,KAAK,aAAa,WAAW,IAAI,KAAK;AAClF,QAAI,CAAC,cAAc,aAAa;AAC9B,mBAAa,CAAC;AACd,MAAAC,KAAI,KAAK,aAAa,aAAa,UAAU;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe,eAAgC;AAC7C,SAAK,cAAc,gBAAgB,UAAU,aAAa,IAAI,CAAC;AAC/D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,aAAgC,aAAiC;AACzE,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AACtE,QAAI,aAAaD,MAAI,YAAY,UAAU;AAC3C,QAAI,CAAC,MAAM,QAAQ,UAAU,GAAG;AAC9B,mBAAa,CAAC;AACd,iBAAW,UAAU,IAAI;AAAA,IAC3B;AAEA,QAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,iBAAW,KAAK,GAAG,WAAW;AAAA,IAChC,OAAO;AACL,iBAAW,KAAK,WAAW;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,aAAgC,aAAiC;AACzE,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AAEtE,UAAM,YAAY,MAAM,QAAQ,WAAW,IAAI,CAAC,GAAG,WAAW,IAAI,CAAC,WAAW;AAC9E,IAAAC,KAAI,YAAY,YAAY,SAAS;AACrC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY,aAAiC;AAC3C,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AACtE,IAAAA,KAAI,YAAY,YAAY,CAAC,CAAC;AAC9B,WAAO;AAAA,EACT;AACF;;;ACtGe,SAAR,UAAoE,QAAW;AACpF,QAAM,OAAsB,CAAC;AAC7B,MAAI,OAAO,YAAY;AACrB,SAAK,OAAO,OAAO;AAAA,EACrB;AACA,MAAI,OAAO,WAAW,OAAO,YAAY,GAAG;AAC1C,SAAK,MAAM,OAAO;AAAA,EACpB;AACA,MAAI,OAAO,WAAW,OAAO,YAAY,GAAG;AAC1C,SAAK,MAAM,OAAO;AAAA,EACpB;AACA,SAAO;AACT;;;ACVe,SAAR,cAKL,QACA,aACA,UAAkC,CAAC,GACnC,qBAAqB,MACL;AAChB,QAAM,aAA6B;AAAA,IACjC,MAAM,eAAe;AAAA,IACrB,GAAG,UAAU,MAAM;AAAA,EACrB;AAGA,MAAI,QAAQ,WAAW;AACrB,eAAW,OAAO,QAAQ;AAAA,EAC5B,WAAW,CAAC,aAAa;AAEvB,QAAI,OAAO,SAAS,UAAU;AAC5B,iBAAW,OAAO;AAElB,UAAI,sBAAsB,WAAW,SAAS,QAAW;AAGvD,mBAAW,OAAO;AAAA,MACpB;AAAA,IACF,WAAW,OAAO,SAAS,WAAW;AACpC,iBAAW,OAAO;AAElB,UAAI,WAAW,SAAS,QAAW;AAEjC,mBAAW,OAAO;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAEA,MAAI,QAAQ,cAAc;AACxB,eAAW,eAAe,QAAQ;AAAA,EACpC;AAEA,SAAO;AACT;;;AChDO,IAAM,kBAA+C;AAAA,EAC1D,OAAO;AAAA,IACL,UAAU;AAAA,EACZ;AAAA,EACA,YAAY;AAAA,EACZ,UAAU;AACZ;AAOe,SAAR,uBAIL,WAA8B,CAAC,GAAgC;AAC/D,QAAM,YAAY,aAAsB,QAAQ;AAChD,MAAI,aAAa,UAAU,sBAAsB,GAAG;AAClD,UAAM,UAAU,UAAU,sBAAsB;AAChD,WAAO,EAAE,GAAG,iBAAiB,GAAG,QAAQ;AAAA,EAC1C;AAEA,SAAO;AACT;;;ACrBe,SAAR,YAKL,MAAY,UAA6B,YAAoC,CAAC,GAAiC;AAC/G,QAAM,EAAE,UAAU,IAAI;AACtB,MAAI,SAAS,mBAAmB;AAC9B,WAAO,UAAU,IAAI;AAAA,EACvB;AACA;AAAA;AAAA;AAAA,IAGI,UAAkB,IAAI,KAAsC,UAAU,IAAI;AAAA;AAEhF;;;ACzBA,SAAS,qBAAqB;AAC9B,OAAO,aAAa;AACpB,OAAOC,WAAS;AAChB,OAAOC,UAAS;AA2EH;AApEb,IAAM,YAAsD;AAAA,EAC1D,SAAS;AAAA,IACP,UAAU;AAAA,IACV,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,IACP,UAAU;AAAA,IACV,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA,IACL,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,gBAAgB;AAAA,IAChB,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAAA,EACA,SAAS;AAAA,IACP,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAAA,EACA,OAAO;AAAA,IACL,QAAQ;AAAA,IACR,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AACF;AASA,SAAS,mBACP,SACA;AACA,MAAI,eAA4CC,MAAI,SAAS,cAAc;AAE3E,MAAI,CAAC,cAAc;AACjB,UAAM,iBAAkB,QAAQ,gBAAgB,QAAQ,aAAa,WAAY,CAAC;AAClF,mBAAe,CAAC,EAAE,SAAS,GAAG,MAAM,MAAM;AACxC,aAAO,oBAAC,WAAQ,SAAS,EAAE,GAAG,gBAAgB,GAAG,QAAQ,GAAI,GAAG,OAAO;AAAA,IACzE;AACA,IAAAC,KAAI,SAAS,gBAAgB,YAAY;AAAA,EAC3C;AACA,SAAO;AACT;AAae,SAAR,UACL,QACA,QACA,oBAAkD,CAAC,GAClC;AACjB,QAAM,OAAO,cAAc,MAAM;AAEjC,MACE,OAAO,WAAW,cACjB,UAAU,QAAQ,aAAa,cAAc,MAAM,CAAC,KACrD,QAAQ,OAAO,MAAM,GACrB;AACA,WAAO,mBAA4B,MAAyB;AAAA,EAC9D;AAEA,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,MAAM,kCAAkC,OAAO,MAAM,EAAE;AAAA,EACnE;AAEA,MAAI,UAAU,mBAAmB;AAC/B,UAAM,mBAAmB,kBAAkB,MAAM;AACjD,WAAO,UAAmB,QAAQ,kBAAkB,iBAAiB;AAAA,EACvE;AAEA,MAAI,OAAO,SAAS,UAAU;AAC5B,QAAI,EAAE,QAAQ,YAAY;AACxB,YAAM,IAAI,MAAM,uBAAuB,IAAI,GAAG;AAAA,IAChD;AAEA,QAAI,UAAU,UAAU,IAAI,GAAG;AAC7B,YAAM,mBAAmB,kBAAkB,UAAU,IAAI,EAAE,MAAM,CAAC;AAClE,aAAO,UAAmB,QAAQ,kBAAkB,iBAAiB;AAAA,IACvE;AAAA,EACF;AAEA,QAAM,IAAI,MAAM,cAAc,MAAM,eAAe,IAAI,GAAG;AAC5D;;;AC3HA,SAAS,WAAW,QAAwB;AAC1C,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACzC,UAAM,MAAM,OAAO,WAAW,CAAC;AAC/B,YAAQ,QAAQ,KAAK,OAAO;AAC5B,WAAO,OAAO;AAAA,EAChB;AACA,SAAO,KAAK,SAAS,EAAE;AACzB;AAQe,SAAR,cAAwE,QAAW;AACxF,QAAM,UAAU,oBAAI,IAAY;AAEhC,OAAK,UAAU,QAAQ,CAAC,KAAK,WAAW,QAAQ,IAAI,GAAG,GAAG,MAAM;AAChE,SAAO,WAAW,KAAK,UAAU,QAAQ,MAAM,KAAK,OAAO,EAAE,KAAK,CAAC,CAAC;AACtE;;;ACnBe,SAAR,UACL,QACA,QACA,oBAAkD,CAAC,GACnD;AACA,MAAI;AACF,cAAU,QAAQ,QAAQ,iBAAiB;AAC3C,WAAO;AAAA,EACT,SAAS,GAAG;AACV,UAAM,MAAa;AACnB,QAAI,IAAI,YAAY,IAAI,QAAQ,WAAW,WAAW,KAAK,IAAI,QAAQ,WAAW,oBAAoB,IAAI;AACxG,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;;;AC1BA,OAAOC,eAAc;AAUrB,SAAS,YAAqB,IAA0B,QAAgB;AACtE,QAAM,QAAQC,UAAS,EAAE,IAAI,KAAK,GAAG,MAAM;AAC3C,SAAO,GAAG,KAAK,KAAK,MAAM;AAC5B;AAMO,SAAS,cAAuB,IAA0B;AAC/D,SAAO,YAAe,IAAI,aAAa;AACzC;AAOO,SAAS,QAAiB,IAA0B;AACzD,SAAO,YAAe,IAAI,OAAO;AACnC;AAOO,SAAS,WAAoB,IAA0B;AAC5D,SAAO,YAAe,IAAI,UAAU;AACtC;AAOO,SAAS,OAAgB,IAA0B;AACxD,SAAO,YAAe,IAAI,MAAM;AAClC;AAOO,SAAS,QAAiB,IAA0B;AACzD,SAAO,YAAe,IAAI,OAAO;AACnC;AAUO,SAAS,mBAA4B,IAA0B,kBAAkB,OAAO;AAC7F,QAAM,WAAW,kBAAkB,IAAI,WAAc,EAAE,CAAC,KAAK;AAC7D,SAAO,GAAG,QAAW,EAAE,CAAC,IAAI,cAAiB,EAAE,CAAC,IAAI,OAAU,EAAE,CAAC,GAAG,QAAQ;AAC9E;AAQO,SAAS,SAAS,IAAY,aAAqB;AACxD,SAAO,GAAG,EAAE,IAAI,WAAW;AAC7B;;;ACnEe,SAAR,WAA4B,OAA+B,WAAqB,UAAuB;AAC5G,SAAO,YAAY,WAAW;AAChC;;;ACVe,SAAR,WAA4B,YAAoB;AACrD,SAAO,aAAa,IAAI,KAAK,UAAU,EAAE,OAAO,IAAI;AACtD;;;ACGe,SAAR,WAAqE,QAAW;AACrF,MAAI,YAAY,UAAU,MAAM,QAAQ,OAAO,IAAI,KAAK,OAAO,KAAK,WAAW,GAAG;AAChF,WAAO,OAAO,KAAK,CAAC;AAAA,EACtB;AACA,MAAI,aAAa,QAAQ;AACvB,WAAO,OAAO;AAAA,EAChB;AACA,QAAM,IAAI,MAAM,yCAAyC;AAC3D;;;ACPe,SAAR,YACL,QACkC;AAGlC,QAAM,sBAAsB;AAC5B,MAAI,oBAAoB,aAAa,MAAuC;AAC1E,YAAQ,KAAK,oFAAoF;AAAA,EACnG;AACA,MAAI,OAAO,MAAM;AACf,WAAO,OAAO,KAAK,IAAI,CAAC,OAAO,MAAM;AACnC,YAAM,QAAS,oBAAoB,aAAa,oBAAoB,UAAU,CAAC,KAAM,OAAO,KAAK;AACjG,aAAO,EAAE,OAAO,MAAM;AAAA,IACxB,CAAC;AAAA,EACH;AACA,QAAM,aAAa,OAAO,SAAS,OAAO;AAC1C,SACE,cACA,WAAW,IAAI,CAAC,eAAe;AAC7B,UAAM,UAAU;AAChB,UAAM,QAAQ,WAAW,OAAO;AAChC,UAAM,QAAQ,QAAQ,SAAS,OAAO,KAAK;AAC3C,WAAO;AAAA,MACL,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AAEL;;;AC5Be,SAAR,gBAAiC,YAAsB,OAA4B;AACxF,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAO;AAAA,EACT;AAEA,QAAM,cAAc,CAAC,QACnB,IAAI,OAAO,CAAC,MAAyB,SAAS;AAC5C,SAAK,IAAI,IAAI;AACb,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP,QAAM,gBAAgB,CAAC,QACrB,IAAI,SAAS,IAAI,eAAe,IAAI,KAAK,MAAM,CAAC,MAAM,aAAa,IAAI,CAAC,CAAC;AAC3E,QAAM,eAAe,YAAY,UAAU;AAC3C,QAAM,gBAAgB,MAAM,OAAO,CAAC,SAAS,SAAS,OAAO,aAAa,IAAI,CAAC;AAC/E,QAAM,YAAY,YAAY,aAAa;AAE3C,QAAM,OAAO,WAAW,OAAO,CAAC,SAAiB,CAAC,UAAU,IAAI,CAAC;AACjE,QAAM,YAAY,cAAc,QAAQ,GAAG;AAC3C,MAAI,cAAc,IAAI;AACpB,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,wCAAwC,cAAc,IAAI,CAAC,EAAE;AAAA,IAC/E;AACA,WAAO;AAAA,EACT;AACA,MAAI,cAAc,cAAc,YAAY,GAAG,GAAG;AAChD,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC5E;AAEA,QAAM,WAAW,CAAC,GAAG,aAAa;AAClC,WAAS,OAAO,WAAW,GAAG,GAAG,IAAI;AACrC,SAAO;AACT;;;ACrCe,SAAR,IAAqB,KAAa,OAAe;AACtD,MAAI,IAAI,OAAO,GAAG;AAClB,SAAO,EAAE,SAAS,OAAO;AACvB,QAAI,MAAM;AAAA,EACZ;AACA,SAAO;AACT;;;ACHe,SAAR,gBAAiC,YAAqB,cAAc,MAAkB;AAC3F,MAAI,CAAC,YAAY;AACf,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM,cAAc,KAAK;AAAA,MACzB,QAAQ,cAAc,KAAK;AAAA,MAC3B,QAAQ,cAAc,KAAK;AAAA,IAC7B;AAAA,EACF;AACA,QAAM,OAAO,IAAI,KAAK,UAAU;AAChC,MAAI,OAAO,MAAM,KAAK,QAAQ,CAAC,GAAG;AAChC,UAAM,IAAI,MAAM,0BAA0B,UAAU;AAAA,EACtD;AACA,SAAO;AAAA,IACL,MAAM,KAAK,eAAe;AAAA,IAC1B,OAAO,KAAK,YAAY,IAAI;AAAA;AAAA,IAC5B,KAAK,KAAK,WAAW;AAAA,IACrB,MAAM,cAAc,KAAK,YAAY,IAAI;AAAA,IACzC,QAAQ,cAAc,KAAK,cAAc,IAAI;AAAA,IAC7C,QAAQ,cAAc,KAAK,cAAc,IAAI;AAAA,EAC/C;AACF;;;ACrBe,SAAR,wBAAkF,QAAoB;AAE3G,MAAI,OAAO,OAAO;AAChB,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,QAAQ,OAAO,KAAK,WAAW,KAAK,OAAO,KAAK,CAAC,MAAM,MAAM;AACtE,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,SAAS,OAAO,MAAM,WAAW,GAAG;AAC7C,WAAO,wBAAwB,OAAO,MAAM,CAAC,CAAM;AAAA,EACrD;AAGA,MAAI,OAAO,SAAS,OAAO,MAAM,WAAW,GAAG;AAC7C,WAAO,wBAAwB,OAAO,MAAM,CAAC,CAAM;AAAA,EACrD;AAGA,MAAI,OAAO,OAAO;AAChB,UAAM,aAAa,CAAC,cAAyC,wBAAwB,SAAc;AACnG,WAAO,OAAO,MAAM,KAAK,UAAU;AAAA,EACrC;AAEA,SAAO;AACT;;;AC3Be,SAAR,aAA8B,WAA4B,WAAgB,WAAgB;AAC/F,QAAM,EAAE,OAAO,MAAM,IAAI;AACzB,SAAO,CAAC,WAAW,OAAO,SAAS,KAAK,CAAC,WAAW,OAAO,SAAS;AACtE;;;ACNe,SAAR,aAA8B,YAAwB,OAAO,MAAM;AACxE,QAAM,EAAE,MAAM,OAAO,KAAK,OAAO,GAAG,SAAS,GAAG,SAAS,EAAE,IAAI;AAC/D,QAAM,UAAU,KAAK,IAAI,MAAM,QAAQ,GAAG,KAAK,MAAM,QAAQ,MAAM;AACnE,QAAM,WAAW,IAAI,KAAK,OAAO,EAAE,OAAO;AAC1C,SAAO,OAAO,WAAW,SAAS,MAAM,GAAG,EAAE;AAC/C;;;ACdA,OAAOC,oBAAmB;AAWX,SAAR,YACL,aACA,YAAsB,CAAC,GACA;AACvB,MAAI,CAAC,aAAa;AAChB,WAAO,CAAC;AAAA,EACV;AACA,MAAI,YAAmC,CAAC;AACxC,MAAI,cAAc,aAAa;AAC7B,gBAAY,UAAU;AAAA,MACpB,YAAY,UAAU,EAAG,IAAI,CAAC,YAAoB;AAChD,cAAM,WAAW,IAAI,UAAU,KAAK,GAAG,CAAC;AACxC,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA,OAAO,GAAG,QAAQ,IAAI,OAAO;AAAA,QAC/B;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACA,SAAO,OAAO,KAAK,WAAW,EAAE,OAAO,CAAC,KAAK,QAAQ;AACnD,QAAI,QAAQ,YAAY;AACtB,YAAM,cAAe,YAAkC,GAAG;AAC1D,UAAIC,eAAc,WAAW,GAAG;AAC9B,cAAM,IAAI,OAAO,YAAY,aAAa,CAAC,GAAG,WAAW,GAAG,CAAC,CAAC;AAAA,MAChE;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,SAAS;AACd;;;ACxCA,OAAO,YAAY;AAwBJ,SAAR,cAAwC,QAA+C;AAC5F,QAAM,UAAU,IAAI,mBAAsB;AAC1C,MAAI,OAAO,QAAQ;AACjB,WAAO,QAAQ,CAAC,UAAU;AACxB,YAAM,EAAE,UAAU,QAAQ,IAAI;AAE9B,YAAM,OAAO,aAAa,MAAM,CAAC,IAAI,OAAO,QAAQ;AAGpD,UAAI,KAAK,SAAS,KAAK,KAAK,CAAC,MAAM,IAAI;AACrC,aAAK,OAAO,GAAG,CAAC;AAAA,MAClB;AACA,UAAI,SAAS;AACX,gBAAQ,UAAU,SAAS,IAAI;AAAA,MACjC;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO,QAAQ;AACjB;;;AC1CA,OAAOC,oBAAmB;AASX,SAAR,mBAA6C,cAAiD;AACnG,SAAO,OAAO,KAAK,YAAY,EAAE,OAAO,CAAC,KAAK,QAAQ;AACpD,QAAI,QAAQ,YAAY;AACtB,aAAO;AAAA,IACT,OAAO;AACL,YAAM,cAAe,aAAmC,GAAG;AAC3D,UAAIA,eAAc,WAAW,GAAG;AAC9B,eAAO;AAAA,UACL,GAAG;AAAA,UACH,CAAC,GAAG,GAAG,mBAAmB,WAAW;AAAA,QACvC;AAAA,MACF;AACA,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,YAAY;AAAA,IACtC;AAAA,EACF,GAAG,CAAC,CAAmB;AACzB;;;ACjBe,SAAR,WAA4B,UAAkB;AACnD,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAQA,QAAM,OAAO,IAAI,KAAK,QAAQ;AAE9B,QAAM,OAAO,IAAI,KAAK,YAAY,GAAG,CAAC;AACtC,QAAM,KAAK,IAAI,KAAK,SAAS,IAAI,GAAG,CAAC;AACrC,QAAM,KAAK,IAAI,KAAK,QAAQ,GAAG,CAAC;AAChC,QAAM,KAAK,IAAI,KAAK,SAAS,GAAG,CAAC;AACjC,QAAM,KAAK,IAAI,KAAK,WAAW,GAAG,CAAC;AACnC,QAAM,KAAK,IAAI,KAAK,WAAW,GAAG,CAAC;AACnC,QAAM,MAAM,IAAI,KAAK,gBAAgB,GAAG,CAAC;AAEzC,SAAO,GAAG,IAAI,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,GAAG;AACrD;;;AC7BA,OAAOC,cAAa;AAeL,SAAR,oBACL,gBACA,uBACmB;AACnB,MAAI,CAAC,uBAAuB;AAC1B,WAAO;AAAA,EACT;AACA,QAAM,EAAE,QAAQ,WAAW,aAAa,eAAe,IAAI;AAC3D,MAAI,SAAS,YAAY,qBAAqB;AAC9C,MAAI,cAAc;AAClB,MAAI,CAACC,SAAQ,cAAc,GAAG;AAC5B,kBAAc,aAAa,gBAAgB,uBAAuB,IAAI;AACtE,aAAS,CAAC,GAAG,SAAS,EAAE,OAAO,MAAM;AAAA,EACvC;AACA,SAAO,EAAE,aAAa,OAAO;AAC/B;;;AC5BA,OAAOC,eAAc;AAOrB,SAAS,sBAA+D,MAAY;AAClF,aAAW,OAAO,MAAM;AACtB,UAAM,UAAgC;AACtC,UAAM,QAAQ,QAAQ,GAAG;AACzB,QAAI,QAAQ,WAAW,OAAO,UAAU,YAAY,MAAM,WAAW,GAAG,GAAG;AACzE,cAAQ,GAAG,IAAI,qBAAqB;AAAA,IACtC,OAAO;AACL,cAAQ,GAAG,IAAI,gBAAmB,KAAK;AAAA,IACzC;AAAA,EACF;AACA,SAAO;AACT;AAOA,SAAS,qBAA8D,MAAgB;AACrF,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,SAAK,CAAC,IAAI,gBAAmB,KAAK,CAAC,CAAC;AAAA,EACtC;AACA,SAAO;AACT;AAQe,SAAR,gBAA0E,YAAwB;AACvG,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,qBAAwB,CAAC,GAAG,UAAU,CAAC;AAAA,EAChD;AACA,MAAIA,UAAS,UAAU,GAAG;AACxB,WAAO,sBAAyB,EAAE,GAAG,WAAW,CAAC;AAAA,EACnD;AACA,SAAO;AACT;;;AC1CO,IAAK,qBAAL,kBAAKC,wBAAL;AAEL,EAAAA,oBAAA,oBAAiB;AAEjB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,cAAW;AAEX,EAAAA,oBAAA,aAAU;AAEV,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,iBAAc;AAEd,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,eAAY;AAEZ,EAAAA,oBAAA,mBAAgB;AAEhB,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,oBAAiB;AAEjB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,cAAW;AAEX,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,mBAAgB;AAEhB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,wBAAqB;AAErB,EAAAA,oBAAA,wBAAqB;AAGrB,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,kBAAe;AAIf,EAAAA,oBAAA,uBAAoB;AAEpB,EAAAA,oBAAA,cAAW;AAGX,EAAAA,oBAAA,wBAAqB;AAErB,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,4BAAyB;AAEzB,EAAAA,oBAAA,gCAA6B;AAI7B,EAAAA,oBAAA,qCAAkC;AAIlC,EAAAA,oBAAA,eAAY;AAlEF,SAAAA;AAAA,GAAA;;;ACNZ,OAAO,aAAa;AACpB,OAAOC,cAAa;;;ACDpB,OAAOC,WAAS;AAChB,OAAOC,cAAa;AA8BpB,IAAqB,kBAArB,MAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,YAAY,YAAe;AAP3B;AAAA,qBAA0B,CAAC;AAQzB,SAAK,aAAa;AAClB,SAAK,UAAU,YAAY,cAAiB,UAAU,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,QAAW,MAAc;AACjC,UAAM,MAAMC,MAAI,QAAQ,QAAQ,IAAI;AACpC,UAAM,mBAAmB,EAAE,GAAG,QAAQ,CAAC,MAAM,GAAG,IAAI;AACpD,UAAM,WAAW,KAAK,UAAU,GAAG;AACnC,QAAI,CAAC,UAAU;AACb,WAAK,UAAU,GAAG,IAAI;AAAA,IACxB,WAAW,CAACC,SAAQ,UAAU,gBAAgB,GAAG;AAC/C,cAAQ,MAAM,oBAAoB,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC;AACnE,cAAQ,MAAM,eAAe,KAAK,UAAU,kBAAkB,MAAM,CAAC,CAAC;AACtE,YAAM,IAAI;AAAA,QACR,iDAAiD,GAAG;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,eAAe;AACb,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,QAAQ,QAAW,WAAc,YAAwB;AACvD,QAAI,CAACA,SAAQ,YAAY,KAAK,UAAU,GAAG;AACzC,YAAM,IAAI,MAAM,gGAAgG;AAAA,IAClH;AACA,SAAK,UAAU,QAAQ,cAAiB,MAAM,CAAC;AAE/C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAA4B,SAAY,WAA+D;AACrG,UAAM,IAAI,MAAM,yEAAyE;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,cAA+B,YAA8C;AACvF,UAAM,IAAI,MAAM,uEAAuE;AAAA,EACzF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,iBACE,WACA,SACA,iBACA,kBACA,WACmB;AACnB,UAAM,IAAI,MAAM,4EAA4E;AAAA,EAC9F;AACF;;;ADjHA,SAAS,YACP,WACA,aACA,YACA,QACA;AACA,QAAM,UAAU,uBAAgC,WAAW,QAAQ,YAAY,QAAW,IAAI;AAC9F,UAAQ,QAAQ,CAACC,YAAW;AAC1B,UAAM,kBAAkB,YAAY,UAAU,CAAC,SAASC,SAAQ,MAAMD,OAAM,CAAC;AAC7E,QAAI,oBAAoB,IAAI;AAC1B,kBAAY,KAAKA,OAAM;AACvB,YAAM,aAAa,yBAAkC,WAAWA,SAAQ,YAAY,IAAI;AACxF,iBAAW,QAAQ,CAAC,MAAM;AACxB,YAAI,kBAAkB,KAAK,EAAE,cAAc,GAAG;AAC5C,kBAAQA,QAAO,cAAc,GAAG,CAAC,UAAU;AACzC,wBAAqB,WAAW,aAAa,YAAY,KAAU;AAAA,UACrE,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AACD,UAAI,aAAaA,WAAU,CAAC,MAAM,QAAQA,QAAO,KAAK,KAAK,OAAOA,QAAO,UAAU,WAAW;AAC5F,oBAAqB,WAAW,aAAa,YAAYA,QAAO,KAAU;AAAA,MAC5E;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAQe,SAAR,aACL,YACc;AACd,QAAM,YAAY,IAAI,gBAAyB,UAAU;AACzD,QAAM,cAAmB,CAAC;AAE1B,cAAY,WAAW,aAAa,YAAY,UAAU;AAE1D,SAAO,UAAU,aAAa;AAChC;",
+  "sourcesContent": ["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\r\n * the type `object` but is NOT null, an array or a File.\r\n *\r\n * @param thing - The thing to check to see whether it is an object\r\n * @returns - True if it is a non-null, non-array, non-File object\r\n */\r\nexport default function isObject(thing: any) {\r\n  if (typeof File !== 'undefined' && thing instanceof File) {\r\n    return false;\r\n  }\r\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\r\n    return false;\r\n  }\r\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\r\n}\r\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\r\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\r\n *\r\n * @param schema - The schema object to check\r\n * @returns - True if additional items is allowed, otherwise false\r\n */\r\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (schema.additionalItems === true) {\r\n    console.warn('additionalItems=true is currently not supported');\r\n  }\r\n  return isObject(schema.additionalItems);\r\n}\r\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\r\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\r\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\r\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\r\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\r\n *\r\n * @param value - The string or null value to convert to a number\r\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\r\n */\r\nexport default function asNumber(value: string | null) {\r\n  if (value === '') {\r\n    return undefined;\r\n  }\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n  if (/\\.$/.test(value)) {\r\n    // '3.' can't really be considered a number even if it parses in js. The\r\n    // user is most likely entering a float.\r\n    return value;\r\n  }\r\n  if (/\\.0$/.test(value)) {\r\n    // we need to return this as a string here, to allow for input like 3.07\r\n    return value;\r\n  }\r\n\r\n  if (/\\.\\d*0$/.test(value)) {\r\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\r\n    // with the user when entering dollar amounts or other values (such as those with\r\n    // specific precision or number of significant digits)\r\n    return value;\r\n  }\r\n\r\n  const n = Number(value);\r\n  const valid = typeof n === 'number' && !Number.isNaN(n);\r\n\r\n  return valid ? n : value;\r\n}\r\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\r\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\r\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\r\n * utility.\r\n */\r\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\r\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\r\nexport const ALL_OF_KEY = 'allOf';\r\nexport const ANY_OF_KEY = 'anyOf';\r\nexport const CONST_KEY = 'const';\r\nexport const DEFAULT_KEY = 'default';\r\nexport const DEFINITIONS_KEY = 'definitions';\r\nexport const DEPENDENCIES_KEY = 'dependencies';\r\nexport const ENUM_KEY = 'enum';\r\nexport const ERRORS_KEY = '__errors';\r\nexport const ID_KEY = '$id';\r\nexport const IF_KEY = 'if';\r\nexport const ITEMS_KEY = 'items';\r\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\r\nexport const NAME_KEY = '$name';\r\nexport const ONE_OF_KEY = 'oneOf';\r\nexport const PROPERTIES_KEY = 'properties';\r\nexport const REQUIRED_KEY = 'required';\r\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\r\nexport const REF_KEY = '$ref';\r\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\r\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\r\nexport const UI_FIELD_KEY = 'ui:field';\r\nexport const UI_WIDGET_KEY = 'ui:widget';\r\nexport const UI_OPTIONS_KEY = 'ui:options';\r\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\r\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\r\nimport isObject from './isObject';\r\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\r\n\r\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\r\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\r\n *\r\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\r\n */\r\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  globalOptions: GlobalUISchemaOptions = {}\r\n): UIOptionsType<T, S, F> {\r\n  return Object.keys(uiSchema)\r\n    .filter((key) => key.indexOf('ui:') === 0)\r\n    .reduce(\r\n      (options, key) => {\r\n        const value = uiSchema[key];\r\n        if (key === UI_WIDGET_KEY && isObject(value)) {\r\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\r\n          return options;\r\n        }\r\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\r\n          return { ...options, ...value };\r\n        }\r\n        return { ...options, [key.substring(3)]: value };\r\n      },\r\n      { ...globalOptions }\r\n    );\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\nimport getUiOptions from './getUiOptions';\r\n\r\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\r\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\r\n * `formData` object doesn't already have `schema.maxProperties` elements.\r\n *\r\n * @param schema - The schema for the field that is being checked\r\n * @param [uiSchema={}] - The uiSchema for the field\r\n * @param [formData] - The formData for the field\r\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\r\n */\r\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  formData?: T\r\n) {\r\n  if (!schema.additionalProperties) {\r\n    return false;\r\n  }\r\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\r\n  if (expandable === false) {\r\n    return expandable;\r\n  }\r\n  // if ui:options.expandable was not explicitly set to false, we can add\r\n  // another property if we have not exceeded maxProperties yet\r\n  if (schema.maxProperties !== undefined && formData) {\r\n    return Object.keys(formData).length < schema.maxProperties;\r\n  }\r\n  return true;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\r\n *\r\n * @param formData - The form data around which the error handler is created\r\n * @returns - A `FormValidation` object based on the `formData` structure\r\n */\r\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\r\n  const handler: FieldValidation = {\r\n    // We store the list of errors for this node in a property named __errors\r\n    // to avoid name collision with a possible sub schema field named\r\n    // 'errors' (see `utils.toErrorSchema`).\r\n    [ERRORS_KEY]: [],\r\n    addError(message: string) {\r\n      this[ERRORS_KEY]!.push(message);\r\n    },\r\n  };\r\n  if (Array.isArray(formData)) {\r\n    return formData.reduce((acc, value, key) => {\r\n      return { ...acc, [key]: createErrorHandler(value) };\r\n    }, handler);\r\n  }\r\n  if (isPlainObject(formData)) {\r\n    const formObject: GenericObjectType = formData as GenericObjectType;\r\n    return Object.keys(formObject).reduce((acc, key) => {\r\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\r\n    }, handler as FormValidation<T>);\r\n  }\r\n  return handler as FormValidation<T>;\r\n}\r\n", "import isEqualWith from 'lodash/isEqualWith';\r\n\r\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\r\n * assumes all functions are equivalent.\r\n *\r\n * @param a - The first element to compare\r\n * @param b - The second element to compare\r\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\r\n */\r\nexport default function deepEquals(a: any, b: any): boolean {\r\n  return isEqualWith(a, b, (obj: any, other: any) => {\r\n    if (typeof obj === 'function' && typeof other === 'function') {\r\n      // Assume all functions are equivalent\r\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\r\n      return true;\r\n    }\r\n    return undefined; // fallback to default isEquals behavior\r\n  });\r\n}\r\n", "import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  ALL_OF_KEY,\n} from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_ArrayMinItems,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\ndeclare module 'json-schema' {\n  export interface JSONSchema7 {\n    overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;\n  }\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      // This is a custom addition that fixes this issue:\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\n      const retrievedSchema =\n        ALL_OF_KEY in schema ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData) : schema;\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          maybeAddDefaultToObject<T>(\n            acc,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            retrievedSchema.required,\n            experimental_defaultFormStateBehavior\n          );\n          return acc;\n        },\n        {}\n      ) as T;\n      if (retrievedSchema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\n          ? retrievedSchema.additionalProperties\n          : {};\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      // On a case by case basis, we may want to override the default behavior of populating array items.\n      const arrayMinItems =\n        schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\n      const neverPopulate = arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = arrayMinItems?.populate === 'requiredOnly';\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? [];\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  // On a case by case basis, we may want to override the default behavior of populating array items.\n  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\n\n  const { mergeExtraDefaults } = arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n", "import jsonpointer from 'jsonpointer';\r\nimport omit from 'lodash/omit';\r\n\r\nimport { REF_KEY } from './constants';\r\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\r\n * location, the `object` minus the `key: value` and in the second location the `value`.\r\n *\r\n * @param key - The key from the object to extract\r\n * @param object - The object from which to extract the element\r\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\r\n *      value from `object[key]`\r\n */\r\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\r\n  const value = object[key];\r\n  const remaining = omit(object, [key]);\r\n  return [remaining, value];\r\n}\r\n\r\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\r\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\r\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\r\n *\r\n * @param $ref - The ref string for which the schema definition is desired\r\n * @param [rootSchema={}] - The root schema in which to search for the definition\r\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\r\n * @throws - Error indicating that no schema for that reference exists\r\n */\r\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\r\n  $ref?: string,\r\n  rootSchema: S = {} as S\r\n): S {\r\n  let ref = $ref || '';\r\n  if (ref.startsWith('#')) {\r\n    // Decode URI fragment representation.\r\n    ref = decodeURIComponent(ref.substring(1));\r\n  } else {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  const current: S = jsonpointer.get(rootSchema, ref);\r\n  if (current === undefined) {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  if (current[REF_KEY]) {\r\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\r\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\r\n    if (Object.keys(remaining).length > 0) {\r\n      return { ...remaining, ...subSchema };\r\n    }\r\n    return subSchema;\r\n  }\r\n  return current;\r\n}\r\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n", "import get from 'lodash/get';\nimport { PROPERTIES_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\n *\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or undefined if there is no match\n */\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  formData: T | undefined,\n  options: S[],\n  discriminatorField?: string\n): number | undefined {\n  if (formData && discriminatorField) {\n    const value = get(formData, discriminatorField);\n\n    if (value === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < options.length; i++) {\n      const option = options[i];\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\n        continue;\n      }\n\n      if (discriminator.const === value) {\n        return i;\n      }\n\n      if (discriminator.enum?.includes(value)) {\n        return i;\n      }\n    }\n  }\n\n  return;\n}\n", "import getMatchingOption from './getMatchingOption';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n * Always returns the first option if there is nothing that matches.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the first matched option or 0 if none is available\r\n */\r\nexport default function getFirstMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\r\n}\r\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        result[key] = resolveAllReferences(value as S, rootSchema, recurseList);\n      },\n      {} as RJSFSchema\n    );\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n", "import get from 'lodash/get';\r\nimport isString from 'lodash/isString';\r\n\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\r\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\r\n *\r\n * @param schema - The schema from which the discriminator is potentially obtained\r\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\r\n */\r\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  let discriminator: string | undefined;\r\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\r\n  if (isString(maybeString)) {\r\n    discriminator = maybeString;\r\n  } else if (maybeString !== undefined) {\r\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\r\n  }\r\n  return discriminator;\r\n}\r\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\r\n *  create a schema, it is useful to know what type to use based on the data we are defining.\r\n *\r\n * @param value - The value from which to guess the type\r\n * @returns - The best guess for the object type\r\n */\r\nexport default function guessType(value: any) {\r\n  if (Array.isArray(value)) {\r\n    return 'array';\r\n  }\r\n  if (typeof value === 'string') {\r\n    return 'string';\r\n  }\r\n  if (value == null) {\r\n    return 'null';\r\n  }\r\n  if (typeof value === 'boolean') {\r\n    return 'boolean';\r\n  }\r\n  if (!isNaN(value)) {\r\n    return 'number';\r\n  }\r\n  if (typeof value === 'object') {\r\n    return 'object';\r\n  }\r\n  // Default to string if we can't figure it out\r\n  return 'string';\r\n}\r\n", "import union from 'lodash/union';\r\n\r\nimport { REQUIRED_KEY } from './constants';\r\nimport getSchemaType from './getSchemaType';\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\r\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\r\n * duplicate values.\r\n *\r\n * @param obj1 - The first schema object to merge\r\n * @param obj2 - The second schema object to merge\r\n * @returns - The merged schema object\r\n */\r\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\r\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeSchemas(left, right);\r\n    } else if (\r\n      obj1 &&\r\n      obj2 &&\r\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\r\n      key === REQUIRED_KEY &&\r\n      Array.isArray(left) &&\r\n      Array.isArray(right)\r\n    ) {\r\n      // Don't include duplicate values when merging 'required' fields.\r\n      acc[key] = union(left, right);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, acc);\r\n}\r\n", "import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type)) {\n    if (type.length === 2 && type.includes('null')) {\n      type = type.find((type) => type !== 'null');\n    } else {\n      type = type[0];\n    }\n  }\n\n  return type;\n}\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\r\n * that only contains objects.\r\n *\r\n * @param schema - The schema in which to check for fixed items\r\n * @returns - True if there are fixed items in the schema, false otherwise\r\n */\r\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\r\n}\r\n", "import get from 'lodash/get';\r\n\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from '../src';\r\n\r\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\r\n *\r\n * When merging defaults and form data, we want to merge in this specific way:\r\n * - objects are deeply merged\r\n * - arrays are merged in such a way that:\r\n *   - when the array is set in form data, only array entries set in form data\r\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\r\n *     which case the extras are appended onto the end of the form data\r\n *   - when the array is not set in form data, the default is copied over\r\n * - scalars are overwritten/set by form data\r\n *\r\n * @param [defaults] - The defaults to merge\r\n * @param [formData] - The form data into which the defaults will be merged\r\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\r\n * @returns - The resulting merged form data with defaults\r\n */\r\nexport default function mergeDefaultsWithFormData<T = any>(\r\n  defaults?: T,\r\n  formData?: T,\r\n  mergeExtraArrayDefaults = false\r\n): T | undefined {\r\n  if (Array.isArray(formData)) {\r\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\r\n    const mapped = formData.map((value, idx) => {\r\n      if (defaultsArray[idx]) {\r\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\r\n      }\r\n      return value;\r\n    });\r\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\r\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\r\n      mapped.push(...defaultsArray.slice(mapped.length));\r\n    }\r\n    return mapped as unknown as T;\r\n  }\r\n  if (isObject(formData)) {\r\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\r\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\r\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\r\n        defaults ? get(defaults, key) : {},\r\n        get(formData, key),\r\n        mergeExtraArrayDefaults\r\n      );\r\n      return acc;\r\n    }, acc);\r\n  }\r\n  return formData;\r\n}\r\n", "import isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested objects.\r\n *\r\n * @param obj1 - The first object to merge\r\n * @param obj2 - The second object to merge\r\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\r\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\r\n *          NOTE: Uses shallow comparison for the duplicate checking.\r\n * @returns - A new object that is the merge of the two given objects\r\n */\r\nexport default function mergeObjects(\r\n  obj1: GenericObjectType,\r\n  obj2: GenericObjectType,\r\n  concatArrays: boolean | 'preventDuplicates' = false\r\n) {\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeObjects(left, right, concatArrays);\r\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\r\n      let toMerge = right;\r\n      if (concatArrays === 'preventDuplicates') {\r\n        toMerge = right.reduce((result, value) => {\r\n          if (!left.includes(value)) {\r\n            result.push(value);\r\n          }\r\n          return result;\r\n        }, []);\r\n      }\r\n      acc[key] = left.concat(toMerge);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\r\n}\r\n", "import { CONST_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\r\n * an `enum` array with a single value or there is a `const` defined.\r\n *\r\n * @param schema - The schema for a field\r\n * @returns - True if the `schema` has a single constant value, false otherwise\r\n */\r\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\r\n}\r\n", "import isConstant from '../isConstant';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` combination represents a select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which check for a select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a select, otherwise false\r\n */\r\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  rootSchema: S = {} as S\r\n) {\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  if (Array.isArray(schema.enum)) {\r\n    return true;\r\n  }\r\n  if (Array.isArray(altSchemas)) {\r\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\r\n  }\r\n  return false;\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\nimport isSelect from './isSelect';\r\n\r\n/** Checks to see if the `schema` combination represents a multi-select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for a multi-select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a multi-select, otherwise false\r\n */\r\nexport default function isMultiSelect<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\r\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\r\n    return false;\r\n  }\r\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\r\n}\r\n", "import getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\n\r\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\r\n *\r\n * @param uiSchema - The UI Schema from which to detect if it is customized\r\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\r\n */\r\nexport default function isCustomWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}) {\r\n  return (\r\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\r\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\r\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\r\n  );\r\n}\r\n", "import { UI_WIDGET_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for array of files flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to check the widget\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n */\r\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S\r\n) {\r\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\r\n    return true;\r\n  }\r\n  if (schema.items) {\r\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\r\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\r\n  }\r\n  return false;\r\n}\r\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\r\nimport getSchemaType from '../getSchemaType';\r\nimport getUiOptions from '../getUiOptions';\r\nimport isCustomWidget from '../isCustomWidget';\r\nimport {\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isFilesArray from './isFilesArray';\r\nimport isMultiSelect from './isMultiSelect';\r\n\r\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n * should be displayed in a UI.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the display label flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - True if the label should be displayed or false if it should not\r\n */\r\nexport default function getDisplayLabel<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S,\r\n  globalOptions?: GlobalUISchemaOptions\r\n): boolean {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\r\n  const { label = true } = uiOptions;\r\n  let displayLabel = !!label;\r\n  const schemaType = getSchemaType<S>(schema);\r\n\r\n  if (schemaType === 'array') {\r\n    displayLabel =\r\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\r\n      isCustomWidget(uiSchema);\r\n  }\r\n\r\n  if (schemaType === 'object') {\r\n    displayLabel = false;\r\n  }\r\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  if (uiSchema[UI_FIELD_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  return displayLabel;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from '../mergeObjects';\r\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n *        removed in the next major release.\r\n */\r\nexport default function mergeValidationData<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = validator.toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\n\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\nconst NO_VALUE = Symbol('no Value');\r\n\r\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\r\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\r\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\r\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\r\n *\r\n * - If the new schema is an object that contains a `properties` object then:\r\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\r\n *   - Create an empty `nestedData` object for use in the key filtering below:\r\n *   - Iterate over each key in the `newSchema.properties` as follows:\r\n *     - Get the `formValue` of the key from the `data`\r\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\r\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\r\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\r\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\r\n *       - If type of the key in the new schema is `object`:\r\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\r\n *       - Otherwise, check for default or const values:\r\n *         - Get the old and new `default` values from the schema and check:\r\n *           - If the new `default` value does not match the form value:\r\n *             - If the old `default` value DOES match the form value, then:\r\n *               - Replace `removeOldSchemaData[key]` with the new `default`\r\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\r\n *         - Get the old and new `const` values from the schema and check:\r\n *           - If the new `const` value does not match the form value:\r\n *           - If the old `const` value DOES match the form value, then:\r\n *             - Replace `removeOldSchemaData[key]` with the new `const`\r\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\r\n *   - Once all keys have been processed, return an object built as follows:\r\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\r\n * - If the new and old schema types are array and the `data` is an array then:\r\n *   - If the type of the old and new schema `items` are a non-array objects:\r\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\r\n *     - If the `type`s of both items are the same (or the old does not have a type):\r\n *       - If the type is \"object\", then:\r\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\r\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\r\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\r\n * - Otherwise return `undefined`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param [newSchema] - The new schema for which the data is being sanitized\r\n * @param [oldSchema] - The old schema from which the data originated\r\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n */\r\nexport default function sanitizeDataForNewSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\r\n  // By default, we will clear the form data\r\n  let newFormData;\r\n  // If the new schema is of type object and that object contains a list of properties\r\n  if (has(newSchema, PROPERTIES_KEY)) {\r\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\r\n    const removeOldSchemaData: GenericObjectType = {};\r\n    if (has(oldSchema, PROPERTIES_KEY)) {\r\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\r\n      Object.keys(properties).forEach((key) => {\r\n        if (has(data, key)) {\r\n          removeOldSchemaData[key] = undefined;\r\n        }\r\n      });\r\n    }\r\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\r\n    // Create a place to store nested data that will be a side-effect of the filter\r\n    const nestedData: GenericObjectType = {};\r\n    keys.forEach((key) => {\r\n      const formValue = get(data, key);\r\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\r\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\r\n      // Resolve the refs if they exist\r\n      if (has(oldKeyedSchema, REF_KEY)) {\r\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\r\n      }\r\n      if (has(newKeyedSchema, REF_KEY)) {\r\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\r\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\r\n        if (has(removeOldSchemaData, key)) {\r\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\r\n          delete removeOldSchemaData[key];\r\n        }\r\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\r\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\r\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\r\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\r\n            validator,\r\n            rootSchema,\r\n            newKeyedSchema,\r\n            oldKeyedSchema,\r\n            formValue\r\n          );\r\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\r\n            // only put undefined values for the array type and not the object type\r\n            nestedData[key] = itemData;\r\n          }\r\n        } else {\r\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\r\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\r\n          // value to be properly selected\r\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\r\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\r\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\r\n            if (oldOptionDefault === formValue) {\r\n              // If the old default matches the formValue, we'll update the new value to match the new default\r\n              removeOldSchemaData[key] = newOptionDefault;\r\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\r\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\r\n              removeOldSchemaData[key] = undefined;\r\n            }\r\n          }\r\n\r\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\r\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\r\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\r\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\r\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    newFormData = {\r\n      ...data,\r\n      ...removeOldSchemaData,\r\n      ...nestedData,\r\n    };\r\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\r\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\r\n    let oldSchemaItems = get(oldSchema, 'items');\r\n    let newSchemaItems = get(newSchema, 'items');\r\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\r\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\r\n    if (\r\n      typeof oldSchemaItems === 'object' &&\r\n      typeof newSchemaItems === 'object' &&\r\n      !Array.isArray(oldSchemaItems) &&\r\n      !Array.isArray(newSchemaItems)\r\n    ) {\r\n      if (has(oldSchemaItems, REF_KEY)) {\r\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      if (has(newSchemaItems, REF_KEY)) {\r\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaType = get(oldSchemaItems, 'type');\r\n      const newSchemaType = get(newSchemaItems, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\r\n        const maxItems = get(newSchema, 'maxItems', -1);\r\n        if (newSchemaType === 'object') {\r\n          newFormData = data.reduce((newValue, aValue) => {\r\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\r\n              validator,\r\n              rootSchema,\r\n              newSchemaItems as S,\r\n              oldSchemaItems as S,\r\n              aValue\r\n            );\r\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\r\n              newValue.push(itemValue);\r\n            }\r\n            return newValue;\r\n          }, []);\r\n        } else {\r\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\r\n        }\r\n      }\r\n    } else if (\r\n      typeof oldSchemaItems === 'boolean' &&\r\n      typeof newSchemaItems === 'boolean' &&\r\n      oldSchemaItems === newSchemaItems\r\n    ) {\r\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\r\n      newFormData = data;\r\n    }\r\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\r\n  }\r\n  return newFormData as T;\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport isObject from '../isObject';\r\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\nimport getSchemaType from '../getSchemaType';\r\n\r\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param idPrefix - The prefix to use for the id\r\n * @param idSeparator - The separator to use for the path segments in the id\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  idPrefix: string,\r\n  idSeparator: string,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): IdSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        idPrefix,\r\n        idSeparator,\r\n        id,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\r\n    return toIdSchemaInternal<T, S, F>(\r\n      validator,\r\n      get(schema, ITEMS_KEY) as S,\r\n      idPrefix,\r\n      idSeparator,\r\n      id,\r\n      rootSchema,\r\n      formData,\r\n      _recurseList\r\n    );\r\n  }\r\n  const $id = id || idPrefix;\r\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\r\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\r\n    for (const name in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, name]);\r\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\r\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        isObject(field) ? field : {},\r\n        idPrefix,\r\n        idSeparator,\r\n        fieldId,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [name]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return idSchema as IdSchema<T>;\r\n}\r\n\r\n/** Generates an `IdSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [idPrefix='root'] - The prefix to use for the id\r\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  idPrefix = 'root',\r\n  idSeparator = '_'\r\n): IdSchema<T> {\r\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\nimport set from 'lodash/set';\r\n\r\nimport {\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  DEPENDENCIES_KEY,\r\n  ITEMS_KEY,\r\n  NAME_KEY,\r\n  ONE_OF_KEY,\r\n  PROPERTIES_KEY,\r\n  REF_KEY,\r\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\r\n} from '../constants';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name: string,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): PathSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        name,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n\r\n  let pathSchema: PathSchema = {\r\n    [NAME_KEY]: name.replace(/^\\./, ''),\r\n  } as PathSchema;\r\n\r\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\r\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\r\n    const _schema: S = xxxOf![index] as S;\r\n    pathSchema = {\r\n      ...pathSchema,\r\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\r\n    };\r\n  }\r\n\r\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\r\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\r\n  }\r\n\r\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\r\n    formData.forEach((element, i: number) => {\r\n      pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        schema.items as S,\r\n        `${name}.${i}`,\r\n        rootSchema,\r\n        element,\r\n        _recurseList\r\n      );\r\n    });\r\n  } else if (PROPERTIES_KEY in schema) {\r\n    for (const property in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, property]);\r\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        field,\r\n        `${name}.${property}`,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [property]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return pathSchema as PathSchema<T>;\r\n}\r\n\r\n/** Generates an `PathSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name = '',\r\n  rootSchema?: S,\r\n  formData?: T\r\n): PathSchema<T> {\r\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\r\n}\r\n", "import deepEquals from './deepEquals';\r\nimport {\r\n  ErrorSchema,\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  IdSchema,\r\n  PathSchema,\r\n  RJSFSchema,\r\n  SchemaUtilsType,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from './types';\r\nimport {\r\n  getDefaultFormState,\r\n  getDisplayLabel,\r\n  getClosestMatchingOption,\r\n  getFirstMatchingOption,\r\n  getMatchingOption,\r\n  isFilesArray,\r\n  isMultiSelect,\r\n  isSelect,\r\n  mergeValidationData,\r\n  retrieveSchema,\r\n  sanitizeDataForNewSchema,\r\n  toIdSchema,\r\n  toPathSchema,\r\n} from './schema';\r\n\r\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\r\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\r\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\r\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\r\n */\r\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements SchemaUtilsType<T, S, F>\r\n{\r\n  rootSchema: S;\r\n  validator: ValidatorType<T, S, F>;\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\r\n\r\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\r\n   */\r\n  constructor(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\r\n  ) {\r\n    this.rootSchema = rootSchema;\r\n    this.validator = validator;\r\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\r\n  }\r\n\r\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\r\n   *\r\n   * @returns - The `ValidatorType`\r\n   */\r\n  getValidator() {\r\n    return this.validator;\r\n  }\r\n\r\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\r\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\r\n   * of a new `SchemaUtilsType` with incomplete properties.\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\r\n   * @param rootSchema - The root schema that will be compared against the current one\r\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\r\n   */\r\n  doesSchemaUtilsDiffer(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior = {}\r\n  ): boolean {\r\n    if (!validator || !rootSchema) {\r\n      return false;\r\n    }\r\n    return (\r\n      this.validator !== validator ||\r\n      !deepEquals(this.rootSchema, rootSchema) ||\r\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\r\n    );\r\n  }\r\n\r\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n   * computed to have defaults provided in the `schema`.\r\n   *\r\n   * @param schema - The schema for which the default state is desired\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\r\n   *          object properties.\r\n   * @returns - The resulting `formData` with all the defaults provided\r\n   */\r\n  getDefaultFormState(\r\n    schema: S,\r\n    formData?: T,\r\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\r\n  ): T | T[] | undefined {\r\n    return getDefaultFormState<T, S, F>(\r\n      this.validator,\r\n      schema,\r\n      formData,\r\n      this.rootSchema,\r\n      includeUndefinedValues,\r\n      this.experimental_defaultFormStateBehavior\r\n    );\r\n  }\r\n\r\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n   * should be displayed in a UI.\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\r\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n   * @returns - True if the label should be displayed or false if it should not\r\n   */\r\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\r\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\r\n  }\r\n\r\n  /** Determines which of the given `options` provided most closely matches the `formData`.\r\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\r\n   *\r\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\r\n   * matching readOnly, default, or const values.\r\n   *\r\n   * @param formData - The form data associated with the schema\r\n   * @param options - The list of options that can be selected from\r\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n   */\r\n  getClosestMatchingOption(\r\n    formData: T | undefined,\r\n    options: S[],\r\n    selectedOption?: number,\r\n    discriminatorField?: string\r\n  ): number {\r\n    return getClosestMatchingOption<T, S, F>(\r\n      this.validator,\r\n      this.rootSchema,\r\n      formData,\r\n      options,\r\n      selectedOption,\r\n      discriminatorField\r\n    );\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n   * Always returns the first option if there is nothing that matches.\r\n   *\r\n   * @param formData - The current formData, if any, used to figure out a match\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The firstindex of the matched option or 0 if none is available\r\n   */\r\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\r\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n   * Deprecated, use `getFirstMatchingOption()` instead.\r\n   *\r\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the matched option or 0 if none is available\r\n   * @deprecated\r\n   */\r\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\r\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n   *\r\n   * @param schema - The schema for which check for array of files flag is desired\r\n   * @param [uiSchema] - The UI schema from which to check the widget\r\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n   */\r\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\r\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a multi-select\r\n   *\r\n   * @param schema - The schema for which check for a multi-select flag is desired\r\n   * @returns - True if schema contains a multi-select, otherwise false\r\n   */\r\n  isMultiSelect(schema: S) {\r\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a select\r\n   *\r\n   * @param schema - The schema for which check for a select flag is desired\r\n   * @returns - True if schema contains a select, otherwise false\r\n   */\r\n  isSelect(schema: S) {\r\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\r\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\r\n   * then `validationData` is returned.\r\n   *\r\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n   * @param [additionalErrorSchema] - The additional set of errors\r\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n   *        removed in the next major release.\r\n   */\r\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\r\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\r\n  }\r\n\r\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\r\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\r\n   * recursive resolution.\r\n   *\r\n   * @param schema - The schema for which retrieving a schema is desired\r\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n   */\r\n  retrieveSchema(schema: S, rawFormData?: T) {\r\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\r\n  }\r\n\r\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\r\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\r\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\r\n   * old schemas that are non-existent in the new schema are set to `undefined`.\r\n   *\r\n   * @param [newSchema] - The new schema for which the data is being sanitized\r\n   * @param [oldSchema] - The old schema from which the data originated\r\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n   */\r\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\r\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\r\n  }\r\n\r\n  /** Generates an `IdSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [id] - The base id for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [idPrefix='root'] - The prefix to use for the id\r\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n   * @returns - The `IdSchema` object for the `schema`\r\n   */\r\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\r\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\r\n  }\r\n\r\n  /** Generates an `PathSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [name] - The base name for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @returns - The `PathSchema` object for the `schema`\r\n   */\r\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\r\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\r\n  }\r\n}\r\n\r\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\r\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - An implementation of a `SchemaUtilsType` interface\r\n */\r\nexport default function createSchemaUtils<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  experimental_defaultFormStateBehavior = {}\r\n): SchemaUtilsType<T, S, F> {\r\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\r\n}\r\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\r\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\r\n *\r\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\r\n * @returns - an object containing a Blob and its name, extracted from the URI\r\n */\r\nexport default function dataURItoBlob(dataURI: string) {\r\n  // Split metadata from data\r\n  const splitted: string[] = dataURI.split(',');\r\n  // Split params\r\n  const params: string[] = splitted[0].split(';');\r\n  // Get mime-type from params\r\n  const type: string = params[0].replace('data:', '');\r\n  // Filter the name property from params\r\n  const properties = params.filter((param) => {\r\n    return param.split('=')[0] === 'name';\r\n  });\r\n  // Look for the name and use unknown if no name property.\r\n  let name: string;\r\n  if (properties.length !== 1) {\r\n    name = 'unknown';\r\n  } else {\r\n    // Because we filtered out the other property,\r\n    // we only have the name case here, which we decode to make it human-readable\r\n    name = decodeURI(properties[0].split('=')[1]);\r\n  }\r\n\r\n  // Built the Uint8Array Blob parameter from the base64 string.\r\n  try {\r\n    const binary = atob(splitted[1]);\r\n    const array = [];\r\n    for (let i = 0; i < binary.length; i++) {\r\n      array.push(binary.charCodeAt(i));\r\n    }\r\n    // Create the blob object\r\n    const blob = new window.Blob([new Uint8Array(array)], { type });\r\n\r\n    return { blob, name };\r\n  } catch (error) {\r\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\r\n  }\r\n}\r\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\r\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\r\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\r\n *\r\n * @param inputString - The string which will be potentially updated with replacement parameters\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The updated string with any replacement specifiers replaced\r\n */\r\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\r\n  let output = inputString;\r\n  if (Array.isArray(params)) {\r\n    const parts = output.split(/(%\\d)/);\r\n    params.forEach((param, index) => {\r\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\r\n      if (partIndex >= 0) {\r\n        parts[partIndex] = param;\r\n      }\r\n    });\r\n    output = parts.join('');\r\n  }\r\n  return output;\r\n}\r\n", "import { TranslatableString } from './enums';\r\nimport replaceStringParameters from './replaceStringParameters';\r\n\r\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\r\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\r\n * `%2`, etc. replacement specifiers.\r\n *\r\n * @param stringToTranslate - The `TranslatableString` value to convert to english\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\r\n */\r\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\r\n  return replaceStringParameters(stringToTranslate, params);\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\n\r\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\r\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\r\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\r\n * is returned, otherwise the `selected` value is returned.\r\n *\r\n * @param valueIndex - The index of the value to be removed from the selected list or single value\r\n * @param selected - The current (list of) selected value(s)\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\r\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\r\n *        undefined, otherwise `selected`.\r\n */\r\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (Array.isArray(selected)) {\r\n    return selected.filter((v) => !isEqual(v, value));\r\n  }\r\n  return isEqual(value, selected) ? undefined : selected;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\r\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\r\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\r\n * valid values or in the worst case, an empty array.\r\n *\r\n * @param valueIndex - The index(es) of the value(s) that should be returned\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\r\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\r\n *        `emptyValue` or an empty list.\r\n */\r\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number | Array<string | number>,\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  emptyValue?: EnumOptionsType<S>['value']\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  if (Array.isArray(valueIndex)) {\r\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\r\n  }\r\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\r\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\r\n  const option = allEnumOptions[index];\r\n  return option ? option.value : emptyValue;\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Determines whether the given `value` is (one of) the `selected` value(s).\r\n *\r\n * @param value - The value being checked to see if it is selected\r\n * @param selected - The current selected value or list of values\r\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\r\n */\r\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'],\r\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\r\n) {\r\n  if (Array.isArray(selected)) {\r\n    return selected.some((sel) => isEqual(sel, value));\r\n  }\r\n  return isEqual(selected, value);\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\r\n\r\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\r\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\r\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\r\n * returned.\r\n *\r\n * @param value - The single value or list of values for which indexes are desired\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\r\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\r\n *        of indexes for (each of) the value(s) in `value`.\r\n */\r\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  multiple = false\r\n): string | string[] | undefined {\r\n  const selectedIndexes: string[] = allEnumOptions\r\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\r\n    .filter((opt) => typeof opt !== 'undefined') as string[];\r\n  if (!multiple) {\r\n    return selectedIndexes[0];\r\n  }\r\n  return selectedIndexes;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\nimport { isNil } from 'lodash';\r\n\r\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\r\n * `allEnumOptions`\r\n *\r\n * @param valueIndex - The index of the value that should be selected\r\n * @param selected - The current list of selected values\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\r\n */\r\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected: EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n) {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (!isNil(value)) {\r\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\r\n    const all = allEnumOptions.map(({ value: val }) => val);\r\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\r\n    // As inserting values at predefined index positions doesn't work with empty\r\n    // arrays, we need to reorder the updated selection to match the initial order\r\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\r\n  }\r\n  return selected;\r\n}\r\n", "import cloneDeep from 'lodash/cloneDeep';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { ErrorSchema } from './types';\r\nimport { ERRORS_KEY } from './constants';\r\n\r\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\r\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\r\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\r\n * get the result and/or reset all the errors back to an initial set and start again.\r\n */\r\nexport default class ErrorSchemaBuilder<T = any> {\r\n  /** The error schema being built\r\n   *\r\n   * @private\r\n   */\r\n  private errorSchema: ErrorSchema<T> = {};\r\n\r\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   */\r\n  constructor(initialSchema?: ErrorSchema<T>) {\r\n    this.resetAllErrors(initialSchema);\r\n  }\r\n\r\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\r\n   */\r\n  get ErrorSchema() {\r\n    return this.errorSchema;\r\n  }\r\n\r\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The error block for the given `pathOfError` or the root if not provided\r\n   * @private\r\n   */\r\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\r\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\r\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\r\n    if (!errorBlock && pathOfError) {\r\n      errorBlock = {};\r\n      set(this.errorSchema, pathOfError, errorBlock);\r\n    }\r\n    return errorBlock;\r\n  }\r\n\r\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\r\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\r\n    return this;\r\n  }\r\n\r\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\r\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    let errorsList = get(errorBlock, ERRORS_KEY);\r\n    if (!Array.isArray(errorsList)) {\r\n      errorsList = [];\r\n      errorBlock[ERRORS_KEY] = errorsList;\r\n    }\r\n\r\n    if (Array.isArray(errorOrList)) {\r\n      errorsList.push(...errorOrList);\r\n    } else {\r\n      errorsList.push(errorOrList);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\r\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\r\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\r\n    set(errorBlock, ERRORS_KEY, listToAdd);\r\n    return this;\r\n  }\r\n\r\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\r\n   * the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  clearErrors(pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    set(errorBlock, ERRORS_KEY, []);\r\n    return this;\r\n  }\r\n}\r\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\r\nimport { RJSFSchema } from './types';\r\n\r\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\r\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\r\n *\r\n * @param schema - The schema from which to extract the range spec\r\n * @returns - A range specification from the schema\r\n */\r\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const spec: RangeSpecType = {};\r\n  if (schema.multipleOf) {\r\n    spec.step = schema.multipleOf;\r\n  }\r\n  if (schema.minimum || schema.minimum === 0) {\r\n    spec.min = schema.minimum;\r\n  }\r\n  if (schema.maximum || schema.maximum === 0) {\r\n    spec.max = schema.maximum;\r\n  }\r\n  return spec;\r\n}\r\n", "import rangeSpec from './rangeSpec';\r\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\r\n\r\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\r\n *\r\n * @param schema - The schema for the field provided by the widget\r\n * @param [defaultType] - The default type, if any, for the field provided by the widget\r\n * @param [options={}] - The UI Options for the field provided by the widget\r\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\r\n * @returns - The extracted `InputPropsType` object\r\n */\r\nexport default function getInputProps<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  schema: RJSFSchema,\r\n  defaultType?: string,\r\n  options: UIOptionsType<T, S, F> = {},\r\n  autoDefaultStepAny = true\r\n): InputPropsType {\r\n  const inputProps: InputPropsType = {\r\n    type: defaultType || 'text',\r\n    ...rangeSpec(schema),\r\n  };\r\n\r\n  // If options.inputType is set use that as the input type\r\n  if (options.inputType) {\r\n    inputProps.type = options.inputType;\r\n  } else if (!defaultType) {\r\n    // If the schema is of type number or integer, set the input type to number\r\n    if (schema.type === 'number') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\r\n      if (autoDefaultStepAny && inputProps.step === undefined) {\r\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\r\n        // allowed in number inputs\r\n        inputProps.step = 'any';\r\n      }\r\n    } else if (schema.type === 'integer') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined\r\n      if (inputProps.step === undefined) {\r\n        // Since this is integer, you always want to step up or down in multiples of 1\r\n        inputProps.step = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (options.autocomplete) {\r\n    inputProps.autoComplete = options.autocomplete;\r\n  }\r\n\r\n  return inputProps;\r\n}\r\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\r\nimport getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\r\n\r\n/** The default submit button options, exported for testing purposes\r\n */\r\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\r\n  props: {\r\n    disabled: false,\r\n  },\r\n  submitText: 'Submit',\r\n  norender: false,\r\n};\r\n\r\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\r\n *\r\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\r\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\r\n */\r\nexport default function getSubmitButtonOptions<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\r\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\r\n    return { ...DEFAULT_OPTIONS, ...options };\r\n  }\r\n\r\n  return DEFAULT_OPTIONS;\r\n}\r\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\r\n\r\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\r\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\r\n *\r\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\r\n * @param registry - The `Registry` from which to read the template\r\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\r\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\r\n */\r\nexport default function getTemplate<\r\n  Name extends keyof TemplatesType<T, S, F>,\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\r\n  const { templates } = registry;\r\n  if (name === 'ButtonTemplates') {\r\n    return templates[name];\r\n  }\r\n  return (\r\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\r\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\r\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\r\n  );\r\n}\r\n", "import { createElement } from 'react';\r\nimport ReactIs from 'react-is';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\r\nimport getSchemaType from './getSchemaType';\r\n\r\n/** The map of schema types to widget type to widget name\r\n */\r\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\r\n  boolean: {\r\n    checkbox: 'CheckboxWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  string: {\r\n    text: 'TextWidget',\r\n    password: 'PasswordWidget',\r\n    email: 'EmailWidget',\r\n    hostname: 'TextWidget',\r\n    ipv4: 'TextWidget',\r\n    ipv6: 'TextWidget',\r\n    uri: 'URLWidget',\r\n    'data-url': 'FileWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    textarea: 'TextareaWidget',\r\n    hidden: 'HiddenWidget',\r\n    date: 'DateWidget',\r\n    datetime: 'DateTimeWidget',\r\n    'date-time': 'DateTimeWidget',\r\n    'alt-date': 'AltDateWidget',\r\n    'alt-datetime': 'AltDateTimeWidget',\r\n    time: 'TimeWidget',\r\n    color: 'ColorWidget',\r\n    file: 'FileWidget',\r\n  },\r\n  number: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  integer: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  array: {\r\n    select: 'SelectWidget',\r\n    checkboxes: 'CheckboxesWidget',\r\n    files: 'FileWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n};\r\n\r\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\r\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\r\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\r\n *\r\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\r\n * @returns - The wrapper widget\r\n */\r\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  AWidget: Widget<T, S, F>\r\n) {\r\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\r\n  // cache return value as property of widget for proper react reconciliation\r\n  if (!MergedWidget) {\r\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\r\n    MergedWidget = ({ options, ...props }) => {\r\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\r\n    };\r\n    set(AWidget, 'MergedWidget', MergedWidget);\r\n  }\r\n  return MergedWidget;\r\n}\r\n\r\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\r\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\r\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\r\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\r\n *\r\n * @param schema - The schema for the field\r\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - The `Widget` component to use\r\n * @throws - An error if there is no `Widget` component that can be returned\r\n */\r\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget?: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n): Widget<T, S, F> {\r\n  const type = getSchemaType(schema);\r\n\r\n  if (\r\n    typeof widget === 'function' ||\r\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\r\n    ReactIs.isMemo(widget)\r\n  ) {\r\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\r\n  }\r\n\r\n  if (typeof widget !== 'string') {\r\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\r\n  }\r\n\r\n  if (widget in registeredWidgets) {\r\n    const registeredWidget = registeredWidgets[widget];\r\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    if (!(type in widgetMap)) {\r\n      throw new Error(`No widget for type '${type}'`);\r\n    }\r\n\r\n    if (widget in widgetMap[type]) {\r\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\r\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n    }\r\n  }\r\n\r\n  throw new Error(`No widget '${widget}' for type '${type}'`);\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** JS has no built-in hashing function, so rolling our own\r\n *  based on Java's hashing fn:\r\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\r\n *\r\n * @param string - The string for which to get the hash\r\n * @returns - The resulting hash of the string in hex format\r\n */\r\nfunction hashString(string: string): string {\r\n  let hash = 0;\r\n  for (let i = 0; i < string.length; i += 1) {\r\n    const chr = string.charCodeAt(i);\r\n    hash = (hash << 5) - hash + chr;\r\n    hash = hash & hash; // Convert to 32bit integer\r\n  }\r\n  return hash.toString(16);\r\n}\r\n\r\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\r\n * in consistent order before stringify to prevent different hash ids for the same schema.\r\n *\r\n * @param schema - The schema for which the hash is desired\r\n * @returns - The string obtained from the hash of the stringified schema\r\n */\r\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const allKeys = new Set<string>();\r\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\r\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\r\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\r\n}\r\n", "import getWidget from './getWidget';\r\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\r\n\r\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\r\n * does, or false if it doesn't.\r\n *\r\n * @param schema - The schema for the field\r\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - True if the widget exists, false otherwise\r\n */\r\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n) {\r\n  try {\r\n    getWidget(schema, widget, registeredWidgets);\r\n    return true;\r\n  } catch (e) {\r\n    const err: Error = e as Error;\r\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\r\n      return false;\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n", "import isString from 'lodash/isString';\r\n\r\nimport { IdSchema } from './types';\r\nimport { ID_KEY } from './constants';\r\n\r\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param suffix - The suffix to append to the id\r\n */\r\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\r\n  const theId = isString(id) ? id : id[ID_KEY];\r\n  return `${theId}__${suffix}`;\r\n}\r\n/** Return a consistent `id` for the field description element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field description element from the given `id`\r\n */\r\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'description');\r\n}\r\n\r\n/** Return a consistent `id` for the field error element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field error element from the given `id`\r\n */\r\nexport function errorId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'error');\r\n}\r\n\r\n/** Return a consistent `id` for the field examples element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field examples element from the given `id`\r\n */\r\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'examples');\r\n}\r\n\r\n/** Return a consistent `id` for the field help element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field help element from the given `id`\r\n */\r\nexport function helpId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'help');\r\n}\r\n\r\n/** Return a consistent `id` for the field title element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field title element from the given `id`\r\n */\r\nexport function titleId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'title');\r\n}\r\n\r\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\r\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\r\n * element.\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\r\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\r\n */\r\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\r\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\r\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\r\n}\r\n\r\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\r\n *\r\n * @param id - The id of the parent component for the option\r\n * @param optionIndex - The index of the option for which the id is desired\r\n * @returns - An id for the option index based on the parent `id`\r\n */\r\nexport function optionId(id: string, optionIndex: number) {\r\n  return `${id}-${optionIndex}`;\r\n}\r\n", "import { ReactElement } from 'react';\r\n\r\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\r\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\r\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\r\n * themes require may `false` and others may require an empty string.\r\n *\r\n * @param [label] - The label string or component to render when not hidden\r\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\r\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\r\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\r\n */\r\nexport function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: ''): undefined | string;\r\nexport default function labelValue(label?: string | ReactElement, hideLabel?: boolean, fallback?: false | '') {\r\n  return hideLabel ? fallback : label;\r\n}\r\n", "/** Converts a local Date string into a UTC date string\r\n *\r\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\r\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\r\n */\r\nexport default function localToUTC(dateString: string) {\r\n  return dateString ? new Date(dateString).toJSON() : undefined;\r\n}\r\n", "import { CONST_KEY, ENUM_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\r\n * throws an error.\r\n *\r\n * @param schema - The schema from which to obtain the constant value\r\n * @returns - The constant value for the schema\r\n * @throws - Error when the schema does not have a constant value\r\n */\r\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\r\n    return schema.enum[0];\r\n  }\r\n  if (CONST_KEY in schema) {\r\n    return schema.const;\r\n  }\r\n  throw new Error('schema cannot be inferred as a constant');\r\n}\r\n", "import toConstant from './toConstant';\r\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\r\n\r\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\r\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\r\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\r\n * `const` values from the schema and the label is either the `schema.title` or the value.\r\n *\r\n * @param schema - The schema from which to extract the options list\r\n * @returns - The list of options from the schema\r\n */\r\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S\r\n): EnumOptionsType<S>[] | undefined {\r\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\r\n  // Cast the type to include enumNames so the feature still works.\r\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\r\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\r\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\r\n  }\r\n  if (schema.enum) {\r\n    return schema.enum.map((value, i) => {\r\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\r\n      return { label, value };\r\n    });\r\n  }\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  return (\r\n    altSchemas &&\r\n    altSchemas.map((aSchemaDef) => {\r\n      const aSchema = aSchemaDef as S;\r\n      const value = toConstant(aSchema);\r\n      const label = aSchema.title || String(value);\r\n      return {\r\n        schema: aSchema,\r\n        label,\r\n        value,\r\n      };\r\n    })\r\n  );\r\n}\r\n", "import { GenericObjectType } from './types';\r\n\r\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\r\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\r\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\r\n * places in the location of the `*`.\r\n *\r\n * @param properties - The list of property keys to be ordered\r\n * @param order - An array of property keys to be ordered first, with an optional '*' property\r\n * @returns - A list with the `properties` ordered\r\n * @throws - Error when the properties cannot be ordered correctly\r\n */\r\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\r\n  if (!Array.isArray(order)) {\r\n    return properties;\r\n  }\r\n\r\n  const arrayToHash = (arr: string[]) =>\r\n    arr.reduce((prev: GenericObjectType, curr) => {\r\n      prev[curr] = true;\r\n      return prev;\r\n    }, {});\r\n  const errorPropList = (arr: string[]) =>\r\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\r\n  const propertyHash = arrayToHash(properties);\r\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\r\n  const orderHash = arrayToHash(orderFiltered);\r\n\r\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\r\n  const restIndex = orderFiltered.indexOf('*');\r\n  if (restIndex === -1) {\r\n    if (rest.length) {\r\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\r\n    }\r\n    return orderFiltered;\r\n  }\r\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\r\n    throw new Error('uiSchema order list contains more than one wildcard item');\r\n  }\r\n\r\n  const complete = [...orderFiltered];\r\n  complete.splice(restIndex, 1, ...rest);\r\n  return complete;\r\n}\r\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\r\n *\r\n * @param num - The number to pad\r\n * @param width - The width of the string at which no lead padding is necessary\r\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\r\n */\r\nexport default function pad(num: number, width: number) {\r\n  let s = String(num);\r\n  while (s.length < width) {\r\n    s = '0' + s;\r\n  }\r\n  return s;\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\r\n *\r\n * @param dateString - The date string to parse into a DateObject\r\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\r\n * @returns - The date string converted to a `DateObject`\r\n * @throws - Error when the date cannot be parsed from the string\r\n */\r\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\r\n  if (!dateString) {\r\n    return {\r\n      year: -1,\r\n      month: -1,\r\n      day: -1,\r\n      hour: includeTime ? -1 : 0,\r\n      minute: includeTime ? -1 : 0,\r\n      second: includeTime ? -1 : 0,\r\n    };\r\n  }\r\n  const date = new Date(dateString);\r\n  if (Number.isNaN(date.getTime())) {\r\n    throw new Error('Unable to parse date ' + dateString);\r\n  }\r\n  return {\r\n    year: date.getUTCFullYear(),\r\n    month: date.getUTCMonth() + 1, // oh you, javascript.\r\n    day: date.getUTCDate(),\r\n    hour: includeTime ? date.getUTCHours() : 0,\r\n    minute: includeTime ? date.getUTCMinutes() : 0,\r\n    second: includeTime ? date.getUTCSeconds() : 0,\r\n  };\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\r\n * - `schema.const` is truthy\r\n * - `schema.enum` == `[true]`\r\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\r\n * - `schema.allOf` has at least one value which recursively returns true\r\n *\r\n * @param schema - The schema to check\r\n * @returns - True if the schema specifies a value that must be true, false otherwise\r\n */\r\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\r\n  // Check if const is a truthy value\r\n  if (schema.const) {\r\n    return true;\r\n  }\r\n\r\n  // Check if an enum has a single value of true\r\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\r\n    return true;\r\n  }\r\n\r\n  // If anyOf has a single value, evaluate the subschema\r\n  if (schema.anyOf && schema.anyOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\r\n  }\r\n\r\n  // If oneOf has a single value, evaluate the subschema\r\n  if (schema.oneOf && schema.oneOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\r\n  }\r\n\r\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\r\n  if (schema.allOf) {\r\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\r\n    return schema.allOf.some(schemaSome);\r\n  }\r\n\r\n  return false;\r\n}\r\n", "import React from 'react';\r\n\r\nimport deepEquals from './deepEquals';\r\n\r\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\r\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\r\n *\r\n * @param component - A React component being checked\r\n * @param nextProps - The next set of props against which to check\r\n * @param nextState - The next set of state against which to check\r\n * @returns - True if the component should be re-rendered, false otherwise\r\n */\r\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\r\n  const { props, state } = component;\r\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\r\n * removed.\r\n *\r\n * @param dateObject - The `DateObject` to convert to a date string\r\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\r\n * @returns - The UTC date string\r\n */\r\nexport default function toDateString(dateObject: DateObject, time = true) {\r\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\r\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\r\n  const datetime = new Date(utcTime).toJSON();\r\n  return time ? datetime : datetime.slice(0, 10);\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\r\n\r\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\r\n *\r\n * @param errorSchema - The `ErrorSchema` instance to convert\r\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\r\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\r\n */\r\nexport default function toErrorList<T = any>(\r\n  errorSchema?: ErrorSchema<T>,\r\n  fieldPath: string[] = []\r\n): RJSFValidationError[] {\r\n  if (!errorSchema) {\r\n    return [];\r\n  }\r\n  let errorList: RJSFValidationError[] = [];\r\n  if (ERRORS_KEY in errorSchema) {\r\n    errorList = errorList.concat(\r\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\r\n        const property = `.${fieldPath.join('.')}`;\r\n        return {\r\n          property,\r\n          message,\r\n          stack: `${property} ${message}`,\r\n        };\r\n      })\r\n    );\r\n  }\r\n  return Object.keys(errorSchema).reduce((acc, key) => {\r\n    if (key !== ERRORS_KEY) {\r\n      const childSchema = (errorSchema as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\r\n      }\r\n    }\r\n    return acc;\r\n  }, errorList);\r\n}\r\n", "import toPath from 'lodash/toPath';\r\n\r\nimport { ErrorSchema, RJSFValidationError } from './types';\r\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\r\n\r\n/** Transforms a rjsf validation errors list:\r\n * [\r\n *   {property: '.level1.level2[2].level3', message: 'err a'},\r\n *   {property: '.level1.level2[2].level3', message: 'err b'},\r\n *   {property: '.level1.level2[4].level3', message: 'err b'},\r\n * ]\r\n * Into an error tree:\r\n * {\r\n *   level1: {\r\n *     level2: {\r\n *       2: {level3: {errors: ['err a', 'err b']}},\r\n *       4: {level3: {errors: ['err b']}},\r\n *     }\r\n *   }\r\n * };\r\n *\r\n * @param errors - The list of RJSFValidationError objects\r\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\r\n */\r\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\r\n  const builder = new ErrorSchemaBuilder<T>();\r\n  if (errors.length) {\r\n    errors.forEach((error) => {\r\n      const { property, message } = error;\r\n      // When the property is the root element, just use an empty array for the path\r\n      const path = property === '.' ? [] : toPath(property);\r\n      // If the property is at the root (.level1) then toPath creates\r\n      // an empty array element at the first index. Remove it.\r\n      if (path.length > 0 && path[0] === '') {\r\n        path.splice(0, 1);\r\n      }\r\n      if (message) {\r\n        builder.addErrors(message, path);\r\n      }\r\n    });\r\n  }\r\n  return builder.ErrorSchema;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\r\n *\r\n * @param errorHandler - The `FormValidation` error handling structure\r\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\r\n */\r\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\r\n  return Object.keys(errorHandler).reduce((acc, key) => {\r\n    if (key === 'addError') {\r\n      return acc;\r\n    } else {\r\n      const childSchema = (errorHandler as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        return {\r\n          ...acc,\r\n          [key]: unwrapErrorHandler(childSchema),\r\n        };\r\n      }\r\n      return { ...acc, [key]: childSchema };\r\n    }\r\n  }, {} as ErrorSchema<T>);\r\n}\r\n", "import pad from './pad';\r\n\r\n/** Converts a UTC date string into a local Date format\r\n *\r\n * @param jsonDate - A UTC date string\r\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\r\n */\r\nexport default function utcToLocal(jsonDate: string) {\r\n  if (!jsonDate) {\r\n    return '';\r\n  }\r\n\r\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\r\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\r\n  // > should be a _valid local date and time string_ (not GMT)\r\n\r\n  // Note - date constructor passed local ISO-8601 does not correctly\r\n  // change time to UTC in node pre-8\r\n  const date = new Date(jsonDate);\r\n\r\n  const yyyy = pad(date.getFullYear(), 4);\r\n  const MM = pad(date.getMonth() + 1, 2);\r\n  const dd = pad(date.getDate(), 2);\r\n  const hh = pad(date.getHours(), 2);\r\n  const mm = pad(date.getMinutes(), 2);\r\n  const ss = pad(date.getSeconds(), 2);\r\n  const SSS = pad(date.getMilliseconds(), 3);\r\n\r\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from './mergeObjects';\r\nimport toErrorList from './toErrorList';\r\nimport { ErrorSchema, ValidationData } from './types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n */\r\nexport default function validationDataMerge<T = any>(\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\nimport isObject from 'lodash/isObject';\r\n\r\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\r\n  for (const key in node) {\r\n    const realObj: { [k: string]: any } = node;\r\n    const value = realObj[key];\r\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\r\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\r\n    } else {\r\n      realObj[key] = withIdRefPrefix<S>(value);\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\r\n  for (let i = 0; i < node.length; i++) {\r\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\r\n * This is used in isValid to make references to the rootSchema\r\n *\r\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n * @returns - A copy of the `schemaNode` with updated `$ref`s\r\n */\r\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(schemaNode: S): S | S[] {\r\n  if (Array.isArray(schemaNode)) {\r\n    return withIdRefPrefixArray<S>([...schemaNode]);\r\n  }\r\n  if (isObject(schemaNode)) {\r\n    return withIdRefPrefixObject<S>({ ...schemaNode });\r\n  }\r\n  return schemaNode;\r\n}\r\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\r\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\r\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\r\n * parameters is important because some languages may choose to put the second parameter before the first in its\r\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\r\n */\r\nexport enum TranslatableString {\r\n  /** Fallback title of an array item, used by ArrayField */\r\n  ArrayItemTitle = 'Item',\r\n  /** Missing items reason, used by ArrayField */\r\n  MissingItems = 'Missing items definition',\r\n  /** Yes label, used by BooleanField */\r\n  YesLabel = 'Yes',\r\n  /** No label, used by BooleanField */\r\n  NoLabel = 'No',\r\n  /** Close label, used by ErrorList */\r\n  CloseLabel = 'Close',\r\n  /** Errors label, used by ErrorList */\r\n  ErrorsLabel = 'Errors',\r\n  /** New additionalProperties string default value, used by ObjectField */\r\n  NewStringDefault = 'New Value',\r\n  /** Add button title, used by AddButton */\r\n  AddButton = 'Add',\r\n  /** Add button title, used by AddButton */\r\n  AddItemButton = 'Add Item',\r\n  /** Copy button title, used by IconButton */\r\n  CopyButton = 'Copy',\r\n  /** Move down button title, used by IconButton */\r\n  MoveDownButton = 'Move down',\r\n  /** Move up button title, used by IconButton */\r\n  MoveUpButton = 'Move up',\r\n  /** Remove button title, used by IconButton */\r\n  RemoveButton = 'Remove',\r\n  /** Now label, used by AltDateWidget */\r\n  NowLabel = 'Now',\r\n  /** Clear label, used by AltDateWidget */\r\n  ClearLabel = 'Clear',\r\n  /** Aria date label, used by DateWidget */\r\n  AriaDateLabel = 'Select a date',\r\n  /** File preview label, used by FileWidget */\r\n  PreviewLabel = 'Preview',\r\n  /** Decrement button aria label, used by UpDownWidget */\r\n  DecrementAriaLabel = 'Decrease value by 1',\r\n  /** Increment button aria label, used by UpDownWidget */\r\n  IncrementAriaLabel = 'Increase value by 1',\r\n  // Strings with replaceable parameters\r\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\r\n  UnknownFieldType = 'Unknown field type %1',\r\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\r\n  OptionPrefix = 'Option %1',\r\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\r\n   * MultiSchemaField\r\n   */\r\n  TitleOptionPrefix = '%1 option %2',\r\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\r\n  KeyLabel = '%1 Key',\r\n  // Strings with replaceable parameters AND/OR that support markdown and html\r\n  /** Invalid object field configuration as provided by the ObjectField */\r\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\r\n  /** Unsupported field schema, used by UnsupportedField */\r\n  UnsupportedField = 'Unsupported field schema.',\r\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\r\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\r\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\r\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\r\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\r\n   * as provided by UnsupportedField\r\n   */\r\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\r\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\r\n   * provided by FileWidget\r\n   */\r\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\r\n}\r\n", "import forEach from 'lodash/forEach';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\r\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\r\nimport ParserValidator, { SchemaMap } from './ParserValidator';\r\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\r\n\r\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\r\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\r\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\r\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\r\n *\r\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\r\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\r\n * @param rootSchema - The root schema from which the schema parsing began\r\n * @param schema - The current schema element being parsed\r\n */\r\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ParserValidator<T, S, F>,\r\n  recurseList: S[],\r\n  rootSchema: S,\r\n  schema: S\r\n) {\r\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\r\n  schemas.forEach((schema) => {\r\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\r\n    if (sameSchemaIndex === -1) {\r\n      recurseList.push(schema);\r\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\r\n      allOptions.forEach((s) => {\r\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\r\n          forEach(schema[PROPERTIES_KEY], (value) => {\r\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\r\n          });\r\n        }\r\n      });\r\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\r\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\r\n * the hash of the schema to schema/sub-schema.\r\n *\r\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\r\n * @returns - The `SchemaMap` of all schemas that were parsed\r\n */\r\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  rootSchema: S\r\n): SchemaMap<S> {\r\n  const validator = new ParserValidator<T, S, F>(rootSchema);\r\n  const recurseList: S[] = [];\r\n\r\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\r\n\r\n  return validator.getSchemaMap();\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ID_KEY } from '../constants';\r\nimport hashForSchema from '../hashForSchema';\r\nimport {\r\n  CustomValidator,\r\n  ErrorSchema,\r\n  ErrorTransformer,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  RJSFValidationError,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from '../types';\r\n\r\n/** The type of the map of schema hash to schema\r\n */\r\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\r\n  [hash: string]: S;\r\n};\r\n\r\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\r\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\r\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\r\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\r\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\r\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\r\n */\r\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements ValidatorType<T, S, F>\r\n{\r\n  /** The rootSchema provided during construction of the class */\r\n  readonly rootSchema: S;\r\n\r\n  /** The map of schemas encountered by the ParserValidator */\r\n  schemaMap: SchemaMap<S> = {};\r\n\r\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\r\n   * first.\r\n   *\r\n   * @param rootSchema - The root schema against which this validator will be executed\r\n   */\r\n  constructor(rootSchema: S) {\r\n    this.rootSchema = rootSchema;\r\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\r\n  }\r\n\r\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\r\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\r\n   * associated with it's `hash` for future use (by a schema compiler).\r\n   *\r\n   * @param schema - The schema which is to be added to the map\r\n   * @param hash - The hash value at which to map the schema\r\n   */\r\n  addSchema(schema: S, hash: string) {\r\n    const key = get(schema, ID_KEY, hash);\r\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\r\n    const existing = this.schemaMap[key];\r\n    if (!existing) {\r\n      this.schemaMap[key] = identifiedSchema;\r\n    } else if (!isEqual(existing, identifiedSchema)) {\r\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\r\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\r\n      throw new Error(\r\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\r\n      );\r\n    }\r\n  }\r\n\r\n  /** Returns the current `schemaMap` to the caller\r\n   */\r\n  getSchemaMap() {\r\n    return this.schemaMap;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\r\n   * the `rootSchema` is not the same as the root schema provided during construction.\r\n   *\r\n   * @param schema - The schema to record in the `schemaMap`\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param rootSchema - The root schema associated with the schema\r\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\r\n   */\r\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\r\n    if (!isEqual(rootSchema, this.rootSchema)) {\r\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\r\n    }\r\n    this.addSchema(schema, hashForSchema<S>(schema));\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _formData - The formData parameter that is ignored\r\n   */\r\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\r\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _errorSchema - The error schema parameter that is ignored\r\n   * @param _fieldPath - The field path parameter that is ignored\r\n   */\r\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\r\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\r\n   * called\r\n   *\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _customValidate - The customValidate parameter that is ignored\r\n   * @param _transformErrors - The transformErrors parameter that is ignored\r\n   * @param _uiSchema - The uiSchema parameter that is ignored\r\n   */\r\n  validateFormData(\r\n    _formData: T,\r\n    _schema: S,\r\n    _customValidate?: CustomValidator<T, S, F>,\r\n    _transformErrors?: ErrorTransformer<T, S, F>,\r\n    _uiSchema?: UiSchema<T, S, F>\r\n  ): ValidationData<T> {\r\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\r\n  }\r\n}\r\n"],
+  "mappings": "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",
   "names": ["get", "get", "has", "isNumber", "isObject", "isString", "times", "get", "get", "get", "get", "type", "acc", "get", "s", "isObject", "get", "has", "key", "isString", "isNumber", "times", "get", "acc", "get", "altSchemas", "get", "isEmpty", "isEmpty", "get", "has", "has", "get", "get", "isEqual", "isEqual", "get", "get", "isEqual", "set", "isEqual", "set", "get", "isEqual", "index", "isEqual", "isEqual", "get", "set", "get", "set", "get", "set", "get", "set", "isString", "isString", "isPlainObject", "isPlainObject", "isPlainObject", "isEmpty", "isEmpty", "isObject", "TranslatableString", "isEqual", "get", "isEqual", "get", "isEqual", "schema", "isEqual"]
 }
diff --git a/node_modules/@rjsf/utils/dist/utils.umd.js b/node_modules/@rjsf/utils/dist/utils.umd.js
index 800e57e..c61f4f4 100644
--- a/node_modules/@rjsf/utils/dist/utils.umd.js
+++ b/node_modules/@rjsf/utils/dist/utils.umd.js
@@ -1004,35 +1004,39 @@
     }
     switch (getSchemaType(schema)) {
       case "object": {
-        const objectDefaults = Object.keys(schema.properties || {}).reduce((acc, key) => {
-          const computedDefault = computeDefaults(validator, get8(schema, [PROPERTIES_KEY, key]), {
-            rootSchema,
-            _recurseList,
-            experimental_defaultFormStateBehavior,
-            includeUndefinedValues: includeUndefinedValues === true,
-            parentDefaults: get8(defaults, [key]),
-            rawFormData: get8(formData, [key]),
-            required: schema.required?.includes(key)
-          });
-          maybeAddDefaultToObject(
-            acc,
-            key,
-            computedDefault,
-            includeUndefinedValues,
-            required,
-            schema.required,
-            experimental_defaultFormStateBehavior
-          );
-          return acc;
-        }, {});
-        if (schema.additionalProperties) {
-          const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};
+        const retrievedSchema = ALL_OF_KEY in schema ? retrieveSchema(validator, schema, rootSchema, formData) : schema;
+        const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(
+          (acc, key) => {
+            const computedDefault = computeDefaults(validator, get8(retrievedSchema, [PROPERTIES_KEY, key]), {
+              rootSchema,
+              _recurseList,
+              experimental_defaultFormStateBehavior,
+              includeUndefinedValues: includeUndefinedValues === true,
+              parentDefaults: get8(defaults, [key]),
+              rawFormData: get8(formData, [key]),
+              required: retrievedSchema.required?.includes(key)
+            });
+            maybeAddDefaultToObject(
+              acc,
+              key,
+              computedDefault,
+              includeUndefinedValues,
+              required,
+              retrievedSchema.required,
+              experimental_defaultFormStateBehavior
+            );
+            return acc;
+          },
+          {}
+        );
+        if (retrievedSchema.additionalProperties) {
+          const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties) ? retrievedSchema.additionalProperties : {};
           const keys = /* @__PURE__ */ new Set();
           if (isObject(defaults)) {
-            Object.keys(defaults).filter((key) => !schema.properties || !schema.properties[key]).forEach((key) => keys.add(key));
+            Object.keys(defaults).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => keys.add(key));
           }
           const formDataRequired = [];
-          Object.keys(formData).filter((key) => !schema.properties || !schema.properties[key]).forEach((key) => {
+          Object.keys(formData).filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key]).forEach((key) => {
             keys.add(key);
             formDataRequired.push(key);
           });
@@ -1044,7 +1048,7 @@
               includeUndefinedValues: includeUndefinedValues === true,
               parentDefaults: get8(defaults, [key]),
               rawFormData: get8(formData, [key]),
-              required: schema.required?.includes(key)
+              required: retrievedSchema.required?.includes(key)
             });
             maybeAddDefaultToObject(
               objectDefaults,
@@ -1059,8 +1063,9 @@
         return objectDefaults;
       }
       case "array": {
-        const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "never";
-        const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "requiredOnly";
+        const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+        const neverPopulate = arrayMinItems?.populate === "never";
+        const ignoreMinItemsFlagSet = arrayMinItems?.populate === "requiredOnly";
         if (Array.isArray(defaults)) {
           defaults = defaults.map((item, idx) => {
             const schemaItem = getInnerSchemaForArrayItem(schema, 2 /* Fallback */, idx);
@@ -1131,7 +1136,8 @@
     if (formData === void 0 || formData === null || typeof formData === "number" && isNaN(formData)) {
       return defaults;
     }
-    const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+    const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+    const { mergeExtraDefaults } = arrayMinItems || {};
     if (isObject(formData)) {
       return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
     }
diff --git a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts
index a767c16..0ec264a 100644
--- a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts
+++ b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts
@@ -1,4 +1,4 @@
-import { Experimental_DefaultFormStateBehavior, FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';
+import { Experimental_ArrayMinItems, Experimental_DefaultFormStateBehavior, FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';
 /** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.
  */
 export declare enum AdditionalItemsHandling {
@@ -6,6 +6,11 @@ export declare enum AdditionalItemsHandling {
     Invert = 1,
     Fallback = 2
 }
+declare module 'json-schema' {
+    interface JSONSchema7 {
+        overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;
+    }
+}
 /** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the
  * `additionalItems` enum and the value of `idx`. There are four possible returns:
  * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid
diff --git a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
index cd9a619..282a0f9 100644
--- a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
+++ b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
@@ -1,7 +1,7 @@
 import { __rest } from "tslib";
 import get from 'lodash/get';
 import isEmpty from 'lodash/isEmpty';
-import { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY } from '../constants';
+import { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY, ALL_OF_KEY, } from '../constants';
 import findSchemaDefinition from '../findSchemaDefinition';
 import getClosestMatchingOption from './getClosestMatchingOption';
 import getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';
@@ -118,7 +118,7 @@ function maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValu
  * @returns - The resulting `formData` with all the defaults provided
  */
 export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormData, rootSchema = {}, includeUndefinedValues = false, _recurseList = [], experimental_defaultFormStateBehavior = undefined, required, } = {}) {
-    var _a, _b;
+    var _a;
     const formData = (isObject(rawFormData) ? rawFormData : {});
     const schema = isObject(rawSchema) ? rawSchema : {};
     // Compute the defaults recursively: give highest priority to deepest nodes.
@@ -193,34 +193,39 @@ export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormD
     switch (getSchemaType(schema)) {
         // We need to recurse for object schema inner default values.
         case 'object': {
-            const objectDefaults = Object.keys(schema.properties || {}).reduce((acc, key) => {
+            // This is a custom addition that fixes this issue:
+            // https://github.com/rjsf-team/react-jsonschema-form/issues/3832
+            const retrievedSchema = ALL_OF_KEY in schema ? retrieveSchema(validator, schema, rootSchema, formData) : schema;
+            const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce((acc, key) => {
                 var _a;
                 // Compute the defaults for this node, with the parent defaults we might
                 // have from a previous run: defaults[key].
-                const computedDefault = computeDefaults(validator, get(schema, [PROPERTIES_KEY, key]), {
+                const computedDefault = computeDefaults(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {
                     rootSchema,
                     _recurseList,
                     experimental_defaultFormStateBehavior,
                     includeUndefinedValues: includeUndefinedValues === true,
                     parentDefaults: get(defaults, [key]),
                     rawFormData: get(formData, [key]),
-                    required: (_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(key),
+                    required: (_a = retrievedSchema.required) === null || _a === void 0 ? void 0 : _a.includes(key),
                 });
-                maybeAddDefaultToObject(acc, key, computedDefault, includeUndefinedValues, required, schema.required, experimental_defaultFormStateBehavior);
+                maybeAddDefaultToObject(acc, key, computedDefault, includeUndefinedValues, required, retrievedSchema.required, experimental_defaultFormStateBehavior);
                 return acc;
             }, {});
-            if (schema.additionalProperties) {
+            if (retrievedSchema.additionalProperties) {
                 // as per spec additionalProperties may be either schema or boolean
-                const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};
+                const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)
+                    ? retrievedSchema.additionalProperties
+                    : {};
                 const keys = new Set();
                 if (isObject(defaults)) {
                     Object.keys(defaults)
-                        .filter((key) => !schema.properties || !schema.properties[key])
+                        .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])
                         .forEach((key) => keys.add(key));
                 }
                 const formDataRequired = [];
                 Object.keys(formData)
-                    .filter((key) => !schema.properties || !schema.properties[key])
+                    .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])
                     .forEach((key) => {
                     keys.add(key);
                     formDataRequired.push(key);
@@ -234,7 +239,7 @@ export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormD
                         includeUndefinedValues: includeUndefinedValues === true,
                         parentDefaults: get(defaults, [key]),
                         rawFormData: get(formData, [key]),
-                        required: (_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(key),
+                        required: (_a = retrievedSchema.required) === null || _a === void 0 ? void 0 : _a.includes(key),
                     });
                     // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop
                     maybeAddDefaultToObject(objectDefaults, key, computedDefault, includeUndefinedValues, required, formDataRequired);
@@ -243,8 +248,10 @@ export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormD
             return objectDefaults;
         }
         case 'array': {
-            const neverPopulate = ((_a = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _a === void 0 ? void 0 : _a.populate) === 'never';
-            const ignoreMinItemsFlagSet = ((_b = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _b === void 0 ? void 0 : _b.populate) === 'requiredOnly';
+            // On a case by case basis, we may want to override the default behavior of populating array items.
+            const arrayMinItems = (_a = schema.overrideArrayMinItemsBehaviour) !== null && _a !== void 0 ? _a : experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems;
+            const neverPopulate = (arrayMinItems === null || arrayMinItems === void 0 ? void 0 : arrayMinItems.populate) === 'never';
+            const ignoreMinItemsFlagSet = (arrayMinItems === null || arrayMinItems === void 0 ? void 0 : arrayMinItems.populate) === 'requiredOnly';
             // Inject defaults into existing array defaults
             if (Array.isArray(defaults)) {
                 defaults = defaults.map((item, idx) => {
@@ -322,6 +329,7 @@ export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormD
  * @returns - The resulting `formData` with all the defaults provided
  */
 export default function getDefaultFormState(validator, theSchema, formData, rootSchema, includeUndefinedValues = false, experimental_defaultFormStateBehavior) {
+    var _a;
     if (!isObject(theSchema)) {
         throw new Error('Invalid schema: ' + theSchema);
     }
@@ -336,7 +344,9 @@ export default function getDefaultFormState(validator, theSchema, formData, root
         // No form data? Use schema defaults.
         return defaults;
     }
-    const { mergeExtraDefaults } = (experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) || {};
+    // On a case by case basis, we may want to override the default behavior of populating array items.
+    const arrayMinItems = (_a = schema.overrideArrayMinItemsBehaviour) !== null && _a !== void 0 ? _a : experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems;
+    const { mergeExtraDefaults } = arrayMinItems || {};
     if (isObject(formData)) {
         return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
     }
diff --git a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map
index e37b659..c73579f 100644
--- a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map
+++ b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map
@@ -1 +1 @@
-{"version":3,"file":"getDefaultFormState.js","sourceRoot":"","sources":["../../src/schema/getDefaultFormState.ts"],"names":[],"mappings":";AAAA,OAAO,GAAG,MAAM,YAAY,CAAC;AAC7B,OAAO,OAAO,MAAM,gBAAgB,CAAC;AAErC,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,gBAAgB,EAAE,cAAc,EAAE,UAAU,EAAE,OAAO,EAAE,MAAM,cAAc,CAAC;AAC9G,OAAO,oBAAoB,MAAM,yBAAyB,CAAC;AAC3D,OAAO,wBAAwB,MAAM,4BAA4B,CAAC;AAClE,OAAO,+BAA+B,MAAM,oCAAoC,CAAC;AACjF,OAAO,aAAa,MAAM,kBAAkB,CAAC;AAC7C,OAAO,QAAQ,MAAM,aAAa,CAAC;AACnC,OAAO,YAAY,MAAM,iBAAiB,CAAC;AAC3C,OAAO,yBAAyB,MAAM,8BAA8B,CAAC;AACrE,OAAO,YAAY,MAAM,iBAAiB,CAAC;AAC3C,OAAO,YAAY,MAAM,iBAAiB,CAAC;AAS3C,OAAO,aAAa,MAAM,iBAAiB,CAAC;AAC5C,OAAO,cAAc,EAAE,EAAE,mBAAmB,EAAE,MAAM,kBAAkB,CAAC;AAEvE;GACG;AACH,MAAM,CAAN,IAAY,uBAIX;AAJD,WAAY,uBAAuB;IACjC,yEAAM,CAAA;IACN,yEAAM,CAAA;IACN,6EAAQ,CAAA;AACV,CAAC,EAJW,uBAAuB,KAAvB,uBAAuB,QAIlC;AAED;;;;;;;;;;;;;;GAcG;AACH,MAAM,UAAU,0BAA0B,CACxC,MAAS,EACT,kBAA2C,uBAAuB,CAAC,MAAM,EACzE,GAAG,GAAG,CAAC,CAAC;IAER,IAAI,GAAG,IAAI,CAAC,EAAE;QACZ,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,GAAG,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE;YAC5D,MAAM,IAAI,GAAG,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAC/B,IAAI,OAAO,IAAI,KAAK,SAAS,EAAE;gBAC7B,OAAO,IAAS,CAAC;aAClB;SACF;KACF;SAAM,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,OAAO,MAAM,CAAC,KAAK,KAAK,SAAS,EAAE;QAC5F,OAAO,MAAM,CAAC,KAAU,CAAC;KAC1B;IACD,IAAI,eAAe,KAAK,uBAAuB,CAAC,MAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,eAAe,CAAC,EAAE;QAC1F,OAAO,MAAM,CAAC,eAAoB,CAAC;KACpC;IACD,OAAO,EAAO,CAAC;AACjB,CAAC;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,SAAS,uBAAuB,CAC9B,GAAsB,EACtB,GAAW,EACX,eAAoC,EACpC,sBAAyD,EACzD,gBAA0B,EAC1B,iBAA2B,EAAE,EAC7B,wCAA+E,EAAE;IAEjF,MAAM,EAAE,iBAAiB,GAAG,qBAAqB,EAAE,GAAG,qCAAqC,CAAC;IAC5F,IAAI,sBAAsB,EAAE;QAC1B,GAAG,CAAC,GAAG,CAAC,GAAG,eAAe,CAAC;KAC5B;SAAM,IAAI,iBAAiB,KAAK,cAAc,EAAE;QAC/C,IAAI,QAAQ,CAAC,eAAe,CAAC,EAAE;YAC7B,gHAAgH;YAChH,mDAAmD;YACnD,MAAM,sBAAsB,GAAG,gBAAgB,KAAK,SAAS,CAAC,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC;YAChH,iGAAiG;YACjG,iFAAiF;YACjF,uGAAuG;YACvG,IACE,CAAC,CAAC,OAAO,CAAC,eAAe,CAAC,IAAI,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;gBAC3D,CAAC,sBAAsB,IAAI,iBAAiB,KAAK,0BAA0B,CAAC,EAC5E;gBACA,GAAG,CAAC,GAAG,CAAC,GAAG,eAAe,CAAC;aAC5B;SACF;aAAM;QACL,kGAAkG;QAClG,gDAAgD;QAChD,+FAA+F;QAC/F,eAAe,KAAK,SAAS;YAC7B,CAAC,iBAAiB,KAAK,qBAAqB,IAAI,cAAc,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAC7E;YACA,GAAG,CAAC,GAAG,CAAC,GAAG,eAAe,CAAC;SAC5B;KACF;AACH,CAAC;AAYD;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,UAAU,eAAe,CAC7B,SAAiC,EACjC,SAAY,EACZ,EACE,cAAc,EACd,WAAW,EACX,UAAU,GAAG,EAAO,EACpB,sBAAsB,GAAG,KAAK,EAC9B,YAAY,GAAG,EAAE,EACjB,qCAAqC,GAAG,SAAS,EACjD,QAAQ,MACsB,EAAE;;IAElC,MAAM,QAAQ,GAAM,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,CAAM,CAAC;IACpE,MAAM,MAAM,GAAM,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAE,EAAQ,CAAC;IAC9D,4EAA4E;IAC5E,IAAI,QAAQ,GAAwB,cAAc,CAAC;IACnD,6FAA6F;IAC7F,IAAI,eAAe,GAAa,IAAI,CAAC;IACrC,IAAI,kBAAkB,GAAG,YAAY,CAAC;IAEtC,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE;QAClD,yEAAyE;QACzE,kBAAkB;QAClB,QAAQ,GAAG,YAAY,CAAC,QAAS,EAAE,MAAM,CAAC,OAA4B,CAAM,CAAC;KAC9E;SAAM,IAAI,WAAW,IAAI,MAAM,EAAE;QAChC,QAAQ,GAAG,MAAM,CAAC,OAAuB,CAAC;KAC3C;SAAM,IAAI,OAAO,IAAI,MAAM,EAAE;QAC5B,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;QAChC,gDAAgD;QAChD,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,OAAQ,CAAC,EAAE;YACpC,kBAAkB,GAAG,YAAY,CAAC,MAAM,CAAC,OAAQ,CAAC,CAAC;YACnD,eAAe,GAAG,oBAAoB,CAAI,OAAO,EAAE,UAAU,CAAC,CAAC;SAChE;KACF;SAAM,IAAI,gBAAgB,IAAI,MAAM,EAAE;QACrC,MAAM,cAAc,GAAG,mBAAmB,CAAU,SAAS,EAAE,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC;QACxG,eAAe,GAAG,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC,mDAAmD;KACzF;SAAM,IAAI,YAAY,CAAC,MAAM,CAAC,EAAE;QAC/B,QAAQ,GAAI,MAAM,CAAC,KAAc,CAAC,GAAG,CAAC,CAAC,UAAa,EAAE,GAAW,EAAE,EAAE,CACnE,eAAe,CAAO,SAAS,EAAE,UAAU,EAAE;YAC3C,UAAU;YACV,sBAAsB;YACtB,YAAY;YACZ,qCAAqC;YACrC,cAAc,EAAE,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,SAAS;YAC/E,WAAW,EAAE,QAAa;YAC1B,QAAQ;SACT,CAAC,CACI,CAAC;KACV;SAAM,IAAI,UAAU,IAAI,MAAM,EAAE;QAC/B,MAAM,EAAE,KAAK,KAAmB,MAAM,EAApB,SAAS,UAAK,MAAM,EAAhC,SAAuB,CAAS,CAAC;QACvC,IAAI,KAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO,SAAS,CAAC;SAClB;QACD,MAAM,aAAa,GAAG,+BAA+B,CAAI,MAAM,CAAC,CAAC;QACjE,eAAe,GAAG,KAAM,CACtB,wBAAwB,CACtB,SAAS,EACT,UAAU,EACV,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,QAAQ,EACxC,KAAY,EACZ,CAAC,EACD,aAAa,CACd,CACG,CAAC;QACP,eAAe,GAAG,YAAY,CAAC,SAAS,EAAE,eAAe,CAAM,CAAC;KACjE;SAAM,IAAI,UAAU,IAAI,MAAM,EAAE;QAC/B,MAAM,EAAE,KAAK,KAAmB,MAAM,EAApB,SAAS,UAAK,MAAM,EAAhC,SAAuB,CAAS,CAAC;QACvC,IAAI,KAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACvB,OAAO,SAAS,CAAC;SAClB;QACD,MAAM,aAAa,GAAG,+BAA+B,CAAI,MAAM,CAAC,CAAC;QACjE,eAAe,GAAG,KAAM,CACtB,wBAAwB,CACtB,SAAS,EACT,UAAU,EACV,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,QAAQ,EACxC,KAAY,EACZ,CAAC,EACD,aAAa,CACd,CACG,CAAC;QACP,eAAe,GAAG,YAAY,CAAC,SAAS,EAAE,eAAe,CAAM,CAAC;KACjE;IAED,IAAI,eAAe,EAAE;QACnB,OAAO,eAAe,CAAU,SAAS,EAAE,eAAe,EAAE;YAC1D,UAAU;YACV,sBAAsB;YACtB,YAAY,EAAE,kBAAkB;YAChC,qCAAqC;YACrC,cAAc,EAAE,QAAyB;YACzC,WAAW,EAAE,QAAa;YAC1B,QAAQ;SACT,CAAC,CAAC;KACJ;IAED,qEAAqE;IACrE,IAAI,QAAQ,KAAK,SAAS,EAAE;QAC1B,QAAQ,GAAG,MAAM,CAAC,OAAuB,CAAC;KAC3C;IAED,QAAQ,aAAa,CAAI,MAAM,CAAC,EAAE;QAChC,6DAA6D;QAC7D,KAAK,QAAQ,CAAC,CAAC;YACb,MAAM,cAAc,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,GAAsB,EAAE,GAAW,EAAE,EAAE;;gBACzG,wEAAwE;gBACxE,2CAA2C;gBAC3C,MAAM,eAAe,GAAG,eAAe,CAAU,SAAS,EAAE,GAAG,CAAC,MAAM,EAAE,CAAC,cAAc,EAAE,GAAG,CAAC,CAAC,EAAE;oBAC9F,UAAU;oBACV,YAAY;oBACZ,qCAAqC;oBACrC,sBAAsB,EAAE,sBAAsB,KAAK,IAAI;oBACvD,cAAc,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC;oBACpC,WAAW,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC;oBACjC,QAAQ,EAAE,MAAA,MAAM,CAAC,QAAQ,0CAAE,QAAQ,CAAC,GAAG,CAAC;iBACzC,CAAC,CAAC;gBACH,uBAAuB,CACrB,GAAG,EACH,GAAG,EACH,eAAe,EACf,sBAAsB,EACtB,QAAQ,EACR,MAAM,CAAC,QAAQ,EACf,qCAAqC,CACtC,CAAC;gBACF,OAAO,GAAG,CAAC;YACb,CAAC,EAAE,EAAE,CAAM,CAAC;YACZ,IAAI,MAAM,CAAC,oBAAoB,EAAE;gBAC/B,mEAAmE;gBACnE,MAAM,0BAA0B,GAAG,QAAQ,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,oBAAoB,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC5G,MAAM,IAAI,GAAG,IAAI,GAAG,EAAU,CAAC;gBAC/B,IAAI,QAAQ,CAAC,QAAQ,CAAC,EAAE;oBACtB,MAAM,CAAC,IAAI,CAAC,QAA6B,CAAC;yBACvC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,UAAU,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;yBAC9D,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;iBACpC;gBACD,MAAM,gBAAgB,GAAa,EAAE,CAAC;gBACtC,MAAM,CAAC,IAAI,CAAC,QAA6B,CAAC;qBACvC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,UAAU,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;qBAC9D,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;oBACf,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBACd,gBAAgB,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBAC7B,CAAC,CAAC,CAAC;gBACL,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,EAAE,EAAE;;oBACnB,MAAM,eAAe,GAAG,eAAe,CAAC,SAAS,EAAE,0BAA+B,EAAE;wBAClF,UAAU;wBACV,YAAY;wBACZ,qCAAqC;wBACrC,sBAAsB,EAAE,sBAAsB,KAAK,IAAI;wBACvD,cAAc,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC;wBACpC,WAAW,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC;wBACjC,QAAQ,EAAE,MAAA,MAAM,CAAC,QAAQ,0CAAE,QAAQ,CAAC,GAAG,CAAC;qBACzC,CAAC,CAAC;oBACH,8GAA8G;oBAC9G,uBAAuB,CACrB,cAAmC,EACnC,GAAG,EACH,eAAe,EACf,sBAAsB,EACtB,QAAQ,EACR,gBAAgB,CACjB,CAAC;gBACJ,CAAC,CAAC,CAAC;aACJ;YACD,OAAO,cAAc,CAAC;SACvB;QACD,KAAK,OAAO,CAAC,CAAC;YACZ,MAAM,aAAa,GAAG,CAAA,MAAA,qCAAqC,aAArC,qCAAqC,uBAArC,qCAAqC,CAAE,aAAa,0CAAE,QAAQ,MAAK,OAAO,CAAC;YACjG,MAAM,qBAAqB,GAAG,CAAA,MAAA,qCAAqC,aAArC,qCAAqC,uBAArC,qCAAqC,CAAE,aAAa,0CAAE,QAAQ,MAAK,cAAc,CAAC;YAEhH,+CAA+C;YAC/C,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;gBAC3B,QAAQ,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;oBACpC,MAAM,UAAU,GAAM,0BAA0B,CAAI,MAAM,EAAE,uBAAuB,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;oBACnG,OAAO,eAAe,CAAU,SAAS,EAAE,UAAU,EAAE;wBACrD,UAAU;wBACV,YAAY;wBACZ,qCAAqC;wBACrC,cAAc,EAAE,IAAI;wBACpB,QAAQ;qBACT,CAAC,CAAC;gBACL,CAAC,CAAQ,CAAC;aACX;YAED,yDAAyD;YACzD,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;gBAC9B,MAAM,UAAU,GAAM,0BAA0B,CAAI,MAAM,CAAC,CAAC;gBAC5D,IAAI,aAAa,EAAE;oBACjB,QAAQ,GAAG,WAAW,CAAC;iBACxB;qBAAM;oBACL,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,IAAO,EAAE,GAAW,EAAE,EAAE;wBAClD,OAAO,eAAe,CAAU,SAAS,EAAE,UAAU,EAAE;4BACrD,UAAU;4BACV,YAAY;4BACZ,qCAAqC;4BACrC,WAAW,EAAE,IAAI;4BACjB,cAAc,EAAE,GAAG,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC;4BACpC,QAAQ;yBACT,CAAC,CAAC;oBACL,CAAC,CAAQ,CAAC;iBACX;aACF;YAED,IAAI,aAAa,EAAE;gBACjB,OAAO,QAAQ,aAAR,QAAQ,cAAR,QAAQ,GAAI,EAAE,CAAC;aACvB;YACD,IAAI,qBAAqB,IAAI,CAAC,QAAQ,EAAE;gBACtC,2FAA2F;gBAC3F,4BAA4B;gBAC5B,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;aACxC;YAED,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACrE,IACE,CAAC,MAAM,CAAC,QAAQ;gBAChB,aAAa,CAAU,SAAS,EAAE,MAAM,EAAE,UAAU,CAAC;gBACrD,MAAM,CAAC,QAAQ,IAAI,cAAc,EACjC;gBACA,OAAO,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;aACjC;YAED,MAAM,cAAc,GAAQ,CAAC,QAAQ,IAAI,EAAE,CAAQ,CAAC;YACpD,MAAM,YAAY,GAAM,0BAA0B,CAAI,MAAM,EAAE,uBAAuB,CAAC,MAAM,CAAC,CAAC;YAC9F,MAAM,aAAa,GAAG,YAAY,CAAC,OAAO,CAAC;YAE3C,uFAAuF;YACvF,MAAM,aAAa,GAAQ,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,GAAG,cAAc,CAAC,CAAC,IAAI,CACzE,eAAe,CAAY,SAAS,EAAE,YAAY,EAAE;gBAClD,cAAc,EAAE,aAAa;gBAC7B,UAAU;gBACV,YAAY;gBACZ,qCAAqC;gBACrC,QAAQ;aACT,CAAC,CACI,CAAC;YACT,8EAA8E;YAC9E,OAAO,cAAc,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;SAC7C;KACF;IAED,OAAO,QAAQ,CAAC;AAClB,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,CAAC,OAAO,UAAU,mBAAmB,CAKzC,SAAiC,EACjC,SAAY,EACZ,QAAY,EACZ,UAAc,EACd,yBAA4D,KAAK,EACjE,qCAA6E;IAE7E,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;QACxB,MAAM,IAAI,KAAK,CAAC,kBAAkB,GAAG,SAAS,CAAC,CAAC;KACjD;IACD,MAAM,MAAM,GAAG,cAAc,CAAU,SAAS,EAAE,SAAS,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC;IACnF,MAAM,QAAQ,GAAG,eAAe,CAAU,SAAS,EAAE,MAAM,EAAE;QAC3D,UAAU;QACV,sBAAsB;QACtB,qCAAqC;QACrC,WAAW,EAAE,QAAQ;KACtB,CAAC,CAAC;IACH,IAAI,QAAQ,KAAK,SAAS,IAAI,QAAQ,KAAK,IAAI,IAAI,CAAC,OAAO,QAAQ,KAAK,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE;QACpG,qCAAqC;QACrC,OAAO,QAAQ,CAAC;KACjB;IACD,MAAM,EAAE,kBAAkB,EAAE,GAAG,CAAA,qCAAqC,aAArC,qCAAqC,uBAArC,qCAAqC,CAAE,aAAa,KAAI,EAAE,CAAC;IAC1F,IAAI,QAAQ,CAAC,QAAQ,CAAC,EAAE;QACtB,OAAO,yBAAyB,CAAI,QAAa,EAAE,QAAQ,EAAE,kBAAkB,CAAC,CAAC;KAClF;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;QAC3B,OAAO,yBAAyB,CAAM,QAAe,EAAE,QAAQ,EAAE,kBAAkB,CAAC,CAAC;KACtF;IACD,OAAO,QAAQ,CAAC;AAClB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"getDefaultFormState.js","sourceRoot":"","sources":["../../src/schema/getDefaultFormState.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts b/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts
index 88464a8..e06d440 100644
--- a/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts
+++ b/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts
@@ -1,7 +1,15 @@
 import get from 'lodash/get';
 import isEmpty from 'lodash/isEmpty';
 
-import { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY } from '../constants';
+import {
+  ANY_OF_KEY,
+  DEFAULT_KEY,
+  DEPENDENCIES_KEY,
+  PROPERTIES_KEY,
+  ONE_OF_KEY,
+  REF_KEY,
+  ALL_OF_KEY,
+} from '../constants';
 import findSchemaDefinition from '../findSchemaDefinition';
 import getClosestMatchingOption from './getClosestMatchingOption';
 import getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';
@@ -12,6 +20,7 @@ import mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';
 import mergeObjects from '../mergeObjects';
 import mergeSchemas from '../mergeSchemas';
 import {
+  Experimental_ArrayMinItems,
   Experimental_DefaultFormStateBehavior,
   FormContextType,
   GenericObjectType,
@@ -30,6 +39,12 @@ export enum AdditionalItemsHandling {
   Fallback,
 }
 
+declare module 'json-schema' {
+  export interface JSONSchema7 {
+    overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;
+  }
+}
+
 /** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the
  * `additionalItems` enum and the value of `idx`. There are four possible returns:
  * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid
@@ -255,41 +270,50 @@ export function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema
   switch (getSchemaType<S>(schema)) {
     // We need to recurse for object schema inner default values.
     case 'object': {
-      const objectDefaults = Object.keys(schema.properties || {}).reduce((acc: GenericObjectType, key: string) => {
-        // Compute the defaults for this node, with the parent defaults we might
-        // have from a previous run: defaults[key].
-        const computedDefault = computeDefaults<T, S, F>(validator, get(schema, [PROPERTIES_KEY, key]), {
-          rootSchema,
-          _recurseList,
-          experimental_defaultFormStateBehavior,
-          includeUndefinedValues: includeUndefinedValues === true,
-          parentDefaults: get(defaults, [key]),
-          rawFormData: get(formData, [key]),
-          required: schema.required?.includes(key),
-        });
-        maybeAddDefaultToObject<T>(
-          acc,
-          key,
-          computedDefault,
-          includeUndefinedValues,
-          required,
-          schema.required,
-          experimental_defaultFormStateBehavior
-        );
-        return acc;
-      }, {}) as T;
-      if (schema.additionalProperties) {
+      // This is a custom addition that fixes this issue:
+      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832
+      const retrievedSchema =
+        ALL_OF_KEY in schema ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData) : schema;
+      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(
+        (acc: GenericObjectType, key: string) => {
+          // Compute the defaults for this node, with the parent defaults we might
+          // have from a previous run: defaults[key].
+          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {
+            rootSchema,
+            _recurseList,
+            experimental_defaultFormStateBehavior,
+            includeUndefinedValues: includeUndefinedValues === true,
+            parentDefaults: get(defaults, [key]),
+            rawFormData: get(formData, [key]),
+            required: retrievedSchema.required?.includes(key),
+          });
+          maybeAddDefaultToObject<T>(
+            acc,
+            key,
+            computedDefault,
+            includeUndefinedValues,
+            required,
+            retrievedSchema.required,
+            experimental_defaultFormStateBehavior
+          );
+          return acc;
+        },
+        {}
+      ) as T;
+      if (retrievedSchema.additionalProperties) {
         // as per spec additionalProperties may be either schema or boolean
-        const additionalPropertiesSchema = isObject(schema.additionalProperties) ? schema.additionalProperties : {};
+        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)
+          ? retrievedSchema.additionalProperties
+          : {};
         const keys = new Set<string>();
         if (isObject(defaults)) {
           Object.keys(defaults as GenericObjectType)
-            .filter((key) => !schema.properties || !schema.properties[key])
+            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])
             .forEach((key) => keys.add(key));
         }
         const formDataRequired: string[] = [];
         Object.keys(formData as GenericObjectType)
-          .filter((key) => !schema.properties || !schema.properties[key])
+          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])
           .forEach((key) => {
             keys.add(key);
             formDataRequired.push(key);
@@ -302,7 +326,7 @@ export function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema
             includeUndefinedValues: includeUndefinedValues === true,
             parentDefaults: get(defaults, [key]),
             rawFormData: get(formData, [key]),
-            required: schema.required?.includes(key),
+            required: retrievedSchema.required?.includes(key),
           });
           // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop
           maybeAddDefaultToObject<T>(
@@ -318,8 +342,11 @@ export function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema
       return objectDefaults;
     }
     case 'array': {
-      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';
-      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';
+      // On a case by case basis, we may want to override the default behavior of populating array items.
+      const arrayMinItems =
+        schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+      const neverPopulate = arrayMinItems?.populate === 'never';
+      const ignoreMinItemsFlagSet = arrayMinItems?.populate === 'requiredOnly';
 
       // Inject defaults into existing array defaults
       if (Array.isArray(defaults)) {
@@ -433,7 +460,10 @@ export default function getDefaultFormState<
     // No form data? Use schema defaults.
     return defaults;
   }
-  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+  // On a case by case basis, we may want to override the default behavior of populating array items.
+  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+
+  const { mergeExtraDefaults } = arrayMinItems || {};
   if (isObject(formData)) {
     return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);
   }
