/* tslint:disable */
/* eslint-disable */
/**
 * Nest tax backend
 * Backend for payment taxes and connection to Noris
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface RequestPostNorisLoadDataDto
 */
export interface RequestPostNorisLoadDataDto {
  /**
   * Year of tax
   * @type {number}
   * @memberof RequestPostNorisLoadDataDto
   */
  year: number
  /**
   * user name to noris
   * @type {string}
   * @memberof RequestPostNorisLoadDataDto
   */
  msq_username: string
  /**
   * password to noris
   * @type {string}
   * @memberof RequestPostNorisLoadDataDto
   */
  msq_password: string
  /**
   * Birth numbers or ALL
   * @type {object}
   * @memberof RequestPostNorisLoadDataDto
   */
  birthNumbers: object
}
/**
 *
 * @export
 * @interface RequestPostNorisPaymentDataLoadDto
 */
export interface RequestPostNorisPaymentDataLoadDto {
  /**
   * Year of tax
   * @type {number}
   * @memberof RequestPostNorisPaymentDataLoadDto
   */
  year: number
  /**
   * user name to noris
   * @type {string}
   * @memberof RequestPostNorisPaymentDataLoadDto
   */
  msq_username: string
  /**
   * password to noris
   * @type {string}
   * @memberof RequestPostNorisPaymentDataLoadDto
   */
  msq_password: string
  /**
   * From date - if is not set, take one from database
   * @type {string}
   * @memberof RequestPostNorisPaymentDataLoadDto
   */
  fromDate: string
  /**
   * To date - if is not set, take one from database
   * @type {string}
   * @memberof RequestPostNorisPaymentDataLoadDto
   */
  toDate: string
  /**
   * If is possible to send confirmation email
   * @type {object}
   * @memberof RequestPostNorisPaymentDataLoadDto
   */
  sendConfEmails: object
  /**
   * If you want to count also overpayments. It is recommended to choose sendConfEmails to false if this is true
   * @type {object}
   * @memberof RequestPostNorisPaymentDataLoadDto
   */
  overPayments: object
}
/**
 *
 * @export
 * @interface ResponseCustomCreatePdfErrorDto
 */
export interface ResponseCustomCreatePdfErrorDto {
  /**
   *
   * @type {number}
   * @memberof ResponseCustomCreatePdfErrorDto
   */
  statusCode: number
  /**
   *
   * @type {string}
   * @memberof ResponseCustomCreatePdfErrorDto
   */
  status: string
  /**
   *
   * @type {string}
   * @memberof ResponseCustomCreatePdfErrorDto
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof ResponseCustomCreatePdfErrorDto
   */
  errorName: ResponseCustomCreatePdfErrorDtoErrorNameEnum
}

export const ResponseCustomCreatePdfErrorDtoErrorNameEnum = {
  PdfCreateError: 'PDF_CREATE_ERROR',
} as const

export type ResponseCustomCreatePdfErrorDtoErrorNameEnum =
  (typeof ResponseCustomCreatePdfErrorDtoErrorNameEnum)[keyof typeof ResponseCustomCreatePdfErrorDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseCustomPaymentErrorDto
 */
export interface ResponseCustomPaymentErrorDto {
  /**
   *
   * @type {number}
   * @memberof ResponseCustomPaymentErrorDto
   */
  statusCode: number
  /**
   *
   * @type {string}
   * @memberof ResponseCustomPaymentErrorDto
   */
  status: string
  /**
   *
   * @type {string}
   * @memberof ResponseCustomPaymentErrorDto
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof ResponseCustomPaymentErrorDto
   */
  errorName: ResponseCustomPaymentErrorDtoErrorNameEnum
}

export const ResponseCustomPaymentErrorDtoErrorNameEnum = {
  TaxNotFound: 'TAX_NOT_FOUND',
  PaymentAlreadyPayed: 'PAYMENT_ALREADY_PAYED',
  DatabaseError: 'DATABASE_ERROR',
  CreatePaymentUrl: 'CREATE_PAYMENT_URL',
} as const

export type ResponseCustomPaymentErrorDtoErrorNameEnum =
  (typeof ResponseCustomPaymentErrorDtoErrorNameEnum)[keyof typeof ResponseCustomPaymentErrorDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseCustomTaxErrorDto
 */
export interface ResponseCustomTaxErrorDto {
  /**
   *
   * @type {number}
   * @memberof ResponseCustomTaxErrorDto
   */
  statusCode: number
  /**
   *
   * @type {string}
   * @memberof ResponseCustomTaxErrorDto
   */
  status: string
  /**
   *
   * @type {string}
   * @memberof ResponseCustomTaxErrorDto
   */
  message: string
  /**
   *
   * @type {string}
   * @memberof ResponseCustomTaxErrorDto
   */
  errorName: ResponseCustomTaxErrorDtoErrorNameEnum
}

export const ResponseCustomTaxErrorDtoErrorNameEnum = {
  TaxyearOrUserNotFound: 'TAXYEAR_OR_USER_NOT_FOUND',
} as const

export type ResponseCustomTaxErrorDtoErrorNameEnum =
  (typeof ResponseCustomTaxErrorDtoErrorNameEnum)[keyof typeof ResponseCustomTaxErrorDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseGetPaymentUrlDto
 */
export interface ResponseGetPaymentUrlDto {
  /**
   * url to redirect to GP webpay
   * @type {string}
   * @memberof ResponseGetPaymentUrlDto
   */
  url: string
}
/**
 *
 * @export
 * @interface ResponseInternalServerErrorDto
 */
export interface ResponseInternalServerErrorDto {
  /**
   * statusCode
   * @type {number}
   * @memberof ResponseInternalServerErrorDto
   */
  statusCode: number
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseInternalServerErrorDto
   */
  message: string
}
/**
 *
 * @export
 * @interface ResponseTaxDetailInstallmentsDto
 */
export interface ResponseTaxDetailInstallmentsDto {
  /**
   * Id of instalments, installments are ordered by this value
   * @type {number}
   * @memberof ResponseTaxDetailInstallmentsDto
   */
  id: number
  /**
   * Created at timestamp
   * @type {string}
   * @memberof ResponseTaxDetailInstallmentsDto
   */
  createdAt: string
  /**
   * Updated at timestamp
   * @type {string}
   * @memberof ResponseTaxDetailInstallmentsDto
   */
  updatedAt: string
  /**
   * Numeric id of tax (foreign key)
   * @type {number}
   * @memberof ResponseTaxDetailInstallmentsDto
   */
  taxId: number
  /**
   * Order of installment
   * @type {string}
   * @memberof ResponseTaxDetailInstallmentsDto
   */
  order?: string
  /**
   * Amount to pay of installment in cents - integer
   * @type {number}
   * @memberof ResponseTaxDetailInstallmentsDto
   */
  amount: number
  /**
   * Text of number of installment
   * @type {string}
   * @memberof ResponseTaxDetailInstallmentsDto
   */
  text: string
}
/**
 *
 * @export
 * @interface ResponseTaxDetailsDto
 */
export interface ResponseTaxDetailsDto {
  /**
   * Numeric id of tax detail
   * @type {number}
   * @memberof ResponseTaxDetailsDto
   */
  id: number
  /**
   * Created at timestamp
   * @type {string}
   * @memberof ResponseTaxDetailsDto
   */
  createdAt: string
  /**
   * Updated at timestamp
   * @type {string}
   * @memberof ResponseTaxDetailsDto
   */
  updatedAt: string
  /**
   * Numeric id of tax (foreign key)
   * @type {number}
   * @memberof ResponseTaxDetailsDto
   */
  taxId: number
  /**
   * Type of tax detail - object of tax
   * @type {string}
   * @memberof ResponseTaxDetailsDto
   */
  type: ResponseTaxDetailsDtoTypeEnum
  /**
   * Area type of tax detail - exact type of object of tax
   * @type {string}
   * @memberof ResponseTaxDetailsDto
   */
  areaType: ResponseTaxDetailsDtoAreaTypeEnum
  /**
   * Area of tax detail - square meters
   * @type {string}
   * @memberof ResponseTaxDetailsDto
   */
  area: string
  /**
   * Base of tax pare meter
   * @type {number}
   * @memberof ResponseTaxDetailsDto
   */
  base: number
  /**
   * Real tax per area type tax detail
   * @type {number}
   * @memberof ResponseTaxDetailsDto
   */
  amount: number
}

export const ResponseTaxDetailsDtoTypeEnum = {
  Apartment: 'APARTMENT',
  Construction: 'CONSTRUCTION',
  Ground: 'GROUND',
} as const

export type ResponseTaxDetailsDtoTypeEnum =
  (typeof ResponseTaxDetailsDtoTypeEnum)[keyof typeof ResponseTaxDetailsDtoTypeEnum]
export const ResponseTaxDetailsDtoAreaTypeEnum = {
  Nonresidential: 'NONRESIDENTIAL',
  Residential: 'RESIDENTIAL',
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  H: 'H',
  JH: 'jH',
  JI: 'jI',
  Byt: 'byt',
  Nebyt: 'nebyt',
} as const

export type ResponseTaxDetailsDtoAreaTypeEnum =
  (typeof ResponseTaxDetailsDtoAreaTypeEnum)[keyof typeof ResponseTaxDetailsDtoAreaTypeEnum]

/**
 *
 * @export
 * @interface ResponseTaxDto
 */
export interface ResponseTaxDto {
  /**
   * Numeric id of tax
   * @type {number}
   * @memberof ResponseTaxDto
   */
  id: number
  /**
   * Uuid of tax
   * @type {string}
   * @memberof ResponseTaxDto
   */
  uuid: string
  /**
   * Created at timestamp
   * @type {string}
   * @memberof ResponseTaxDto
   */
  createdAt: string
  /**
   * Updated at timestamp
   * @type {string}
   * @memberof ResponseTaxDto
   */
  updatedAt: string
  /**
   * Year of tax
   * @type {number}
   * @memberof ResponseTaxDto
   */
  year: number
  /**
   * Numeric id of taxpayer
   * @type {number}
   * @memberof ResponseTaxDto
   */
  taxPayerId: number
  /**
   * Amount to pay in cents - integer
   * @type {number}
   * @memberof ResponseTaxDto
   */
  amount: number
  /**
   * Amount which was already payed in cents - integer
   * @type {number}
   * @memberof ResponseTaxDto
   */
  payedAmount: number
  /**
   * Variable symbol of payment
   * @type {string}
   * @memberof ResponseTaxDto
   */
  variableSymbol: string
  /**
   * Id of tax employee - id is from Noris
   * @type {number}
   * @memberof ResponseTaxDto
   */
  taxEmployeeId: number
  /**
   * Tax Id from order of exact year
   * @type {string}
   * @memberof ResponseTaxDto
   */
  taxId: string
  /**
   * Date of tax order.
   * @type {string}
   * @memberof ResponseTaxDto
   */
  dateCreateTax: string
  /**
   * Part of tax amount for lands in cents in Eur.
   * @type {number}
   * @memberof ResponseTaxDto
   */
  taxLand: number
  /**
   * Part of tax amount for constructions in cents in Eur.
   * @type {number}
   * @memberof ResponseTaxDto
   */
  taxConstructions: number
  /**
   * Part of tax amount for flats in cents in Eur.
   * @type {number}
   * @memberof ResponseTaxDto
   */
  taxFlat: number
  /**
   * Qr code use for pay in web in Base64 representing image of paybysquare QRcode
   * @type {string}
   * @memberof ResponseTaxDto
   */
  qrCodeWeb: string
  /**
   * Qr code use for pay in email in Base64 representing image of paybysquare QRcode
   * @type {string}
   * @memberof ResponseTaxDto
   */
  qrCodeEmail: string
  /**
   *
   * @type {ResponseTaxDtoTaxPayer}
   * @memberof ResponseTaxDto
   */
  taxPayer: ResponseTaxDtoTaxPayer
  /**
   * Installments of payment tax - it can be array of 1 value or 3 values
   * @type {Array<ResponseTaxDetailInstallmentsDto>}
   * @memberof ResponseTaxDto
   */
  taxInstallments: Array<ResponseTaxDetailInstallmentsDto>
  /**
   * Tax employee
   * @type {Array<ResponseTaxDetailsDto>}
   * @memberof ResponseTaxDto
   */
  taxDetails: Array<ResponseTaxDetailsDto>
  /**
   *
   * @type {ResponseTaxDtoTaxEmployees}
   * @memberof ResponseTaxDto
   */
  taxEmployees: ResponseTaxDtoTaxEmployees
}
/**
 * Tax into details on area type
 * @export
 * @interface ResponseTaxDtoTaxEmployees
 */
export interface ResponseTaxDtoTaxEmployees {
  /**
   * Numeric id of Employee from noris
   * @type {number}
   * @memberof ResponseTaxDtoTaxEmployees
   */
  id: number
  /**
   * Created at timestamp
   * @type {string}
   * @memberof ResponseTaxDtoTaxEmployees
   */
  createdAt: string
  /**
   * Updated at timestamp
   * @type {string}
   * @memberof ResponseTaxDtoTaxEmployees
   */
  updatedAt: string
  /**
   * External of employee
   * @type {string}
   * @memberof ResponseTaxDtoTaxEmployees
   */
  externalId: string
  /**
   * Name of employee
   * @type {string}
   * @memberof ResponseTaxDtoTaxEmployees
   */
  name: string
  /**
   * Phone number of employee
   * @type {string}
   * @memberof ResponseTaxDtoTaxEmployees
   */
  phoneNumber: string
  /**
   * Email of employee
   * @type {string}
   * @memberof ResponseTaxDtoTaxEmployees
   */
  email: string
}
/**
 * Tax payer data
 * @export
 * @interface ResponseTaxDtoTaxPayer
 */
export interface ResponseTaxDtoTaxPayer {
  /**
   * Numeric id of tax payer
   * @type {number}
   * @memberof ResponseTaxDtoTaxPayer
   */
  id: number
  /**
   * Uuid of tax payer
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  uuid: string
  /**
   * Created at timestamp
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  createdAt: string
  /**
   * Updated at timestamp
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  updatedAt: string
  /**
   * Is tax payer active
   * @type {boolean}
   * @memberof ResponseTaxDtoTaxPayer
   */
  active: boolean
  /**
   * Permanent address of tax payer
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  permanentResidenceAddress: string
  /**
   * Id of tax payer from Noris
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  externalId: string
  /**
   * Name of taxpayer
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  name: string
  /**
   * Text of descreption of name for pdf
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  nameTxt: string
  /**
   * Text of descreption of street for pdf
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  permanentResidenceStreetTxt: string
  /**
   * Street of permanent residence with number
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  permanentResidenceStreet: string
  /**
   * Zip of permanent residence with number
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  permanentResidenceZip: string
  /**
   * City of permanent residence with number
   * @type {string}
   * @memberof ResponseTaxDtoTaxPayer
   */
  permanentResidenceCity: string
}
/**
 *
 * @export
 * @interface ResponseTaxEmployeesDto
 */
export interface ResponseTaxEmployeesDto {
  /**
   * Numeric id of Employee from noris
   * @type {number}
   * @memberof ResponseTaxEmployeesDto
   */
  id: number
  /**
   * Created at timestamp
   * @type {string}
   * @memberof ResponseTaxEmployeesDto
   */
  createdAt: string
  /**
   * Updated at timestamp
   * @type {string}
   * @memberof ResponseTaxEmployeesDto
   */
  updatedAt: string
  /**
   * External of employee
   * @type {string}
   * @memberof ResponseTaxEmployeesDto
   */
  externalId: string
  /**
   * Name of employee
   * @type {string}
   * @memberof ResponseTaxEmployeesDto
   */
  name: string
  /**
   * Phone number of employee
   * @type {string}
   * @memberof ResponseTaxEmployeesDto
   */
  phoneNumber: string
  /**
   * Email of employee
   * @type {string}
   * @memberof ResponseTaxEmployeesDto
   */
  email: string
}
/**
 *
 * @export
 * @interface ResponseTaxPayerDto
 */
export interface ResponseTaxPayerDto {
  /**
   * Numeric id of tax payer
   * @type {number}
   * @memberof ResponseTaxPayerDto
   */
  id: number
  /**
   * Uuid of tax payer
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  uuid: string
  /**
   * Created at timestamp
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  createdAt: string
  /**
   * Updated at timestamp
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  updatedAt: string
  /**
   * Is tax payer active
   * @type {boolean}
   * @memberof ResponseTaxPayerDto
   */
  active: boolean
  /**
   * Permanent address of tax payer
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  permanentResidenceAddress: string
  /**
   * Id of tax payer from Noris
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  externalId: string
  /**
   * Name of taxpayer
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  name: string
  /**
   * Text of descreption of name for pdf
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  nameTxt: string
  /**
   * Text of descreption of street for pdf
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  permanentResidenceStreetTxt: string
  /**
   * Street of permanent residence with number
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  permanentResidenceStreet: string
  /**
   * Zip of permanent residence with number
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  permanentResidenceZip: string
  /**
   * City of permanent residence with number
   * @type {string}
   * @memberof ResponseTaxPayerDto
   */
  permanentResidenceCity: string
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Integrate data from norris if not exists by birth numbers or all
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerLoadDataFromNorris: async (
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPostNorisLoadDataDto' is not null or undefined
      assertParamExists(
        'adminControllerLoadDataFromNorris',
        'requestPostNorisLoadDataDto',
        requestPostNorisLoadDataDto,
      )
      const localVarPath = `/admin/create-data-from-noris`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPostNorisLoadDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Integrate data from norris
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdateDataFromNorris: async (
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPostNorisLoadDataDto' is not null or undefined
      assertParamExists(
        'adminControllerUpdateDataFromNorris',
        'requestPostNorisLoadDataDto',
        requestPostNorisLoadDataDto,
      )
      const localVarPath = `/admin/update-data-from-norris`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPostNorisLoadDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Integrate Paid for day from - to.
     * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdatePaymentsFromNoris: async (
      requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPostNorisPaymentDataLoadDto' is not null or undefined
      assertParamExists(
        'adminControllerUpdatePaymentsFromNoris',
        'requestPostNorisPaymentDataLoadDto',
        requestPostNorisPaymentDataLoadDto,
      )
      const localVarPath = `/admin/payments-from-noris`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPostNorisPaymentDataLoadDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Integrate data from norris if not exists by birth numbers or all
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerLoadDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerLoadDataFromNorris(
        requestPostNorisLoadDataDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Integrate data from norris
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerUpdateDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerUpdateDataFromNorris(
        requestPostNorisLoadDataDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Integrate Paid for day from - to.
     * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerUpdatePaymentsFromNoris(
      requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerUpdatePaymentsFromNoris(
          requestPostNorisPaymentDataLoadDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration)
  return {
    /**
     *
     * @summary Integrate data from norris if not exists by birth numbers or all
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerLoadDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerLoadDataFromNorris(requestPostNorisLoadDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Integrate data from norris
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdateDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerUpdateDataFromNorris(requestPostNorisLoadDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Integrate Paid for day from - to.
     * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdatePaymentsFromNoris(
      requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerUpdatePaymentsFromNoris(requestPostNorisPaymentDataLoadDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
  /**
   *
   * @summary Integrate data from norris if not exists by birth numbers or all
   * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminControllerLoadDataFromNorris(
    requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerLoadDataFromNorris(requestPostNorisLoadDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Integrate data from norris
   * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminControllerUpdateDataFromNorris(
    requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerUpdateDataFromNorris(requestPostNorisLoadDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Integrate Paid for day from - to.
   * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AdminApi
   */
  public adminControllerUpdatePaymentsFromNoris(
    requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
    options?: AxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerUpdatePaymentsFromNoris(requestPostNorisPaymentDataLoadDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealth(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealth(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth(options?: AxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.appControllerHealth(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealth(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} taxUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGetQrCodeByTaxUuid: async (
      taxUuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taxUuid' is not null or undefined
      assertParamExists('paymentControllerGetQrCodeByTaxUuid', 'taxUuid', taxUuid)
      const localVarPath = `/payment/qrcode/email/{taxUuid}`.replace(
        `{${'taxUuid'}}`,
        encodeURIComponent(String(taxUuid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
     * @summary Generate payment link to logged user for submitted year if there is no payment.
     * @param {string} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPayment: async (
      year: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('paymentControllerPayment', 'year', year)
      const localVarPath = `/payment/cardpay/by-year/{year}`.replace(
        `{${'year'}}`,
        encodeURIComponent(String(year)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
     * @summary Generate payment link and redirect to this link to gpwebpay.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPaymentByTaxId: async (
      uuid: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('paymentControllerPaymentByTaxId', 'uuid', uuid)
      const localVarPath = `/payment/cardpay/by-tax-id/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} oPERATION
     * @param {string} oRDERNUMBER
     * @param {string} pRCODE
     * @param {string} sRCODE
     * @param {string} dIGEST
     * @param {string} dIGEST1
     * @param {string} rESULTTEXT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPaymentResponse: async (
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oPERATION' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'oPERATION', oPERATION)
      // verify required parameter 'oRDERNUMBER' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'oRDERNUMBER', oRDERNUMBER)
      // verify required parameter 'pRCODE' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'pRCODE', pRCODE)
      // verify required parameter 'sRCODE' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'sRCODE', sRCODE)
      // verify required parameter 'dIGEST' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'dIGEST', dIGEST)
      // verify required parameter 'dIGEST1' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'dIGEST1', dIGEST1)
      // verify required parameter 'rESULTTEXT' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'rESULTTEXT', rESULTTEXT)
      const localVarPath = `/payment/cardpay/response`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (oPERATION !== undefined) {
        localVarQueryParameter['OPERATION'] = oPERATION
      }

      if (oRDERNUMBER !== undefined) {
        localVarQueryParameter['ORDERNUMBER'] = oRDERNUMBER
      }

      if (pRCODE !== undefined) {
        localVarQueryParameter['PRCODE'] = pRCODE
      }

      if (sRCODE !== undefined) {
        localVarQueryParameter['SRCODE'] = sRCODE
      }

      if (dIGEST !== undefined) {
        localVarQueryParameter['DIGEST'] = dIGEST
      }

      if (dIGEST1 !== undefined) {
        localVarQueryParameter['DIGEST1'] = dIGEST1
      }

      if (rESULTTEXT !== undefined) {
        localVarQueryParameter['RESULTTEXT'] = rESULTTEXT
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} taxUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerGetQrCodeByTaxUuid(
      taxUuid: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerGetQrCodeByTaxUuid(
        taxUuid,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
     * @summary Generate payment link to logged user for submitted year if there is no payment.
     * @param {string} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerPayment(
      year: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetPaymentUrlDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerPayment(
        year,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
     * @summary Generate payment link and redirect to this link to gpwebpay.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerPaymentByTaxId(
      uuid: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerPaymentByTaxId(
        uuid,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {string} oPERATION
     * @param {string} oRDERNUMBER
     * @param {string} pRCODE
     * @param {string} sRCODE
     * @param {string} dIGEST
     * @param {string} dIGEST1
     * @param {string} rESULTTEXT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerPaymentResponse(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerPaymentResponse(
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        dIGEST,
        dIGEST1,
        rESULTTEXT,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PaymentApiFp(configuration)
  return {
    /**
     *
     * @param {string} taxUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGetQrCodeByTaxUuid(
      taxUuid: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerGetQrCodeByTaxUuid(taxUuid, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
     * @summary Generate payment link to logged user for submitted year if there is no payment.
     * @param {string} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPayment(
      year: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseGetPaymentUrlDto> {
      return localVarFp
        .paymentControllerPayment(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
     * @summary Generate payment link and redirect to this link to gpwebpay.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPaymentByTaxId(
      uuid: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerPaymentByTaxId(uuid, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} oPERATION
     * @param {string} oRDERNUMBER
     * @param {string} pRCODE
     * @param {string} sRCODE
     * @param {string} dIGEST
     * @param {string} dIGEST1
     * @param {string} rESULTTEXT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPaymentResponse(
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      dIGEST: string,
      dIGEST1: string,
      rESULTTEXT: string,
      options?: AxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerPaymentResponse(
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          dIGEST,
          dIGEST1,
          rESULTTEXT,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
  /**
   *
   * @param {string} taxUuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentApi
   */
  public paymentControllerGetQrCodeByTaxUuid(taxUuid: string, options?: AxiosRequestConfig) {
    return PaymentApiFp(this.configuration)
      .paymentControllerGetQrCodeByTaxUuid(taxUuid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
   * @summary Generate payment link to logged user for submitted year if there is no payment.
   * @param {string} year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentApi
   */
  public paymentControllerPayment(year: string, options?: AxiosRequestConfig) {
    return PaymentApiFp(this.configuration)
      .paymentControllerPayment(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * If there is payment, there will be error, also if there is payed only one installment, user can not pay by paygate
   * @summary Generate payment link and redirect to this link to gpwebpay.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentApi
   */
  public paymentControllerPaymentByTaxId(uuid: string, options?: AxiosRequestConfig) {
    return PaymentApiFp(this.configuration)
      .paymentControllerPaymentByTaxId(uuid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} oPERATION
   * @param {string} oRDERNUMBER
   * @param {string} pRCODE
   * @param {string} sRCODE
   * @param {string} dIGEST
   * @param {string} dIGEST1
   * @param {string} rESULTTEXT
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentApi
   */
  public paymentControllerPaymentResponse(
    oPERATION: string,
    oRDERNUMBER: string,
    pRCODE: string,
    sRCODE: string,
    dIGEST: string,
    dIGEST1: string,
    rESULTTEXT: string,
    options?: AxiosRequestConfig,
  ) {
    return PaymentApiFp(this.configuration)
      .paymentControllerPaymentResponse(
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        dIGEST,
        dIGEST1,
        rESULTTEXT,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TaxApi - axios parameter creator
 * @export
 */
export const TaxApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get tax by year and how much is payed
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerGetActualTaxes: async (
      year: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('taxControllerGetActualTaxes', 'year', year)
      const localVarPath = `/tax/get-tax-by-year`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (year !== undefined) {
        localVarQueryParameter['year'] = year
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get old already payed taxes from last years
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    taxControllerGetArchivedTaxes: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tax/archived-taxes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get tax by year and how much is payed
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerGetTaxByYearPdf: async (
      year: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('taxControllerGetTaxByYearPdf', 'year', year)
      const localVarPath = `/tax/get-tax-pdf-by-year`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (year !== undefined) {
        localVarQueryParameter['year'] = year
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TaxApi - functional programming interface
 * @export
 */
export const TaxApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TaxApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get tax by year and how much is payed
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taxControllerGetActualTaxes(
      year: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTaxDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taxControllerGetActualTaxes(
        year,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get old already payed taxes from last years
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async taxControllerGetArchivedTaxes(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.taxControllerGetArchivedTaxes(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @summary Get tax by year and how much is payed
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taxControllerGetTaxByYearPdf(
      year: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTaxDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taxControllerGetTaxByYearPdf(
        year,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * TaxApi - factory interface
 * @export
 */
export const TaxApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TaxApiFp(configuration)
  return {
    /**
     *
     * @summary Get tax by year and how much is payed
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerGetActualTaxes(
      year: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseTaxDto> {
      return localVarFp
        .taxControllerGetActualTaxes(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get old already payed taxes from last years
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    taxControllerGetArchivedTaxes(options?: AxiosRequestConfig): AxiosPromise<Array<object>> {
      return localVarFp
        .taxControllerGetArchivedTaxes(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get tax by year and how much is payed
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerGetTaxByYearPdf(
      year: number,
      options?: AxiosRequestConfig,
    ): AxiosPromise<ResponseTaxDto> {
      return localVarFp
        .taxControllerGetTaxByYearPdf(year, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TaxApi - object-oriented interface
 * @export
 * @class TaxApi
 * @extends {BaseAPI}
 */
export class TaxApi extends BaseAPI {
  /**
   *
   * @summary Get tax by year and how much is payed
   * @param {number} year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxApi
   */
  public taxControllerGetActualTaxes(year: number, options?: AxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerGetActualTaxes(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get old already payed taxes from last years
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof TaxApi
   */
  public taxControllerGetArchivedTaxes(options?: AxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerGetArchivedTaxes(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get tax by year and how much is payed
   * @param {number} year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TaxApi
   */
  public taxControllerGetTaxByYearPdf(year: number, options?: AxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerGetTaxByYearPdf(year, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
