/* tslint:disable */
/* eslint-disable */
/**
 * User Module - city account
 * User module use for store additional data for users and authentication against Azure AD
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface ChangeEmailRequestDto
 */
export interface ChangeEmailRequestDto {
  /**
   * New email for a user
   * @type {string}
   * @memberof ChangeEmailRequestDto
   */
  newEmail: string
}
/**
 *
 * @export
 * @interface CognitoGetUserData
 */
export interface CognitoGetUserData {
  /**
   * Id from cognito
   * @type {string}
   * @memberof CognitoGetUserData
   */
  sub: string
  /**
   * Is email verified in cognito?
   * @type {string}
   * @memberof CognitoGetUserData
   */
  email_verified?: string
  /**
   * Usually name of the company
   * @type {string}
   * @memberof CognitoGetUserData
   */
  name?: string
  /**
   * Which type of verified tier it is?
   * @type {object}
   * @memberof CognitoGetUserData
   */
  'custom:tier'?: object
  /**
   * Which type of account it is?
   * @type {string}
   * @memberof CognitoGetUserData
   */
  'custom:account_type': CognitoGetUserDataCustomAccountTypeEnum
  /**
   * First name
   * @type {string}
   * @memberof CognitoGetUserData
   */
  given_name?: string
  /**
   * Last name
   * @type {string}
   * @memberof CognitoGetUserData
   */
  family_name?: string
  /**
   * email
   * @type {string}
   * @memberof CognitoGetUserData
   */
  email: string
  /**
   * User Id from cognito, same as sub
   * @type {string}
   * @memberof CognitoGetUserData
   */
  idUser: string
  /**
   * User create date
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserCreateDate?: string
  /**
   * User updated date
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserLastModifiedDate?: string
  /**
   * Is user enabled?
   * @type {boolean}
   * @memberof CognitoGetUserData
   */
  Enabled: boolean
  /**
   * Cognito confirmation statue
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserStatus?: CognitoGetUserDataUserStatusEnum
}

export const CognitoGetUserDataCustomAccountTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type CognitoGetUserDataCustomAccountTypeEnum =
  (typeof CognitoGetUserDataCustomAccountTypeEnum)[keyof typeof CognitoGetUserDataCustomAccountTypeEnum]
export const CognitoGetUserDataUserStatusEnum = {
  Archived: 'ARCHIVED',
  Compromised: 'COMPROMISED',
  Confirmed: 'CONFIRMED',
  ForceChangePassword: 'FORCE_CHANGE_PASSWORD',
  ResetRequired: 'RESET_REQUIRED',
  Unconfirmed: 'UNCONFIRMED',
  Unknown: 'UNKNOWN',
} as const

export type CognitoGetUserDataUserStatusEnum =
  (typeof CognitoGetUserDataUserStatusEnum)[keyof typeof CognitoGetUserDataUserStatusEnum]

/**
 *
 * @export
 * @interface DeactivateAccountResponseDto
 */
export interface DeactivateAccountResponseDto {
  /**
   * Marks if the operation has been successful
   * @type {boolean}
   * @memberof DeactivateAccountResponseDto
   */
  success: boolean
  /**
   * Status of the anonymization of user in bloomreach
   * @type {string}
   * @memberof DeactivateAccountResponseDto
   */
  bloomreachRemoved: DeactivateAccountResponseDtoBloomreachRemovedEnum
  /**
   * Status of the removal of tax delivery methods in Noris. If false, there was an error. If true it was successful, or the user is not a tax payer in Noris.
   * @type {boolean}
   * @memberof DeactivateAccountResponseDto
   */
  taxDeliveryMethodsRemoved: boolean
}

export const DeactivateAccountResponseDtoBloomreachRemovedEnum = {
  NotFound: 'NOT_FOUND',
  NotActive: 'NOT_ACTIVE',
  Error: 'ERROR',
  Success: 'SUCCESS',
} as const

export type DeactivateAccountResponseDtoBloomreachRemovedEnum =
  (typeof DeactivateAccountResponseDtoBloomreachRemovedEnum)[keyof typeof DeactivateAccountResponseDtoBloomreachRemovedEnum]

/**
 *
 * @export
 * @interface GdprDataDto
 */
export interface GdprDataDto {
  /**
   * Type of Gdpr subscription
   * @type {string}
   * @memberof GdprDataDto
   */
  type: GdprDataDtoTypeEnum
  /**
   * Type of Gdpr category
   * @type {string}
   * @memberof GdprDataDto
   */
  category: GdprDataDtoCategoryEnum
}

export const GdprDataDtoTypeEnum = {
  License: 'LICENSE',
  Marketing: 'MARKETING',
  FormalCommunication: 'FORMAL_COMMUNICATION',
} as const

export type GdprDataDtoTypeEnum = (typeof GdprDataDtoTypeEnum)[keyof typeof GdprDataDtoTypeEnum]
export const GdprDataDtoCategoryEnum = {
  Taxes: 'TAXES',
  Esbs: 'ESBS',
} as const

export type GdprDataDtoCategoryEnum =
  (typeof GdprDataDtoCategoryEnum)[keyof typeof GdprDataDtoCategoryEnum]

/**
 *
 * @export
 * @interface GetUserDataByBirthNumbersBatchResponseDto
 */
export interface GetUserDataByBirthNumbersBatchResponseDto {
  /**
   * A record of users keyed by their birth number
   * @type {{ [key: string]: ResponseUserByBirthNumberDto; }}
   * @memberof GetUserDataByBirthNumbersBatchResponseDto
   */
  users: { [key: string]: ResponseUserByBirthNumberDto }
}
/**
 *
 * @export
 * @interface ManuallyVerifyUserRequestDto
 */
export interface ManuallyVerifyUserRequestDto {
  /**
   * userBirthNumber
   * @type {string}
   * @memberof ManuallyVerifyUserRequestDto
   */
  birthNumber: string
  /**
   * Ifo of the user
   * @type {string}
   * @memberof ManuallyVerifyUserRequestDto
   */
  ifo?: string
  /**
   * ico
   * @type {string}
   * @memberof ManuallyVerifyUserRequestDto
   */
  ico?: string
}
/**
 *
 * @export
 * @interface OnlySuccessDto
 */
export interface OnlySuccessDto {
  /**
   * Marks if the operation has been successful
   * @type {boolean}
   * @memberof OnlySuccessDto
   */
  success: boolean
}
/**
 *
 * @export
 * @interface RequestBatchQueryUsersByBirthNumbersDto
 */
export interface RequestBatchQueryUsersByBirthNumbersDto {
  /**
   * Birth numbers without slash which should be retrieved from user database.
   * @type {Array<string>}
   * @memberof RequestBatchQueryUsersByBirthNumbersDto
   */
  birthNumbers: Array<string>
}
/**
 *
 * @export
 * @interface RequestBodyValidateEdeskForUserIdsDto
 */
export interface RequestBodyValidateEdeskForUserIdsDto {
  /**
   * How many records to skip
   * @type {number}
   * @memberof RequestBodyValidateEdeskForUserIdsDto
   */
  offset?: number
}
/**
 *
 * @export
 * @interface RequestBodyVerifyIdentityCardDto
 */
export interface RequestBodyVerifyIdentityCardDto {
  /**
   * Birth number for check
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  birthNumber: string
  /**
   * String of identitiy card
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  turnstileToken: string
}
/**
 *
 * @export
 * @interface RequestBodyVerifyWithEidDto
 */
export interface RequestBodyVerifyWithEidDto {
  /**
   * Token returned by https://fix.slovensko-sk-api.bratislava.sk/login
   * @type {string}
   * @memberof RequestBodyVerifyWithEidDto
   */
  oboToken: string
}
/**
 *
 * @export
 * @interface RequestBodyVerifyWithRpoDto
 */
export interface RequestBodyVerifyWithRpoDto {
  /**
   * ico
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  ico: string
  /**
   * Birth number of legal entity\'s executive
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  birthNumber: string
  /**
   * Identity card of legal entity\'s executive
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  turnstileToken: string
}
/**
 *
 * @export
 * @interface RequestGdprDataDto
 */
export interface RequestGdprDataDto {
  /**
   *
   * @type {Array<GdprDataDto>}
   * @memberof RequestGdprDataDto
   */
  gdprData: Array<GdprDataDto>
}
/**
 *
 * @export
 * @interface RequestValidatePhysicalEntityRfoDto
 */
export interface RequestValidatePhysicalEntityRfoDto {
  /**
   * Id of the physical entity object in db
   * @type {string}
   * @memberof RequestValidatePhysicalEntityRfoDto
   */
  physicalEntityId: string
}
/**
 *
 * @export
 * @interface ResponseCustomErrorVerificationEidDto
 */
export interface ResponseCustomErrorVerificationEidDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseCustomErrorVerificationEidDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseCustomErrorVerificationEidDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseCustomErrorVerificationEidDto
   */
  errorName: ResponseCustomErrorVerificationEidDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationEidDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseCustomErrorVerificationEidDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseCustomErrorVerificationIdentityCardDto
 */
export interface ResponseCustomErrorVerificationIdentityCardDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  errorName: ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseGdprLegalPersonDataDto
 */
export interface ResponseGdprLegalPersonDataDto {
  /**
   *
   * @type {string}
   * @memberof ResponseGdprLegalPersonDataDto
   */
  category: ResponseGdprLegalPersonDataDtoCategoryEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprLegalPersonDataDto
   */
  type: ResponseGdprLegalPersonDataDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprLegalPersonDataDto
   */
  subType: ResponseGdprLegalPersonDataDtoSubTypeEnum
}

export const ResponseGdprLegalPersonDataDtoCategoryEnum = {
  Taxes: 'TAXES',
  Esbs: 'ESBS',
} as const

export type ResponseGdprLegalPersonDataDtoCategoryEnum =
  (typeof ResponseGdprLegalPersonDataDtoCategoryEnum)[keyof typeof ResponseGdprLegalPersonDataDtoCategoryEnum]
export const ResponseGdprLegalPersonDataDtoTypeEnum = {
  License: 'LICENSE',
  Marketing: 'MARKETING',
  FormalCommunication: 'FORMAL_COMMUNICATION',
} as const

export type ResponseGdprLegalPersonDataDtoTypeEnum =
  (typeof ResponseGdprLegalPersonDataDtoTypeEnum)[keyof typeof ResponseGdprLegalPersonDataDtoTypeEnum]
export const ResponseGdprLegalPersonDataDtoSubTypeEnum = {
  Unsubscribe: 'unsubscribe',
  Subscribe: 'subscribe',
} as const

export type ResponseGdprLegalPersonDataDtoSubTypeEnum =
  (typeof ResponseGdprLegalPersonDataDtoSubTypeEnum)[keyof typeof ResponseGdprLegalPersonDataDtoSubTypeEnum]

/**
 *
 * @export
 * @interface ResponseGdprUserDataDto
 */
export interface ResponseGdprUserDataDto {
  /**
   *
   * @type {string}
   * @memberof ResponseGdprUserDataDto
   */
  category: ResponseGdprUserDataDtoCategoryEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprUserDataDto
   */
  type: ResponseGdprUserDataDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprUserDataDto
   */
  subType: ResponseGdprUserDataDtoSubTypeEnum
}

export const ResponseGdprUserDataDtoCategoryEnum = {
  Taxes: 'TAXES',
  Esbs: 'ESBS',
} as const

export type ResponseGdprUserDataDtoCategoryEnum =
  (typeof ResponseGdprUserDataDtoCategoryEnum)[keyof typeof ResponseGdprUserDataDtoCategoryEnum]
export const ResponseGdprUserDataDtoTypeEnum = {
  License: 'LICENSE',
  Marketing: 'MARKETING',
  FormalCommunication: 'FORMAL_COMMUNICATION',
} as const

export type ResponseGdprUserDataDtoTypeEnum =
  (typeof ResponseGdprUserDataDtoTypeEnum)[keyof typeof ResponseGdprUserDataDtoTypeEnum]
export const ResponseGdprUserDataDtoSubTypeEnum = {
  Unsubscribe: 'unsubscribe',
  Subscribe: 'subscribe',
} as const

export type ResponseGdprUserDataDtoSubTypeEnum =
  (typeof ResponseGdprUserDataDtoSubTypeEnum)[keyof typeof ResponseGdprUserDataDtoSubTypeEnum]

/**
 *
 * @export
 * @interface ResponseInternalServerErrorDto
 */
export interface ResponseInternalServerErrorDto {
  /**
   * statusCode
   * @type {number}
   * @memberof ResponseInternalServerErrorDto
   */
  statusCode: number
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseInternalServerErrorDto
   */
  message: string
}
/**
 *
 * @export
 * @interface ResponseLegalPersonDataDto
 */
export interface ResponseLegalPersonDataDto {
  /**
   * Local ID of user
   * @type {string}
   * @memberof ResponseLegalPersonDataDto
   */
  id: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof ResponseLegalPersonDataDto
   */
  createdAt: string
  /**
   * Last updated timestamp
   * @type {string}
   * @memberof ResponseLegalPersonDataDto
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   * @type {string}
   * @memberof ResponseLegalPersonDataDto
   */
  externalId: string | null
  /**
   * Ico of company, which this user represents
   * @type {string}
   * @memberof ResponseLegalPersonDataDto
   */
  ico: string | null
  /**
   * Email
   * @type {string}
   * @memberof ResponseLegalPersonDataDto
   */
  email: string | null
  /**
   * Birth number
   * @type {string}
   * @memberof ResponseLegalPersonDataDto
   */
  birthNumber: string | null
  /**
   * Subscription Data in array
   * @type {Array<ResponseGdprLegalPersonDataDto>}
   * @memberof ResponseLegalPersonDataDto
   */
  gdprData: Array<ResponseGdprLegalPersonDataDto>
}
/**
 *
 * @export
 * @interface ResponseLegalPersonDataSimpleDto
 */
export interface ResponseLegalPersonDataSimpleDto {
  /**
   * Local ID of user
   * @type {string}
   * @memberof ResponseLegalPersonDataSimpleDto
   */
  id: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof ResponseLegalPersonDataSimpleDto
   */
  createdAt: string
  /**
   * Last updated timestamp
   * @type {string}
   * @memberof ResponseLegalPersonDataSimpleDto
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   * @type {string}
   * @memberof ResponseLegalPersonDataSimpleDto
   */
  externalId: string | null
  /**
   * Ico of company, which this user represents
   * @type {string}
   * @memberof ResponseLegalPersonDataSimpleDto
   */
  ico: string | null
  /**
   * Email
   * @type {string}
   * @memberof ResponseLegalPersonDataSimpleDto
   */
  email: string | null
  /**
   * Birth number
   * @type {string}
   * @memberof ResponseLegalPersonDataSimpleDto
   */
  birthNumber: string | null
}
/**
 *
 * @export
 * @interface ResponseNotFoundErrorVerificationIdentityCardDto
 */
export interface ResponseNotFoundErrorVerificationIdentityCardDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  errorName: string
}
/**
 *
 * @export
 * @interface ResponseUserByBirthNumberDto
 */
export interface ResponseUserByBirthNumberDto {
  /**
   * userBirthNumber
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  birthNumber: string | null
  /**
   * email
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  email: string | null
  /**
   * Cognito Id
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  externalId: string | null
  /**
   * Special user attribute for user segmentation
   * @type {object}
   * @memberof ResponseUserByBirthNumberDto
   */
  userAttribute: object
  /**
   * Tier from cognito
   * @type {object}
   * @memberof ResponseUserByBirthNumberDto
   */
  cognitoAttributes?: object
}
/**
 *
 * @export
 * @interface ResponseUserDataBasicDto
 */
export interface ResponseUserDataBasicDto {
  /**
   * Local ID of user
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  id: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  createdAt: string
  /**
   * Last updated timestamp
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  externalId: string | null
  /**
   * Email
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  email: string | null
  /**
   * Birth number
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  birthNumber: string | null
  /**
   *
   * @type {UserOfficialCorrespondenceChannelEnum}
   * @memberof ResponseUserDataBasicDto
   */
  officialCorrespondenceChannel: UserOfficialCorrespondenceChannelEnum
  /**
   * True if user was registered and have verified birth number until 2024-04-22. This date can be varied every year. In this date, user are sent into Noris and taxes will be generated.
   * @type {boolean}
   * @memberof ResponseUserDataBasicDto
   */
  wasVerifiedBeforeTaxDeadline: boolean
  /**
   * Can show banner for formal communication through email? If it was shown and clicked, it will not be shown.
   * @type {boolean}
   * @memberof ResponseUserDataBasicDto
   */
  showEmailCommunicationBanner: boolean
}

/**
 *
 * @export
 * @interface ResponseUserDataDto
 */
export interface ResponseUserDataDto {
  /**
   * Local ID of user
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  id: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  createdAt: string
  /**
   * Last updated timestamp
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  externalId: string | null
  /**
   * Email
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  email: string | null
  /**
   * Birth number
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  birthNumber: string | null
  /**
   *
   * @type {UserOfficialCorrespondenceChannelEnum}
   * @memberof ResponseUserDataDto
   */
  officialCorrespondenceChannel: UserOfficialCorrespondenceChannelEnum
  /**
   * True if user was registered and have verified birth number until 2024-04-22. This date can be varied every year. In this date, user are sent into Noris and taxes will be generated.
   * @type {boolean}
   * @memberof ResponseUserDataDto
   */
  wasVerifiedBeforeTaxDeadline: boolean
  /**
   * Can show banner for formal communication through email? If it was shown and clicked, it will not be shown.
   * @type {boolean}
   * @memberof ResponseUserDataDto
   */
  showEmailCommunicationBanner: boolean
  /**
   * Subscription Data in array
   * @type {Array<ResponseGdprUserDataDto>}
   * @memberof ResponseUserDataDto
   */
  gdprData: Array<ResponseGdprUserDataDto>
}

/**
 *
 * @export
 * @interface ResponseValidatePhysicalEntityRfoDto
 */
export interface ResponseValidatePhysicalEntityRfoDto {
  /**
   * Entity data (updated if new info was found in state registry)
   * @type {object}
   * @memberof ResponseValidatePhysicalEntityRfoDto
   */
  physicalEntity: object
  /**
   * Data received from RFO
   * @type {object}
   * @memberof ResponseValidatePhysicalEntityRfoDto
   */
  rfoData: object
  /**
   * Data received from UPVS
   * @type {object}
   * @memberof ResponseValidatePhysicalEntityRfoDto
   */
  upvsResult: object
}
/**
 *
 * @export
 * @interface ResponseVerificationDto
 */
export interface ResponseVerificationDto {
  /**
   * number of status code
   * @type {number}
   * @memberof ResponseVerificationDto
   */
  statusCode: number
  /**
   * status
   * @type {string}
   * @memberof ResponseVerificationDto
   */
  status: string
  /**
   * Message about update
   * @type {string}
   * @memberof ResponseVerificationDto
   */
  message: string
  /**
   * Error if exists
   * @type {string}
   * @memberof ResponseVerificationDto
   */
  errorName?: ResponseVerificationDtoErrorNameEnum
}

export const ResponseVerificationDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseVerificationDtoErrorNameEnum =
  (typeof ResponseVerificationDtoErrorNameEnum)[keyof typeof ResponseVerificationDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseVerificationIdentityCardToQueueDto
 */
export interface ResponseVerificationIdentityCardToQueueDto {
  /**
   * number of status code
   * @type {number}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  statusCode: number
  /**
   * status
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  status: string
  /**
   * Message about update
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  message: ResponseVerificationIdentityCardToQueueDtoMessageEnum
  /**
   * Error if exists
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  errorName?: ResponseVerificationIdentityCardToQueueDtoErrorNameEnum
}

export const ResponseVerificationIdentityCardToQueueDtoMessageEnum = {
  SendToQueue: 'SendToQueue',
  AlreadyVerified: 'AlreadyVerified',
} as const

export type ResponseVerificationIdentityCardToQueueDtoMessageEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum]
export const ResponseVerificationIdentityCardToQueueDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseVerificationIdentityCardToQueueDtoErrorNameEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum]

/**
 * @type UserControllerChangeEmail200Response
 * @export
 */
export type UserControllerChangeEmail200Response =
  | ResponseLegalPersonDataSimpleDto
  | ResponseUserDataBasicDto

/**
 * @type UserControllerGetOrCreateUser200Response
 * @export
 */
export type UserControllerGetOrCreateUser200Response =
  | ResponseLegalPersonDataDto
  | ResponseUserDataDto

/**
 * State, if we can communicate user with email, or user have active e-desk slovensko.sk mail or we need to communicate with him with post. First we are looking for edesk, if he has registered edesk communication in NASES use edesk. If not, check if there is subscription for communication through email, use email from city account. Else use Postal communication.
 * @export
 * @enum {string}
 */

export const UserOfficialCorrespondenceChannelEnum = {
  Postal: 'POSTAL',
  Edesk: 'EDESK',
  Email: 'EMAIL',
} as const

export type UserOfficialCorrespondenceChannelEnum =
  (typeof UserOfficialCorrespondenceChannelEnum)[keyof typeof UserOfficialCorrespondenceChannelEnum]

/**
 *
 * @export
 * @interface UserVerifyState
 */
export interface UserVerifyState {
  /**
   * Id of given user\'s email, if exists
   * @type {string}
   * @memberof UserVerifyState
   */
  externalId?: string | null
  /**
   * Type of user.
   * @type {string}
   * @memberof UserVerifyState
   */
  type?: UserVerifyStateTypeEnum
  /**
   * Marks if the user with given email is in database.
   * @type {boolean}
   * @memberof UserVerifyState
   */
  isInDatabase: boolean
  /**
   * Marks if the user with given email is in cognito.
   * @type {boolean}
   * @memberof UserVerifyState
   */
  isInCognito: boolean
  /**
   * Current cognito tier, marks the status of verifying.
   * @type {string}
   * @memberof UserVerifyState
   */
  cognitoTier?: UserVerifyStateCognitoTierEnum
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   * @type {string}
   * @memberof UserVerifyState
   */
  birthNumberAlreadyExists?: string
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   * @type {string}
   * @memberof UserVerifyState
   */
  birthNumberIcoAlreadyExists?: string
  /**
   * Marks if the user with given email is verified.
   * @type {boolean}
   * @memberof UserVerifyState
   */
  isVerified: boolean
  /**
   * Possible cause of the verify error.
   * @type {string}
   * @memberof UserVerifyState
   */
  possibleCause?: string
}

export const UserVerifyStateTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type UserVerifyStateTypeEnum =
  (typeof UserVerifyStateTypeEnum)[keyof typeof UserVerifyStateTypeEnum]
export const UserVerifyStateCognitoTierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type UserVerifyStateCognitoTierEnum =
  (typeof UserVerifyStateCognitoTierEnum)[keyof typeof UserVerifyStateCognitoTierEnum]

/**
 *
 * @export
 * @interface ValidateEdeskForUserIdsResponseDto
 */
export interface ValidateEdeskForUserIdsResponseDto {
  /**
   * Number of users that were validated
   * @type {number}
   * @memberof ValidateEdeskForUserIdsResponseDto
   */
  validatedUsers: number
  /**
   * Temp debug data
   * @type {object}
   * @memberof ValidateEdeskForUserIdsResponseDto
   */
  enitites: object
}
/**
 *
 * @export
 * @interface ValidatedUsersToPhysicalEntitiesResponseDto
 */
export interface ValidatedUsersToPhysicalEntitiesResponseDto {
  /**
   *
   * @type {number}
   * @memberof ValidatedUsersToPhysicalEntitiesResponseDto
   */
  existingPhysicalEntitiesUpdated: number
  /**
   *
   * @type {number}
   * @memberof ValidatedUsersToPhysicalEntitiesResponseDto
   */
  newPhysicalEntitiesCreated: number
}
/**
 *
 * @export
 * @interface VerificationDataForUser
 */
export interface VerificationDataForUser {
  /**
   * Id of the user in cognito.
   * @type {string}
   * @memberof VerificationDataForUser
   */
  userId: string
  /**
   * userBirthNumber
   * @type {string}
   * @memberof VerificationDataForUser
   */
  birthNumber: string
  /**
   * Id card used for verification.
   * @type {string}
   * @memberof VerificationDataForUser
   */
  idCard: string
  /**
   * Ico used for verification.
   * @type {string}
   * @memberof VerificationDataForUser
   */
  ico?: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof VerificationDataForUser
   */
  verifyStart: string
}
/**
 *
 * @export
 * @interface VerificationDataForUserResponseDto
 */
export interface VerificationDataForUserResponseDto {
  /**
   * Id of the user in cognito.
   * @type {string}
   * @memberof VerificationDataForUserResponseDto
   */
  externalId: string | null
  /**
   * Email of the user.
   * @type {string}
   * @memberof VerificationDataForUserResponseDto
   */
  email: string | null
  /**
   * Verification data for the user in the last month. Ordered by start date descending.
   * @type {Array<VerificationDataForUser>}
   * @memberof VerificationDataForUserResponseDto
   */
  verificationDataLastMonth: Array<VerificationDataForUser>
}

/**
 * ADMINApi - axios parameter creator
 * @export
 */
export const ADMINApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerCheckUserVerifyState', 'email', email)
      const localVarPath = `/admin/status/user/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeactivateAccount: async (
      externalId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalId' is not null or undefined
      assertParamExists('adminControllerDeactivateAccount', 'externalId', externalId)
      const localVarPath = `/admin/deactivate/{externalId}`.replace(
        `{${'externalId'}}`,
        encodeURIComponent(String(externalId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber: async (
      birthNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('adminControllerGetUserDataByBirthNumber', 'birthNumber', birthNumber)
      const localVarPath = `/admin/userdata`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      if (birthNumber !== undefined) {
        localVarQueryParameter['birthNumber'] = birthNumber
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumbersBatch: async (
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBatchQueryUsersByBirthNumbersDto' is not null or undefined
      assertParamExists(
        'adminControllerGetUserDataByBirthNumbersBatch',
        'requestBatchQueryUsersByBirthNumbersDto',
        requestBatchQueryUsersByBirthNumbersDto,
      )
      const localVarPath = `/admin/userdata-batch`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBatchQueryUsersByBirthNumbersDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetVerificationDataForUser: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerGetVerificationDataForUser', 'email', email)
      const localVarPath = `/admin/user/id-card-verification-data/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidateEdeskForUserIds: async (
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyValidateEdeskForUserIdsDto' is not null or undefined
      assertParamExists(
        'adminControllerValidateEdeskForUserIds',
        'requestBodyValidateEdeskForUserIdsDto',
        requestBodyValidateEdeskForUserIdsDto,
      )
      const localVarPath = `/admin/validate-edesk-by-cognito-where-first-try`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyValidateEdeskForUserIdsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatePhysicalEntityRfo: async (
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestValidatePhysicalEntityRfoDto' is not null or undefined
      assertParamExists(
        'adminControllerValidatePhysicalEntityRfo',
        'requestValidatePhysicalEntityRfoDto',
        requestValidatePhysicalEntityRfoDto,
      )
      const localVarPath = `/admin/validate-physical-entity-rfo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestValidatePhysicalEntityRfoDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatedUsersToPhysicalEntities: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/validated-users-to-physical-entities`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerVerifyUserManually: async (
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerVerifyUserManually', 'email', email)
      // verify required parameter 'manuallyVerifyUserRequestDto' is not null or undefined
      assertParamExists(
        'adminControllerVerifyUserManually',
        'manuallyVerifyUserRequestDto',
        manuallyVerifyUserRequestDto,
      )
      const localVarPath = `/admin/user/verify-manually/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        manuallyVerifyUserRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ADMINApi - functional programming interface
 * @export
 */
export const ADMINApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ADMINApiAxiosParamCreator(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCheckUserVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserVerifyState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerCheckUserVerifyState(
        email,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerCheckUserVerifyState']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerDeactivateAccount(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeactivateAccountResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerDeactivateAccount(
        externalId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerDeactivateAccount']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserByBirthNumberDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumber(
          birthNumber,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetUserDataByBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumbersBatch(
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetUserDataByBirthNumbersBatchResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumbersBatch(
          requestBatchQueryUsersByBirthNumbersDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetUserDataByBirthNumbersBatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetVerificationDataForUser(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationDataForUserResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetVerificationDataForUser(email, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetVerificationDataForUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidateEdeskForUserIds(
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateEdeskForUserIdsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidateEdeskForUserIds(
          requestBodyValidateEdeskForUserIdsDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidateEdeskForUserIds']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidatePhysicalEntityRfo(
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseValidatePhysicalEntityRfoDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidatePhysicalEntityRfo(
          requestValidatePhysicalEntityRfoDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidatePhysicalEntityRfo']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidatedUsersToPhysicalEntities(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ValidatedUsersToPhysicalEntitiesResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidatedUsersToPhysicalEntities(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidatedUsersToPhysicalEntities']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerVerifyUserManually(
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnlySuccessDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerVerifyUserManually(
        email,
        manuallyVerifyUserRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerVerifyUserManually']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ADMINApi - factory interface
 * @export
 */
export const ADMINApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ADMINApiFp(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserVerifyState> {
      return localVarFp
        .adminControllerCheckUserVerifyState(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeactivateAccount(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeactivateAccountResponseDto> {
      return localVarFp
        .adminControllerDeactivateAccount(externalId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserByBirthNumberDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumber(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumbersBatch(
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetUserDataByBirthNumbersBatchResponseDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumbersBatch(
          requestBatchQueryUsersByBirthNumbersDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetVerificationDataForUser(
      email: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VerificationDataForUserResponseDto> {
      return localVarFp
        .adminControllerGetVerificationDataForUser(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidateEdeskForUserIds(
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ValidateEdeskForUserIdsResponseDto> {
      return localVarFp
        .adminControllerValidateEdeskForUserIds(requestBodyValidateEdeskForUserIdsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatePhysicalEntityRfo(
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseValidatePhysicalEntityRfoDto> {
      return localVarFp
        .adminControllerValidatePhysicalEntityRfo(requestValidatePhysicalEntityRfoDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatedUsersToPhysicalEntities(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ValidatedUsersToPhysicalEntitiesResponseDto> {
      return localVarFp
        .adminControllerValidatedUsersToPhysicalEntities(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerVerifyUserManually(
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OnlySuccessDto> {
      return localVarFp
        .adminControllerVerifyUserManually(email, manuallyVerifyUserRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ADMINApi - object-oriented interface
 * @export
 * @class ADMINApi
 * @extends {BaseAPI}
 */
export class ADMINApi extends BaseAPI {
  /**
   * Return the state of user verifying.
   * @summary Get user\'s verify state
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerCheckUserVerifyState(email: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerCheckUserVerifyState(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deactivates user account in cognito and deletes personal info from database.
   * @summary Deactivate user account
   * @param {string} externalId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerDeactivateAccount(externalId: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerDeactivateAccount(externalId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get user data by birthnumber
   * @summary Get user data
   * @param {string} birthNumber userBirthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerGetUserDataByBirthNumber(
    birthNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumber(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get user data by birthnumbers in batch.
   * @summary Get user data
   * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerGetUserDataByBirthNumbersBatch(
    requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumbersBatch(
        requestBatchQueryUsersByBirthNumbersDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
   * @summary Get verification data for user.
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerGetVerificationDataForUser(email: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetVerificationDataForUser(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
   * @summary Validate edesk for physicalEntities
   * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerValidateEdeskForUserIds(
    requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidateEdeskForUserIds(requestBodyValidateEdeskForUserIdsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Manually update entity data against RFO (and UPVS) if possible
   * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerValidatePhysicalEntityRfo(
    requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidatePhysicalEntityRfo(requestValidatePhysicalEntityRfoDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
   * @summary Create physicalEntity records for validated users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerValidatedUsersToPhysicalEntities(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidatedUsersToPhysicalEntities(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
   * @summary Manually verify user.
   * @param {string} email
   * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerVerifyUserManually(
    email: string,
    manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerVerifyUserManually(email, manuallyVerifyUserRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CognitoGetUserData>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(options?: RawAxiosRequestConfig): AxiosPromise<CognitoGetUserData> {
      return localVarFp.authControllerLogin(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Check if user is authorized
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerLogin(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealthCheck(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealthCheck(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.appControllerHealthCheck']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .appControllerHealthCheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if app is working!
   * @summary HealthCheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealthCheck(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealthCheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserVerificationsApi - axios parameter creator
 * @export
 */
export const UserVerificationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard: async (
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyIdentityCardDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyBirthNumberAndIdentityCard',
        'requestBodyVerifyIdentityCardDto',
        requestBodyVerifyIdentityCardDto,
      )
      const localVarPath = `/user-verification/identity-card`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyIdentityCardDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard: async (
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithRpoDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyIcoBirthNumberAndIdentityCard',
        'requestBodyVerifyWithRpoDto',
        requestBodyVerifyWithRpoDto,
      )
      const localVarPath = `/user-verification/ico-rpo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithRpoDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid: async (
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithEidDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyWithEid',
        'requestBodyVerifyWithEidDto',
        requestBodyVerifyWithEidDto,
      )
      const localVarPath = `/user-verification/eid`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithEidDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserVerificationsApi - functional programming interface
 * @export
 */
export const UserVerificationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserVerificationsApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseVerificationIdentityCardToQueueDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyIcoBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyWithEid(
        requestBodyVerifyWithEidDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UserVerificationsApi.verificationControllerVerifyWithEid']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UserVerificationsApi - factory interface
 * @export
 */
export const UserVerificationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserVerificationsApiFp(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationIdentityCardToQueueDto> {
      return localVarFp
        .verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserVerificationsApi - object-oriented interface
 * @export
 * @class UserVerificationsApi
 * @extends {BaseAPI}
 */
export class UserVerificationsApi extends BaseAPI {
  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserVerificationsApi
   */
  public verificationControllerVerifyBirthNumberAndIdentityCard(
    requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyBirthNumberAndIdentityCard(
        requestBodyVerifyIdentityCardDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via the register of legal entities
   * @summary Validate user via rpo
   * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserVerificationsApi
   */
  public verificationControllerVerifyIcoBirthNumberAndIdentityCard(
    requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
        requestBodyVerifyWithRpoDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
   * @summary Validate user via eid
   * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserVerificationsApi
   */
  public verificationControllerVerifyWithEid(
    requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersManipulationApi - axios parameter creator
 * @export
 */
export const UsersManipulationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail: async (
      changeEmailRequestDto: ChangeEmailRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'changeEmailRequestDto' is not null or undefined
      assertParamExists('userControllerChangeEmail', 'changeEmailRequestDto', changeEmailRequestDto)
      const localVarPath = `/user/change-email`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeEmailRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/get-or-create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/remove-birthnumber`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerSubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/subscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerUnsubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/unsubscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {UserControllerUnsubscribePublicUserTypeEnum} type Type of Gdpr subscription
     * @param {UserControllerUnsubscribePublicUserCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser: async (
      id: string,
      type: UserControllerUnsubscribePublicUserTypeEnum,
      category: UserControllerUnsubscribePublicUserCategoryEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'id', id)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'type', type)
      // verify required parameter 'category' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'category', category)
      const localVarPath = `/user/public/unsubscribe/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {UserControllerUnsubscribePublicUserByExternalIdTypeEnum} type Type of Gdpr subscription
     * @param {UserControllerUnsubscribePublicUserByExternalIdCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUserByExternalId: async (
      id: string,
      type: UserControllerUnsubscribePublicUserByExternalIdTypeEnum,
      category: UserControllerUnsubscribePublicUserByExternalIdCategoryEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'id', id)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'type', type)
      // verify required parameter 'category' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'category', category)
      const localVarPath = `/user/public/unsubscribe/external-id/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersManipulationApi - functional programming interface
 * @export
 */
export const UsersManipulationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersManipulationApiAxiosParamCreator(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerChangeEmail(
      changeEmailRequestDto: ChangeEmailRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerChangeEmail200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerChangeEmail(
        changeEmailRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerChangeEmail']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerGetOrCreateUser(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerGetOrCreateUser(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerGetOrCreateUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRemoveBirthNumber(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerRemoveBirthNumber(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerRemoveBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerSubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {UserControllerUnsubscribePublicUserTypeEnum} type Type of Gdpr subscription
     * @param {UserControllerUnsubscribePublicUserCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUser(
      id: string,
      type: UserControllerUnsubscribePublicUserTypeEnum,
      category: UserControllerUnsubscribePublicUserCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribePublicUser(
        id,
        type,
        category,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribePublicUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {UserControllerUnsubscribePublicUserByExternalIdTypeEnum} type Type of Gdpr subscription
     * @param {UserControllerUnsubscribePublicUserByExternalIdCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUserByExternalId(
      id: string,
      type: UserControllerUnsubscribePublicUserByExternalIdTypeEnum,
      category: UserControllerUnsubscribePublicUserByExternalIdCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerUnsubscribePublicUserByExternalId(
          id,
          type,
          category,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UsersManipulationApi.userControllerUnsubscribePublicUserByExternalId'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UsersManipulationApi - factory interface
 * @export
 */
export const UsersManipulationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersManipulationApiFp(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail(
      changeEmailRequestDto: ChangeEmailRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerChangeEmail200Response> {
      return localVarFp
        .userControllerChangeEmail(changeEmailRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerGetOrCreateUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerRemoveBirthNumber(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {UserControllerUnsubscribePublicUserTypeEnum} type Type of Gdpr subscription
     * @param {UserControllerUnsubscribePublicUserCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser(
      id: string,
      type: UserControllerUnsubscribePublicUserTypeEnum,
      category: UserControllerUnsubscribePublicUserCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUser(id, type, category, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {UserControllerUnsubscribePublicUserByExternalIdTypeEnum} type Type of Gdpr subscription
     * @param {UserControllerUnsubscribePublicUserByExternalIdCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUserByExternalId(
      id: string,
      type: UserControllerUnsubscribePublicUserByExternalIdTypeEnum,
      category: UserControllerUnsubscribePublicUserByExternalIdCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUserByExternalId(id, type, category, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersManipulationApi - object-oriented interface
 * @export
 * @class UsersManipulationApi
 * @extends {BaseAPI}
 */
export class UsersManipulationApi extends BaseAPI {
  /**
   * Change email saved in database for a given cognito user.
   * @summary Change email of cognito user in database
   * @param {ChangeEmailRequestDto} changeEmailRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerChangeEmail(
    changeEmailRequestDto: ChangeEmailRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerChangeEmail(changeEmailRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerGetOrCreateUser(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerGetOrCreateUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerRemoveBirthNumber(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerRemoveBirthNumber(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
   * @summary Create subscribed or unsubscribed log for logged in users
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerSubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
   * @summary Unsubscribe logged user
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerUnsubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by uuid with different categories of subscription
   * @summary Unsubscribe user by uuid
   * @param {string} id
   * @param {UserControllerUnsubscribePublicUserTypeEnum} type Type of Gdpr subscription
   * @param {UserControllerUnsubscribePublicUserCategoryEnum} category Type of Gdpr category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerUnsubscribePublicUser(
    id: string,
    type: UserControllerUnsubscribePublicUserTypeEnum,
    category: UserControllerUnsubscribePublicUserCategoryEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUser(id, type, category, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by external Id from cognito with different categories of subscription
   * @summary Unsubscribe user by external Id
   * @param {string} id
   * @param {UserControllerUnsubscribePublicUserByExternalIdTypeEnum} type Type of Gdpr subscription
   * @param {UserControllerUnsubscribePublicUserByExternalIdCategoryEnum} category Type of Gdpr category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerUnsubscribePublicUserByExternalId(
    id: string,
    type: UserControllerUnsubscribePublicUserByExternalIdTypeEnum,
    category: UserControllerUnsubscribePublicUserByExternalIdCategoryEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUserByExternalId(id, type, category, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const UserControllerUnsubscribePublicUserTypeEnum = {
  License: 'LICENSE',
  Marketing: 'MARKETING',
  FormalCommunication: 'FORMAL_COMMUNICATION',
} as const
export type UserControllerUnsubscribePublicUserTypeEnum =
  (typeof UserControllerUnsubscribePublicUserTypeEnum)[keyof typeof UserControllerUnsubscribePublicUserTypeEnum]
/**
 * @export
 */
export const UserControllerUnsubscribePublicUserCategoryEnum = {
  Taxes: 'TAXES',
  Esbs: 'ESBS',
} as const
export type UserControllerUnsubscribePublicUserCategoryEnum =
  (typeof UserControllerUnsubscribePublicUserCategoryEnum)[keyof typeof UserControllerUnsubscribePublicUserCategoryEnum]
/**
 * @export
 */
export const UserControllerUnsubscribePublicUserByExternalIdTypeEnum = {
  License: 'LICENSE',
  Marketing: 'MARKETING',
  FormalCommunication: 'FORMAL_COMMUNICATION',
} as const
export type UserControllerUnsubscribePublicUserByExternalIdTypeEnum =
  (typeof UserControllerUnsubscribePublicUserByExternalIdTypeEnum)[keyof typeof UserControllerUnsubscribePublicUserByExternalIdTypeEnum]
/**
 * @export
 */
export const UserControllerUnsubscribePublicUserByExternalIdCategoryEnum = {
  Taxes: 'TAXES',
  Esbs: 'ESBS',
} as const
export type UserControllerUnsubscribePublicUserByExternalIdCategoryEnum =
  (typeof UserControllerUnsubscribePublicUserByExternalIdCategoryEnum)[keyof typeof UserControllerUnsubscribePublicUserByExternalIdCategoryEnum]
