/* tslint:disable */
/* eslint-disable */
/**
 * Nest Forms Backend
 * Backend od processing forms and handling the attachments
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

export interface BumpJsonVersionResponseDto {
  /**
   * UUID of the form.
   */
  formId: string
  /**
   * True if the form was successfully bumped.
   */
  success: boolean
}
export interface ClaimMigrationOutput {
  success: boolean
}
export interface ConvertToPdfRequestDto {
  /**
   * Form values in JSON
   */
  jsonData?: object
  /**
   * Used only in the FE requests to display files not yet uploaded to the server.
   */
  clientFiles?: Array<SimplifiedClientFileInfoDto>
}
export interface CreateFormInput {
  formDefinitionSlug: string
}
export interface CreateFormOutput {
  formId: string
}
export interface DownloadTokenResponseDataDto {
  /**
   * Download jwt token
   */
  jwt: string
}
export interface EidUpdateSendFormRequestDto {
  /**
   * Send JSON body of form
   */
  formDataJson?: object
  /**
   * Form signature with metadata
   */
  formSignature?: FormSignatureDto | null
  /**
   * EID token to send form
   */
  eidToken: string
}
export interface FormSignatureDto {
  /**
   * Base64 encoded signature
   */
  signatureBase64: string
  /**
   * POSP ID of the form
   */
  pospID: string
  /**
   * POSP version of the form
   */
  pospVersion: string
  /**
   * JSON version of the form
   */
  jsonVersion: string
  /**
   * Hash of the form data
   */
  formDataHash: string
}

export const FormState = {
  Draft: 'DRAFT',
  Queued: 'QUEUED',
  DeliveredNases: 'DELIVERED_NASES',
  DeliveredGinis: 'DELIVERED_GINIS',
  SendingToSharepoint: 'SENDING_TO_SHAREPOINT',
  Processing: 'PROCESSING',
  Finished: 'FINISHED',
  Rejected: 'REJECTED',
  Error: 'ERROR',
} as const

export type FormState = (typeof FormState)[keyof typeof FormState]

export interface FormUserInformationDto {
  /**
   * User ID (from cognito) who submit this form, can be empty, if it was submitted by user through eID
   */
  userExternalId: string | null
  /**
   * Uri for defining electronic sendbox, if person has it
   */
  mainUri: string | null
  /**
   * Uri for defining electronic sendbox, if person has it
   */
  actorUri: string | null
}
export interface GetFileResponseReducedDto {
  /**
   * id of the record in db
   */
  id: string
  /**
   * Real file name of the file, but is used only for display
   */
  fileName: string
  /**
   * File size in bytes
   */
  fileSize: number
  /**
   * scan result
   */
  status: GetFileResponseReducedDtoStatusEnum
  /**
   * order of this file in respective ginis submission
   */
  ginisOrder: number | null
  /**
   * If the file was uploaded to GINIS
   */
  ginisUploaded: boolean
}

export const GetFileResponseReducedDtoStatusEnum = {
  Uploaded: 'UPLOADED',
  Accepted: 'ACCEPTED',
  Queued: 'QUEUED',
  Scanning: 'SCANNING',
  Safe: 'SAFE',
  Infected: 'INFECTED',
  NotFound: 'NOT_FOUND',
  MoveErrorSafe: 'MOVE_ERROR_SAFE',
  MoveErrorInfected: 'MOVE_ERROR_INFECTED',
  ScanError: 'SCAN_ERROR',
  ScanTimeout: 'SCAN_TIMEOUT',
  ScanNotSuccessful: 'SCAN_NOT_SUCCESSFUL',
  FormIdNotFound: 'FORM_ID_NOT_FOUND',
} as const

export type GetFileResponseReducedDtoStatusEnum =
  (typeof GetFileResponseReducedDtoStatusEnum)[keyof typeof GetFileResponseReducedDtoStatusEnum]

export interface GetFormMetaDto {
  /**
   * Number of forms for each state
   */
  countByState: object
}
export interface GetFormResponseDto {
  /**
   * Change email, on which you can be contacted
   */
  email: string | null
  /**
   * Id of record
   */
  id: string
  /**
   * Create date of record
   */
  createdAt: string
  /**
   * Update date of record
   */
  updatedAt: string
  /**
   * Id of send form from other system, (probably ginis)
   */
  externalId: string | null
  /**
   * User ID (from cognito) who submit this form, can be empty, if it was submitted by user through eID
   */
  userExternalId: string | null
  /**
   * Uri for defining electronic sendbox, if person has it
   */
  mainUri: string | null
  /**
   * Uri for defining electronic sendbox, if person has it
   */
  actorUri: string | null
  /**
   * State of form
   */
  state: GetFormResponseDtoStateEnum
  /**
   * Specific error type
   */
  error: GetFormResponseDtoErrorEnum
  /**
   * Data from ginis saved in our db
   */
  formDataGinis: string | null
  /**
   * Ginis document id generated after registering the submission
   */
  ginisDocumentId: string | null
  /**
   * Data in JSON format
   */
  formDataJson: object | null
  /**
   * Form subject
   */
  formSubject: string
  /**
   * Form signature with metadata
   */
  formSignature?: FormSignatureDto | null
  /**
   * Technical NASES id of sender
   */
  senderId: string | null
  /**
   * Technical NASES id of recipient
   */
  recipientId: string | null
  /**
   * end of submition
   */
  finishSubmission: string | null
  /**
   * Slug of the form definition
   */
  formDefinitionSlug: string
  /**
   * JSON version
   */
  jsonVersion: string
  requiresMigration: boolean
}

export const GetFormResponseDtoStateEnum = {
  Draft: 'DRAFT',
  Queued: 'QUEUED',
  DeliveredNases: 'DELIVERED_NASES',
  DeliveredGinis: 'DELIVERED_GINIS',
  SendingToSharepoint: 'SENDING_TO_SHAREPOINT',
  Processing: 'PROCESSING',
  Finished: 'FINISHED',
  Rejected: 'REJECTED',
  Error: 'ERROR',
} as const

export type GetFormResponseDtoStateEnum =
  (typeof GetFormResponseDtoStateEnum)[keyof typeof GetFormResponseDtoStateEnum]
export const GetFormResponseDtoErrorEnum = {
  None: 'NONE',
  RabbitmqMaxTries: 'RABBITMQ_MAX_TRIES',
  FilesNotYetScanned: 'FILES_NOT_YET_SCANNED',
  UnableToScanFiles: 'UNABLE_TO_SCAN_FILES',
  InfectedFiles: 'INFECTED_FILES',
  NasesSendError: 'NASES_SEND_ERROR',
  GinisSendError: 'GINIS_SEND_ERROR',
  SharepointSendError: 'SHAREPOINT_SEND_ERROR',
  EmailSendError: 'EMAIL_SEND_ERROR',
  WebhookSendError: 'WEBHOOK_SEND_ERROR',
} as const

export type GetFormResponseDtoErrorEnum =
  (typeof GetFormResponseDtoErrorEnum)[keyof typeof GetFormResponseDtoErrorEnum]

export interface GetFormResponseSimpleDto {
  /**
   * Id of record
   */
  id: string
  /**
   * Create date of record
   */
  createdAt: string
  /**
   * Update date of record
   */
  updatedAt: string
  /**
   * State of form
   */
  state: GetFormResponseSimpleDtoStateEnum
  /**
   * Specific error type
   */
  error: GetFormResponseSimpleDtoErrorEnum
  /**
   * Data in JSON format
   */
  formDataJson: object | null
  /**
   * Form subject
   */
  formSubject: string
  /**
   * Slug of the form definition
   */
  formDefinitionSlug: string
}

export const GetFormResponseSimpleDtoStateEnum = {
  Draft: 'DRAFT',
  Queued: 'QUEUED',
  DeliveredNases: 'DELIVERED_NASES',
  DeliveredGinis: 'DELIVERED_GINIS',
  SendingToSharepoint: 'SENDING_TO_SHAREPOINT',
  Processing: 'PROCESSING',
  Finished: 'FINISHED',
  Rejected: 'REJECTED',
  Error: 'ERROR',
} as const

export type GetFormResponseSimpleDtoStateEnum =
  (typeof GetFormResponseSimpleDtoStateEnum)[keyof typeof GetFormResponseSimpleDtoStateEnum]
export const GetFormResponseSimpleDtoErrorEnum = {
  None: 'NONE',
  RabbitmqMaxTries: 'RABBITMQ_MAX_TRIES',
  FilesNotYetScanned: 'FILES_NOT_YET_SCANNED',
  UnableToScanFiles: 'UNABLE_TO_SCAN_FILES',
  InfectedFiles: 'INFECTED_FILES',
  NasesSendError: 'NASES_SEND_ERROR',
  GinisSendError: 'GINIS_SEND_ERROR',
  SharepointSendError: 'SHAREPOINT_SEND_ERROR',
  EmailSendError: 'EMAIL_SEND_ERROR',
  WebhookSendError: 'WEBHOOK_SEND_ERROR',
} as const

export type GetFormResponseSimpleDtoErrorEnum =
  (typeof GetFormResponseSimpleDtoErrorEnum)[keyof typeof GetFormResponseSimpleDtoErrorEnum]

export interface GetFormsResponseDto {
  /**
   * actual page
   */
  currentPage: number
  /**
   * number of items in one page
   */
  pagination: number
  /**
   * Total number of items
   */
  countPages: number
  /**
   * Items
   */
  items: Array<GetFormResponseSimpleDto>
  /**
   * Meta data
   */
  meta: GetFormMetaDto
}
export interface GinisDocumentDetailResponseDto {
  id: string
  dossierId: string
  ownerName: string
  ownerEmail: string
  ownerPhone: string
  documentHistory: Array<GinisSdkHistorieDokumentuWithAssignedCategory>
}
export interface GinisSdkHistorieDokumentuWithAssignedCategory {
  'Id-dokumentu': string
  'Text-zmeny'?: string
  Poznamka?: string
  'Datum-zmeny': string
  'Id-zmenu-provedl': string
  'Id-ktg-zmeny': string
  assignedCategory: GinisSdkHistorieDokumentuWithAssignedCategoryAssignedCategoryEnum
}

export const GinisSdkHistorieDokumentuWithAssignedCategoryAssignedCategoryEnum = {
  DocumentCreated: 'DOCUMENT_CREATED',
} as const

export type GinisSdkHistorieDokumentuWithAssignedCategoryAssignedCategoryEnum =
  (typeof GinisSdkHistorieDokumentuWithAssignedCategoryAssignedCategoryEnum)[keyof typeof GinisSdkHistorieDokumentuWithAssignedCategoryAssignedCategoryEnum]

export interface JsonToXmlV2RequestDto {
  /**
   * JSON form values, if not provided the form data from the database will be used.
   */
  jsonData?: object
}
export interface PostFileResponseDto {
  /**
   * Real file name of the file, but is used only for display
   */
  fileName: string
  /**
   * Name under which is file stored in minio
   */
  minioFileName: string
  /**
   * Form type
   */
  pospId: string
  /**
   * Identifier of sent form
   */
  formId: string
  /**
   * scan result
   */
  status: PostFileResponseDtoStatusEnum
  /**
   * File size in bytes
   */
  fileSize: number
  /**
   * order of this file in respective ginis submission
   */
  ginisOrder: number | null
  /**
   * If the file was uploaded to GINIS
   */
  ginisUploaded: boolean
  /**
   * id of the record in db
   */
  id: string
  /**
   * File id under which is file stored in the scanner
   */
  scannerId?: string | null
  /**
   * Date when file was created
   */
  createdAt: string
  /**
   * Date when file was updated
   */
  updatedAt: string
  /**
   * Info about user who sent the form
   */
  forms?: FormUserInformationDto
}

export const PostFileResponseDtoStatusEnum = {
  Uploaded: 'UPLOADED',
  Accepted: 'ACCEPTED',
  Queued: 'QUEUED',
  Scanning: 'SCANNING',
  Safe: 'SAFE',
  Infected: 'INFECTED',
  NotFound: 'NOT_FOUND',
  MoveErrorSafe: 'MOVE_ERROR_SAFE',
  MoveErrorInfected: 'MOVE_ERROR_INFECTED',
  ScanError: 'SCAN_ERROR',
  ScanTimeout: 'SCAN_TIMEOUT',
  ScanNotSuccessful: 'SCAN_NOT_SUCCESSFUL',
  FormIdNotFound: 'FORM_ID_NOT_FOUND',
} as const

export type PostFileResponseDtoStatusEnum =
  (typeof PostFileResponseDtoStatusEnum)[keyof typeof PostFileResponseDtoStatusEnum]

export interface PrepareMigrationInput {
  guestIdentityId: string
}
export interface PrepareMigrationOutput {
  success: boolean
}
export interface SendFormResponseDto {
  /**
   * Id of record
   */
  id: string
  /**
   * Message response regarding the process
   */
  message: string
  /**
   * Form state
   */
  state: object
}
export interface ServiceRunningDto {
  /**
   * is service running?
   */
  running: boolean
}
export interface SignerDataRequestDto {
  /**
   * Form values in JSON
   */
  formDataJson: object
}
export interface SignerDataResponseDto {
  signatureId: string
  objectId: string
  objectDescription: string
  objectFormatIdentifier: string
  xdcXMLData: string
  xdcIdentifier: string
  xdcVersion: string
  xdcUsedXSD: string
  xsdReferenceURI: string
  xdcUsedXSLT: string
  xslReferenceURI: string
  xslMediaDestinationTypeDescription: string
  xslXSLTLanguage: string
  xslTargetEnvironment: string
  xdcIncludeRefs: boolean
  xdcNamespaceURI: string
}
export interface SimplifiedClientFileInfoDto {
  id: string
  file: object
  status: object
}
export interface StatusResponseDto {
  prisma: ServiceRunningDto
  minio: ServiceRunningDto
  scanner: ServiceRunningDto
}
export interface UpdateFileStatusRequestDto {
  /**
   * scan result
   */
  status: UpdateFileStatusRequestDtoStatusEnum
}

export const UpdateFileStatusRequestDtoStatusEnum = {
  Uploaded: 'UPLOADED',
  Accepted: 'ACCEPTED',
  Queued: 'QUEUED',
  Scanning: 'SCANNING',
  Safe: 'SAFE',
  Infected: 'INFECTED',
  NotFound: 'NOT_FOUND',
  MoveErrorSafe: 'MOVE_ERROR_SAFE',
  MoveErrorInfected: 'MOVE_ERROR_INFECTED',
  ScanError: 'SCAN_ERROR',
  ScanTimeout: 'SCAN_TIMEOUT',
  ScanNotSuccessful: 'SCAN_NOT_SUCCESSFUL',
  FormIdNotFound: 'FORM_ID_NOT_FOUND',
} as const

export type UpdateFileStatusRequestDtoStatusEnum =
  (typeof UpdateFileStatusRequestDtoStatusEnum)[keyof typeof UpdateFileStatusRequestDtoStatusEnum]

export interface UpdateFileStatusResponseDto {
  /**
   * Real file name of the file, but is used only for display
   */
  fileName: string
  /**
   * Name under which is file stored in minio
   */
  minioFileName: string
  /**
   * Form type
   */
  pospId: string
  /**
   * Identifier of sent form
   */
  formId: string
  /**
   * scan result
   */
  status: UpdateFileStatusResponseDtoStatusEnum
  /**
   * File size in bytes
   */
  fileSize: number
  /**
   * order of this file in respective ginis submission
   */
  ginisOrder: number | null
  /**
   * If the file was uploaded to GINIS
   */
  ginisUploaded: boolean
  /**
   * id of the record in db
   */
  id: string
  /**
   * File id under which is file stored in the scanner
   */
  scannerId?: string | null
  /**
   * Date when file was created
   */
  createdAt: string
  /**
   * Date when file was updated
   */
  updatedAt: string
  /**
   * Info about user who sent the form
   */
  forms?: FormUserInformationDto
  /**
   * more info
   */
  message: string
}

export const UpdateFileStatusResponseDtoStatusEnum = {
  Uploaded: 'UPLOADED',
  Accepted: 'ACCEPTED',
  Queued: 'QUEUED',
  Scanning: 'SCANNING',
  Safe: 'SAFE',
  Infected: 'INFECTED',
  NotFound: 'NOT_FOUND',
  MoveErrorSafe: 'MOVE_ERROR_SAFE',
  MoveErrorInfected: 'MOVE_ERROR_INFECTED',
  ScanError: 'SCAN_ERROR',
  ScanTimeout: 'SCAN_TIMEOUT',
  ScanNotSuccessful: 'SCAN_NOT_SUCCESSFUL',
  FormIdNotFound: 'FORM_ID_NOT_FOUND',
} as const

export type UpdateFileStatusResponseDtoStatusEnum =
  (typeof UpdateFileStatusResponseDtoStatusEnum)[keyof typeof UpdateFileStatusResponseDtoStatusEnum]

export interface UpdateFormRequestDto {
  /**
   * Send JSON body of form
   */
  formDataJson?: object
  /**
   * Form signature with metadata
   */
  formSignature?: FormSignatureDto | null
}
export interface XmlToJsonRequestDto {
  /**
   * Form values in XML
   */
  xmlForm: string
}
export interface XmlToJsonResponseDto {
  /**
   * Form values in JSON
   */
  formDataJson: object
  /**
   * Indicates if version confirmation is required
   */
  requiresVersionConfirmation: boolean
}

/**
 * ADMINApi - axios parameter creator
 */
export const ADMINApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Return administration account JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetAdministrationJwt: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/administration-jwt`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return eid user JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetEidJwt: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/admin/eid-jwt`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return technical account JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetTechnicalJwt: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/technical-jwt`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ADMINApi - functional programming interface
 */
export const ADMINApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ADMINApiAxiosParamCreator(configuration)
  return {
    /**
     * Return administration account JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetAdministrationJwt(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetAdministrationJwt(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetAdministrationJwt']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return eid user JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetEidJwt(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerGetEidJwt(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetEidJwt']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return technical account JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetTechnicalJwt(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetTechnicalJwt(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetTechnicalJwt']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ADMINApi - factory interface
 */
export const ADMINApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ADMINApiFp(configuration)
  return {
    /**
     * Return administration account JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetAdministrationJwt(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .adminControllerGetAdministrationJwt(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return eid user JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetEidJwt(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .adminControllerGetEidJwt(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return technical account JWT token
     * @summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetTechnicalJwt(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp
        .adminControllerGetTechnicalJwt(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ADMINApi - object-oriented interface
 */
export class ADMINApi extends BaseAPI {
  /**
   * Return administration account JWT token
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetAdministrationJwt(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetAdministrationJwt(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return eid user JWT token
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetEidJwt(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetEidJwt(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return technical account JWT token
   * @summary
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetTechnicalJwt(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetTechnicalJwt(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConvertApi - axios parameter creator
 */
export const ConvertApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Generates XML form from given JSON data or form data stored in the database. If jsonData is not provided, the form data from the database will be used.
     * @summary Convert JSON to XML
     * @param {string} formId
     * @param {JsonToXmlV2RequestDto} jsonToXmlV2RequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertControllerConvertJsonToXmlV2: async (
      formId: string,
      jsonToXmlV2RequestDto: JsonToXmlV2RequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('convertControllerConvertJsonToXmlV2', 'formId', formId)
      // verify required parameter 'jsonToXmlV2RequestDto' is not null or undefined
      assertParamExists(
        'convertControllerConvertJsonToXmlV2',
        'jsonToXmlV2RequestDto',
        jsonToXmlV2RequestDto,
      )
      const localVarPath = `/convert/json-to-xml-v2/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        jsonToXmlV2RequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Generates PDF for given form data.
     * @summary
     * @param {string} formId
     * @param {ConvertToPdfRequestDto} convertToPdfRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertControllerConvertToPdf: async (
      formId: string,
      convertToPdfRequestDto: ConvertToPdfRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('convertControllerConvertToPdf', 'formId', formId)
      // verify required parameter 'convertToPdfRequestDto' is not null or undefined
      assertParamExists(
        'convertControllerConvertToPdf',
        'convertToPdfRequestDto',
        convertToPdfRequestDto,
      )
      const localVarPath = `/convert/pdf/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        convertToPdfRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Generates JSON form from given XML data and form ID
     * @summary Convert XML to JSON
     * @param {string} formId
     * @param {XmlToJsonRequestDto} xmlToJsonRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertControllerConvertXmlToJson: async (
      formId: string,
      xmlToJsonRequestDto: XmlToJsonRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('convertControllerConvertXmlToJson', 'formId', formId)
      // verify required parameter 'xmlToJsonRequestDto' is not null or undefined
      assertParamExists(
        'convertControllerConvertXmlToJson',
        'xmlToJsonRequestDto',
        xmlToJsonRequestDto,
      )
      const localVarPath = `/convert/xml-to-json/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        xmlToJsonRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConvertApi - functional programming interface
 */
export const ConvertApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConvertApiAxiosParamCreator(configuration)
  return {
    /**
     * Generates XML form from given JSON data or form data stored in the database. If jsonData is not provided, the form data from the database will be used.
     * @summary Convert JSON to XML
     * @param {string} formId
     * @param {JsonToXmlV2RequestDto} jsonToXmlV2RequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async convertControllerConvertJsonToXmlV2(
      formId: string,
      jsonToXmlV2RequestDto: JsonToXmlV2RequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.convertControllerConvertJsonToXmlV2(
        formId,
        jsonToXmlV2RequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConvertApi.convertControllerConvertJsonToXmlV2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Generates PDF for given form data.
     * @summary
     * @param {string} formId
     * @param {ConvertToPdfRequestDto} convertToPdfRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async convertControllerConvertToPdf(
      formId: string,
      convertToPdfRequestDto: ConvertToPdfRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.convertControllerConvertToPdf(
        formId,
        convertToPdfRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConvertApi.convertControllerConvertToPdf']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Generates JSON form from given XML data and form ID
     * @summary Convert XML to JSON
     * @param {string} formId
     * @param {XmlToJsonRequestDto} xmlToJsonRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async convertControllerConvertXmlToJson(
      formId: string,
      xmlToJsonRequestDto: XmlToJsonRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<XmlToJsonResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.convertControllerConvertXmlToJson(
        formId,
        xmlToJsonRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConvertApi.convertControllerConvertXmlToJson']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ConvertApi - factory interface
 */
export const ConvertApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConvertApiFp(configuration)
  return {
    /**
     * Generates XML form from given JSON data or form data stored in the database. If jsonData is not provided, the form data from the database will be used.
     * @summary Convert JSON to XML
     * @param {string} formId
     * @param {JsonToXmlV2RequestDto} jsonToXmlV2RequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertControllerConvertJsonToXmlV2(
      formId: string,
      jsonToXmlV2RequestDto: JsonToXmlV2RequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .convertControllerConvertJsonToXmlV2(formId, jsonToXmlV2RequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Generates PDF for given form data.
     * @summary
     * @param {string} formId
     * @param {ConvertToPdfRequestDto} convertToPdfRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertControllerConvertToPdf(
      formId: string,
      convertToPdfRequestDto: ConvertToPdfRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .convertControllerConvertToPdf(formId, convertToPdfRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Generates JSON form from given XML data and form ID
     * @summary Convert XML to JSON
     * @param {string} formId
     * @param {XmlToJsonRequestDto} xmlToJsonRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    convertControllerConvertXmlToJson(
      formId: string,
      xmlToJsonRequestDto: XmlToJsonRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<XmlToJsonResponseDto> {
      return localVarFp
        .convertControllerConvertXmlToJson(formId, xmlToJsonRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConvertApi - object-oriented interface
 */
export class ConvertApi extends BaseAPI {
  /**
   * Generates XML form from given JSON data or form data stored in the database. If jsonData is not provided, the form data from the database will be used.
   * @summary Convert JSON to XML
   * @param {string} formId
   * @param {JsonToXmlV2RequestDto} jsonToXmlV2RequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public convertControllerConvertJsonToXmlV2(
    formId: string,
    jsonToXmlV2RequestDto: JsonToXmlV2RequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ConvertApiFp(this.configuration)
      .convertControllerConvertJsonToXmlV2(formId, jsonToXmlV2RequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Generates PDF for given form data.
   * @summary
   * @param {string} formId
   * @param {ConvertToPdfRequestDto} convertToPdfRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public convertControllerConvertToPdf(
    formId: string,
    convertToPdfRequestDto: ConvertToPdfRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ConvertApiFp(this.configuration)
      .convertControllerConvertToPdf(formId, convertToPdfRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Generates JSON form from given XML data and form ID
   * @summary Convert XML to JSON
   * @param {string} formId
   * @param {XmlToJsonRequestDto} xmlToJsonRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public convertControllerConvertXmlToJson(
    formId: string,
    xmlToJsonRequestDto: XmlToJsonRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ConvertApiFp(this.configuration)
      .convertControllerConvertXmlToJson(formId, xmlToJsonRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FilesApi - axios parameter creator
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * You can download file byt fileId.
     * @summary Download file by jwt token
     * @param {string} jwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerDownloadFile: async (
      jwtToken: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'jwtToken' is not null or undefined
      assertParamExists('filesControllerDownloadFile', 'jwtToken', jwtToken)
      const localVarPath = `/files/download/file/{jwtToken}`.replace(
        `{${'jwtToken'}}`,
        encodeURIComponent(String(jwtToken)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * To be able to download file you need to obtain jwt token.
     * @summary Obtain jwt token form file download
     * @param {string} formId
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerDownloadToken: async (
      formId: string,
      fileId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('filesControllerDownloadToken', 'formId', formId)
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('filesControllerDownloadToken', 'fileId', fileId)
      const localVarPath = `/files/download/jwt/{formId}/{fileId}`
        .replace(`{${'formId'}}`, encodeURIComponent(String(formId)))
        .replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * If you need list of files and their file statuses based on formId.
     * @summary List of files and statuses based on formId
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerGetFilesStatusByForm: async (
      formId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('filesControllerGetFilesStatusByForm', 'formId', formId)
      const localVarPath = `/files/forms/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * You have to provide scannerId and status which you want to update. Service will return updated file with status saying that file was updated. If not then proper error will be propagated.
     * @summary Endpoint for updating file status from scanner.
     * @param {string} scannerId
     * @param {UpdateFileStatusRequestDto} updateFileStatusRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerUpdateFileStatusScannerId: async (
      scannerId: string,
      updateFileStatusRequestDto: UpdateFileStatusRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scannerId' is not null or undefined
      assertParamExists('filesControllerUpdateFileStatusScannerId', 'scannerId', scannerId)
      // verify required parameter 'updateFileStatusRequestDto' is not null or undefined
      assertParamExists(
        'filesControllerUpdateFileStatusScannerId',
        'updateFileStatusRequestDto',
        updateFileStatusRequestDto,
      )
      const localVarPath = `/files/scan/{scannerId}`.replace(
        `{${'scannerId'}}`,
        encodeURIComponent(String(scannerId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication basic required
      // http basic authentication required
      setBasicAuthToObject(localVarRequestOptions, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateFileStatusRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * You can upload file to form.
     * @summary Upload file to form
     * @param {string} formId
     * @param {File} [file]
     * @param {string} [filename]
     * @param {string} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerUploadFile: async (
      formId: string,
      file?: File,
      filename?: string,
      id?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('filesControllerUploadFile', 'formId', formId)
      const localVarPath = `/files/upload/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)()

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (file !== undefined) {
        localVarFormParams.append('file', file as any)
      }

      if (filename !== undefined) {
        localVarFormParams.append('filename', filename as any)
      }

      if (id !== undefined) {
        localVarFormParams.append('id', id as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FilesApi - functional programming interface
 */
export const FilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
  return {
    /**
     * You can download file byt fileId.
     * @summary Download file by jwt token
     * @param {string} jwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async filesControllerDownloadFile(
      jwtToken: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerDownloadFile(
        jwtToken,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.filesControllerDownloadFile']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * To be able to download file you need to obtain jwt token.
     * @summary Obtain jwt token form file download
     * @param {string} formId
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async filesControllerDownloadToken(
      formId: string,
      fileId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DownloadTokenResponseDataDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerDownloadToken(
        formId,
        fileId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.filesControllerDownloadToken']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * If you need list of files and their file statuses based on formId.
     * @summary List of files and statuses based on formId
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async filesControllerGetFilesStatusByForm(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetFileResponseReducedDto>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerGetFilesStatusByForm(
        formId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.filesControllerGetFilesStatusByForm']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * You have to provide scannerId and status which you want to update. Service will return updated file with status saying that file was updated. If not then proper error will be propagated.
     * @summary Endpoint for updating file status from scanner.
     * @param {string} scannerId
     * @param {UpdateFileStatusRequestDto} updateFileStatusRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async filesControllerUpdateFileStatusScannerId(
      scannerId: string,
      updateFileStatusRequestDto: UpdateFileStatusRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateFileStatusResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.filesControllerUpdateFileStatusScannerId(
          scannerId,
          updateFileStatusRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.filesControllerUpdateFileStatusScannerId']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * You can upload file to form.
     * @summary Upload file to form
     * @param {string} formId
     * @param {File} [file]
     * @param {string} [filename]
     * @param {string} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async filesControllerUploadFile(
      formId: string,
      file?: File,
      filename?: string,
      id?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostFileResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.filesControllerUploadFile(
        formId,
        file,
        filename,
        id,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.filesControllerUploadFile']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FilesApi - factory interface
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FilesApiFp(configuration)
  return {
    /**
     * You can download file byt fileId.
     * @summary Download file by jwt token
     * @param {string} jwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerDownloadFile(
      jwtToken: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .filesControllerDownloadFile(jwtToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * To be able to download file you need to obtain jwt token.
     * @summary Obtain jwt token form file download
     * @param {string} formId
     * @param {string} fileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerDownloadToken(
      formId: string,
      fileId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DownloadTokenResponseDataDto> {
      return localVarFp
        .filesControllerDownloadToken(formId, fileId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * If you need list of files and their file statuses based on formId.
     * @summary List of files and statuses based on formId
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerGetFilesStatusByForm(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<GetFileResponseReducedDto>> {
      return localVarFp
        .filesControllerGetFilesStatusByForm(formId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * You have to provide scannerId and status which you want to update. Service will return updated file with status saying that file was updated. If not then proper error will be propagated.
     * @summary Endpoint for updating file status from scanner.
     * @param {string} scannerId
     * @param {UpdateFileStatusRequestDto} updateFileStatusRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerUpdateFileStatusScannerId(
      scannerId: string,
      updateFileStatusRequestDto: UpdateFileStatusRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UpdateFileStatusResponseDto> {
      return localVarFp
        .filesControllerUpdateFileStatusScannerId(scannerId, updateFileStatusRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * You can upload file to form.
     * @summary Upload file to form
     * @param {string} formId
     * @param {File} [file]
     * @param {string} [filename]
     * @param {string} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    filesControllerUploadFile(
      formId: string,
      file?: File,
      filename?: string,
      id?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PostFileResponseDto> {
      return localVarFp
        .filesControllerUploadFile(formId, file, filename, id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FilesApi - object-oriented interface
 */
export class FilesApi extends BaseAPI {
  /**
   * You can download file byt fileId.
   * @summary Download file by jwt token
   * @param {string} jwtToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public filesControllerDownloadFile(jwtToken: string, options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .filesControllerDownloadFile(jwtToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * To be able to download file you need to obtain jwt token.
   * @summary Obtain jwt token form file download
   * @param {string} formId
   * @param {string} fileId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public filesControllerDownloadToken(
    formId: string,
    fileId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .filesControllerDownloadToken(formId, fileId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * If you need list of files and their file statuses based on formId.
   * @summary List of files and statuses based on formId
   * @param {string} formId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public filesControllerGetFilesStatusByForm(formId: string, options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .filesControllerGetFilesStatusByForm(formId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * You have to provide scannerId and status which you want to update. Service will return updated file with status saying that file was updated. If not then proper error will be propagated.
   * @summary Endpoint for updating file status from scanner.
   * @param {string} scannerId
   * @param {UpdateFileStatusRequestDto} updateFileStatusRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public filesControllerUpdateFileStatusScannerId(
    scannerId: string,
    updateFileStatusRequestDto: UpdateFileStatusRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .filesControllerUpdateFileStatusScannerId(scannerId, updateFileStatusRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * You can upload file to form.
   * @summary Upload file to form
   * @param {string} formId
   * @param {File} [file]
   * @param {string} [filename]
   * @param {string} [id]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public filesControllerUploadFile(
    formId: string,
    file?: File,
    filename?: string,
    id?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .filesControllerUploadFile(formId, file, filename, id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FormMigrationsApi - axios parameter creator
 */
export const FormMigrationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formMigrationsControllerClaimMigration: async (
      formId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('formMigrationsControllerClaimMigration', 'formId', formId)
      const localVarPath = `/forms/migrations/claim/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {PrepareMigrationInput} prepareMigrationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formMigrationsControllerPrepareMigration: async (
      prepareMigrationInput: PrepareMigrationInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'prepareMigrationInput' is not null or undefined
      assertParamExists(
        'formMigrationsControllerPrepareMigration',
        'prepareMigrationInput',
        prepareMigrationInput,
      )
      const localVarPath = `/forms/migrations/prepare`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        prepareMigrationInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FormMigrationsApi - functional programming interface
 */
export const FormMigrationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FormMigrationsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async formMigrationsControllerClaimMigration(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClaimMigrationOutput>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.formMigrationsControllerClaimMigration(formId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FormMigrationsApi.formMigrationsControllerClaimMigration']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {PrepareMigrationInput} prepareMigrationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async formMigrationsControllerPrepareMigration(
      prepareMigrationInput: PrepareMigrationInput,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrepareMigrationOutput>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.formMigrationsControllerPrepareMigration(
          prepareMigrationInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FormMigrationsApi.formMigrationsControllerPrepareMigration']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FormMigrationsApi - factory interface
 */
export const FormMigrationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FormMigrationsApiFp(configuration)
  return {
    /**
     *
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formMigrationsControllerClaimMigration(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ClaimMigrationOutput> {
      return localVarFp
        .formMigrationsControllerClaimMigration(formId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {PrepareMigrationInput} prepareMigrationInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formMigrationsControllerPrepareMigration(
      prepareMigrationInput: PrepareMigrationInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PrepareMigrationOutput> {
      return localVarFp
        .formMigrationsControllerPrepareMigration(prepareMigrationInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FormMigrationsApi - object-oriented interface
 */
export class FormMigrationsApi extends BaseAPI {
  /**
   *
   * @param {string} formId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public formMigrationsControllerClaimMigration(formId: string, options?: RawAxiosRequestConfig) {
    return FormMigrationsApiFp(this.configuration)
      .formMigrationsControllerClaimMigration(formId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {PrepareMigrationInput} prepareMigrationInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public formMigrationsControllerPrepareMigration(
    prepareMigrationInput: PrepareMigrationInput,
    options?: RawAxiosRequestConfig,
  ) {
    return FormMigrationsApiFp(this.configuration)
      .formMigrationsControllerPrepareMigration(prepareMigrationInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FormsApi - axios parameter creator
 */
export const FormsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Updates form JSON version if a newer version is available
     * @summary Bump form JSON version to latest available version
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsControllerBumpJsonVersion: async (
      formId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('formsControllerBumpJsonVersion', 'formId', formId)
      const localVarPath = `/forms/{formId}/bump-version`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FormsApi - functional programming interface
 */
export const FormsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
  return {
    /**
     * Updates form JSON version if a newer version is available
     * @summary Bump form JSON version to latest available version
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async formsControllerBumpJsonVersion(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BumpJsonVersionResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.formsControllerBumpJsonVersion(
        formId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FormsApi.formsControllerBumpJsonVersion']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FormsApi - factory interface
 */
export const FormsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FormsApiFp(configuration)
  return {
    /**
     * Updates form JSON version if a newer version is available
     * @summary Bump form JSON version to latest available version
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsControllerBumpJsonVersion(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<BumpJsonVersionResponseDto> {
      return localVarFp
        .formsControllerBumpJsonVersion(formId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FormsApi - object-oriented interface
 */
export class FormsApi extends BaseAPI {
  /**
   * Updates form JSON version if a newer version is available
   * @summary Bump form JSON version to latest available version
   * @param {string} formId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public formsControllerBumpJsonVersion(formId: string, options?: RawAxiosRequestConfig) {
    return FormsApiFp(this.configuration)
      .formsControllerBumpJsonVersion(formId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FormsV2Api - axios parameter creator
 */
export const FormsV2ApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary
     * @param {CreateFormInput} createFormInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsV2ControllerCreateForm: async (
      createFormInput: CreateFormInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createFormInput' is not null or undefined
      assertParamExists('formsV2ControllerCreateForm', 'createFormInput', createFormInput)
      const localVarPath = `/forms-v2`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createFormInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FormsV2Api - functional programming interface
 */
export const FormsV2ApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FormsV2ApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary
     * @param {CreateFormInput} createFormInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async formsV2ControllerCreateForm(
      createFormInput: CreateFormInput,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateFormOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.formsV2ControllerCreateForm(
        createFormInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FormsV2Api.formsV2ControllerCreateForm']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FormsV2Api - factory interface
 */
export const FormsV2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FormsV2ApiFp(configuration)
  return {
    /**
     *
     * @summary
     * @param {CreateFormInput} createFormInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    formsV2ControllerCreateForm(
      createFormInput: CreateFormInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateFormOutput> {
      return localVarFp
        .formsV2ControllerCreateForm(createFormInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FormsV2Api - object-oriented interface
 */
export class FormsV2Api extends BaseAPI {
  /**
   *
   * @summary
   * @param {CreateFormInput} createFormInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public formsV2ControllerCreateForm(
    createFormInput: CreateFormInput,
    options?: RawAxiosRequestConfig,
  ) {
    return FormsV2ApiFp(this.configuration)
      .formsV2ControllerCreateForm(createFormInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * GinisApi - axios parameter creator
 */
export const GinisApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Return GINIS document by ID
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ginisControllerGetGinisDocumentByFormId: async (
      formId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('ginisControllerGetGinisDocumentByFormId', 'formId', formId)
      const localVarPath = `/ginis/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * GinisApi - functional programming interface
 */
export const GinisApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GinisApiAxiosParamCreator(configuration)
  return {
    /**
     * Return GINIS document by ID
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ginisControllerGetGinisDocumentByFormId(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GinisDocumentDetailResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ginisControllerGetGinisDocumentByFormId(formId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['GinisApi.ginisControllerGetGinisDocumentByFormId']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * GinisApi - factory interface
 */
export const GinisApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GinisApiFp(configuration)
  return {
    /**
     * Return GINIS document by ID
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ginisControllerGetGinisDocumentByFormId(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GinisDocumentDetailResponseDto> {
      return localVarFp
        .ginisControllerGetGinisDocumentByFormId(formId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * GinisApi - object-oriented interface
 */
export class GinisApi extends BaseAPI {
  /**
   * Return GINIS document by ID
   * @summary
   * @param {string} formId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public ginisControllerGetGinisDocumentByFormId(formId: string, options?: RawAxiosRequestConfig) {
    return GinisApiFp(this.configuration)
      .ginisControllerGetGinisDocumentByFormId(formId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * HealthcheckApi - axios parameter creator
 */
export const HealthcheckApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Hello world!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerGetHello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * HealthcheckApi - functional programming interface
 */
export const HealthcheckApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HealthcheckApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Hello world!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerGetHello(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerGetHello(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['HealthcheckApi.appControllerGetHello']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * HealthcheckApi - factory interface
 */
export const HealthcheckApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = HealthcheckApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Hello world!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerGetHello(options?: RawAxiosRequestConfig): AxiosPromise<object> {
      return localVarFp.appControllerGetHello(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * HealthcheckApi - object-oriented interface
 */
export class HealthcheckApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Hello world!
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public appControllerGetHello(options?: RawAxiosRequestConfig) {
    return HealthcheckApiFp(this.configuration)
      .appControllerGetHello(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * NasesApi - axios parameter creator
 */
export const NasesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Archive form (hide from user but keep in database)
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerDeleteForm: async (
      formId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('nasesControllerDeleteForm', 'formId', formId)
      const localVarPath = `/nases/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return form by ID and by logged user
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerGetForm: async (
      formId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('nasesControllerGetForm', 'formId', formId)
      const localVarPath = `/nases/form/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get paginated forms
     * @summary Get paginated forms
     * @param {string} [currentPage] Page number
     * @param {string} [pagination] Number of items per page
     * @param {Array<FormState>} [states] Forms in which states are searched - when omitted, all forms of the user are searched
     * @param {boolean} [userCanEdit] Get only forms in such a state, that user can still edit it.
     * @param {string} [formDefinitionSlug] Slug of the form definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerGetForms: async (
      currentPage?: string,
      pagination?: string,
      states?: Array<FormState>,
      userCanEdit?: boolean,
      formDefinitionSlug?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/nases/forms`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (currentPage !== undefined) {
        localVarQueryParameter['currentPage'] = currentPage
      }

      if (pagination !== undefined) {
        localVarQueryParameter['pagination'] = pagination
      }

      if (states) {
        localVarQueryParameter['states'] = states
      }

      if (userCanEdit !== undefined) {
        localVarQueryParameter['userCanEdit'] = userCanEdit
      }

      if (formDefinitionSlug !== undefined) {
        localVarQueryParameter['formDefinitionSlug'] = formDefinitionSlug
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
     * @summary
     * @param {string} formId
     * @param {UpdateFormRequestDto} updateFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerSendAndUpdateForm: async (
      formId: string,
      updateFormRequestDto: UpdateFormRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('nasesControllerSendAndUpdateForm', 'formId', formId)
      // verify required parameter 'updateFormRequestDto' is not null or undefined
      assertParamExists(
        'nasesControllerSendAndUpdateForm',
        'updateFormRequestDto',
        updateFormRequestDto,
      )
      const localVarPath = `/nases/send-and-update-form/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateFormRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
     * @summary
     * @param {string} formId
     * @param {EidUpdateSendFormRequestDto} eidUpdateSendFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerSendAndUpdateFormEid: async (
      formId: string,
      eidUpdateSendFormRequestDto: EidUpdateSendFormRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('nasesControllerSendAndUpdateFormEid', 'formId', formId)
      // verify required parameter 'eidUpdateSendFormRequestDto' is not null or undefined
      assertParamExists(
        'nasesControllerSendAndUpdateFormEid',
        'eidUpdateSendFormRequestDto',
        eidUpdateSendFormRequestDto,
      )
      const localVarPath = `/nases/eid/send-and-update-form/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        eidUpdateSendFormRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update form
     * @summary
     * @param {string} formId
     * @param {UpdateFormRequestDto} updateFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerUpdateForm: async (
      formId: string,
      updateFormRequestDto: UpdateFormRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('nasesControllerUpdateForm', 'formId', formId)
      // verify required parameter 'updateFormRequestDto' is not null or undefined
      assertParamExists('nasesControllerUpdateForm', 'updateFormRequestDto', updateFormRequestDto)
      const localVarPath = `/nases/update-form/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateFormRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NasesApi - functional programming interface
 */
export const NasesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = NasesApiAxiosParamCreator(configuration)
  return {
    /**
     * Archive form (hide from user but keep in database)
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nasesControllerDeleteForm(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nasesControllerDeleteForm(
        formId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NasesApi.nasesControllerDeleteForm']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return form by ID and by logged user
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nasesControllerGetForm(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFormResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nasesControllerGetForm(
        formId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NasesApi.nasesControllerGetForm']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get paginated forms
     * @summary Get paginated forms
     * @param {string} [currentPage] Page number
     * @param {string} [pagination] Number of items per page
     * @param {Array<FormState>} [states] Forms in which states are searched - when omitted, all forms of the user are searched
     * @param {boolean} [userCanEdit] Get only forms in such a state, that user can still edit it.
     * @param {string} [formDefinitionSlug] Slug of the form definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nasesControllerGetForms(
      currentPage?: string,
      pagination?: string,
      states?: Array<FormState>,
      userCanEdit?: boolean,
      formDefinitionSlug?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFormsResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nasesControllerGetForms(
        currentPage,
        pagination,
        states,
        userCanEdit,
        formDefinitionSlug,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NasesApi.nasesControllerGetForms']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
     * @summary
     * @param {string} formId
     * @param {UpdateFormRequestDto} updateFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nasesControllerSendAndUpdateForm(
      formId: string,
      updateFormRequestDto: UpdateFormRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendFormResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nasesControllerSendAndUpdateForm(
        formId,
        updateFormRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NasesApi.nasesControllerSendAndUpdateForm']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
     * @summary
     * @param {string} formId
     * @param {EidUpdateSendFormRequestDto} eidUpdateSendFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nasesControllerSendAndUpdateFormEid(
      formId: string,
      eidUpdateSendFormRequestDto: EidUpdateSendFormRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendFormResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nasesControllerSendAndUpdateFormEid(
        formId,
        eidUpdateSendFormRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NasesApi.nasesControllerSendAndUpdateFormEid']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Update form
     * @summary
     * @param {string} formId
     * @param {UpdateFormRequestDto} updateFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async nasesControllerUpdateForm(
      formId: string,
      updateFormRequestDto: UpdateFormRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFormResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.nasesControllerUpdateForm(
        formId,
        updateFormRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NasesApi.nasesControllerUpdateForm']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * NasesApi - factory interface
 */
export const NasesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = NasesApiFp(configuration)
  return {
    /**
     * Archive form (hide from user but keep in database)
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerDeleteForm(formId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .nasesControllerDeleteForm(formId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return form by ID and by logged user
     * @summary
     * @param {string} formId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerGetForm(
      formId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetFormResponseDto> {
      return localVarFp
        .nasesControllerGetForm(formId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get paginated forms
     * @summary Get paginated forms
     * @param {string} [currentPage] Page number
     * @param {string} [pagination] Number of items per page
     * @param {Array<FormState>} [states] Forms in which states are searched - when omitted, all forms of the user are searched
     * @param {boolean} [userCanEdit] Get only forms in such a state, that user can still edit it.
     * @param {string} [formDefinitionSlug] Slug of the form definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerGetForms(
      currentPage?: string,
      pagination?: string,
      states?: Array<FormState>,
      userCanEdit?: boolean,
      formDefinitionSlug?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetFormsResponseDto> {
      return localVarFp
        .nasesControllerGetForms(
          currentPage,
          pagination,
          states,
          userCanEdit,
          formDefinitionSlug,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
     * @summary
     * @param {string} formId
     * @param {UpdateFormRequestDto} updateFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerSendAndUpdateForm(
      formId: string,
      updateFormRequestDto: UpdateFormRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SendFormResponseDto> {
      return localVarFp
        .nasesControllerSendAndUpdateForm(formId, updateFormRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
     * @summary
     * @param {string} formId
     * @param {EidUpdateSendFormRequestDto} eidUpdateSendFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerSendAndUpdateFormEid(
      formId: string,
      eidUpdateSendFormRequestDto: EidUpdateSendFormRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SendFormResponseDto> {
      return localVarFp
        .nasesControllerSendAndUpdateFormEid(formId, eidUpdateSendFormRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update form
     * @summary
     * @param {string} formId
     * @param {UpdateFormRequestDto} updateFormRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    nasesControllerUpdateForm(
      formId: string,
      updateFormRequestDto: UpdateFormRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetFormResponseDto> {
      return localVarFp
        .nasesControllerUpdateForm(formId, updateFormRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * NasesApi - object-oriented interface
 */
export class NasesApi extends BaseAPI {
  /**
   * Archive form (hide from user but keep in database)
   * @summary
   * @param {string} formId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nasesControllerDeleteForm(formId: string, options?: RawAxiosRequestConfig) {
    return NasesApiFp(this.configuration)
      .nasesControllerDeleteForm(formId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return form by ID and by logged user
   * @summary
   * @param {string} formId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nasesControllerGetForm(formId: string, options?: RawAxiosRequestConfig) {
    return NasesApiFp(this.configuration)
      .nasesControllerGetForm(formId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get paginated forms
   * @summary Get paginated forms
   * @param {string} [currentPage] Page number
   * @param {string} [pagination] Number of items per page
   * @param {Array<FormState>} [states] Forms in which states are searched - when omitted, all forms of the user are searched
   * @param {boolean} [userCanEdit] Get only forms in such a state, that user can still edit it.
   * @param {string} [formDefinitionSlug] Slug of the form definition
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nasesControllerGetForms(
    currentPage?: string,
    pagination?: string,
    states?: Array<FormState>,
    userCanEdit?: boolean,
    formDefinitionSlug?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return NasesApiFp(this.configuration)
      .nasesControllerGetForms(
        currentPage,
        pagination,
        states,
        userCanEdit,
        formDefinitionSlug,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
   * @summary
   * @param {string} formId
   * @param {UpdateFormRequestDto} updateFormRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nasesControllerSendAndUpdateForm(
    formId: string,
    updateFormRequestDto: UpdateFormRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return NasesApiFp(this.configuration)
      .nasesControllerSendAndUpdateForm(formId, updateFormRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used for updating from and sending it to NASES. First is form updated then send to rabbitmq, then is controlled if everything is okay and files are scanned and after that is send to NASES
   * @summary
   * @param {string} formId
   * @param {EidUpdateSendFormRequestDto} eidUpdateSendFormRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nasesControllerSendAndUpdateFormEid(
    formId: string,
    eidUpdateSendFormRequestDto: EidUpdateSendFormRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return NasesApiFp(this.configuration)
      .nasesControllerSendAndUpdateFormEid(formId, eidUpdateSendFormRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update form
   * @summary
   * @param {string} formId
   * @param {UpdateFormRequestDto} updateFormRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public nasesControllerUpdateForm(
    formId: string,
    updateFormRequestDto: UpdateFormRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return NasesApiFp(this.configuration)
      .nasesControllerUpdateForm(formId, updateFormRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SignerApi - axios parameter creator
 */
export const SignerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Generates signer data including XML and metadata for form signing
     * @summary Get signer data
     * @param {string} formId
     * @param {SignerDataRequestDto} signerDataRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signerControllerGetSignerData: async (
      formId: string,
      signerDataRequestDto: SignerDataRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'formId' is not null or undefined
      assertParamExists('signerControllerGetSignerData', 'formId', formId)
      // verify required parameter 'signerDataRequestDto' is not null or undefined
      assertParamExists(
        'signerControllerGetSignerData',
        'signerDataRequestDto',
        signerDataRequestDto,
      )
      const localVarPath = `/signer/get-signer-data/{formId}`.replace(
        `{${'formId'}}`,
        encodeURIComponent(String(formId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication cognitoGuestIdentityId required
      await setApiKeyToObject(localVarHeaderParameter, 'X-Cognito-Guest-Identity-Id', configuration)

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signerDataRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SignerApi - functional programming interface
 */
export const SignerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SignerApiAxiosParamCreator(configuration)
  return {
    /**
     * Generates signer data including XML and metadata for form signing
     * @summary Get signer data
     * @param {string} formId
     * @param {SignerDataRequestDto} signerDataRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signerControllerGetSignerData(
      formId: string,
      signerDataRequestDto: SignerDataRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignerDataResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signerControllerGetSignerData(
        formId,
        signerDataRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['SignerApi.signerControllerGetSignerData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * SignerApi - factory interface
 */
export const SignerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = SignerApiFp(configuration)
  return {
    /**
     * Generates signer data including XML and metadata for form signing
     * @summary Get signer data
     * @param {string} formId
     * @param {SignerDataRequestDto} signerDataRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signerControllerGetSignerData(
      formId: string,
      signerDataRequestDto: SignerDataRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignerDataResponseDto> {
      return localVarFp
        .signerControllerGetSignerData(formId, signerDataRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SignerApi - object-oriented interface
 */
export class SignerApi extends BaseAPI {
  /**
   * Generates signer data including XML and metadata for form signing
   * @summary Get signer data
   * @param {string} formId
   * @param {SignerDataRequestDto} signerDataRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public signerControllerGetSignerData(
    formId: string,
    signerDataRequestDto: SignerDataRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return SignerApiFp(this.configuration)
      .signerControllerGetSignerData(formId, signerDataRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StatusesApi - axios parameter creator
 */
export const StatusesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint checks if forms backend is running
     * @summary Check scanner backend status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsFormsRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/status/scanner`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks if minio is running
     * @summary Check minio status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsMinioRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/status/minio`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks if prisma is running
     * @summary Check prisma status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsPrismaRunning: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/status/prisma`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint checks all services status
     * @summary Check all services status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/status`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StatusesApi - functional programming interface
 */
export const StatusesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StatusesApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint checks if forms backend is running
     * @summary Check scanner backend status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerIsFormsRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusControllerIsFormsRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerIsFormsRunning']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks if minio is running
     * @summary Check minio status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerIsMinioRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusControllerIsMinioRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerIsMinioRunning']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks if prisma is running
     * @summary Check prisma status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerIsPrismaRunning(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRunningDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.statusControllerIsPrismaRunning(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerIsPrismaRunning']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint checks all services status
     * @summary Check all services status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async statusControllerStatus(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.statusControllerStatus(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StatusesApi.statusControllerStatus']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StatusesApi - factory interface
 */
export const StatusesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StatusesApiFp(configuration)
  return {
    /**
     * This endpoint checks if forms backend is running
     * @summary Check scanner backend status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsFormsRunning(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .statusControllerIsFormsRunning(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks if minio is running
     * @summary Check minio status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsMinioRunning(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .statusControllerIsMinioRunning(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks if prisma is running
     * @summary Check prisma status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerIsPrismaRunning(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ServiceRunningDto> {
      return localVarFp
        .statusControllerIsPrismaRunning(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint checks all services status
     * @summary Check all services status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    statusControllerStatus(options?: RawAxiosRequestConfig): AxiosPromise<StatusResponseDto> {
      return localVarFp.statusControllerStatus(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * StatusesApi - object-oriented interface
 */
export class StatusesApi extends BaseAPI {
  /**
   * This endpoint checks if forms backend is running
   * @summary Check scanner backend status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public statusControllerIsFormsRunning(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerIsFormsRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks if minio is running
   * @summary Check minio status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public statusControllerIsMinioRunning(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerIsMinioRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks if prisma is running
   * @summary Check prisma status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public statusControllerIsPrismaRunning(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerIsPrismaRunning(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint checks all services status
   * @summary Check all services status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public statusControllerStatus(options?: RawAxiosRequestConfig) {
    return StatusesApiFp(this.configuration)
      .statusControllerStatus(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
