/* tslint:disable */
/* eslint-disable */
/**
 * User Module - city account
 * User module use for store additional data for users and authentication against Azure AD
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface CognitoGetUserData
 */
export interface CognitoGetUserData {
  /**
   * Id from cognito
   * @type {string}
   * @memberof CognitoGetUserData
   */
  sub?: string
  /**
   * Is email verified in cognito?
   * @type {string}
   * @memberof CognitoGetUserData
   */
  email_verified?: string
  /**
   * Which type of verified tier it is?
   * @type {string}
   * @memberof CognitoGetUserData
   */
  'custom:tier'?: CognitoGetUserDataCustomtierEnum
  /**
   * First name
   * @type {string}
   * @memberof CognitoGetUserData
   */
  given_name?: string
  /**
   * Last name
   * @type {string}
   * @memberof CognitoGetUserData
   */
  family_name?: string
  /**
   * email
   * @type {string}
   * @memberof CognitoGetUserData
   */
  email?: string
  /**
   * User Id from cognito, same as sub
   * @type {string}
   * @memberof CognitoGetUserData
   */
  idUser: string
  /**
   * User create date
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserCreateDate: string
  /**
   * User updated date
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserLastModifiedDate: string
  /**
   * Is user enabled?
   * @type {boolean}
   * @memberof CognitoGetUserData
   */
  Enabled: boolean
  /**
   * Cognito confirmation statue
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserStatus?: CognitoGetUserDataUserStatusEnum
}

export const CognitoGetUserDataCustomtierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type CognitoGetUserDataCustomtierEnum =
  (typeof CognitoGetUserDataCustomtierEnum)[keyof typeof CognitoGetUserDataCustomtierEnum]
export const CognitoGetUserDataUserStatusEnum = {
  Archived: 'ARCHIVED',
  Compromised: 'COMPROMISED',
  Confirmed: 'CONFIRMED',
  ForceChangePassword: 'FORCE_CHANGE_PASSWORD',
  ResetRequired: 'RESET_REQUIRED',
  Unconfirmed: 'UNCONFIRMED',
  Unknown: 'UNKNOWN',
} as const

export type CognitoGetUserDataUserStatusEnum =
  (typeof CognitoGetUserDataUserStatusEnum)[keyof typeof CognitoGetUserDataUserStatusEnum]

/**
 *
 * @export
 * @interface GdprDataDto
 */
export interface GdprDataDto {
  /**
   * Type of Gdpr subscription
   * @type {string}
   * @memberof GdprDataDto
   */
  type: GdprDataDtoTypeEnum
  /**
   * Type of Gdpr category
   * @type {string}
   * @memberof GdprDataDto
   */
  category: GdprDataDtoCategoryEnum
}

export const GdprDataDtoTypeEnum = {
  License: 'LICENSE',
  Dataprocessing: 'DATAPROCESSING',
  Marketing: 'MARKETING',
  Analytics: 'ANALYTICS',
} as const

export type GdprDataDtoTypeEnum = (typeof GdprDataDtoTypeEnum)[keyof typeof GdprDataDtoTypeEnum]
export const GdprDataDtoCategoryEnum = {
  Swimmingpools: 'SWIMMINGPOOLS',
  Taxes: 'TAXES',
  City: 'CITY',
  Esbs: 'ESBS',
} as const

export type GdprDataDtoCategoryEnum =
  (typeof GdprDataDtoCategoryEnum)[keyof typeof GdprDataDtoCategoryEnum]

/**
 *
 * @export
 * @interface RequestBodyVerifyIdentityCardDto
 */
export interface RequestBodyVerifyIdentityCardDto {
  /**
   * Birth number for check
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  birthNumber: string
  /**
   * String of identitiy card
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  turnstileToken: string
}
/**
 *
 * @export
 * @interface RequestGdprDataDto
 */
export interface RequestGdprDataDto {
  /**
   *
   * @type {Array<GdprDataDto>}
   * @memberof RequestGdprDataDto
   */
  gdprData: Array<GdprDataDto>
}
/**
 *
 * @export
 * @interface RequestPublicSubscriptionDto
 */
export interface RequestPublicSubscriptionDto {
  /**
   * Email to subscribe
   * @type {string}
   * @memberof RequestPublicSubscriptionDto
   */
  email: string
  /**
   *
   * @type {Array<GdprDataDto>}
   * @memberof RequestPublicSubscriptionDto
   */
  gdprData: Array<GdprDataDto>
}
/**
 *
 * @export
 * @interface ResponseCustomErrorVerificationIdentityCardDto
 */
export interface ResponseCustomErrorVerificationIdentityCardDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  errorName: ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
} as const

export type ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseGdprDataDataDto
 */
export interface ResponseGdprDataDataDto {
  /**
   *
   * @type {string}
   * @memberof ResponseGdprDataDataDto
   */
  category: ResponseGdprDataDataDtoCategoryEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprDataDataDto
   */
  type: ResponseGdprDataDataDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprDataDataDto
   */
  subType: ResponseGdprDataDataDtoSubTypeEnum
}

export const ResponseGdprDataDataDtoCategoryEnum = {
  Swimmingpools: 'SWIMMINGPOOLS',
  Taxes: 'TAXES',
  City: 'CITY',
  Esbs: 'ESBS',
} as const

export type ResponseGdprDataDataDtoCategoryEnum =
  (typeof ResponseGdprDataDataDtoCategoryEnum)[keyof typeof ResponseGdprDataDataDtoCategoryEnum]
export const ResponseGdprDataDataDtoTypeEnum = {
  Unsubscribe: 'unsubscribe',
  Subscribe: 'subscribe',
} as const

export type ResponseGdprDataDataDtoTypeEnum =
  (typeof ResponseGdprDataDataDtoTypeEnum)[keyof typeof ResponseGdprDataDataDtoTypeEnum]
export const ResponseGdprDataDataDtoSubTypeEnum = {
  Unsubscribe: 'unsubscribe',
  Subscribe: 'subscribe',
} as const

export type ResponseGdprDataDataDtoSubTypeEnum =
  (typeof ResponseGdprDataDataDtoSubTypeEnum)[keyof typeof ResponseGdprDataDataDtoSubTypeEnum]

/**
 *
 * @export
 * @interface ResponseGdprDataDto
 */
export interface ResponseGdprDataDto {
  /**
   * Local ID of user
   * @type {string}
   * @memberof ResponseGdprDataDto
   */
  id: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof ResponseGdprDataDto
   */
  createdAt: string
  /**
   * Last updated timestamp
   * @type {string}
   * @memberof ResponseGdprDataDto
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   * @type {string}
   * @memberof ResponseGdprDataDto
   */
  externalId?: string
  /**
   * Email
   * @type {string}
   * @memberof ResponseGdprDataDto
   */
  email: string
  /**
   * Birth number
   * @type {string}
   * @memberof ResponseGdprDataDto
   */
  birthNumber: string
  /**
   * Subscription Data in array
   * @type {Array<ResponseGdprDataDataDto>}
   * @memberof ResponseGdprDataDto
   */
  gdprData: Array<ResponseGdprDataDataDto>
}
/**
 *
 * @export
 * @interface ResponseInternalServerErrorDto
 */
export interface ResponseInternalServerErrorDto {
  /**
   * statusCode
   * @type {number}
   * @memberof ResponseInternalServerErrorDto
   */
  statusCode: number
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseInternalServerErrorDto
   */
  message: string
}
/**
 *
 * @export
 * @interface ResponseNotFoundErrorVerificationIdentityCardDto
 */
export interface ResponseNotFoundErrorVerificationIdentityCardDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  errorName: string
}
/**
 *
 * @export
 * @interface ResponseUserByBirthNumberDto
 */
export interface ResponseUserByBirthNumberDto {
  /**
   * userBirthNumber
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  birthNumber: string
  /**
   * email
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  email: string
  /**
   * Cognito Id
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  externalId: string
  /**
   * Special user attribute for user segmentation
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  userAttribute?: string
  /**
   * Tier from cognito
   * @type {object}
   * @memberof ResponseUserByBirthNumberDto
   */
  cognitoAttributes?: object
}
/**
 *
 * @export
 * @interface ResponseVerificationIdentityCardToQueueDto
 */
export interface ResponseVerificationIdentityCardToQueueDto {
  /**
   * number of status code
   * @type {number}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  statusCode: number
  /**
   * status
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  status: string
  /**
   * Message about update
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  message: ResponseVerificationIdentityCardToQueueDtoMessageEnum
  /**
   * Error if exists
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  errorName?: ResponseVerificationIdentityCardToQueueDtoErrorNameEnum
}

export const ResponseVerificationIdentityCardToQueueDtoMessageEnum = {
  SendToQueue: 'SendToQueue',
  AlreadyVerified: 'AlreadyVerified',
} as const

export type ResponseVerificationIdentityCardToQueueDtoMessageEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum]
export const ResponseVerificationIdentityCardToQueueDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
} as const

export type ResponseVerificationIdentityCardToQueueDtoErrorNameEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum]

/**
 * ADMINApi - axios parameter creator
 * @export
 */
export const ADMINApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber: async (
      birthNumber: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('adminControllerGetUserDataByBirthNumber', 'birthNumber', birthNumber)
      const localVarPath = `/admin/userdata`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      if (birthNumber !== undefined) {
        localVarQueryParameter['birthNumber'] = birthNumber
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ADMINApi - functional programming interface
 * @export
 */
export const ADMINApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ADMINApiAxiosParamCreator(configuration)
  return {
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserByBirthNumberDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumber(
          birthNumber,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * ADMINApi - factory interface
 * @export
 */
export const ADMINApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ADMINApiFp(configuration)
  return {
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: any,
    ): AxiosPromise<ResponseUserByBirthNumberDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumber(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ADMINApi - object-oriented interface
 * @export
 * @class ADMINApi
 * @extends {BaseAPI}
 */
export class ADMINApi extends BaseAPI {
  /**
   * Get user data by birthnumber
   * @summary Get user data
   * @param {string} birthNumber userBirthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerGetUserDataByBirthNumber(
    birthNumber: string,
    options?: AxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumber(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CognitoGetUserData>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(options?: any): AxiosPromise<CognitoGetUserData> {
      return localVarFp.authControllerLogin(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Check if user is authorized
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerLogin(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealthCheck(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealthCheck(options)
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck(options?: any): AxiosPromise<string> {
      return localVarFp
        .appControllerHealthCheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if app is working!
   * @summary HealthCheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealthCheck(options?: AxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealthCheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserVerificationsApi - axios parameter creator
 * @export
 */
export const UserVerificationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard: async (
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyIdentityCardDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyBirthNumberAndIdentityCard',
        'requestBodyVerifyIdentityCardDto',
        requestBodyVerifyIdentityCardDto,
      )
      const localVarPath = `/user-verification/identity-card`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyIdentityCardDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserVerificationsApi - functional programming interface
 * @export
 */
export const UserVerificationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserVerificationsApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseVerificationIdentityCardToQueueDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UserVerificationsApi - factory interface
 * @export
 */
export const UserVerificationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserVerificationsApiFp(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: any,
    ): AxiosPromise<ResponseVerificationIdentityCardToQueueDto> {
      return localVarFp
        .verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserVerificationsApi - object-oriented interface
 * @export
 * @class UserVerificationsApi
 * @extends {BaseAPI}
 */
export class UserVerificationsApi extends BaseAPI {
  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserVerificationsApi
   */
  public verificationControllerVerifyBirthNumberAndIdentityCard(
    requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
    options?: AxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyBirthNumberAndIdentityCard(
        requestBodyVerifyIdentityCardDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersManipulationApi - axios parameter creator
 * @export
 */
export const UsersManipulationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/get-or-create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/remove-birthnumber`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerSubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/subscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribePublicUser: async (
      requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPublicSubscriptionDto' is not null or undefined
      assertParamExists(
        'userControllerSubscribePublicUser',
        'requestPublicSubscriptionDto',
        requestPublicSubscriptionDto,
      )
      const localVarPath = `/user/public/subscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPublicSubscriptionDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerUnsubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/unsubscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS'} type Type of Gdpr subscription
     * @param {'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS'} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser: async (
      id: string,
      type: 'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS',
      category: 'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS',
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'id', id)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'type', type)
      // verify required parameter 'category' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'category', category)
      const localVarPath = `/user/public/unsubscribe/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersManipulationApi - functional programming interface
 * @export
 */
export const UsersManipulationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersManipulationApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerGetOrCreateUser(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGdprDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetOrCreateUser(
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRemoveBirthNumber(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGdprDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemoveBirthNumber(
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGdprDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerSubscribePublicUser(
      requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGdprDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSubscribePublicUser(
        requestPublicSubscriptionDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGdprDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS'} type Type of Gdpr subscription
     * @param {'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS'} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUser(
      id: string,
      type: 'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS',
      category: 'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS',
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribePublicUser(
        id,
        type,
        category,
        options,
      )
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)
    },
  }
}

/**
 * UsersManipulationApi - factory interface
 * @export
 */
export const UsersManipulationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersManipulationApiFp(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser(options?: any): AxiosPromise<ResponseGdprDataDto> {
      return localVarFp
        .userControllerGetOrCreateUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber(options?: any): AxiosPromise<ResponseGdprDataDto> {
      return localVarFp
        .userControllerRemoveBirthNumber(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: any,
    ): AxiosPromise<ResponseGdprDataDto> {
      return localVarFp
        .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribePublicUser(
      requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
      options?: any,
    ): AxiosPromise<ResponseGdprDataDto> {
      return localVarFp
        .userControllerSubscribePublicUser(requestPublicSubscriptionDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: any,
    ): AxiosPromise<ResponseGdprDataDto> {
      return localVarFp
        .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS'} type Type of Gdpr subscription
     * @param {'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS'} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser(
      id: string,
      type: 'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS',
      category: 'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS',
      options?: any,
    ): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUser(id, type, category, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersManipulationApi - object-oriented interface
 * @export
 * @class UsersManipulationApi
 * @extends {BaseAPI}
 */
export class UsersManipulationApi extends BaseAPI {
  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerGetOrCreateUser(options?: AxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerGetOrCreateUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerRemoveBirthNumber(options?: AxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerRemoveBirthNumber(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
   * @summary Create subscribed or unsubscribed log for logged in users
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerSubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: AxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
   * @summary Create subscribed or unsubscribed log for logged in users
   * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerSubscribePublicUser(
    requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
    options?: AxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerSubscribePublicUser(requestPublicSubscriptionDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
   * @summary Unsubscribe logged user
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerUnsubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: AxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by uuid with different categories of subscription
   * @summary Unsubscribe user by uuid
   * @param {string} id
   * @param {'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS'} type Type of Gdpr subscription
   * @param {'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS'} category Type of Gdpr category
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerUnsubscribePublicUser(
    id: string,
    type: 'LICENSE' | 'DATAPROCESSING' | 'MARKETING' | 'ANALYTICS',
    category: 'SWIMMINGPOOLS' | 'TAXES' | 'CITY' | 'ESBS',
    options?: AxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUser(id, type, category, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
