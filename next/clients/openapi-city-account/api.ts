/* tslint:disable */
/* eslint-disable */
/**
 * User Module - city account
 * User module use for store additional data for users and authentication against Azure AD
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface CognitoGetUserData
 */
export interface CognitoGetUserData {
  /**
   * Id from cognito
   * @type {string}
   * @memberof CognitoGetUserData
   */
  sub?: string
  /**
   * Is email verified in cognito?
   * @type {string}
   * @memberof CognitoGetUserData
   */
  email_verified?: string
  /**
   * Usually name of the company
   * @type {string}
   * @memberof CognitoGetUserData
   */
  name?: string
  /**
   * Which type of verified tier it is?
   * @type {string}
   * @memberof CognitoGetUserData
   */
  'custom:tier'?: CognitoGetUserDataCustomtierEnum
  /**
   * Which type of account it is?
   * @type {string}
   * @memberof CognitoGetUserData
   */
  'custom:account_type'?: CognitoGetUserDataCustomaccountTypeEnum
  /**
   * First name
   * @type {string}
   * @memberof CognitoGetUserData
   */
  given_name?: string
  /**
   * Last name
   * @type {string}
   * @memberof CognitoGetUserData
   */
  family_name?: string
  /**
   * email
   * @type {string}
   * @memberof CognitoGetUserData
   */
  email?: string
  /**
   * User Id from cognito, same as sub
   * @type {string}
   * @memberof CognitoGetUserData
   */
  idUser: string
  /**
   * User create date
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserCreateDate: string
  /**
   * User updated date
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserLastModifiedDate: string
  /**
   * Is user enabled?
   * @type {boolean}
   * @memberof CognitoGetUserData
   */
  Enabled: boolean
  /**
   * Cognito confirmation statue
   * @type {string}
   * @memberof CognitoGetUserData
   */
  UserStatus?: CognitoGetUserDataUserStatusEnum
}

export const CognitoGetUserDataCustomtierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type CognitoGetUserDataCustomtierEnum =
  (typeof CognitoGetUserDataCustomtierEnum)[keyof typeof CognitoGetUserDataCustomtierEnum]
export const CognitoGetUserDataCustomaccountTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type CognitoGetUserDataCustomaccountTypeEnum =
  (typeof CognitoGetUserDataCustomaccountTypeEnum)[keyof typeof CognitoGetUserDataCustomaccountTypeEnum]
export const CognitoGetUserDataUserStatusEnum = {
  Archived: 'ARCHIVED',
  Compromised: 'COMPROMISED',
  Confirmed: 'CONFIRMED',
  ForceChangePassword: 'FORCE_CHANGE_PASSWORD',
  ResetRequired: 'RESET_REQUIRED',
  Unconfirmed: 'UNCONFIRMED',
  Unknown: 'UNKNOWN',
} as const

export type CognitoGetUserDataUserStatusEnum =
  (typeof CognitoGetUserDataUserStatusEnum)[keyof typeof CognitoGetUserDataUserStatusEnum]

/**
 *
 * @export
 * @interface GdprDataDto
 */
export interface GdprDataDto {
  /**
   * Type of Gdpr subscription
   * @type {object}
   * @memberof GdprDataDto
   */
  type: object
  /**
   * Type of Gdpr category
   * @type {object}
   * @memberof GdprDataDto
   */
  category: object
}
/**
 *
 * @export
 * @interface LegalPersonVerifyState
 */
export interface LegalPersonVerifyState {
  /**
   * Id of given legal person\'s email, if exists
   * @type {string}
   * @memberof LegalPersonVerifyState
   */
  legalPersonId?: string
  /**
   * Marks if the legal person with given email is in database.
   * @type {boolean}
   * @memberof LegalPersonVerifyState
   */
  isInDatabase: boolean
  /**
   * Marks if the legal person with given email is in cognito.
   * @type {boolean}
   * @memberof LegalPersonVerifyState
   */
  isInCognito: boolean
  /**
   * Current cognito tier, marks the status of verifying.
   * @type {string}
   * @memberof LegalPersonVerifyState
   */
  cognitoTier: LegalPersonVerifyStateCognitoTierEnum
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   * @type {string}
   * @memberof LegalPersonVerifyState
   */
  birthNumberIcoAlreadyExists?: string
  /**
   * Marks if the legal person with given email is verified.
   * @type {boolean}
   * @memberof LegalPersonVerifyState
   */
  isVerified: boolean
  /**
   * Possible cause of the verify error.
   * @type {string}
   * @memberof LegalPersonVerifyState
   */
  possibleCause?: string
}

export const LegalPersonVerifyStateCognitoTierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type LegalPersonVerifyStateCognitoTierEnum =
  (typeof LegalPersonVerifyStateCognitoTierEnum)[keyof typeof LegalPersonVerifyStateCognitoTierEnum]

/**
 *
 * @export
 * @interface RequestBodyVerifyIdentityCardDto
 */
export interface RequestBodyVerifyIdentityCardDto {
  /**
   * Birth number for check
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  birthNumber: string
  /**
   * String of identitiy card
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   * @type {string}
   * @memberof RequestBodyVerifyIdentityCardDto
   */
  turnstileToken: string
}
/**
 *
 * @export
 * @interface RequestBodyVerifyWithEidDto
 */
export interface RequestBodyVerifyWithEidDto {
  /**
   * Token returned by https://fix.slovensko-sk-api.bratislava.sk/login
   * @type {string}
   * @memberof RequestBodyVerifyWithEidDto
   */
  oboToken: string
}
/**
 *
 * @export
 * @interface RequestBodyVerifyWithRpoDto
 */
export interface RequestBodyVerifyWithRpoDto {
  /**
   * ico
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  ico: string
  /**
   * Birth number of legal entity\'s executive
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  birthNumber: string
  /**
   * Identity card of legal entity\'s executive
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   * @type {string}
   * @memberof RequestBodyVerifyWithRpoDto
   */
  turnstileToken: string
}
/**
 *
 * @export
 * @interface RequestGdprDataDto
 */
export interface RequestGdprDataDto {
  /**
   *
   * @type {Array<GdprDataDto>}
   * @memberof RequestGdprDataDto
   */
  gdprData: Array<GdprDataDto>
}
/**
 *
 * @export
 * @interface RequestPublicSubscriptionDto
 */
export interface RequestPublicSubscriptionDto {
  /**
   * Email to subscribe
   * @type {string}
   * @memberof RequestPublicSubscriptionDto
   */
  email: string
  /**
   *
   * @type {Array<GdprDataDto>}
   * @memberof RequestPublicSubscriptionDto
   */
  gdprData: Array<GdprDataDto>
}
/**
 *
 * @export
 * @interface ResponseCustomErrorVerificationEidDto
 */
export interface ResponseCustomErrorVerificationEidDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseCustomErrorVerificationEidDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseCustomErrorVerificationEidDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseCustomErrorVerificationEidDto
   */
  errorName: ResponseCustomErrorVerificationEidDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationEidDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  LegalEntitiesNotFound: 'LEGAL_ENTITIES_NOT_FOUND',
  UserNotFoundInLegalEntity: 'USER_NOT_FOUND_IN_LEGAL_ENTITY',
  NoIfFoundForStatutory: 'NO_IF_FOUND_FOR_STATUTORY',
  UnexpectedMagproxyResponseError: 'UNEXPECTED_MAGPROXY_RESPONSE_ERROR',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
} as const

export type ResponseCustomErrorVerificationEidDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseCustomErrorVerificationIdentityCardDto
 */
export interface ResponseCustomErrorVerificationIdentityCardDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseCustomErrorVerificationIdentityCardDto
   */
  errorName: ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  LegalEntitiesNotFound: 'LEGAL_ENTITIES_NOT_FOUND',
  UserNotFoundInLegalEntity: 'USER_NOT_FOUND_IN_LEGAL_ENTITY',
  NoIfFoundForStatutory: 'NO_IF_FOUND_FOR_STATUTORY',
  UnexpectedMagproxyResponseError: 'UNEXPECTED_MAGPROXY_RESPONSE_ERROR',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
} as const

export type ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseGdprUserDataDto
 */
export interface ResponseGdprUserDataDto {
  /**
   *
   * @type {string}
   * @memberof ResponseGdprUserDataDto
   */
  category: ResponseGdprUserDataDtoCategoryEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprUserDataDto
   */
  type: ResponseGdprUserDataDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof ResponseGdprUserDataDto
   */
  subType: ResponseGdprUserDataDtoSubTypeEnum
}

export const ResponseGdprUserDataDtoCategoryEnum = {
  Swimmingpools: 'SWIMMINGPOOLS',
  Taxes: 'TAXES',
  City: 'CITY',
  Esbs: 'ESBS',
} as const

export type ResponseGdprUserDataDtoCategoryEnum =
  (typeof ResponseGdprUserDataDtoCategoryEnum)[keyof typeof ResponseGdprUserDataDtoCategoryEnum]
export const ResponseGdprUserDataDtoTypeEnum = {
  License: 'LICENSE',
  Dataprocessing: 'DATAPROCESSING',
  Marketing: 'MARKETING',
  Analytics: 'ANALYTICS',
} as const

export type ResponseGdprUserDataDtoTypeEnum =
  (typeof ResponseGdprUserDataDtoTypeEnum)[keyof typeof ResponseGdprUserDataDtoTypeEnum]
export const ResponseGdprUserDataDtoSubTypeEnum = {
  Unsubscribe: 'unsubscribe',
  Subscribe: 'subscribe',
} as const

export type ResponseGdprUserDataDtoSubTypeEnum =
  (typeof ResponseGdprUserDataDtoSubTypeEnum)[keyof typeof ResponseGdprUserDataDtoSubTypeEnum]

/**
 *
 * @export
 * @interface ResponseInternalServerErrorDto
 */
export interface ResponseInternalServerErrorDto {
  /**
   * statusCode
   * @type {number}
   * @memberof ResponseInternalServerErrorDto
   */
  statusCode: number
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseInternalServerErrorDto
   */
  message: string
}
/**
 *
 * @export
 * @interface ResponseNotFoundErrorVerificationIdentityCardDto
 */
export interface ResponseNotFoundErrorVerificationIdentityCardDto {
  /**
   * status
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  status: string
  /**
   * Message about error
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  message: string
  /**
   * Error name for decoding.
   * @type {string}
   * @memberof ResponseNotFoundErrorVerificationIdentityCardDto
   */
  errorName: string
}
/**
 *
 * @export
 * @interface ResponseUserByBirthNumberDto
 */
export interface ResponseUserByBirthNumberDto {
  /**
   * userBirthNumber
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  birthNumber: string
  /**
   * email
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  email: string
  /**
   * Cognito Id
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  externalId: string
  /**
   * Special user attribute for user segmentation
   * @type {string}
   * @memberof ResponseUserByBirthNumberDto
   */
  userAttribute?: string
  /**
   * Tier from cognito
   * @type {object}
   * @memberof ResponseUserByBirthNumberDto
   */
  cognitoAttributes?: object
}
/**
 *
 * @export
 * @interface ResponseUserDataBasicDto
 */
export interface ResponseUserDataBasicDto {
  /**
   * Local ID of user
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  id: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  createdAt: string
  /**
   * Last updated timestamp
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  externalId?: string
  /**
   * Email
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  email: string
  /**
   * Birth number
   * @type {string}
   * @memberof ResponseUserDataBasicDto
   */
  birthNumber: string
}
/**
 *
 * @export
 * @interface ResponseUserDataDto
 */
export interface ResponseUserDataDto {
  /**
   * Local ID of user
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  id: string
  /**
   * Created timestamp
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  createdAt: string
  /**
   * Last updated timestamp
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  externalId?: string
  /**
   * Email
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  email: string
  /**
   * Birth number
   * @type {string}
   * @memberof ResponseUserDataDto
   */
  birthNumber: string
  /**
   * Subscription Data in array
   * @type {Array<ResponseGdprUserDataDto>}
   * @memberof ResponseUserDataDto
   */
  gdprData: Array<ResponseGdprUserDataDto>
}
/**
 *
 * @export
 * @interface ResponseVerificationDto
 */
export interface ResponseVerificationDto {
  /**
   * number of status code
   * @type {number}
   * @memberof ResponseVerificationDto
   */
  statusCode: number
  /**
   * status
   * @type {string}
   * @memberof ResponseVerificationDto
   */
  status: string
  /**
   * Message about update
   * @type {string}
   * @memberof ResponseVerificationDto
   */
  message: string
  /**
   * Error if exists
   * @type {string}
   * @memberof ResponseVerificationDto
   */
  errorName?: ResponseVerificationDtoErrorNameEnum
}

export const ResponseVerificationDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  LegalEntitiesNotFound: 'LEGAL_ENTITIES_NOT_FOUND',
  UserNotFoundInLegalEntity: 'USER_NOT_FOUND_IN_LEGAL_ENTITY',
  NoIfFoundForStatutory: 'NO_IF_FOUND_FOR_STATUTORY',
  UnexpectedMagproxyResponseError: 'UNEXPECTED_MAGPROXY_RESPONSE_ERROR',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
} as const

export type ResponseVerificationDtoErrorNameEnum =
  (typeof ResponseVerificationDtoErrorNameEnum)[keyof typeof ResponseVerificationDtoErrorNameEnum]

/**
 *
 * @export
 * @interface ResponseVerificationIdentityCardToQueueDto
 */
export interface ResponseVerificationIdentityCardToQueueDto {
  /**
   * number of status code
   * @type {number}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  statusCode: number
  /**
   * status
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  status: string
  /**
   * Message about update
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  message: ResponseVerificationIdentityCardToQueueDtoMessageEnum
  /**
   * Error if exists
   * @type {string}
   * @memberof ResponseVerificationIdentityCardToQueueDto
   */
  errorName?: ResponseVerificationIdentityCardToQueueDtoErrorNameEnum
}

export const ResponseVerificationIdentityCardToQueueDtoMessageEnum = {
  SendToQueue: 'SendToQueue',
  AlreadyVerified: 'AlreadyVerified',
} as const

export type ResponseVerificationIdentityCardToQueueDtoMessageEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum]
export const ResponseVerificationIdentityCardToQueueDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  LegalEntitiesNotFound: 'LEGAL_ENTITIES_NOT_FOUND',
  UserNotFoundInLegalEntity: 'USER_NOT_FOUND_IN_LEGAL_ENTITY',
  NoIfFoundForStatutory: 'NO_IF_FOUND_FOR_STATUTORY',
  UnexpectedMagproxyResponseError: 'UNEXPECTED_MAGPROXY_RESPONSE_ERROR',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
} as const

export type ResponseVerificationIdentityCardToQueueDtoErrorNameEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum]

/**
 *
 * @export
 * @interface UserVerifyState
 */
export interface UserVerifyState {
  /**
   * Id of given user\'s email, if exists
   * @type {string}
   * @memberof UserVerifyState
   */
  userId?: string
  /**
   * Marks if the user with given email is in database.
   * @type {boolean}
   * @memberof UserVerifyState
   */
  isInDatabase: boolean
  /**
   * Marks if the user with given email is in cognito.
   * @type {boolean}
   * @memberof UserVerifyState
   */
  isInCognito: boolean
  /**
   * Current cognito tier, marks the status of verifying.
   * @type {string}
   * @memberof UserVerifyState
   */
  cognitoTier: UserVerifyStateCognitoTierEnum
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   * @type {string}
   * @memberof UserVerifyState
   */
  birthNumberAlreadyExists?: string
  /**
   * Marks if the user with given email is verified.
   * @type {boolean}
   * @memberof UserVerifyState
   */
  isVerified: boolean
  /**
   * Possible cause of the verify error.
   * @type {string}
   * @memberof UserVerifyState
   */
  possibleCause?: string
}

export const UserVerifyStateCognitoTierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type UserVerifyStateCognitoTierEnum =
  (typeof UserVerifyStateCognitoTierEnum)[keyof typeof UserVerifyStateCognitoTierEnum]

/**
 * ADMINApi - axios parameter creator
 * @export
 */
export const ADMINApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Return the state of user verifying.
     * @summary Get legal person\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckLegalPersonVerifyState: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerCheckLegalPersonVerifyState', 'email', email)
      const localVarPath = `/admin/status/legal-person/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerCheckUserVerifyState', 'email', email)
      const localVarPath = `/admin/status/user/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber: async (
      birthNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('adminControllerGetUserDataByBirthNumber', 'birthNumber', birthNumber)
      const localVarPath = `/admin/userdata`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      if (birthNumber !== undefined) {
        localVarQueryParameter['birthNumber'] = birthNumber
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ADMINApi - functional programming interface
 * @export
 */
export const ADMINApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ADMINApiAxiosParamCreator(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get legal person\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCheckLegalPersonVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LegalPersonVerifyState>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerCheckLegalPersonVerifyState(email, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerCheckLegalPersonVerifyState']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCheckUserVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserVerifyState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerCheckUserVerifyState(
        email,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerCheckUserVerifyState']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserByBirthNumberDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumber(
          birthNumber,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetUserDataByBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ADMINApi - factory interface
 * @export
 */
export const ADMINApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ADMINApiFp(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get legal person\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckLegalPersonVerifyState(
      email: string,
      options?: any,
    ): AxiosPromise<LegalPersonVerifyState> {
      return localVarFp
        .adminControllerCheckLegalPersonVerifyState(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState(
      email: string,
      options?: any,
    ): AxiosPromise<UserVerifyState> {
      return localVarFp
        .adminControllerCheckUserVerifyState(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: any,
    ): AxiosPromise<ResponseUserByBirthNumberDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumber(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ADMINApi - object-oriented interface
 * @export
 * @class ADMINApi
 * @extends {BaseAPI}
 */
export class ADMINApi extends BaseAPI {
  /**
   * Return the state of user verifying.
   * @summary Get legal person\'s verify state
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerCheckLegalPersonVerifyState(
    email: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerCheckLegalPersonVerifyState(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Return the state of user verifying.
   * @summary Get user\'s verify state
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerCheckUserVerifyState(email: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerCheckUserVerifyState(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get user data by birthnumber
   * @summary Get user data
   * @param {string} birthNumber userBirthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ADMINApi
   */
  public adminControllerGetUserDataByBirthNumber(
    birthNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumber(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CognitoGetUserData>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(options?: any): AxiosPromise<CognitoGetUserData> {
      return localVarFp.authControllerLogin(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Check if user is authorized
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authControllerLogin(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealthCheck(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealthCheck(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.appControllerHealthCheck']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck(options?: any): AxiosPromise<string> {
      return localVarFp
        .appControllerHealthCheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if app is working!
   * @summary HealthCheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public appControllerHealthCheck(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealthCheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserVerificationsApi - axios parameter creator
 * @export
 */
export const UserVerificationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard: async (
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyIdentityCardDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyBirthNumberAndIdentityCard',
        'requestBodyVerifyIdentityCardDto',
        requestBodyVerifyIdentityCardDto,
      )
      const localVarPath = `/user-verification/identity-card`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyIdentityCardDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard: async (
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithRpoDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyIcoBirthNumberAndIdentityCard',
        'requestBodyVerifyWithRpoDto',
        requestBodyVerifyWithRpoDto,
      )
      const localVarPath = `/user-verification/ico-rpo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithRpoDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid: async (
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithEidDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyWithEid',
        'requestBodyVerifyWithEidDto',
        requestBodyVerifyWithEidDto,
      )
      const localVarPath = `/user-verification/eid`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithEidDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserVerificationsApi - functional programming interface
 * @export
 */
export const UserVerificationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserVerificationsApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseVerificationIdentityCardToQueueDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyIcoBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyWithEid(
        requestBodyVerifyWithEidDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UserVerificationsApi.verificationControllerVerifyWithEid']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UserVerificationsApi - factory interface
 * @export
 */
export const UserVerificationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserVerificationsApiFp(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: any,
    ): AxiosPromise<ResponseVerificationIdentityCardToQueueDto> {
      return localVarFp
        .verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: any,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: any,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserVerificationsApi - object-oriented interface
 * @export
 * @class UserVerificationsApi
 * @extends {BaseAPI}
 */
export class UserVerificationsApi extends BaseAPI {
  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserVerificationsApi
   */
  public verificationControllerVerifyBirthNumberAndIdentityCard(
    requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyBirthNumberAndIdentityCard(
        requestBodyVerifyIdentityCardDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via the register of legal entities
   * @summary Validate user via rpo
   * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserVerificationsApi
   */
  public verificationControllerVerifyIcoBirthNumberAndIdentityCard(
    requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
        requestBodyVerifyWithRpoDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
   * @summary Validate user via eid
   * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserVerificationsApi
   */
  public verificationControllerVerifyWithEid(
    requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersManipulationApi - axios parameter creator
 * @export
 */
export const UsersManipulationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {string} newEmail New email for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail: async (
      newEmail: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'newEmail' is not null or undefined
      assertParamExists('userControllerChangeEmail', 'newEmail', newEmail)
      const localVarPath = `/user/change-email`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (newEmail !== undefined) {
        localVarQueryParameter['newEmail'] = newEmail
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/get-or-create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/remove-birthnumber`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerSubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/subscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribePublicUser: async (
      requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPublicSubscriptionDto' is not null or undefined
      assertParamExists(
        'userControllerSubscribePublicUser',
        'requestPublicSubscriptionDto',
        requestPublicSubscriptionDto,
      )
      const localVarPath = `/user/public/subscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPublicSubscriptionDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerUnsubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/unsubscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'id', id)
      const localVarPath = `/user/public/unsubscribe/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersManipulationApi - functional programming interface
 * @export
 */
export const UsersManipulationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersManipulationApiAxiosParamCreator(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {string} newEmail New email for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerChangeEmail(
      newEmail: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataBasicDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerChangeEmail(
        newEmail,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerChangeEmail']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerGetOrCreateUser(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerGetOrCreateUser(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerGetOrCreateUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRemoveBirthNumber(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerRemoveBirthNumber(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerRemoveBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerSubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerSubscribePublicUser(
      requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSubscribePublicUser(
        requestPublicSubscriptionDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerSubscribePublicUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUser(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribePublicUser(
        id,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribePublicUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UsersManipulationApi - factory interface
 * @export
 */
export const UsersManipulationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersManipulationApiFp(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {string} newEmail New email for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail(
      newEmail: string,
      options?: any,
    ): AxiosPromise<ResponseUserDataBasicDto> {
      return localVarFp
        .userControllerChangeEmail(newEmail, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser(options?: any): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerGetOrCreateUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber(options?: any): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerRemoveBirthNumber(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: any,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerSubscribePublicUser(
      requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
      options?: any,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerSubscribePublicUser(requestPublicSubscriptionDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: any,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser(id: string, options?: any): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUser(id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersManipulationApi - object-oriented interface
 * @export
 * @class UsersManipulationApi
 * @extends {BaseAPI}
 */
export class UsersManipulationApi extends BaseAPI {
  /**
   * Change email saved in database for a given cognito user.
   * @summary Change email of cognito user in database
   * @param {string} newEmail New email for a user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerChangeEmail(newEmail: string, options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerChangeEmail(newEmail, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerGetOrCreateUser(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerGetOrCreateUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerRemoveBirthNumber(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerRemoveBirthNumber(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
   * @summary Create subscribed or unsubscribed log for logged in users
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerSubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWTtoken. You can send subscription data from model in array, or you can send empty body and it will automatically create subscribed data.
   * @summary Create subscribed or unsubscribed log for logged in users
   * @param {RequestPublicSubscriptionDto} requestPublicSubscriptionDto
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerSubscribePublicUser(
    requestPublicSubscriptionDto: RequestPublicSubscriptionDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerSubscribePublicUser(requestPublicSubscriptionDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
   * @summary Unsubscribe logged user
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerUnsubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by uuid with different categories of subscription
   * @summary Unsubscribe user by uuid
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof UsersManipulationApi
   */
  public userControllerUnsubscribePublicUser(id: string, options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUser(id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
