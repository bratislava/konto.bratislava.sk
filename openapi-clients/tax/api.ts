/* tslint:disable */
/* eslint-disable */
/**
 * Nest tax backend
 * Backend for payment taxes and connection to Noris
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

export interface CreateBirthNumbersResponseDto {
  /**
   * An array of birth numbers which were added to TaxPayers in this batch.
   */
  birthNumbers: Array<string>
}
/**
 * delivery_method
 */

export const DeliveryMethodNamed = {
  Edesk: 'EDESK',
  Postal: 'POSTAL',
  CityAccount: 'CITY_ACCOUNT',
} as const

export type DeliveryMethodNamed = (typeof DeliveryMethodNamed)[keyof typeof DeliveryMethodNamed]

/**
 * Payment status
 */

export const InstallmentPaidStatusEnum = {
  NotPaid: 'NOT_PAID',
  PartiallyPaid: 'PARTIALLY_PAID',
  Paid: 'PAID',
  OverPaid: 'OVER_PAID',
  AfterDueDate: 'AFTER_DUE_DATE',
} as const

export type InstallmentPaidStatusEnum =
  (typeof InstallmentPaidStatusEnum)[keyof typeof InstallmentPaidStatusEnum]

export interface RequestAdminCreateTestingTaxDto {
  /**
   * Year of tax
   */
  year: number
  /**
   * Fake Noris Data
   */
  norisData: RequestAdminCreateTestingTaxNorisData
}
export interface RequestAdminCreateTestingTaxNorisData {
  /**
   * Delivery method for the tax
   */
  deliveryMethod: RequestAdminCreateTestingTaxNorisDataDeliveryMethodEnum | null
  /**
   * Birth number in format with slash
   */
  fakeBirthNumber: string
  /**
   * Full name and surname of the tax payer
   */
  nameSurname: string
  /**
   * Total tax amount as string
   */
  taxTotal: string
  /**
   * Amount already paid as string
   */
  alreadyPaid: string
  /**
   * Date of tax ruling (d치tum pr치voplatnosti)
   */
  dateTaxRuling: string | null
}

export const RequestAdminCreateTestingTaxNorisDataDeliveryMethodEnum = {
  E: 'E',
  O: 'O',
  P: 'P',
} as const

export type RequestAdminCreateTestingTaxNorisDataDeliveryMethodEnum =
  (typeof RequestAdminCreateTestingTaxNorisDataDeliveryMethodEnum)[keyof typeof RequestAdminCreateTestingTaxNorisDataDeliveryMethodEnum]

export interface RequestAdminDeleteTaxDto {
  /**
   * Year of tax
   */
  year: number
  /**
   * Birth number in format with slash
   */
  birthNumber: string
}
export interface RequestPostNorisLoadDataDto {
  /**
   * Year of tax
   */
  year: number
  /**
   * Birth numbers or ALL
   */
  birthNumbers: object
}
export interface RequestPostNorisPaymentDataLoadDto {
  /**
   * Year of tax
   */
  year: number
  /**
   * From date - if is not set, take one from database
   */
  fromDate: string
  /**
   * To date - if is not set, take one from database
   */
  toDate: string
  /**
   * If you want to count also overpayments.
   */
  overPayments: object
}
export interface RequestPostReportingSendReport {
  /**
   * Date since when reports should be generated
   */
  date: string
  /**
   * Emails the report will be sent to
   */
  emailRecipients: Array<string>
}
export interface RequestUpdateNorisDeliveryMethodsDto {
  /**
   * The new delivery methods for the birth numbers. For city account notification, date must be provided.
   */
  data: { [key: string]: RequestUpdateNorisDeliveryMethodsDtoDataValue }
}
/**
 * @type RequestUpdateNorisDeliveryMethodsDtoDataValue
 */
export type RequestUpdateNorisDeliveryMethodsDtoDataValue =
  | RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf
  | RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf1

export interface RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf {
  deliveryMethod: RequestUpdateNorisDeliveryMethodsDtoDataValueOneOfDeliveryMethodEnum
  date: string
}

export const RequestUpdateNorisDeliveryMethodsDtoDataValueOneOfDeliveryMethodEnum = {
  O: 'O',
} as const

export type RequestUpdateNorisDeliveryMethodsDtoDataValueOneOfDeliveryMethodEnum =
  (typeof RequestUpdateNorisDeliveryMethodsDtoDataValueOneOfDeliveryMethodEnum)[keyof typeof RequestUpdateNorisDeliveryMethodsDtoDataValueOneOfDeliveryMethodEnum]

export interface RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf1 {
  deliveryMethod: RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf1DeliveryMethodEnum
}

export const RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf1DeliveryMethodEnum = {
  E: 'E',
  P: 'P',
} as const

export type RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf1DeliveryMethodEnum =
  (typeof RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf1DeliveryMethodEnum)[keyof typeof RequestUpdateNorisDeliveryMethodsDtoDataValueOneOf1DeliveryMethodEnum]

export interface ResponseActiveInstallmentDto {
  /**
   * Remaining amount to pay in the installment
   */
  remainingAmount: number
  /**
   * Variable symbol
   */
  variableSymbol: string
  /**
   * QR code
   */
  qrCode: string
}
export interface ResponseApartmentTaxDetailDto {
  /**
   * Type of apartment
   */
  type: TaxDetailareaType
  /**
   * Base of tax in m^2
   */
  base: number
  /**
   * Amount of tax in Eur
   */
  amount: number
}

export interface ResponseConstructionTaxDetailDto {
  /**
   * Type of construction
   */
  type: TaxDetailareaType
  /**
   * Base of tax in m^2
   */
  base: number
  /**
   * Amount of tax in Eur
   */
  amount: number
}

export interface ResponseErrorDto {
  /**
   * statusCode
   */
  statusCode: number
  /**
   * status
   */
  status: string
  /**
   * Message about error
   */
  message: string
  /**
   * Name of the error
   */
  errorName: object
}
export interface ResponseGetPaymentUrlDto {
  /**
   * url to redirect to GP webpay
   */
  url: string
}
export interface ResponseGetTaxesBodyDto {
  /**
   * Numeric id of tax
   */
  id: number
  /**
   * Uuid of tax
   */
  uuid: string
  /**
   * Date of tax creation in backend
   */
  createdAt: string
  /**
   * Amount to paid in cents
   */
  amount: number
  /**
   * Year of tax
   */
  year: number
  /**
   * Amount already paid
   */
  paidAmount: number
  /**
   * Type of paid status
   */
  paidStatus: TaxPaidStatusEnum
  /**
   * Is tax payable (is tax from this year), and frontend can show payment data?
   */
  isPayable: boolean
}

export interface ResponseGetTaxesDto {
  /**
   * Birth number of user is in Noris actual or historical Tax
   */
  isInNoris: boolean
  items: Array<ResponseGetTaxesBodyDto>
  /**
   * Assigned tax administrator
   */
  taxAdministrator: ResponseTaxAdministratorDto | null
}
export interface ResponseGetTaxesListBodyDto {
  /**
   * Date of tax delivery to city account
   */
  createdAt?: string
  /**
   * Amount to be paid in cents
   */
  amountToBePaid?: number
  /**
   * Year of tax
   */
  year: number
  /**
   * Type of paid status
   */
  status: TaxStatusEnum
}

export interface ResponseGetTaxesListDto {
  /**
   * Tax availability status
   */
  availabilityStatus: TaxAvailabilityStatus
  items: Array<ResponseGetTaxesListBodyDto>
  /**
   * Assigned tax administrator
   */
  taxAdministrator: ResponseTaxAdministratorDto | null
}

export interface ResponseGroundTaxDetailDto {
  /**
   * Type of area
   */
  type: TaxDetailareaType
  /**
   * Area of taxed ground in m^2
   */
  area?: string
  /**
   * Base of tax in Eur
   */
  base: number
  /**
   * Amount of tax in Eur
   */
  amount: number
}

export interface ResponseInstallmentItemDto {
  /**
   * Installment number
   */
  installmentNumber: number
  /**
   * Due date
   */
  dueDate?: string
  /**
   * Payment status
   */
  status: InstallmentPaidStatusEnum
  /**
   * Remaining amount to pay
   */
  remainingAmount: number
  /**
   * Total amount to pay
   */
  totalInstallmentAmount: number
}

export interface ResponseInstallmentPaymentDetailDto {
  /**
   * Indicates if installment payment is possible
   */
  isPossible: boolean
  /**
   * Reason why installment is not possible
   */
  reasonNotPossible?: ResponseInstallmentPaymentDetailDtoReasonNotPossibleEnum
  /**
   * Latest possible due date.
   */
  dueDateLastPayment?: string
  /**
   * List of exactly 3 installments or none at all
   */
  installments?: Array<ResponseInstallmentItemDto>
  /**
   * Details of active installment
   */
  activeInstallment?: ResponseActiveInstallmentDto
}

export const ResponseInstallmentPaymentDetailDtoReasonNotPossibleEnum = {
  BelowThreshold: 'BELOW_THRESHOLD',
  AfterDueDate: 'AFTER_DUE_DATE',
  AlreadyPaid: 'ALREADY_PAID',
} as const

export type ResponseInstallmentPaymentDetailDtoReasonNotPossibleEnum =
  (typeof ResponseInstallmentPaymentDetailDtoReasonNotPossibleEnum)[keyof typeof ResponseInstallmentPaymentDetailDtoReasonNotPossibleEnum]

export interface ResponseInternalServerErrorDto {
  /**
   * statusCode
   */
  statusCode: number
  /**
   * Message about error
   */
  message: string
}
export interface ResponseOneTimePaymentDetailsDto {
  /**
   * Indicates if one-time payment is possible.
   */
  isPossible: boolean
  /**
   * Type of payment
   */
  type?: ResponseOneTimePaymentDetailsDtoTypeEnum
  /**
   * Reason why payment is not possible
   */
  reasonNotPossible?: ResponseOneTimePaymentDetailsDtoReasonNotPossibleEnum
  /**
   * Payment amount
   */
  amount?: number
  /**
   * Due date
   */
  dueDate?: string
  /**
   * QR code for payment
   */
  qrCode?: string
  /**
   * Variable symbol for payment
   */
  variableSymbol?: string
}

export const ResponseOneTimePaymentDetailsDtoTypeEnum = {
  OneTimePayment: 'ONE_TIME_PAYMENT',
  RemainingAmountPayment: 'REMAINING_AMOUNT_PAYMENT',
} as const

export type ResponseOneTimePaymentDetailsDtoTypeEnum =
  (typeof ResponseOneTimePaymentDetailsDtoTypeEnum)[keyof typeof ResponseOneTimePaymentDetailsDtoTypeEnum]
export const ResponseOneTimePaymentDetailsDtoReasonNotPossibleEnum = {
  AlreadyPaid: 'ALREADY_PAID',
} as const

export type ResponseOneTimePaymentDetailsDtoReasonNotPossibleEnum =
  (typeof ResponseOneTimePaymentDetailsDtoReasonNotPossibleEnum)[keyof typeof ResponseOneTimePaymentDetailsDtoReasonNotPossibleEnum]

export interface ResponseTaxAdministratorDto {
  /**
   * Name of the tax administrator
   */
  name: string
  /**
   * Phone number of the tax administrator
   */
  phoneNumber: string
  /**
   * Email address of the tax administrator
   */
  email: string
}
export interface ResponseTaxDetailInstallmentsDto {
  /**
   * Id of instalments, installments are ordered by this value
   */
  id: number
  /**
   * Created at timestamp
   */
  createdAt: string
  /**
   * Updated at timestamp
   */
  updatedAt: string
  /**
   * Numeric id of tax (foreign key)
   */
  taxId: number
  /**
   * Order of installment
   */
  order: string | null
  /**
   * Amount to pay of installment in cents - integer
   */
  amount: number
  /**
   * Text of number of installment
   */
  text: string | null
}
export interface ResponseTaxDetailItemizedDto {
  /**
   * Total amount of tax for apartment
   */
  apartmentTotalAmount: number
  /**
   * Total amount of tax for construction
   */
  constructionTotalAmount: number
  /**
   * Total amount of tax for ground
   */
  groundTotalAmount: number
  /**
   * Apartment tax itemized
   */
  apartmentTaxDetail: Array<ResponseApartmentTaxDetailDto>
  /**
   * Ground tax itemized
   */
  groundTaxDetail: Array<ResponseGroundTaxDetailDto>
  /**
   * Construction tax itemized
   */
  constructionTaxDetail: Array<ResponseConstructionTaxDetailDto>
}
export interface ResponseTaxDetailsDto {
  /**
   * Numeric id of tax detail
   */
  id: number
  /**
   * Created at timestamp
   */
  createdAt: string
  /**
   * Updated at timestamp
   */
  updatedAt: string
  /**
   * Numeric id of tax (foreign key)
   */
  taxId: number
  /**
   * Type of tax detail - object of tax
   */
  type: TaxDetailTypeEnum
  /**
   * Area type of tax detail - exact type of object of tax
   */
  areaType: TaxDetailareaType
  /**
   * Area of tax detail - square meters
   */
  area: string | null
  /**
   * Base of tax pare meter
   */
  base: number
  /**
   * Real tax per area type tax detail
   */
  amount: number
}

export interface ResponseTaxDto {
  /**
   * Numeric id of tax
   */
  id: number
  /**
   * Uuid of tax
   */
  uuid: string
  /**
   * Created at timestamp
   */
  createdAt: string
  /**
   * Updated at timestamp
   */
  updatedAt: string
  /**
   * Year of tax
   */
  year: number
  /**
   * Numeric id of taxpayer
   */
  taxPayerId: number
  /**
   * Amount to pay in cents - integer
   */
  amount: number
  /**
   * Amount which was already paid in cents - integer
   */
  paidAmount: number
  /**
   * Variable symbol of payment
   */
  variableSymbol: string
  /**
   * Tax Id from order of exact year
   */
  taxId: string | null
  /**
   * Date of tax order.
   */
  dateCreateTax: string | null
  /**
   * Date and time of tax ruling (pr치voplatnos콘 rozhodnutia)
   */
  dateTaxRuling: string | null
  /**
   * Part of tax amount for lands in cents in Eur.
   */
  taxLand: number | null
  /**
   * Part of tax amount for constructions in cents in Eur.
   */
  taxConstructions: number | null
  /**
   * Part of tax amount for flats in cents in Eur.
   */
  taxFlat: number | null
  /**
   * Qr code use for pay in web in Base64 representing image of paybysquare QRcode
   */
  qrCodeWeb: string | null
  /**
   * Qr code use for pay in email in Base64 representing image of paybysquare QRcode
   */
  qrCodeEmail: string | null
  /**
   * Type of paid status
   */
  paidStatus: TaxPaidStatusEnum
  /**
   * Is tax payable (is tax from this year), and frontend can show payment data?
   */
  isPayable: boolean
  /**
   * Whether PDF export is available, since 2024 we stopped generating PDFs
   */
  pdfExport: boolean
  /**
   * Tax payer data
   */
  taxPayer: ResponseTaxPayerDto
  /**
   * Installments of payment tax - it can be array of 1 value or 3 values
   */
  taxInstallments: Array<ResponseTaxDetailInstallmentsDto>
  /**
   * Tax administrator
   */
  taxDetails: Array<ResponseTaxDetailsDto>
  /**
   * When were last checked payments for this tax with automatic task.
   */
  lastCheckedPayments: string
  /**
   * When were last checked updates for this tax with automatic task.
   */
  lastCheckedUpdates: string
  /**
   * delivery_method
   */
  deliveryMethod: DeliveryMethodNamed | null
  /**
   * Has the unpaid tax notification event been sent to Bloomreach for this tax
   */
  bloomreachUnpaidTaxReminderSent: boolean
  /**
   * Assigned tax administrator
   */
  taxAdministrator: ResponseTaxAdministratorDto | null
}

export interface ResponseTaxPayerDto {
  /**
   * Numeric id of tax payer
   */
  id: number
  /**
   * Uuid of tax payer
   */
  uuid: string
  /**
   * Created at timestamp
   */
  createdAt: string
  /**
   * Updated at timestamp
   */
  updatedAt: string
  /**
   * Is tax payer active
   */
  active: boolean
  /**
   * Permanent address of tax payer
   */
  permanentResidenceAddress: string | null
  /**
   * Id of tax payer from Noris
   */
  externalId: string | null
  /**
   * Name of taxpayer
   */
  name: string | null
  /**
   * Text of description of name for pdf
   */
  nameTxt: string | null
  /**
   * Text of description of street for pdf
   */
  permanentResidenceStreetTxt: string | null
  /**
   * Street of permanent residence with number
   */
  permanentResidenceStreet: string | null
  /**
   * Zip of permanent residence with number
   */
  permanentResidenceZip: string | null
  /**
   * City of permanent residence with number
   */
  permanentResidenceCity: string | null
  /**
   * Birth number with slash
   */
  birthNumber: string
  /**
   * Id of tax administrator - id is from Noris
   */
  taxAdministratorId: number | null
}
export interface ResponseTaxPayerReducedDto {
  /**
   * Name of taxpayer
   */
  name: string | null
  /**
   * Street of permanent residence with number
   */
  permanentResidenceStreet: string | null
  /**
   * Zip of permanent residence with number
   */
  permanentResidenceZip: string | null
  /**
   * City of permanent residence with number
   */
  permanentResidenceCity: string | null
  /**
   * Id of tax payer from Noris
   */
  externalId: string | null
}
export interface ResponseTaxSummaryDetailDto {
  /**
   * Payment status
   */
  paidStatus: TaxPaidStatusEnum
  /**
   * Year of tax
   */
  year: number
  /**
   * Total amount paid
   */
  overallPaid: number
  /**
   * Total remaining balance
   */
  overallBalance: number
  /**
   * Total tax amount
   */
  overallAmount: number
  /**
   * Itemized details
   */
  itemizedDetail: ResponseTaxDetailItemizedDto
  /**
   * One-time payment details
   */
  oneTimePayment: ResponseOneTimePaymentDetailsDto
  /**
   * Installment payment details
   */
  installmentPayment: ResponseInstallmentPaymentDetailDto
  /**
   * Assigned tax administrator
   */
  taxAdministrator: ResponseTaxAdministratorDto | null
  /**
   * Tax payer data
   */
  taxPayer: ResponseTaxPayerReducedDto
}

/**
 * Tax availability status
 */

export const TaxAvailabilityStatus = {
  Available: 'AVAILABLE',
  LookingForYourTax: 'LOOKING_FOR_YOUR_TAX',
  TaxNotOnRecord: 'TAX_NOT_ON_RECORD',
} as const

export type TaxAvailabilityStatus =
  (typeof TaxAvailabilityStatus)[keyof typeof TaxAvailabilityStatus]

/**
 * Type of tax detail - object of tax
 */

export const TaxDetailTypeEnum = {
  Apartment: 'APARTMENT',
  Construction: 'CONSTRUCTION',
  Ground: 'GROUND',
} as const

export type TaxDetailTypeEnum = (typeof TaxDetailTypeEnum)[keyof typeof TaxDetailTypeEnum]

/**
 * Area type of tax detail - exact type of object of tax
 */

export const TaxDetailareaType = {
  Nonresidential: 'NONRESIDENTIAL',
  Residential: 'RESIDENTIAL',
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  E: 'E',
  F: 'F',
  G: 'G',
  H: 'H',
  JH: 'jH',
  JI: 'jI',
  Byt: 'byt',
  Nebyt: 'nebyt',
} as const

export type TaxDetailareaType = (typeof TaxDetailareaType)[keyof typeof TaxDetailareaType]

/**
 * Type of paid status
 */

export const TaxPaidStatusEnum = {
  NotPaid: 'NOT_PAID',
  PartiallyPaid: 'PARTIALLY_PAID',
  Paid: 'PAID',
  OverPaid: 'OVER_PAID',
} as const

export type TaxPaidStatusEnum = (typeof TaxPaidStatusEnum)[keyof typeof TaxPaidStatusEnum]

/**
 * Type of paid status
 */

export const TaxStatusEnum = {
  NotPaid: 'NOT_PAID',
  PartiallyPaid: 'PARTIALLY_PAID',
  Paid: 'PAID',
  OverPaid: 'OVER_PAID',
  AwaitingProcessing: 'AWAITING_PROCESSING',
} as const

export type TaxStatusEnum = (typeof TaxStatusEnum)[keyof typeof TaxStatusEnum]

/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Creates a testing tax record with specified details for development and testing purposes
     * @summary Create a testing tax record
     * @param {RequestAdminCreateTestingTaxDto} requestAdminCreateTestingTaxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCreateTestingTax: async (
      requestAdminCreateTestingTaxDto: RequestAdminCreateTestingTaxDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestAdminCreateTestingTaxDto' is not null or undefined
      assertParamExists(
        'adminControllerCreateTestingTax',
        'requestAdminCreateTestingTaxDto',
        requestAdminCreateTestingTaxDto,
      )
      const localVarPath = `/admin/create-testing-tax`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestAdminCreateTestingTaxDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes a tax record for a specific birth number and year
     * @summary Delete a tax record
     * @param {RequestAdminDeleteTaxDto} requestAdminDeleteTaxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeleteTax: async (
      requestAdminDeleteTaxDto: RequestAdminDeleteTaxDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestAdminDeleteTaxDto' is not null or undefined
      assertParamExists(
        'adminControllerDeleteTax',
        'requestAdminDeleteTaxDto',
        requestAdminDeleteTaxDto,
      )
      const localVarPath = `/admin/delete-tax`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestAdminDeleteTaxDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Integrate data from norris if not exists by birth numbers or all
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerLoadDataFromNorris: async (
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPostNorisLoadDataDto' is not null or undefined
      assertParamExists(
        'adminControllerLoadDataFromNorris',
        'requestPostNorisLoadDataDto',
        requestPostNorisLoadDataDto,
      )
      const localVarPath = `/admin/create-data-from-noris`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPostNorisLoadDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Used when deactivating user from city account, to mark that this user does not have delivery methods anymore.
     * @summary Remove delivery methods for given birth number.
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerRemoveDeliveryMethodsFromNoris: async (
      birthNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('adminControllerRemoveDeliveryMethodsFromNoris', 'birthNumber', birthNumber)
      const localVarPath = `/admin/remove-delivery-methods-from-noris/{birthNumber}`.replace(
        `{${'birthNumber'}}`,
        encodeURIComponent(String(birthNumber)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Integrate data from norris
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdateDataFromNorris: async (
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPostNorisLoadDataDto' is not null or undefined
      assertParamExists(
        'adminControllerUpdateDataFromNorris',
        'requestPostNorisLoadDataDto',
        requestPostNorisLoadDataDto,
      )
      const localVarPath = `/admin/update-data-from-norris`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPostNorisLoadDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update delivery methods for given birth numbers and date.
     * @param {RequestUpdateNorisDeliveryMethodsDto} requestUpdateNorisDeliveryMethodsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdateDeliveryMethodsInNoris: async (
      requestUpdateNorisDeliveryMethodsDto: RequestUpdateNorisDeliveryMethodsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestUpdateNorisDeliveryMethodsDto' is not null or undefined
      assertParamExists(
        'adminControllerUpdateDeliveryMethodsInNoris',
        'requestUpdateNorisDeliveryMethodsDto',
        requestUpdateNorisDeliveryMethodsDto,
      )
      const localVarPath = `/admin/update-delivery-methods-in-noris`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestUpdateNorisDeliveryMethodsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Integrate Paid for day from - to.
     * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdatePaymentsFromNoris: async (
      requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPostNorisPaymentDataLoadDto' is not null or undefined
      assertParamExists(
        'adminControllerUpdatePaymentsFromNoris',
        'requestPostNorisPaymentDataLoadDto',
        requestPostNorisPaymentDataLoadDto,
      )
      const localVarPath = `/admin/payments-from-noris`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPostNorisPaymentDataLoadDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
  return {
    /**
     * Creates a testing tax record with specified details for development and testing purposes
     * @summary Create a testing tax record
     * @param {RequestAdminCreateTestingTaxDto} requestAdminCreateTestingTaxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCreateTestingTax(
      requestAdminCreateTestingTaxDto: RequestAdminCreateTestingTaxDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerCreateTestingTax(
        requestAdminCreateTestingTaxDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerCreateTestingTax']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deletes a tax record for a specific birth number and year
     * @summary Delete a tax record
     * @param {RequestAdminDeleteTaxDto} requestAdminDeleteTaxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerDeleteTax(
      requestAdminDeleteTaxDto: RequestAdminDeleteTaxDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerDeleteTax(
        requestAdminDeleteTaxDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerDeleteTax']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Integrate data from norris if not exists by birth numbers or all
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerLoadDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBirthNumbersResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerLoadDataFromNorris(
        requestPostNorisLoadDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerLoadDataFromNorris']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Used when deactivating user from city account, to mark that this user does not have delivery methods anymore.
     * @summary Remove delivery methods for given birth number.
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerRemoveDeliveryMethodsFromNoris(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerRemoveDeliveryMethodsFromNoris(
          birthNumber,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerRemoveDeliveryMethodsFromNoris']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Integrate data from norris
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerUpdateDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerUpdateDataFromNorris(
        requestPostNorisLoadDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerUpdateDataFromNorris']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Update delivery methods for given birth numbers and date.
     * @param {RequestUpdateNorisDeliveryMethodsDto} requestUpdateNorisDeliveryMethodsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerUpdateDeliveryMethodsInNoris(
      requestUpdateNorisDeliveryMethodsDto: RequestUpdateNorisDeliveryMethodsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerUpdateDeliveryMethodsInNoris(
          requestUpdateNorisDeliveryMethodsDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerUpdateDeliveryMethodsInNoris']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Integrate Paid for day from - to.
     * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerUpdatePaymentsFromNoris(
      requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerUpdatePaymentsFromNoris(
          requestPostNorisPaymentDataLoadDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AdminApi.adminControllerUpdatePaymentsFromNoris']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AdminApiFp(configuration)
  return {
    /**
     * Creates a testing tax record with specified details for development and testing purposes
     * @summary Create a testing tax record
     * @param {RequestAdminCreateTestingTaxDto} requestAdminCreateTestingTaxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCreateTestingTax(
      requestAdminCreateTestingTaxDto: RequestAdminCreateTestingTaxDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerCreateTestingTax(requestAdminCreateTestingTaxDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes a tax record for a specific birth number and year
     * @summary Delete a tax record
     * @param {RequestAdminDeleteTaxDto} requestAdminDeleteTaxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeleteTax(
      requestAdminDeleteTaxDto: RequestAdminDeleteTaxDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerDeleteTax(requestAdminDeleteTaxDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Integrate data from norris if not exists by birth numbers or all
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerLoadDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateBirthNumbersResponseDto> {
      return localVarFp
        .adminControllerLoadDataFromNorris(requestPostNorisLoadDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Used when deactivating user from city account, to mark that this user does not have delivery methods anymore.
     * @summary Remove delivery methods for given birth number.
     * @param {string} birthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerRemoveDeliveryMethodsFromNoris(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerRemoveDeliveryMethodsFromNoris(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Integrate data from norris
     * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdateDataFromNorris(
      requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerUpdateDataFromNorris(requestPostNorisLoadDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update delivery methods for given birth numbers and date.
     * @param {RequestUpdateNorisDeliveryMethodsDto} requestUpdateNorisDeliveryMethodsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdateDeliveryMethodsInNoris(
      requestUpdateNorisDeliveryMethodsDto: RequestUpdateNorisDeliveryMethodsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerUpdateDeliveryMethodsInNoris(requestUpdateNorisDeliveryMethodsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Integrate Paid for day from - to.
     * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerUpdatePaymentsFromNoris(
      requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminControllerUpdatePaymentsFromNoris(requestPostNorisPaymentDataLoadDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
  /**
   * Creates a testing tax record with specified details for development and testing purposes
   * @summary Create a testing tax record
   * @param {RequestAdminCreateTestingTaxDto} requestAdminCreateTestingTaxDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerCreateTestingTax(
    requestAdminCreateTestingTaxDto: RequestAdminCreateTestingTaxDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerCreateTestingTax(requestAdminCreateTestingTaxDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes a tax record for a specific birth number and year
   * @summary Delete a tax record
   * @param {RequestAdminDeleteTaxDto} requestAdminDeleteTaxDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerDeleteTax(
    requestAdminDeleteTaxDto: RequestAdminDeleteTaxDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerDeleteTax(requestAdminDeleteTaxDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Integrate data from norris if not exists by birth numbers or all
   * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerLoadDataFromNorris(
    requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerLoadDataFromNorris(requestPostNorisLoadDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Used when deactivating user from city account, to mark that this user does not have delivery methods anymore.
   * @summary Remove delivery methods for given birth number.
   * @param {string} birthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerRemoveDeliveryMethodsFromNoris(
    birthNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerRemoveDeliveryMethodsFromNoris(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Integrate data from norris
   * @param {RequestPostNorisLoadDataDto} requestPostNorisLoadDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerUpdateDataFromNorris(
    requestPostNorisLoadDataDto: RequestPostNorisLoadDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerUpdateDataFromNorris(requestPostNorisLoadDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update delivery methods for given birth numbers and date.
   * @param {RequestUpdateNorisDeliveryMethodsDto} requestUpdateNorisDeliveryMethodsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerUpdateDeliveryMethodsInNoris(
    requestUpdateNorisDeliveryMethodsDto: RequestUpdateNorisDeliveryMethodsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerUpdateDeliveryMethodsInNoris(requestUpdateNorisDeliveryMethodsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Integrate Paid for day from - to.
   * @param {RequestPostNorisPaymentDataLoadDto} requestPostNorisPaymentDataLoadDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerUpdatePaymentsFromNoris(
    requestPostNorisPaymentDataLoadDto: RequestPostNorisPaymentDataLoadDto,
    options?: RawAxiosRequestConfig,
  ) {
    return AdminApiFp(this.configuration)
      .adminControllerUpdatePaymentsFromNoris(requestPostNorisPaymentDataLoadDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CardPaymentReportingApi - axios parameter creator
 */
export const CardPaymentReportingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Send payment report to an email
     * @param {RequestPostReportingSendReport} requestPostReportingSendReport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardPaymentReportingControllerSendReport: async (
      requestPostReportingSendReport: RequestPostReportingSendReport,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPostReportingSendReport' is not null or undefined
      assertParamExists(
        'cardPaymentReportingControllerSendReport',
        'requestPostReportingSendReport',
        requestPostReportingSendReport,
      )
      const localVarPath = `/card-payment-reporting/send-report`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPostReportingSendReport,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CardPaymentReportingApi - functional programming interface
 */
export const CardPaymentReportingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CardPaymentReportingApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Send payment report to an email
     * @param {RequestPostReportingSendReport} requestPostReportingSendReport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cardPaymentReportingControllerSendReport(
      requestPostReportingSendReport: RequestPostReportingSendReport,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.cardPaymentReportingControllerSendReport(
          requestPostReportingSendReport,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CardPaymentReportingApi.cardPaymentReportingControllerSendReport']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * CardPaymentReportingApi - factory interface
 */
export const CardPaymentReportingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CardPaymentReportingApiFp(configuration)
  return {
    /**
     *
     * @summary Send payment report to an email
     * @param {RequestPostReportingSendReport} requestPostReportingSendReport
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cardPaymentReportingControllerSendReport(
      requestPostReportingSendReport: RequestPostReportingSendReport,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .cardPaymentReportingControllerSendReport(requestPostReportingSendReport, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CardPaymentReportingApi - object-oriented interface
 */
export class CardPaymentReportingApi extends BaseAPI {
  /**
   *
   * @summary Send payment report to an email
   * @param {RequestPostReportingSendReport} requestPostReportingSendReport
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public cardPaymentReportingControllerSendReport(
    requestPostReportingSendReport: RequestPostReportingSendReport,
    options?: RawAxiosRequestConfig,
  ) {
    return CardPaymentReportingApiFp(this.configuration)
      .cardPaymentReportingControllerSendReport(requestPostReportingSendReport, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealth(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealth(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.appControllerHealth']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * See if nest is working!
     * @summary Healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.appControllerHealth(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
  /**
   * See if nest is working!
   * @summary Healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public appControllerHealth(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .appControllerHealth(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PaymentApi - axios parameter creator
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Creates a payment link for paying the entire tax amount or remaining balance for the current year.
     * @summary Generate payment link for full tax payment for the current year.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGenerateFullPaymentLink: async (
      year: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('paymentControllerGenerateFullPaymentLink', 'year', year)
      const localVarPath = `/payment/cardpay/full-payment/{year}`.replace(
        `{${'year'}}`,
        encodeURIComponent(String(year)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a payment link for making an installment payment for the specified year.
     * @summary Generate payment link for installment tax payment.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGenerateInstallmentPaymentLink: async (
      year: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('paymentControllerGenerateInstallmentPaymentLink', 'year', year)
      const localVarPath = `/payment/cardpay/installment-payment/{year}`.replace(
        `{${'year'}}`,
        encodeURIComponent(String(year)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} taxUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGetQrCodeByTaxUuid: async (
      taxUuid: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'taxUuid' is not null or undefined
      assertParamExists('paymentControllerGetQrCodeByTaxUuid', 'taxUuid', taxUuid)
      const localVarPath = `/payment/qrcode/email/{taxUuid}`.replace(
        `{${'taxUuid'}}`,
        encodeURIComponent(String(taxUuid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
     * @summary Generate payment link to logged user for submitted year if there is no payment.
     * @param {string} year
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    paymentControllerPayment: async (
      year: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('paymentControllerPayment', 'year', year)
      const localVarPath = `/payment/cardpay/by-year/{year}`.replace(
        `{${'year'}}`,
        encodeURIComponent(String(year)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
     * @summary Generate payment link and redirect to this link to gpwebpay.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    paymentControllerPaymentByTaxId: async (
      uuid: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'uuid' is not null or undefined
      assertParamExists('paymentControllerPaymentByTaxId', 'uuid', uuid)
      const localVarPath = `/payment/cardpay/by-tax-id/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} dIGEST
     * @param {string} dIGEST1
     * @param {string} oPERATION
     * @param {string} oRDERNUMBER
     * @param {string} pRCODE
     * @param {string} sRCODE
     * @param {string} rESULTTEXT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPaymentResponse: async (
      dIGEST: string,
      dIGEST1: string,
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      rESULTTEXT: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dIGEST' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'dIGEST', dIGEST)
      // verify required parameter 'dIGEST1' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'dIGEST1', dIGEST1)
      // verify required parameter 'oPERATION' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'oPERATION', oPERATION)
      // verify required parameter 'oRDERNUMBER' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'oRDERNUMBER', oRDERNUMBER)
      // verify required parameter 'pRCODE' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'pRCODE', pRCODE)
      // verify required parameter 'sRCODE' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'sRCODE', sRCODE)
      // verify required parameter 'rESULTTEXT' is not null or undefined
      assertParamExists('paymentControllerPaymentResponse', 'rESULTTEXT', rESULTTEXT)
      const localVarPath = `/payment/cardpay/response`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (dIGEST !== undefined) {
        localVarQueryParameter['DIGEST'] = dIGEST
      }

      if (dIGEST1 !== undefined) {
        localVarQueryParameter['DIGEST1'] = dIGEST1
      }

      if (oPERATION !== undefined) {
        localVarQueryParameter['OPERATION'] = oPERATION
      }

      if (oRDERNUMBER !== undefined) {
        localVarQueryParameter['ORDERNUMBER'] = oRDERNUMBER
      }

      if (pRCODE !== undefined) {
        localVarQueryParameter['PRCODE'] = pRCODE
      }

      if (sRCODE !== undefined) {
        localVarQueryParameter['SRCODE'] = sRCODE
      }

      if (rESULTTEXT !== undefined) {
        localVarQueryParameter['RESULTTEXT'] = rESULTTEXT
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PaymentApi - functional programming interface
 */
export const PaymentApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
  return {
    /**
     * Creates a payment link for paying the entire tax amount or remaining balance for the current year.
     * @summary Generate payment link for full tax payment for the current year.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerGenerateFullPaymentLink(
      year: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetPaymentUrlDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentControllerGenerateFullPaymentLink(year, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PaymentApi.paymentControllerGenerateFullPaymentLink']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates a payment link for making an installment payment for the specified year.
     * @summary Generate payment link for installment tax payment.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerGenerateInstallmentPaymentLink(
      year: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetPaymentUrlDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paymentControllerGenerateInstallmentPaymentLink(
          year,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PaymentApi.paymentControllerGenerateInstallmentPaymentLink']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} taxUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerGetQrCodeByTaxUuid(
      taxUuid: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerGetQrCodeByTaxUuid(
        taxUuid,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PaymentApi.paymentControllerGetQrCodeByTaxUuid']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
     * @summary Generate payment link to logged user for submitted year if there is no payment.
     * @param {string} year
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async paymentControllerPayment(
      year: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetPaymentUrlDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerPayment(
        year,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PaymentApi.paymentControllerPayment']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
     * @summary Generate payment link and redirect to this link to gpwebpay.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async paymentControllerPaymentByTaxId(
      uuid: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerPaymentByTaxId(
        uuid,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PaymentApi.paymentControllerPaymentByTaxId']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} dIGEST
     * @param {string} dIGEST1
     * @param {string} oPERATION
     * @param {string} oRDERNUMBER
     * @param {string} pRCODE
     * @param {string} sRCODE
     * @param {string} rESULTTEXT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paymentControllerPaymentResponse(
      dIGEST: string,
      dIGEST1: string,
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      rESULTTEXT: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paymentControllerPaymentResponse(
        dIGEST,
        dIGEST1,
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        rESULTTEXT,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PaymentApi.paymentControllerPaymentResponse']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PaymentApi - factory interface
 */
export const PaymentApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PaymentApiFp(configuration)
  return {
    /**
     * Creates a payment link for paying the entire tax amount or remaining balance for the current year.
     * @summary Generate payment link for full tax payment for the current year.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGenerateFullPaymentLink(
      year: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseGetPaymentUrlDto> {
      return localVarFp
        .paymentControllerGenerateFullPaymentLink(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Creates a payment link for making an installment payment for the specified year.
     * @summary Generate payment link for installment tax payment.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGenerateInstallmentPaymentLink(
      year: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseGetPaymentUrlDto> {
      return localVarFp
        .paymentControllerGenerateInstallmentPaymentLink(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} taxUuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerGetQrCodeByTaxUuid(
      taxUuid: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerGetQrCodeByTaxUuid(taxUuid, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
     * @summary Generate payment link to logged user for submitted year if there is no payment.
     * @param {string} year
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    paymentControllerPayment(
      year: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseGetPaymentUrlDto> {
      return localVarFp
        .paymentControllerPayment(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
     * @summary Generate payment link and redirect to this link to gpwebpay.
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    paymentControllerPaymentByTaxId(
      uuid: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerPaymentByTaxId(uuid, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} dIGEST
     * @param {string} dIGEST1
     * @param {string} oPERATION
     * @param {string} oRDERNUMBER
     * @param {string} pRCODE
     * @param {string} sRCODE
     * @param {string} rESULTTEXT
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentControllerPaymentResponse(
      dIGEST: string,
      dIGEST1: string,
      oPERATION: string,
      oRDERNUMBER: string,
      pRCODE: string,
      sRCODE: string,
      rESULTTEXT: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .paymentControllerPaymentResponse(
          dIGEST,
          dIGEST1,
          oPERATION,
          oRDERNUMBER,
          pRCODE,
          sRCODE,
          rESULTTEXT,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PaymentApi - object-oriented interface
 */
export class PaymentApi extends BaseAPI {
  /**
   * Creates a payment link for paying the entire tax amount or remaining balance for the current year.
   * @summary Generate payment link for full tax payment for the current year.
   * @param {number} year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public paymentControllerGenerateFullPaymentLink(year: number, options?: RawAxiosRequestConfig) {
    return PaymentApiFp(this.configuration)
      .paymentControllerGenerateFullPaymentLink(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a payment link for making an installment payment for the specified year.
   * @summary Generate payment link for installment tax payment.
   * @param {number} year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public paymentControllerGenerateInstallmentPaymentLink(
    year: number,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentApiFp(this.configuration)
      .paymentControllerGenerateInstallmentPaymentLink(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} taxUuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public paymentControllerGetQrCodeByTaxUuid(taxUuid: string, options?: RawAxiosRequestConfig) {
    return PaymentApiFp(this.configuration)
      .paymentControllerGetQrCodeByTaxUuid(taxUuid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
   * @summary Generate payment link to logged user for submitted year if there is no payment.
   * @param {string} year
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public paymentControllerPayment(year: string, options?: RawAxiosRequestConfig) {
    return PaymentApiFp(this.configuration)
      .paymentControllerPayment(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * If there is payment, there will be error, also if there is paid only one installment, user can not pay by paygate
   * @summary Generate payment link and redirect to this link to gpwebpay.
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public paymentControllerPaymentByTaxId(uuid: string, options?: RawAxiosRequestConfig) {
    return PaymentApiFp(this.configuration)
      .paymentControllerPaymentByTaxId(uuid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} dIGEST
   * @param {string} dIGEST1
   * @param {string} oPERATION
   * @param {string} oRDERNUMBER
   * @param {string} pRCODE
   * @param {string} sRCODE
   * @param {string} rESULTTEXT
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public paymentControllerPaymentResponse(
    dIGEST: string,
    dIGEST1: string,
    oPERATION: string,
    oRDERNUMBER: string,
    pRCODE: string,
    sRCODE: string,
    rESULTTEXT: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PaymentApiFp(this.configuration)
      .paymentControllerPaymentResponse(
        dIGEST,
        dIGEST1,
        oPERATION,
        oRDERNUMBER,
        pRCODE,
        sRCODE,
        rESULTTEXT,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TaxApi - axios parameter creator
 */
export const TaxApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get tax by year and how much is paid
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerGetActualTaxes: async (
      year: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('taxControllerGetActualTaxes', 'year', year)
      const localVarPath = `/tax/get-tax-by-year`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (year !== undefined) {
        localVarQueryParameter['year'] = year
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all taxes (paid and not paid)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    taxControllerGetArchivedTaxes: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/tax/taxes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get tax by year and how much is paid
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    taxControllerGetTaxByYearPdf: async (
      year: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('taxControllerGetTaxByYearPdf', 'year', year)
      const localVarPath = `/tax/get-tax-pdf-by-year`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (year !== undefined) {
        localVarQueryParameter['year'] = year
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get tax detail by year.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerV2GetTaxDetailByYearV2: async (
      year: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'year' is not null or undefined
      assertParamExists('taxControllerV2GetTaxDetailByYearV2', 'year', year)
      const localVarPath = `/v2/tax/get-tax-detail-by-year`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (year !== undefined) {
        localVarQueryParameter['year'] = year
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get all taxes (paid and not paid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerV2GetTaxesListV2: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/tax/taxes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TaxApi - functional programming interface
 */
export const TaxApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TaxApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get tax by year and how much is paid
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taxControllerGetActualTaxes(
      year: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTaxDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taxControllerGetActualTaxes(
        year,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaxApi.taxControllerGetActualTaxes']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get all taxes (paid and not paid)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async taxControllerGetArchivedTaxes(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetTaxesDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.taxControllerGetArchivedTaxes(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaxApi.taxControllerGetArchivedTaxes']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get tax by year and how much is paid
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async taxControllerGetTaxByYearPdf(
      year: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTaxDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taxControllerGetTaxByYearPdf(
        year,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaxApi.taxControllerGetTaxByYearPdf']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get tax detail by year.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taxControllerV2GetTaxDetailByYearV2(
      year: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTaxSummaryDetailDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.taxControllerV2GetTaxDetailByYearV2(
        year,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaxApi.taxControllerV2GetTaxDetailByYearV2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Get all taxes (paid and not paid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async taxControllerV2GetTaxesListV2(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetTaxesListDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.taxControllerV2GetTaxesListV2(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TaxApi.taxControllerV2GetTaxesListV2']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * TaxApi - factory interface
 */
export const TaxApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TaxApiFp(configuration)
  return {
    /**
     *
     * @summary Get tax by year and how much is paid
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerGetActualTaxes(
      year: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseTaxDto> {
      return localVarFp
        .taxControllerGetActualTaxes(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all taxes (paid and not paid)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    taxControllerGetArchivedTaxes(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseGetTaxesDto> {
      return localVarFp
        .taxControllerGetArchivedTaxes(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get tax by year and how much is paid
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    taxControllerGetTaxByYearPdf(
      year: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseTaxDto> {
      return localVarFp
        .taxControllerGetTaxByYearPdf(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get tax detail by year.
     * @param {number} year
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerV2GetTaxDetailByYearV2(
      year: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseTaxSummaryDetailDto> {
      return localVarFp
        .taxControllerV2GetTaxDetailByYearV2(year, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get all taxes (paid and not paid)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    taxControllerV2GetTaxesListV2(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseGetTaxesListDto> {
      return localVarFp
        .taxControllerV2GetTaxesListV2(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TaxApi - object-oriented interface
 */
export class TaxApi extends BaseAPI {
  /**
   *
   * @summary Get tax by year and how much is paid
   * @param {number} year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public taxControllerGetActualTaxes(year: number, options?: RawAxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerGetActualTaxes(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all taxes (paid and not paid)
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public taxControllerGetArchivedTaxes(options?: RawAxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerGetArchivedTaxes(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get tax by year and how much is paid
   * @param {number} year
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   */
  public taxControllerGetTaxByYearPdf(year: number, options?: RawAxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerGetTaxByYearPdf(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get tax detail by year.
   * @param {number} year
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public taxControllerV2GetTaxDetailByYearV2(year: number, options?: RawAxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerV2GetTaxDetailByYearV2(year, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get all taxes (paid and not paid)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public taxControllerV2GetTaxesListV2(options?: RawAxiosRequestConfig) {
    return TaxApiFp(this.configuration)
      .taxControllerV2GetTaxesListV2(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
