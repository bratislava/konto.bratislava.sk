diff --git a/node_modules/@rjsf/utils/dist/index.js b/node_modules/@rjsf/utils/dist/index.js
index 84e824c..eb93726 100644
--- a/node_modules/@rjsf/utils/dist/index.js
+++ b/node_modules/@rjsf/utils/dist/index.js
@@ -1247,8 +1247,9 @@ function computeDefaults(validator, rawSchema, {
       return objectDefaults;
     }
     case "array": {
-      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "never";
-      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "requiredOnly";
+      const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+      const neverPopulate = arrayMinItems?.populate === "never";
+      const ignoreMinItemsFlagSet = arrayMinItems?.populate === "requiredOnly";
       if (Array.isArray(defaults)) {
         defaults = defaults.map((item, idx) => {
           const schemaItem = getInnerSchemaForArrayItem(schema, 2 /* Fallback */, idx);
@@ -1319,7 +1320,8 @@ function getDefaultFormState(validator, theSchema, formData, rootSchema, include
   if (formData === void 0 || formData === null || typeof formData === "number" && isNaN(formData)) {
     return defaults;
   }
-  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+  const { mergeExtraDefaults } = arrayMinItems || {};
   if (isObject(formData)) {
     return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
   }
diff --git a/node_modules/@rjsf/utils/dist/index.js.map b/node_modules/@rjsf/utils/dist/index.js.map
index 790f800..1038948 100644
--- a/node_modules/@rjsf/utils/dist/index.js.map
+++ b/node_modules/@rjsf/utils/dist/index.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../src/index.ts", "../src/isObject.ts", "../src/allowAdditionalItems.ts", "../src/asNumber.ts", "../src/constants.ts", "../src/getUiOptions.ts", "../src/canExpand.ts", "../src/createErrorHandler.ts", "../src/deepEquals.ts", "../src/schema/getDefaultFormState.ts", "../src/findSchemaDefinition.ts", "../src/schema/getClosestMatchingOption.ts", "../src/schema/getMatchingOption.ts", "../src/getOptionMatchingSimpleDiscriminator.ts", "../src/schema/getFirstMatchingOption.ts", "../src/schema/retrieveSchema.ts", "../src/getDiscriminatorFieldFromSchema.ts", "../src/guessType.ts", "../src/mergeSchemas.ts", "../src/getSchemaType.ts", "../src/isFixedItems.ts", "../src/mergeDefaultsWithFormData.ts", "../src/mergeObjects.ts", "../src/isConstant.ts", "../src/schema/isSelect.ts", "../src/schema/isMultiSelect.ts", "../src/isCustomWidget.ts", "../src/schema/isFilesArray.ts", "../src/schema/getDisplayLabel.ts", "../src/schema/mergeValidationData.ts", "../src/schema/sanitizeDataForNewSchema.ts", "../src/schema/toIdSchema.ts", "../src/schema/toPathSchema.ts", "../src/createSchemaUtils.ts", "../src/dataURItoBlob.ts", "../src/replaceStringParameters.ts", "../src/englishStringTranslator.ts", "../src/enumOptionsDeselectValue.ts", "../src/enumOptionsValueForIndex.ts", "../src/enumOptionsIsSelected.ts", "../src/enumOptionsIndexForValue.ts", "../src/enumOptionsSelectValue.ts", "../src/ErrorSchemaBuilder.ts", "../src/rangeSpec.ts", "../src/getInputProps.ts", "../src/getSubmitButtonOptions.ts", "../src/getTemplate.ts", "../src/getWidget.tsx", "../src/hashForSchema.ts", "../src/hasWidget.ts", "../src/idGenerators.ts", "../src/labelValue.ts", "../src/localToUTC.ts", "../src/toConstant.ts", "../src/optionsList.ts", "../src/orderProperties.ts", "../src/pad.ts", "../src/parseDateString.ts", "../src/schemaRequiresTrueValue.ts", "../src/shouldRender.ts", "../src/toDateString.ts", "../src/toErrorList.ts", "../src/toErrorSchema.ts", "../src/unwrapErrorHandler.ts", "../src/utcToLocal.ts", "../src/validationDataMerge.ts", "../src/withIdRefPrefix.ts", "../src/enums.ts", "../src/parser/schemaParser.ts", "../src/parser/ParserValidator.ts"],
-  "sourcesContent": ["import allowAdditionalItems from './allowAdditionalItems';\nimport asNumber from './asNumber';\nimport canExpand from './canExpand';\nimport createErrorHandler from './createErrorHandler';\nimport createSchemaUtils from './createSchemaUtils';\nimport dataURItoBlob from './dataURItoBlob';\nimport deepEquals from './deepEquals';\nimport englishStringTranslator from './englishStringTranslator';\nimport enumOptionsDeselectValue from './enumOptionsDeselectValue';\nimport enumOptionsIndexForValue from './enumOptionsIndexForValue';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\nimport enumOptionsSelectValue from './enumOptionsSelectValue';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\nimport findSchemaDefinition from './findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from './getDiscriminatorFieldFromSchema';\nimport getInputProps from './getInputProps';\nimport getSchemaType from './getSchemaType';\nimport getSubmitButtonOptions from './getSubmitButtonOptions';\nimport getTemplate from './getTemplate';\nimport getUiOptions from './getUiOptions';\nimport getWidget from './getWidget';\nimport guessType from './guessType';\nimport hashForSchema from './hashForSchema';\nimport hasWidget from './hasWidget';\nimport { ariaDescribedByIds, descriptionId, errorId, examplesId, helpId, optionId, titleId } from './idGenerators';\nimport isConstant from './isConstant';\nimport isCustomWidget from './isCustomWidget';\nimport isFixedItems from './isFixedItems';\nimport isObject from './isObject';\nimport labelValue from './labelValue';\nimport localToUTC from './localToUTC';\nimport mergeDefaultsWithFormData from './mergeDefaultsWithFormData';\nimport mergeObjects from './mergeObjects';\nimport mergeSchemas from './mergeSchemas';\nimport optionsList from './optionsList';\nimport orderProperties from './orderProperties';\nimport pad from './pad';\nimport parseDateString from './parseDateString';\nimport rangeSpec from './rangeSpec';\nimport replaceStringParameters from './replaceStringParameters';\nimport schemaRequiresTrueValue from './schemaRequiresTrueValue';\nimport shouldRender from './shouldRender';\nimport toConstant from './toConstant';\nimport toDateString from './toDateString';\nimport toErrorList from './toErrorList';\nimport toErrorSchema from './toErrorSchema';\nimport unwrapErrorHandler from './unwrapErrorHandler';\nimport utcToLocal from './utcToLocal';\nimport validationDataMerge from './validationDataMerge';\nimport withIdRefPrefix from './withIdRefPrefix';\nimport getOptionMatchingSimpleDiscriminator from './getOptionMatchingSimpleDiscriminator';\n\nexport * from './types';\nexport * from './enums';\n\nexport * from './constants';\nexport * from './parser';\nexport * from './schema';\n\nexport {\n  allowAdditionalItems,\n  ariaDescribedByIds,\n  asNumber,\n  canExpand,\n  createErrorHandler,\n  createSchemaUtils,\n  dataURItoBlob,\n  deepEquals,\n  descriptionId,\n  englishStringTranslator,\n  enumOptionsDeselectValue,\n  enumOptionsIndexForValue,\n  enumOptionsIsSelected,\n  enumOptionsSelectValue,\n  enumOptionsValueForIndex,\n  errorId,\n  examplesId,\n  ErrorSchemaBuilder,\n  findSchemaDefinition,\n  getDiscriminatorFieldFromSchema,\n  getInputProps,\n  getOptionMatchingSimpleDiscriminator,\n  getSchemaType,\n  getSubmitButtonOptions,\n  getTemplate,\n  getUiOptions,\n  getWidget,\n  guessType,\n  hasWidget,\n  hashForSchema,\n  helpId,\n  isConstant,\n  isCustomWidget,\n  isFixedItems,\n  isObject,\n  labelValue,\n  localToUTC,\n  mergeDefaultsWithFormData,\n  mergeObjects,\n  mergeSchemas,\n  optionId,\n  optionsList,\n  orderProperties,\n  pad,\n  parseDateString,\n  rangeSpec,\n  replaceStringParameters,\n  schemaRequiresTrueValue,\n  shouldRender,\n  titleId,\n  toConstant,\n  toDateString,\n  toErrorList,\n  toErrorSchema,\n  unwrapErrorHandler,\n  utcToLocal,\n  validationDataMerge,\n  withIdRefPrefix,\n};\n", "/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const IF_KEY = 'if';\nexport const ITEMS_KEY = 'items';\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\n\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n *\n * @param formData - The form data around which the error handler is created\n * @returns - A `FormValidation` object based on the `formData` structure\n */\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\n  const handler: FieldValidation = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // 'errors' (see `utils.toErrorSchema`).\n    [ERRORS_KEY]: [],\n    addError(message: string) {\n      this[ERRORS_KEY]!.push(message);\n    },\n  };\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  if (isPlainObject(formData)) {\n    const formObject: GenericObjectType = formData as GenericObjectType;\n    return Object.keys(formObject).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\n    }, handler as FormValidation<T>);\n  }\n  return handler as FormValidation<T>;\n}\n", "import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n", "import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  ALL_OF_KEY,\n} from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      // This is a custom addition that fixes this issue:\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\n      const retrievedSchema =\n        experimental_defaultFormStateBehavior?.allOf === 'populateDefaults' && ALL_OF_KEY in schema\n          ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData)\n          : schema;\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          maybeAddDefaultToObject<T>(\n            acc,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            retrievedSchema.required,\n            experimental_defaultFormStateBehavior\n          );\n          return acc;\n        },\n        {}\n      ) as T;\n      if (retrievedSchema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\n          ? retrievedSchema.additionalProperties\n          : {};\n\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? [];\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n", "import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n", "import get from 'lodash/get';\nimport { PROPERTIES_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\n *\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or undefined if there is no match\n */\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  formData: T | undefined,\n  options: S[],\n  discriminatorField?: string\n): number | undefined {\n  if (formData && discriminatorField) {\n    const value = get(formData, discriminatorField);\n\n    if (value === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < options.length; i++) {\n      const option = options[i];\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\n        continue;\n      }\n\n      if (discriminator.const === value) {\n        return i;\n      }\n\n      if (discriminator.enum?.includes(value)) {\n        return i;\n      }\n    }\n  }\n\n  return;\n}\n", "import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport merge from 'lodash/merge';\nimport flattenDeep from 'lodash/flattenDeep';\nimport uniq from 'lodash/uniq';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const childrenLists: string[][] = [];\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        const childList: string[] = [...recurseList];\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\n        childrenLists.push(childList);\n      },\n      {} as RJSFSchema\n    );\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n", "import get from 'lodash/get';\nimport isString from 'lodash/isString';\n\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\n *\n * @param schema - The schema from which the discriminator is potentially obtained\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\n */\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  let discriminator: string | undefined;\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\n  if (isString(maybeString)) {\n    discriminator = maybeString;\n  } else if (maybeString !== undefined) {\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\n  }\n  return discriminator;\n}\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n", "import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n", "import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type)) {\n    if (type.length === 2 && type.includes('null')) {\n      type = type.find((type) => type !== 'null');\n    } else {\n      type = type[0];\n    }\n  }\n\n  return type;\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n", "import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\n *     which case the extras are appended onto the end of the form data\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults?: T,\n  formData?: T,\n  mergeExtraArrayDefaults = false\n): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\n      }\n      return value;\n    });\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\n      mapped.push(...defaultsArray.slice(mapped.length));\n    }\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key),\n        mergeExtraArrayDefaults\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n", "import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n", "import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n", "import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n", "import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n", "import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n *        removed in the next major release.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  idPrefix: string,\n  idSeparator: string,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        idPrefix,\n        idSeparator,\n        id,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal<T, S, F>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      idPrefix,\n      idSeparator,\n      id,\n      rootSchema,\n      formData,\n      _recurseList\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        idPrefix,\n        idSeparator,\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        _recurseList\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\n\n    if (Array.isArray(schemaItems)) {\n      formData.forEach((element, i: number) => {\n        if (schemaItems[i]) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaItems[i] as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else if (schemaAdditionalItems) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaAdditionalItems as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else {\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\n        }\n      });\n    } else {\n      formData.forEach((element, i: number) => {\n        pathSchema[i] = toPathSchemaInternal<T, S, F>(\n          validator,\n          schemaItems as S,\n          `${name}.${i}`,\n          rootSchema,\n          element,\n          _recurseList\n        );\n      });\n    }\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n", "import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\n  ) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior = {}\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator ||\n      !deepEquals(this.rootSchema, rootSchema) ||\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues,\n      this.experimental_defaultFormStateBehavior\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number {\n    return getClosestMatchingOption<T, S, F>(\n      this.validator,\n      this.rootSchema,\n      formData,\n      options,\n      selectedOption,\n      discriminatorField\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  experimental_defaultFormStateBehavior = {}\n): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\n}\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n", "import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport isNil from 'lodash/isNil';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n", "import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n", "import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n", "import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** JS has no built-in hashing function, so rolling our own\n *  based on Java's hashing fn:\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\n *\n * @param string - The string for which to get the hash\n * @returns - The resulting hash of the string in hex format\n */\nfunction hashString(string: string): string {\n  let hash = 0;\n  for (let i = 0; i < string.length; i += 1) {\n    const chr = string.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n}\n\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\n * in consistent order before stringify to prevent different hash ids for the same schema.\n *\n * @param schema - The schema for which the hash is desired\n * @returns - The string obtained from the hash of the stringified schema\n */\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const allKeys = new Set<string>();\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\n}\n", "import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n", "import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n", "import { ReactElement } from 'react';\n\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\n * themes require may `false` and others may require an empty string.\n *\n * @param [label] - The label string or component to render when not hidden\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\n */\n\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: ''): undefined | string;\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: false): undefined | false | string;\nexport default function labelValue(label?: ReactElement, hideLabel?: boolean, fallback?: ''): undefined | ReactElement;\nexport default function labelValue(\n  label?: ReactElement,\n  hideLabel?: boolean,\n  fallback?: false\n): undefined | false | ReactElement;\nexport default function labelValue(\n  label?: string | ReactElement,\n  hideLabel?: boolean,\n  fallback?: false | ''\n): undefined | false | string | ReactElement {\n  return hideLabel ? fallback : label;\n}\n", "/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n", "import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n", "import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n", "import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n", "import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n", "import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n", "import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\n\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n *\n * @param errorSchema - The `ErrorSchema` instance to convert\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\n */\nexport default function toErrorList<T = any>(\n  errorSchema?: ErrorSchema<T>,\n  fieldPath: string[] = []\n): RJSFValidationError[] {\n  if (!errorSchema) {\n    return [];\n  }\n  let errorList: RJSFValidationError[] = [];\n  if (ERRORS_KEY in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\n        const property = `.${fieldPath.join('.')}`;\n        return {\n          property,\n          message,\n          stack: `${property} ${message}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== ERRORS_KEY) {\n      const childSchema = (errorSchema as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\n      }\n    }\n    return acc;\n  }, errorList);\n}\n", "import toPath from 'lodash/toPath';\n\nimport { ErrorSchema, RJSFValidationError } from './types';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\n  const builder = new ErrorSchemaBuilder<T>();\n  if (errors.length) {\n    errors.forEach((error) => {\n      const { property, message } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\n\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\n *\n * @param errorHandler - The `FormValidation` error handling structure\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\n */\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === 'addError') {\n      return acc;\n    } else {\n      const childSchema = (errorHandler as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        return {\n          ...acc,\n          [key]: unwrapErrorHandler(childSchema),\n        };\n      }\n      return { ...acc, [key]: childSchema };\n    }\n  }, {} as ErrorSchema<T>);\n}\n", "import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from './mergeObjects';\nimport toErrorList from './toErrorList';\nimport { ErrorSchema, ValidationData } from './types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function validationDataMerge<T = any>(\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\nimport isObject from 'lodash/isObject';\n\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\n  for (const key in node) {\n    const realObj: { [k: string]: any } = node;\n    const value = realObj[key];\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\n    } else {\n      realObj[key] = withIdRefPrefix<S>(value);\n    }\n  }\n  return node;\n}\n\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\n  for (let i = 0; i < node.length; i++) {\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\n  }\n  return node;\n}\n\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\n * This is used in isValid to make references to the rootSchema\n *\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n * @returns - A copy of the `schemaNode` with updated `$ref`s\n */\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(\n  schemaNode: S | S[] | S[keyof S]\n): S | S[] | S[keyof S] {\n  if (Array.isArray(schemaNode)) {\n    return withIdRefPrefixArray<S>([...schemaNode]);\n  }\n  if (isObject(schemaNode)) {\n    return withIdRefPrefixObject<S>({ ...schemaNode });\n  }\n  return schemaNode;\n}\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** File preview label, used by FileWidget */\n  PreviewLabel = 'Preview',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\n}\n", "import forEach from 'lodash/forEach';\nimport isEqual from 'lodash/isEqual';\n\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport ParserValidator, { SchemaMap } from './ParserValidator';\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\n\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\n *\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\n * @param rootSchema - The root schema from which the schema parsing began\n * @param schema - The current schema element being parsed\n */\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ParserValidator<T, S, F>,\n  recurseList: S[],\n  rootSchema: S,\n  schema: S\n) {\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\n  schemas.forEach((schema) => {\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\n    if (sameSchemaIndex === -1) {\n      recurseList.push(schema);\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\n      allOptions.forEach((s) => {\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\n          forEach(schema[PROPERTIES_KEY], (value) => {\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\n          });\n        }\n      });\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\n      }\n    }\n  });\n}\n\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\n * the hash of the schema to schema/sub-schema.\n *\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\n * @returns - The `SchemaMap` of all schemas that were parsed\n */\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  rootSchema: S\n): SchemaMap<S> {\n  const validator = new ParserValidator<T, S, F>(rootSchema);\n  const recurseList: S[] = [];\n\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\n\n  return validator.getSchemaMap();\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ID_KEY } from '../constants';\nimport hashForSchema from '../hashForSchema';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from '../types';\n\n/** The type of the map of schema hash to schema\n */\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\n  [hash: string]: S;\n};\n\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\n */\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The rootSchema provided during construction of the class */\n  readonly rootSchema: S;\n\n  /** The map of schemas encountered by the ParserValidator */\n  schemaMap: SchemaMap<S> = {};\n\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\n   * first.\n   *\n   * @param rootSchema - The root schema against which this validator will be executed\n   */\n  constructor(rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\n  }\n\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\n   * associated with it's `hash` for future use (by a schema compiler).\n   *\n   * @param schema - The schema which is to be added to the map\n   * @param hash - The hash value at which to map the schema\n   */\n  addSchema(schema: S, hash: string) {\n    const key = get(schema, ID_KEY, hash);\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\n    const existing = this.schemaMap[key];\n    if (!existing) {\n      this.schemaMap[key] = identifiedSchema;\n    } else if (!isEqual(existing, identifiedSchema)) {\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\n      throw new Error(\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\n      );\n    }\n  }\n\n  /** Returns the current `schemaMap` to the caller\n   */\n  getSchemaMap() {\n    return this.schemaMap;\n  }\n\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\n   * the `rootSchema` is not the same as the root schema provided during construction.\n   *\n   * @param schema - The schema to record in the `schemaMap`\n   * @param _formData - The formData parameter that is ignored\n   * @param rootSchema - The root schema associated with the schema\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\n   */\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\n    if (!isEqual(rootSchema, this.rootSchema)) {\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\n    }\n    this.addSchema(schema, hashForSchema<S>(schema));\n\n    return false;\n  }\n\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\n   *\n   * @param _schema - The schema parameter that is ignored\n   * @param _formData - The formData parameter that is ignored\n   */\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\n   *\n   * @param _errorSchema - The error schema parameter that is ignored\n   * @param _fieldPath - The field path parameter that is ignored\n   */\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\n   * called\n   *\n   * @param _formData - The formData parameter that is ignored\n   * @param _schema - The schema parameter that is ignored\n   * @param _customValidate - The customValidate parameter that is ignored\n   * @param _transformErrors - The transformErrors parameter that is ignored\n   * @param _uiSchema - The uiSchema parameter that is ignored\n   */\n  validateFormData(\n    _formData: T,\n    _schema: S,\n    _customValidate?: CustomValidator<T, S, F>,\n    _transformErrors?: ErrorTransformer<T, S, F>,\n    _uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\n  }\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["import allowAdditionalItems from './allowAdditionalItems';\r\nimport asNumber from './asNumber';\r\nimport canExpand from './canExpand';\r\nimport createErrorHandler from './createErrorHandler';\r\nimport createSchemaUtils from './createSchemaUtils';\r\nimport dataURItoBlob from './dataURItoBlob';\r\nimport deepEquals from './deepEquals';\r\nimport englishStringTranslator from './englishStringTranslator';\r\nimport enumOptionsDeselectValue from './enumOptionsDeselectValue';\r\nimport enumOptionsIndexForValue from './enumOptionsIndexForValue';\r\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\r\nimport enumOptionsSelectValue from './enumOptionsSelectValue';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\r\nimport findSchemaDefinition from './findSchemaDefinition';\r\nimport getDiscriminatorFieldFromSchema from './getDiscriminatorFieldFromSchema';\r\nimport getInputProps from './getInputProps';\r\nimport getSchemaType from './getSchemaType';\r\nimport getSubmitButtonOptions from './getSubmitButtonOptions';\r\nimport getTemplate from './getTemplate';\r\nimport getUiOptions from './getUiOptions';\r\nimport getWidget from './getWidget';\r\nimport guessType from './guessType';\r\nimport hashForSchema from './hashForSchema';\r\nimport hasWidget from './hasWidget';\r\nimport { ariaDescribedByIds, descriptionId, errorId, examplesId, helpId, optionId, titleId } from './idGenerators';\r\nimport isConstant from './isConstant';\r\nimport isCustomWidget from './isCustomWidget';\r\nimport isFixedItems from './isFixedItems';\r\nimport isObject from './isObject';\r\nimport labelValue from './labelValue';\r\nimport localToUTC from './localToUTC';\r\nimport mergeDefaultsWithFormData from './mergeDefaultsWithFormData';\r\nimport mergeObjects from './mergeObjects';\r\nimport mergeSchemas from './mergeSchemas';\r\nimport optionsList from './optionsList';\r\nimport orderProperties from './orderProperties';\r\nimport pad from './pad';\r\nimport parseDateString from './parseDateString';\r\nimport rangeSpec from './rangeSpec';\r\nimport replaceStringParameters from './replaceStringParameters';\r\nimport schemaRequiresTrueValue from './schemaRequiresTrueValue';\r\nimport shouldRender from './shouldRender';\r\nimport toConstant from './toConstant';\r\nimport toDateString from './toDateString';\r\nimport toErrorList from './toErrorList';\r\nimport toErrorSchema from './toErrorSchema';\r\nimport unwrapErrorHandler from './unwrapErrorHandler';\r\nimport utcToLocal from './utcToLocal';\r\nimport validationDataMerge from './validationDataMerge';\r\nimport withIdRefPrefix from './withIdRefPrefix';\r\nimport getOptionMatchingSimpleDiscriminator from './getOptionMatchingSimpleDiscriminator';\r\n\r\nexport * from './types';\r\nexport * from './enums';\r\n\r\nexport * from './constants';\r\nexport * from './parser';\r\nexport * from './schema';\r\n\r\nexport {\r\n  allowAdditionalItems,\r\n  ariaDescribedByIds,\r\n  asNumber,\r\n  canExpand,\r\n  createErrorHandler,\r\n  createSchemaUtils,\r\n  dataURItoBlob,\r\n  deepEquals,\r\n  descriptionId,\r\n  englishStringTranslator,\r\n  enumOptionsDeselectValue,\r\n  enumOptionsIndexForValue,\r\n  enumOptionsIsSelected,\r\n  enumOptionsSelectValue,\r\n  enumOptionsValueForIndex,\r\n  errorId,\r\n  examplesId,\r\n  ErrorSchemaBuilder,\r\n  findSchemaDefinition,\r\n  getDiscriminatorFieldFromSchema,\r\n  getInputProps,\r\n  getOptionMatchingSimpleDiscriminator,\r\n  getSchemaType,\r\n  getSubmitButtonOptions,\r\n  getTemplate,\r\n  getUiOptions,\r\n  getWidget,\r\n  guessType,\r\n  hasWidget,\r\n  hashForSchema,\r\n  helpId,\r\n  isConstant,\r\n  isCustomWidget,\r\n  isFixedItems,\r\n  isObject,\r\n  labelValue,\r\n  localToUTC,\r\n  mergeDefaultsWithFormData,\r\n  mergeObjects,\r\n  mergeSchemas,\r\n  optionId,\r\n  optionsList,\r\n  orderProperties,\r\n  pad,\r\n  parseDateString,\r\n  rangeSpec,\r\n  replaceStringParameters,\r\n  schemaRequiresTrueValue,\r\n  shouldRender,\r\n  titleId,\r\n  toConstant,\r\n  toDateString,\r\n  toErrorList,\r\n  toErrorSchema,\r\n  unwrapErrorHandler,\r\n  utcToLocal,\r\n  validationDataMerge,\r\n  withIdRefPrefix,\r\n};\r\n", "/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\r\n * the type `object` but is NOT null, an array or a File.\r\n *\r\n * @param thing - The thing to check to see whether it is an object\r\n * @returns - True if it is a non-null, non-array, non-File object\r\n */\r\nexport default function isObject(thing: any) {\r\n  if (typeof File !== 'undefined' && thing instanceof File) {\r\n    return false;\r\n  }\r\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\r\n    return false;\r\n  }\r\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\r\n}\r\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\r\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\r\n *\r\n * @param schema - The schema object to check\r\n * @returns - True if additional items is allowed, otherwise false\r\n */\r\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (schema.additionalItems === true) {\r\n    console.warn('additionalItems=true is currently not supported');\r\n  }\r\n  return isObject(schema.additionalItems);\r\n}\r\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\r\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\r\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\r\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\r\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\r\n *\r\n * @param value - The string or null value to convert to a number\r\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\r\n */\r\nexport default function asNumber(value: string | null) {\r\n  if (value === '') {\r\n    return undefined;\r\n  }\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n  if (/\\.$/.test(value)) {\r\n    // '3.' can't really be considered a number even if it parses in js. The\r\n    // user is most likely entering a float.\r\n    return value;\r\n  }\r\n  if (/\\.0$/.test(value)) {\r\n    // we need to return this as a string here, to allow for input like 3.07\r\n    return value;\r\n  }\r\n\r\n  if (/\\.\\d*0$/.test(value)) {\r\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\r\n    // with the user when entering dollar amounts or other values (such as those with\r\n    // specific precision or number of significant digits)\r\n    return value;\r\n  }\r\n\r\n  const n = Number(value);\r\n  const valid = typeof n === 'number' && !Number.isNaN(n);\r\n\r\n  return valid ? n : value;\r\n}\r\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\r\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\r\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\r\n * utility.\r\n */\r\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\r\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\r\nexport const ALL_OF_KEY = 'allOf';\r\nexport const ANY_OF_KEY = 'anyOf';\r\nexport const CONST_KEY = 'const';\r\nexport const DEFAULT_KEY = 'default';\r\nexport const DEFINITIONS_KEY = 'definitions';\r\nexport const DEPENDENCIES_KEY = 'dependencies';\r\nexport const ENUM_KEY = 'enum';\r\nexport const ERRORS_KEY = '__errors';\r\nexport const ID_KEY = '$id';\r\nexport const IF_KEY = 'if';\r\nexport const ITEMS_KEY = 'items';\r\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\r\nexport const NAME_KEY = '$name';\r\nexport const ONE_OF_KEY = 'oneOf';\r\nexport const PROPERTIES_KEY = 'properties';\r\nexport const REQUIRED_KEY = 'required';\r\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\r\nexport const REF_KEY = '$ref';\r\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\r\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\r\nexport const UI_FIELD_KEY = 'ui:field';\r\nexport const UI_WIDGET_KEY = 'ui:widget';\r\nexport const UI_OPTIONS_KEY = 'ui:options';\r\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\r\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\r\nimport isObject from './isObject';\r\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\r\n\r\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\r\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\r\n *\r\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\r\n */\r\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  globalOptions: GlobalUISchemaOptions = {}\r\n): UIOptionsType<T, S, F> {\r\n  return Object.keys(uiSchema)\r\n    .filter((key) => key.indexOf('ui:') === 0)\r\n    .reduce(\r\n      (options, key) => {\r\n        const value = uiSchema[key];\r\n        if (key === UI_WIDGET_KEY && isObject(value)) {\r\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\r\n          return options;\r\n        }\r\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\r\n          return { ...options, ...value };\r\n        }\r\n        return { ...options, [key.substring(3)]: value };\r\n      },\r\n      { ...globalOptions }\r\n    );\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\nimport getUiOptions from './getUiOptions';\r\n\r\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\r\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\r\n * `formData` object doesn't already have `schema.maxProperties` elements.\r\n *\r\n * @param schema - The schema for the field that is being checked\r\n * @param [uiSchema={}] - The uiSchema for the field\r\n * @param [formData] - The formData for the field\r\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\r\n */\r\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  formData?: T\r\n) {\r\n  if (!schema.additionalProperties) {\r\n    return false;\r\n  }\r\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\r\n  if (expandable === false) {\r\n    return expandable;\r\n  }\r\n  // if ui:options.expandable was not explicitly set to false, we can add\r\n  // another property if we have not exceeded maxProperties yet\r\n  if (schema.maxProperties !== undefined && formData) {\r\n    return Object.keys(formData).length < schema.maxProperties;\r\n  }\r\n  return true;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\r\n *\r\n * @param formData - The form data around which the error handler is created\r\n * @returns - A `FormValidation` object based on the `formData` structure\r\n */\r\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\r\n  const handler: FieldValidation = {\r\n    // We store the list of errors for this node in a property named __errors\r\n    // to avoid name collision with a possible sub schema field named\r\n    // 'errors' (see `utils.toErrorSchema`).\r\n    [ERRORS_KEY]: [],\r\n    addError(message: string) {\r\n      this[ERRORS_KEY]!.push(message);\r\n    },\r\n  };\r\n  if (Array.isArray(formData)) {\r\n    return formData.reduce((acc, value, key) => {\r\n      return { ...acc, [key]: createErrorHandler(value) };\r\n    }, handler);\r\n  }\r\n  if (isPlainObject(formData)) {\r\n    const formObject: GenericObjectType = formData as GenericObjectType;\r\n    return Object.keys(formObject).reduce((acc, key) => {\r\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\r\n    }, handler as FormValidation<T>);\r\n  }\r\n  return handler as FormValidation<T>;\r\n}\r\n", "import isEqualWith from 'lodash/isEqualWith';\r\n\r\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\r\n * assumes all functions are equivalent.\r\n *\r\n * @param a - The first element to compare\r\n * @param b - The second element to compare\r\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\r\n */\r\nexport default function deepEquals(a: any, b: any): boolean {\r\n  return isEqualWith(a, b, (obj: any, other: any) => {\r\n    if (typeof obj === 'function' && typeof other === 'function') {\r\n      // Assume all functions are equivalent\r\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\r\n      return true;\r\n    }\r\n    return undefined; // fallback to default isEquals behavior\r\n  });\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEmpty from 'lodash/isEmpty';\r\n\r\nimport {\r\n  ANY_OF_KEY,\r\n  DEFAULT_KEY,\r\n  DEPENDENCIES_KEY,\r\n  PROPERTIES_KEY,\r\n  ONE_OF_KEY,\r\n  REF_KEY,\r\n  ALL_OF_KEY,\r\n} from '../constants';\r\nimport findSchemaDefinition from '../findSchemaDefinition';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport getSchemaType from '../getSchemaType';\r\nimport isObject from '../isObject';\r\nimport isFixedItems from '../isFixedItems';\r\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\r\nimport mergeObjects from '../mergeObjects';\r\nimport mergeSchemas from '../mergeSchemas';\r\nimport {\r\n  Experimental_ArrayMinItems,\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GenericObjectType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isMultiSelect from './isMultiSelect';\r\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\r\n\r\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\r\n */\r\nexport enum AdditionalItemsHandling {\r\n  Ignore,\r\n  Invert,\r\n  Fallback,\r\n}\r\n\r\ndeclare module 'json-schema' {\r\n  export interface JSONSchema7 {\r\n    overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;\r\n  }\r\n}\r\n\r\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\r\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\r\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\r\n *    index and not a boolean, otherwise it falls through to 3.\r\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\r\n *    is a schema, otherwise it falls through to 3.\r\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\r\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\r\n * 4. {} is returned representing an empty schema\r\n *\r\n * @param schema - The schema from which to get the particular item\r\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\r\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\r\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\r\n */\r\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\r\n  idx = -1\r\n): S {\r\n  if (idx >= 0) {\r\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\r\n      const item = schema.items[idx];\r\n      if (typeof item !== 'boolean') {\r\n        return item as S;\r\n      }\r\n    }\r\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\r\n    return schema.items as S;\r\n  }\r\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\r\n    return schema.additionalItems as S;\r\n  }\r\n  return {} as S;\r\n}\r\n\r\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\r\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\r\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\r\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\r\n * values will be added based on certain conditions.\r\n *\r\n * @param obj - The object into which the computed default may be added\r\n * @param key - The key into the object at which the computed default may be added\r\n * @param computedDefault - The computed default value that maybe should be added to the obj\r\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\r\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\r\n * @param requiredFields - The list of fields that are required\r\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\r\n *        default form state behavior\r\n */\r\nfunction maybeAddDefaultToObject<T = any>(\r\n  obj: GenericObjectType,\r\n  key: string,\r\n  computedDefault: T | T[] | undefined,\r\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\r\n  isParentRequired?: boolean,\r\n  requiredFields: string[] = [],\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\r\n) {\r\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\r\n  if (includeUndefinedValues) {\r\n    obj[key] = computedDefault;\r\n  } else if (emptyObjectFields !== 'skipDefaults') {\r\n    if (isObject(computedDefault)) {\r\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\r\n      // the field key itself in the `requiredField` list\r\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\r\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\r\n      // Condition 1: If computedDefault is not empty or if the key is a required field\r\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\r\n      if (\r\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\r\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\r\n      ) {\r\n        obj[key] = computedDefault;\r\n      }\r\n    } else if (\r\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\r\n      // Condition 1: computedDefault is not undefined\r\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\r\n      computedDefault !== undefined &&\r\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\r\n    ) {\r\n      obj[key] = computedDefault;\r\n    }\r\n  }\r\n}\r\n\r\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\r\n  parentDefaults?: T;\r\n  rootSchema?: S;\r\n  rawFormData?: T;\r\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\r\n  _recurseList?: string[];\r\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\r\n  required?: boolean;\r\n}\r\n\r\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\r\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rawSchema - The schema for which the default state is desired\r\n * @param [props] - Optional props for this function\r\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\r\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\r\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\r\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\r\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rawSchema: S,\r\n  {\r\n    parentDefaults,\r\n    rawFormData,\r\n    rootSchema = {} as S,\r\n    includeUndefinedValues = false,\r\n    _recurseList = [],\r\n    experimental_defaultFormStateBehavior = undefined,\r\n    required,\r\n  }: ComputeDefaultsProps<T, S> = {}\r\n): T | T[] | undefined {\r\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\r\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\r\n  // Compute the defaults recursively: give highest priority to deepest nodes.\r\n  let defaults: T | T[] | undefined = parentDefaults;\r\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\r\n  let schemaToCompute: S | null = null;\r\n  let updatedRecurseList = _recurseList;\r\n\r\n  if (isObject(defaults) && isObject(schema.default)) {\r\n    // For object defaults, only override parent defaults that are defined in\r\n    // schema.default.\r\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\r\n  } else if (DEFAULT_KEY in schema) {\r\n    defaults = schema.default as unknown as T;\r\n  } else if (REF_KEY in schema) {\r\n    const refName = schema[REF_KEY];\r\n    // Use referenced schema defaults for this node.\r\n    if (!_recurseList.includes(refName!)) {\r\n      updatedRecurseList = _recurseList.concat(refName!);\r\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\r\n    }\r\n  } else if (DEPENDENCIES_KEY in schema) {\r\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\r\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\r\n  } else if (isFixedItems(schema)) {\r\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\r\n      computeDefaults<T, S>(validator, itemSchema, {\r\n        rootSchema,\r\n        includeUndefinedValues,\r\n        _recurseList,\r\n        experimental_defaultFormStateBehavior,\r\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\r\n        rawFormData: formData as T,\r\n        required,\r\n      })\r\n    ) as T[];\r\n  } else if (ONE_OF_KEY in schema) {\r\n    const { oneOf, ...remaining } = schema;\r\n    if (oneOf!.length === 0) {\r\n      return undefined;\r\n    }\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    schemaToCompute = oneOf![\r\n      getClosestMatchingOption<T, S, F>(\r\n        validator,\r\n        rootSchema,\r\n        isEmpty(formData) ? undefined : formData,\r\n        oneOf as S[],\r\n        0,\r\n        discriminator\r\n      )\r\n    ] as S;\r\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\r\n  } else if (ANY_OF_KEY in schema) {\r\n    const { anyOf, ...remaining } = schema;\r\n    if (anyOf!.length === 0) {\r\n      return undefined;\r\n    }\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    schemaToCompute = anyOf![\r\n      getClosestMatchingOption<T, S, F>(\r\n        validator,\r\n        rootSchema,\r\n        isEmpty(formData) ? undefined : formData,\r\n        anyOf as S[],\r\n        0,\r\n        discriminator\r\n      )\r\n    ] as S;\r\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\r\n  }\r\n\r\n  if (schemaToCompute) {\r\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\r\n      rootSchema,\r\n      includeUndefinedValues,\r\n      _recurseList: updatedRecurseList,\r\n      experimental_defaultFormStateBehavior,\r\n      parentDefaults: defaults as T | undefined,\r\n      rawFormData: formData as T,\r\n      required,\r\n    });\r\n  }\r\n\r\n  // No defaults defined for this node, fallback to generic typed ones.\r\n  if (defaults === undefined) {\r\n    defaults = schema.default as unknown as T;\r\n  }\r\n\r\n  switch (getSchemaType<S>(schema)) {\r\n    // We need to recurse for object schema inner default values.\r\n    case 'object': {\r\n      // This is a custom addition that fixes this issue:\r\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\r\n      const retrievedSchema =\r\n        experimental_defaultFormStateBehavior?.allOf === 'populateDefaults' && ALL_OF_KEY in schema\r\n          ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData)\r\n          : schema;\r\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\r\n        (acc: GenericObjectType, key: string) => {\r\n          // Compute the defaults for this node, with the parent defaults we might\r\n          // have from a previous run: defaults[key].\r\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            includeUndefinedValues: includeUndefinedValues === true,\r\n            parentDefaults: get(defaults, [key]),\r\n            rawFormData: get(formData, [key]),\r\n            required: retrievedSchema.required?.includes(key),\r\n          });\r\n          maybeAddDefaultToObject<T>(\r\n            acc,\r\n            key,\r\n            computedDefault,\r\n            includeUndefinedValues,\r\n            required,\r\n            retrievedSchema.required,\r\n            experimental_defaultFormStateBehavior\r\n          );\r\n          return acc;\r\n        },\r\n        {}\r\n      ) as T;\r\n      if (retrievedSchema.additionalProperties) {\r\n        // as per spec additionalProperties may be either schema or boolean\r\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\r\n          ? retrievedSchema.additionalProperties\r\n          : {};\r\n\r\n        const keys = new Set<string>();\r\n        if (isObject(defaults)) {\r\n          Object.keys(defaults as GenericObjectType)\r\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\r\n            .forEach((key) => keys.add(key));\r\n        }\r\n        const formDataRequired: string[] = [];\r\n        Object.keys(formData as GenericObjectType)\r\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\r\n          .forEach((key) => {\r\n            keys.add(key);\r\n            formDataRequired.push(key);\r\n          });\r\n        keys.forEach((key) => {\r\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            includeUndefinedValues: includeUndefinedValues === true,\r\n            parentDefaults: get(defaults, [key]),\r\n            rawFormData: get(formData, [key]),\r\n            required: retrievedSchema.required?.includes(key),\r\n          });\r\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\r\n          maybeAddDefaultToObject<T>(\r\n            objectDefaults as GenericObjectType,\r\n            key,\r\n            computedDefault,\r\n            includeUndefinedValues,\r\n            required,\r\n            formDataRequired\r\n          );\r\n        });\r\n      }\r\n      return objectDefaults;\r\n    }\r\n    case 'array': {\r\n      // On a case by case basis, we may want to override the default behavior of populating array items.\r\n      const arrayMinItems =\r\n          schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\r\n      const neverPopulate = arrayMinItems?.populate === 'never';\r\n      const ignoreMinItemsFlagSet = arrayMinItems?.populate === 'requiredOnly';\r\n\r\n      // Inject defaults into existing array defaults\r\n      if (Array.isArray(defaults)) {\r\n        defaults = defaults.map((item, idx) => {\r\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\r\n          return computeDefaults<T, S, F>(validator, schemaItem, {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            parentDefaults: item,\r\n            required,\r\n          });\r\n        }) as T[];\r\n      }\r\n\r\n      // Deeply inject defaults into already existing form data\r\n      if (Array.isArray(rawFormData)) {\r\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\r\n        if (neverPopulate) {\r\n          defaults = rawFormData;\r\n        } else {\r\n          defaults = rawFormData.map((item: T, idx: number) => {\r\n            return computeDefaults<T, S, F>(validator, schemaItem, {\r\n              rootSchema,\r\n              _recurseList,\r\n              experimental_defaultFormStateBehavior,\r\n              rawFormData: item,\r\n              parentDefaults: get(defaults, [idx]),\r\n              required,\r\n            });\r\n          }) as T[];\r\n        }\r\n      }\r\n\r\n      if (neverPopulate) {\r\n        return defaults ?? [];\r\n      }\r\n      if (ignoreMinItemsFlagSet && !required) {\r\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\r\n        // return form data/defaults\r\n        return defaults ? defaults : undefined;\r\n      }\r\n\r\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\r\n      if (\r\n        !schema.minItems ||\r\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n        schema.minItems <= defaultsLength\r\n      ) {\r\n        return defaults ? defaults : [];\r\n      }\r\n\r\n      const defaultEntries: T[] = (defaults || []) as T[];\r\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\r\n      const fillerDefault = fillerSchema.default;\r\n\r\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\r\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\r\n        computeDefaults<any, S, F>(validator, fillerSchema, {\r\n          parentDefaults: fillerDefault,\r\n          rootSchema,\r\n          _recurseList,\r\n          experimental_defaultFormStateBehavior,\r\n          required,\r\n        })\r\n      ) as T[];\r\n      // then fill up the rest with either the item default or empty, up to minItems\r\n      return defaultEntries.concat(fillerEntries);\r\n    }\r\n  }\r\n\r\n  return defaults;\r\n}\r\n\r\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n * computed to have defaults provided in the `schema`.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which the default state is desired\r\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\r\nexport default function getDefaultFormState<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  formData?: T,\r\n  rootSchema?: S,\r\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\r\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\r\n) {\r\n  if (!isObject(theSchema)) {\r\n    throw new Error('Invalid schema: ' + theSchema);\r\n  }\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\r\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\r\n    rootSchema,\r\n    includeUndefinedValues,\r\n    experimental_defaultFormStateBehavior,\r\n    rawFormData: formData,\r\n  });\r\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\r\n    // No form data? Use schema defaults.\r\n    return defaults;\r\n  }\r\n  // On a case by case basis, we may want to override the default behavior of populating array items.\r\n  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\r\n\r\n  const { mergeExtraDefaults } = arrayMinItems || {};\r\n  if (isObject(formData)) {\r\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\r\n  }\r\n  if (Array.isArray(formData)) {\r\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\r\n  }\r\n  return formData;\r\n}\r\n", "import jsonpointer from 'jsonpointer';\r\nimport omit from 'lodash/omit';\r\n\r\nimport { REF_KEY } from './constants';\r\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\r\n * location, the `object` minus the `key: value` and in the second location the `value`.\r\n *\r\n * @param key - The key from the object to extract\r\n * @param object - The object from which to extract the element\r\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\r\n *      value from `object[key]`\r\n */\r\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\r\n  const value = object[key];\r\n  const remaining = omit(object, [key]);\r\n  return [remaining, value];\r\n}\r\n\r\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\r\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\r\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\r\n *\r\n * @param $ref - The ref string for which the schema definition is desired\r\n * @param [rootSchema={}] - The root schema in which to search for the definition\r\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\r\n * @throws - Error indicating that no schema for that reference exists\r\n */\r\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\r\n  $ref?: string,\r\n  rootSchema: S = {} as S\r\n): S {\r\n  let ref = $ref || '';\r\n  if (ref.startsWith('#')) {\r\n    // Decode URI fragment representation.\r\n    ref = decodeURIComponent(ref.substring(1));\r\n  } else {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  const current: S = jsonpointer.get(rootSchema, ref);\r\n  if (current === undefined) {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  if (current[REF_KEY]) {\r\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\r\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\r\n    if (Object.keys(remaining).length > 0) {\r\n      return { ...remaining, ...subSchema };\r\n    }\r\n    return subSchema;\r\n  }\r\n  return current;\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\nimport isNumber from 'lodash/isNumber';\r\nimport isObject from 'lodash/isObject';\r\nimport isString from 'lodash/isString';\r\nimport reduce from 'lodash/reduce';\r\nimport times from 'lodash/times';\r\n\r\nimport getFirstMatchingOption from './getFirstMatchingOption';\r\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\r\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\r\nimport guessType from '../guessType';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\r\n\r\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\r\n * the first item\r\n */\r\nexport const JUNK_OPTION: StrictRJSFSchema = {\r\n  type: 'object',\r\n  $id: JUNK_OPTION_ID,\r\n  properties: {\r\n    __not_really_there__: {\r\n      type: 'number',\r\n    },\r\n  },\r\n};\r\n\r\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\r\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\r\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\r\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\r\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\r\n *   the total.\r\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\r\n *   `getClosestMatchingOption()` of that oneOf.\r\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\r\n *   `value` itself as the sub-schema, and the score is added to the total.\r\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\r\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\r\n *   is incremented by another 1 otherwise it is decremented by 1.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param schema - The schema for which the score is being calculated\r\n * @param formData - The form data associated with the schema, used to calculate the score\r\n * @returns - The score a schema against the formData\r\n */\r\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  schema?: S,\r\n  formData: any = {}\r\n): number {\r\n  let totalScore = 0;\r\n  if (schema) {\r\n    if (isObject(schema.properties)) {\r\n      totalScore += reduce(\r\n        schema.properties,\r\n        (score, value, key) => {\r\n          const formValue = get(formData, key);\r\n          if (typeof value === 'boolean') {\r\n            return score;\r\n          }\r\n          if (has(value, REF_KEY)) {\r\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\r\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\r\n          }\r\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\r\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\r\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\r\n            return (\r\n              score +\r\n              getClosestMatchingOption<T, S, F>(\r\n                validator,\r\n                rootSchema,\r\n                formValue,\r\n                get(value, key) as S[],\r\n                -1,\r\n                discriminator\r\n              )\r\n            );\r\n          }\r\n          if (value.type === 'object') {\r\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\r\n          }\r\n          if (value.type === guessType(formValue)) {\r\n            // If the types match, then we bump the score by one\r\n            let newScore = score + 1;\r\n            if (value.default) {\r\n              // If the schema contains a readonly default value score the value that matches the default higher and\r\n              // any non-matching value lower\r\n              newScore += formValue === value.default ? 1 : -1;\r\n            } else if (value.const) {\r\n              // If the schema contains a const value score the value that matches the default higher and\r\n              // any non-matching value lower\r\n              newScore += formValue === value.const ? 1 : -1;\r\n            }\r\n            // TODO eventually, deal with enums/arrays\r\n            return newScore;\r\n          }\r\n          return score;\r\n        },\r\n        0\r\n      );\r\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\r\n      totalScore += 1;\r\n    }\r\n  }\r\n  return totalScore;\r\n}\r\n\r\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\r\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\r\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\r\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\r\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\r\n * matched.\r\n *\r\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\r\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\r\n * option with the highest score is determined by iterating over the list of valid options, calling\r\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\r\n * eventually has the best score.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param formData - The form data associated with the schema\r\n * @param options - The list of options that can be selected from\r\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n */\r\nexport default function getClosestMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  selectedOption = -1,\r\n  discriminatorField?: string\r\n): number {\r\n  // First resolve any refs in the options\r\n  const resolvedOptions = options.map((option) => {\r\n    return resolveAllReferences<S>(option, rootSchema, []);\r\n  });\r\n\r\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\r\n  if (isNumber(simpleDiscriminatorMatch)) {\r\n    return simpleDiscriminatorMatch;\r\n  }\r\n\r\n  // Reduce the array of options down to a list of the indexes that are considered matching options\r\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\r\n    const testOptions: S[] = [JUNK_OPTION as S, option];\r\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\r\n    // The match is the real option, so add its index to list of valid indexes\r\n    if (match === 1) {\r\n      validList.push(index);\r\n    }\r\n    return validList;\r\n  }, []);\r\n\r\n  // There is only one valid index, so return it!\r\n  if (allValidIndexes.length === 1) {\r\n    return allValidIndexes[0];\r\n  }\r\n  if (!allValidIndexes.length) {\r\n    // No indexes were valid, so we'll score all the options, add all the indexes\r\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\r\n  }\r\n  type BestType = { bestIndex: number; bestScore: number };\r\n  const scoreCount = new Set<number>();\r\n  // Score all the options in the list of valid indexes and return the index with the best score\r\n  const { bestIndex }: BestType = allValidIndexes.reduce(\r\n    (scoreData: BestType, index: number) => {\r\n      const { bestScore } = scoreData;\r\n      const option = resolvedOptions[index];\r\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\r\n      scoreCount.add(score);\r\n      if (score > bestScore) {\r\n        return { bestIndex: index, bestScore: score };\r\n      }\r\n      return scoreData;\r\n    },\r\n    { bestIndex: selectedOption, bestScore: 0 }\r\n  );\r\n  // if all scores are the same go with selectedOption\r\n  if (scoreCount.size === 1 && selectedOption >= 0) {\r\n    return selectedOption;\r\n  }\r\n\r\n  return bestIndex;\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\nimport isNumber from 'lodash/isNumber';\r\n\r\nimport { PROPERTIES_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n * Deprecated, use `getFirstMatchingOption()` instead.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the matched option or 0 if none is available\r\n * @deprecated\r\n */\r\nexport default function getMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  // For performance, skip validating subschemas if formData is undefined. We just\r\n  // want to get the first option in that case.\r\n  if (formData === undefined) {\r\n    return 0;\r\n  }\r\n\r\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\r\n  if (isNumber(simpleDiscriminatorMatch)) {\r\n    return simpleDiscriminatorMatch;\r\n  }\r\n\r\n  for (let i = 0; i < options.length; i++) {\r\n    const option = options[i];\r\n\r\n    // If we have a discriminator field, then we will use this to make the determination\r\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\r\n      const value = get(formData, discriminatorField);\r\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\r\n      if (validator.isValid(discriminator, value, rootSchema)) {\r\n        return i;\r\n      }\r\n    } else if (option[PROPERTIES_KEY]) {\r\n      // If the schema describes an object then we need to add slightly more\r\n      // strict matching to the schema, because unless the schema uses the\r\n      // \"requires\" keyword, an object will match the schema as long as it\r\n      // doesn't have matching keys with a conflicting type. To do this we use an\r\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\r\n      // schema should match if any of the keys in the schema are present on the\r\n      // object and pass validation.\r\n      //\r\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\r\n      // \"properties\" object\r\n      const requiresAnyOf = {\r\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\r\n          required: [key],\r\n        })),\r\n      };\r\n\r\n      let augmentedSchema;\r\n\r\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\r\n      if (option.anyOf) {\r\n        // Create a shallow clone of the option\r\n        const { ...shallowClone } = option;\r\n\r\n        if (!shallowClone.allOf) {\r\n          shallowClone.allOf = [];\r\n        } else {\r\n          // If \"allOf\" already exists, shallow clone the array\r\n          shallowClone.allOf = shallowClone.allOf.slice();\r\n        }\r\n\r\n        shallowClone.allOf.push(requiresAnyOf);\r\n\r\n        augmentedSchema = shallowClone;\r\n      } else {\r\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\r\n      }\r\n\r\n      // Remove the \"required\" field as it's likely that not all fields have\r\n      // been filled in yet, which will mean that the schema is not valid\r\n      delete augmentedSchema.required;\r\n\r\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\r\n        return i;\r\n      }\r\n    } else if (validator.isValid(option, formData, rootSchema)) {\r\n      return i;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n", "import get from 'lodash/get';\r\nimport { PROPERTIES_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\r\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\r\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\r\n *\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the matched option or undefined if there is no match\r\n */\r\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\r\n  formData: T | undefined,\r\n  options: S[],\r\n  discriminatorField?: string\r\n): number | undefined {\r\n  if (formData && discriminatorField) {\r\n    const value = get(formData, discriminatorField);\r\n\r\n    if (value === undefined) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < options.length; i++) {\r\n      const option = options[i];\r\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\r\n\r\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\r\n        continue;\r\n      }\r\n\r\n      if (discriminator.const === value) {\r\n        return i;\r\n      }\r\n\r\n      if (discriminator.enum?.includes(value)) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  return;\r\n}\r\n", "import getMatchingOption from './getMatchingOption';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n * Always returns the first option if there is nothing that matches.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the first matched option or 0 if none is available\r\n */\r\nexport default function getFirstMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\nimport set from 'lodash/set';\r\nimport times from 'lodash/times';\r\nimport transform from 'lodash/transform';\r\nimport merge from 'lodash/merge';\r\nimport flattenDeep from 'lodash/flattenDeep';\r\nimport uniq from 'lodash/uniq';\r\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\r\n\r\nimport {\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  ADDITIONAL_PROPERTY_FLAG,\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  DEPENDENCIES_KEY,\r\n  IF_KEY,\r\n  ONE_OF_KEY,\r\n  REF_KEY,\r\n  PROPERTIES_KEY,\r\n  ITEMS_KEY,\r\n} from '../constants';\r\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport guessType from '../guessType';\r\nimport isObject from '../isObject';\r\nimport mergeSchemas from '../mergeSchemas';\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getFirstMatchingOption from './getFirstMatchingOption';\r\n\r\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\r\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\r\n * potentially recursive resolution.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n */\r\nexport default function retrieveSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\r\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\r\n}\r\n\r\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\r\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\r\n * conditions will be returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\r\n * @param schema - The schema for which resolving a condition is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\r\n *          dependencies as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\r\n */\r\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\r\n\r\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\r\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\r\n  let schemas: S[] = [];\r\n  if (expandAllBranches) {\r\n    if (then && typeof then !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\r\n      );\r\n    }\r\n    if (otherwise && typeof otherwise !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\r\n      );\r\n    }\r\n  } else {\r\n    const conditionalSchema = conditionValue ? then : otherwise;\r\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(\r\n          validator,\r\n          conditionalSchema as S,\r\n          rootSchema,\r\n          formData,\r\n          expandAllBranches,\r\n          recurseList\r\n        )\r\n      );\r\n    }\r\n  }\r\n  if (schemas.length) {\r\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\r\n  }\r\n  return resolvedSchemas.flatMap((s) =>\r\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\r\n  );\r\n}\r\n\r\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\r\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\r\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\r\n *\r\n * For example:\r\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\r\n *   C schemas then:\r\n *   - The permutation for the first row is `[[A]]`\r\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\r\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\r\n *\r\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\r\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\r\n */\r\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\r\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\r\n    (permutations, list) => {\r\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\r\n      if (list.length > 1) {\r\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\r\n      }\r\n      // Otherwise just push in the single value into the current set of permutations\r\n      permutations.forEach((permutation) => permutation.push(list[0]));\r\n      return permutations;\r\n    },\r\n    [[]] as S[][] // Start with an empty list\r\n  );\r\n\r\n  return allPermutations;\r\n}\r\n\r\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\r\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\r\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\r\n */\r\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const updatedSchemas = resolveReference<T, S, F>(\r\n    validator,\r\n    schema,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    recurseList,\r\n    formData\r\n  );\r\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\r\n    // return the updatedSchemas array if it has either multiple schemas within it\r\n    // OR the first schema is not the same as the original schema\r\n    return updatedSchemas;\r\n  }\r\n  if (DEPENDENCIES_KEY in schema) {\r\n    const resolvedSchemas = resolveDependencies<T, S, F>(\r\n      validator,\r\n      schema,\r\n      rootSchema,\r\n      expandAllBranches,\r\n      recurseList,\r\n      formData\r\n    );\r\n    return resolvedSchemas.flatMap((s) => {\r\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\r\n    });\r\n  }\r\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\r\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\r\n      retrieveSchemaInternal<T, S, F>(\r\n        validator,\r\n        allOfSubschema as S,\r\n        rootSchema,\r\n        formData,\r\n        expandAllBranches,\r\n        recurseList\r\n      )\r\n    );\r\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\r\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\r\n  }\r\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\r\n  return [schema];\r\n}\r\n\r\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\r\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\r\n * helper call.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a reference is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list schemas retrieved after having all references resolved\r\n */\r\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\r\n  if (updatedSchema !== schema) {\r\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\r\n    return retrieveSchemaInternal<T, S, F>(\r\n      validator,\r\n      updatedSchema,\r\n      rootSchema,\r\n      formData,\r\n      expandAllBranches,\r\n      recurseList\r\n    );\r\n  }\r\n  return [schema];\r\n}\r\n\r\n/** Resolves all references within the schema itself as well as any of its properties and array items.\r\n *\r\n * @param schema - The schema for which resolving all references is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param recurseList - List of $refs already resolved to prevent recursion\r\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\r\n */\r\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  rootSchema: S,\r\n  recurseList: string[]\r\n): S {\r\n  if (!isObject(schema)) {\r\n    return schema;\r\n  }\r\n  let resolvedSchema: S = schema;\r\n  // resolve top level ref\r\n  if (REF_KEY in resolvedSchema) {\r\n    const { $ref, ...localSchema } = resolvedSchema;\r\n    // Check for a recursive reference and stop the loop\r\n    if (recurseList.includes($ref!)) {\r\n      return resolvedSchema;\r\n    }\r\n    recurseList.push($ref!);\r\n    // Retrieve the referenced schema definition.\r\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\r\n    resolvedSchema = { ...refSchema, ...localSchema };\r\n  }\r\n\r\n  if (PROPERTIES_KEY in resolvedSchema) {\r\n    const childrenLists: string[][] = [];\r\n    const updatedProps = transform(\r\n      resolvedSchema[PROPERTIES_KEY]!,\r\n      (result, value, key: string) => {\r\n        const childList: string[] = [...recurseList];\r\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\r\n        childrenLists.push(childList);\r\n      },\r\n      {} as RJSFSchema\r\n    );\r\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\r\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\r\n  }\r\n\r\n  if (\r\n    ITEMS_KEY in resolvedSchema &&\r\n    !Array.isArray(resolvedSchema.items) &&\r\n    typeof resolvedSchema.items !== 'boolean'\r\n  ) {\r\n    resolvedSchema = {\r\n      ...resolvedSchema,\r\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\r\n    };\r\n  }\r\n\r\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\r\n}\r\n\r\n/** Creates new 'properties' items for each key in the `formData`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which the existing additional properties is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\r\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The updated schema with additional properties stubbed\r\n */\r\nexport function stubExistingAdditionalProperties<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\r\n  // Clone the schema so that we don't ruin the consumer's original\r\n  const schema = {\r\n    ...theSchema,\r\n    properties: { ...theSchema.properties },\r\n  };\r\n\r\n  // make sure formData is an object\r\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\r\n  Object.keys(formData).forEach((key) => {\r\n    if (key in schema.properties) {\r\n      // No need to stub, our schema already has the property\r\n      return;\r\n    }\r\n\r\n    let additionalProperties: S['additionalProperties'] = {};\r\n    if (typeof schema.additionalProperties !== 'boolean') {\r\n      if (REF_KEY in schema.additionalProperties!) {\r\n        additionalProperties = retrieveSchema<T, S, F>(\r\n          validator,\r\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\r\n          rootSchema,\r\n          formData as T\r\n        );\r\n      } else if ('type' in schema.additionalProperties!) {\r\n        additionalProperties = { ...schema.additionalProperties };\r\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\r\n        additionalProperties = {\r\n          type: 'object',\r\n          ...schema.additionalProperties,\r\n        };\r\n      } else {\r\n        additionalProperties = { type: guessType(get(formData, [key])) };\r\n      }\r\n    } else {\r\n      additionalProperties = { type: guessType(get(formData, [key])) };\r\n    }\r\n\r\n    // The type of our new key should match the additionalProperties value;\r\n    schema.properties[key] = additionalProperties;\r\n    // Set our additional property flag so we know it was dynamically added\r\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\r\n  });\r\n\r\n  return schema;\r\n}\r\n\r\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\r\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\r\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\r\n * of the schema and its references, conditions and dependencies are returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\r\n *          dependencies as a list of schemas\r\n * @param [recurseList=[]] - The optional, list of recursive references already processed\r\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\r\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\r\n */\r\nexport function retrieveSchemaInternal<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  rawFormData?: T,\r\n  expandAllBranches = false,\r\n  recurseList: string[] = []\r\n): S[] {\r\n  if (!isObject(schema)) {\r\n    return [{} as S];\r\n  }\r\n  const resolvedSchemas = resolveSchema<T, S, F>(\r\n    validator,\r\n    schema,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    recurseList,\r\n    rawFormData\r\n  );\r\n  return resolvedSchemas.flatMap((s: S) => {\r\n    let resolvedSchema = s;\r\n    if (IF_KEY in resolvedSchema) {\r\n      return resolveCondition<T, S, F>(\r\n        validator,\r\n        resolvedSchema,\r\n        rootSchema,\r\n        expandAllBranches,\r\n        recurseList,\r\n        rawFormData as T\r\n      );\r\n    }\r\n    if (ALL_OF_KEY in resolvedSchema) {\r\n      // resolve allOf schemas\r\n      if (expandAllBranches) {\r\n        const { allOf, ...restOfSchema } = resolvedSchema;\r\n        return [...(allOf as S[]), restOfSchema as S];\r\n      }\r\n      try {\r\n        resolvedSchema = mergeAllOf(resolvedSchema, {\r\n          deep: false,\r\n        } as Options) as S;\r\n      } catch (e) {\r\n        console.warn('could not merge subschemas in allOf:\\n', e);\r\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\r\n        return resolvedSchemaWithoutAllOf as S;\r\n      }\r\n    }\r\n    const hasAdditionalProperties =\r\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\r\n    if (hasAdditionalProperties) {\r\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\r\n    }\r\n\r\n    return resolvedSchema;\r\n  });\r\n}\r\n\r\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\r\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\r\n * options are retrieved and returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\r\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\r\n */\r\nexport function resolveAnyOrOneOfSchemas<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\r\n  let anyOrOneOf: S[] | undefined;\r\n  const { oneOf, anyOf, ...remaining } = schema;\r\n  if (Array.isArray(oneOf)) {\r\n    anyOrOneOf = oneOf as S[];\r\n  } else if (Array.isArray(anyOf)) {\r\n    anyOrOneOf = anyOf as S[];\r\n  }\r\n  if (anyOrOneOf) {\r\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\r\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    anyOrOneOf = anyOrOneOf.map((s) => {\r\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\r\n      // can resolve recursive references independently\r\n      return resolveAllReferences(s, rootSchema, []);\r\n    });\r\n    // Call this to trigger the set of isValid() calls that the schema parser will need\r\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\r\n    if (expandAllBranches) {\r\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\r\n    }\r\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\r\n  }\r\n  return [schema];\r\n}\r\n\r\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\r\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependency is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list of schemas with their dependencies resolved\r\n */\r\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  // Drop the dependencies from the source schema.\r\n  const { dependencies, ...remainingSchema } = schema;\r\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\r\n    validator,\r\n    remainingSchema as S,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    formData\r\n  );\r\n  return resolvedSchemas.flatMap((resolvedSchema) =>\r\n    processDependencies<T, S, F>(\r\n      validator,\r\n      dependencies,\r\n      resolvedSchema,\r\n      rootSchema,\r\n      expandAllBranches,\r\n      recurseList,\r\n      formData\r\n    )\r\n  );\r\n}\r\n\r\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\r\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param dependencies - The set of dependencies that needs to be processed\r\n * @param resolvedSchema - The schema for which processing dependencies is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema with the `dependencies` resolved into it\r\n */\r\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  dependencies: S['dependencies'],\r\n  resolvedSchema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  let schemas = [resolvedSchema];\r\n  // Process dependencies updating the local schema properties as appropriate.\r\n  for (const dependencyKey in dependencies) {\r\n    // Skip this dependency if its trigger property is not present.\r\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\r\n      continue;\r\n    }\r\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\r\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\r\n      continue;\r\n    }\r\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\r\n      dependencyKey,\r\n      dependencies as GenericObjectType\r\n    );\r\n    if (Array.isArray(dependencyValue)) {\r\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\r\n    } else if (isObject(dependencyValue)) {\r\n      schemas = withDependentSchema<T, S, F>(\r\n        validator,\r\n        resolvedSchema,\r\n        rootSchema,\r\n        dependencyKey,\r\n        dependencyValue as S,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      );\r\n    }\r\n    return schemas.flatMap((schema) =>\r\n      processDependencies<T, S, F>(\r\n        validator,\r\n        remainingDependencies,\r\n        schema,\r\n        rootSchema,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      )\r\n    );\r\n  }\r\n  return schemas;\r\n}\r\n\r\n/** Updates a schema with additionally required properties added\r\n *\r\n * @param schema - The schema for which resolving a dependent properties is desired\r\n * @param [additionallyRequired] - An optional array of additionally required names\r\n * @returns - The schema with the additional required values merged in\r\n */\r\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  additionallyRequired?: string[]\r\n) {\r\n  if (!additionallyRequired) {\r\n    return schema;\r\n  }\r\n  const required = Array.isArray(schema.required)\r\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\r\n    : additionallyRequired;\r\n  return { ...schema, required: required };\r\n}\r\n\r\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\r\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependent schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the dependency\r\n * @param dependencyValue - The potentially dependent schema\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData]- The current formData to assist retrieving a schema\r\n * @returns - The list of schemas with the dependent schema resolved into them\r\n */\r\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  dependencyKey: string,\r\n  dependencyValue: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\r\n    validator,\r\n    dependencyValue,\r\n    rootSchema,\r\n    formData,\r\n    expandAllBranches,\r\n    recurseList\r\n  );\r\n  return dependentSchemas.flatMap((dependent) => {\r\n    const { oneOf, ...dependentSchema } = dependent;\r\n    schema = mergeSchemas(schema, dependentSchema) as S;\r\n    // Since it does not contain oneOf, we return the original schema.\r\n    if (oneOf === undefined) {\r\n      return schema;\r\n    }\r\n    // Resolve $refs inside oneOf.\r\n    const resolvedOneOfs = oneOf.map((subschema) => {\r\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\r\n        return [subschema as S];\r\n      }\r\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\r\n    });\r\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\r\n    return allPermutations.flatMap((resolvedOneOf) =>\r\n      withExactlyOneSubschema<T, S, F>(\r\n        validator,\r\n        schema,\r\n        rootSchema,\r\n        dependencyKey,\r\n        resolvedOneOf,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      )\r\n    );\r\n  });\r\n}\r\n\r\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\r\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\r\n * the `retrieveSchemaInternal()` helper call.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\r\n * @param schema - The schema for which resolving a oneOf subschema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the oneOf dependency\r\n * @param oneOf - The list of schemas representing the oneOf options\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\r\n */\r\nexport function withExactlyOneSubschema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  dependencyKey: string,\r\n  oneOf: S['oneOf'],\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const validSubschemas = oneOf!.filter((subschema) => {\r\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\r\n      return false;\r\n    }\r\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\r\n    if (conditionPropertySchema) {\r\n      const conditionSchema: S = {\r\n        type: 'object',\r\n        properties: {\r\n          [dependencyKey]: conditionPropertySchema,\r\n        },\r\n      } as S;\r\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\r\n    }\r\n    return false;\r\n  });\r\n\r\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\r\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\r\n    return [schema];\r\n  }\r\n  return validSubschemas.flatMap((s) => {\r\n    const subschema: S = s as S;\r\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\r\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\r\n    const schemas = retrieveSchemaInternal<T, S, F>(\r\n      validator,\r\n      dependentSchema,\r\n      rootSchema,\r\n      formData,\r\n      expandAllBranches,\r\n      recurseList\r\n    );\r\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\r\n  });\r\n}\r\n", "import get from 'lodash/get';\r\nimport isString from 'lodash/isString';\r\n\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\r\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\r\n *\r\n * @param schema - The schema from which the discriminator is potentially obtained\r\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\r\n */\r\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  let discriminator: string | undefined;\r\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\r\n  if (isString(maybeString)) {\r\n    discriminator = maybeString;\r\n  } else if (maybeString !== undefined) {\r\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\r\n  }\r\n  return discriminator;\r\n}\r\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\r\n *  create a schema, it is useful to know what type to use based on the data we are defining.\r\n *\r\n * @param value - The value from which to guess the type\r\n * @returns - The best guess for the object type\r\n */\r\nexport default function guessType(value: any) {\r\n  if (Array.isArray(value)) {\r\n    return 'array';\r\n  }\r\n  if (typeof value === 'string') {\r\n    return 'string';\r\n  }\r\n  if (value == null) {\r\n    return 'null';\r\n  }\r\n  if (typeof value === 'boolean') {\r\n    return 'boolean';\r\n  }\r\n  if (!isNaN(value)) {\r\n    return 'number';\r\n  }\r\n  if (typeof value === 'object') {\r\n    return 'object';\r\n  }\r\n  // Default to string if we can't figure it out\r\n  return 'string';\r\n}\r\n", "import union from 'lodash/union';\r\n\r\nimport { REQUIRED_KEY } from './constants';\r\nimport getSchemaType from './getSchemaType';\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\r\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\r\n * duplicate values.\r\n *\r\n * @param obj1 - The first schema object to merge\r\n * @param obj2 - The second schema object to merge\r\n * @returns - The merged schema object\r\n */\r\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\r\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeSchemas(left, right);\r\n    } else if (\r\n      obj1 &&\r\n      obj2 &&\r\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\r\n      key === REQUIRED_KEY &&\r\n      Array.isArray(left) &&\r\n      Array.isArray(right)\r\n    ) {\r\n      // Don't include duplicate values when merging 'required' fields.\r\n      acc[key] = union(left, right);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, acc);\r\n}\r\n", "import guessType from './guessType';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\r\n * other elements of the schema as follows:\r\n * - schema.const: Returns the `guessType()` of that value\r\n * - schema.enum: Returns `string`\r\n * - schema.properties: Returns `object`\r\n * - schema.additionalProperties: Returns `object`\r\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\r\n *\r\n * @param schema - The schema for which to get the type\r\n * @returns - The type of the schema\r\n */\r\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S\r\n): string | string[] | undefined {\r\n  let { type } = schema;\r\n\r\n  if (!type && schema.const) {\r\n    return guessType(schema.const);\r\n  }\r\n\r\n  if (!type && schema.enum) {\r\n    return 'string';\r\n  }\r\n\r\n  if (!type && (schema.properties || schema.additionalProperties)) {\r\n    return 'object';\r\n  }\r\n\r\n  if (Array.isArray(type)) {\r\n    if (type.length === 2 && type.includes('null')) {\r\n      type = type.find((type) => type !== 'null');\r\n    } else {\r\n      type = type[0];\r\n    }\r\n  }\r\n\r\n  return type;\r\n}\r\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\r\n * that only contains objects.\r\n *\r\n * @param schema - The schema in which to check for fixed items\r\n * @returns - True if there are fixed items in the schema, false otherwise\r\n */\r\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\r\n}\r\n", "import get from 'lodash/get';\r\n\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from '../src';\r\n\r\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\r\n *\r\n * When merging defaults and form data, we want to merge in this specific way:\r\n * - objects are deeply merged\r\n * - arrays are merged in such a way that:\r\n *   - when the array is set in form data, only array entries set in form data\r\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\r\n *     which case the extras are appended onto the end of the form data\r\n *   - when the array is not set in form data, the default is copied over\r\n * - scalars are overwritten/set by form data\r\n *\r\n * @param [defaults] - The defaults to merge\r\n * @param [formData] - The form data into which the defaults will be merged\r\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\r\n * @returns - The resulting merged form data with defaults\r\n */\r\nexport default function mergeDefaultsWithFormData<T = any>(\r\n  defaults?: T,\r\n  formData?: T,\r\n  mergeExtraArrayDefaults = false\r\n): T | undefined {\r\n  if (Array.isArray(formData)) {\r\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\r\n    const mapped = formData.map((value, idx) => {\r\n      if (defaultsArray[idx]) {\r\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\r\n      }\r\n      return value;\r\n    });\r\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\r\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\r\n      mapped.push(...defaultsArray.slice(mapped.length));\r\n    }\r\n    return mapped as unknown as T;\r\n  }\r\n  if (isObject(formData)) {\r\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\r\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\r\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\r\n        defaults ? get(defaults, key) : {},\r\n        get(formData, key),\r\n        mergeExtraArrayDefaults\r\n      );\r\n      return acc;\r\n    }, acc);\r\n  }\r\n  return formData;\r\n}\r\n", "import isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested objects.\r\n *\r\n * @param obj1 - The first object to merge\r\n * @param obj2 - The second object to merge\r\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\r\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\r\n *          NOTE: Uses shallow comparison for the duplicate checking.\r\n * @returns - A new object that is the merge of the two given objects\r\n */\r\nexport default function mergeObjects(\r\n  obj1: GenericObjectType,\r\n  obj2: GenericObjectType,\r\n  concatArrays: boolean | 'preventDuplicates' = false\r\n) {\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeObjects(left, right, concatArrays);\r\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\r\n      let toMerge = right;\r\n      if (concatArrays === 'preventDuplicates') {\r\n        toMerge = right.reduce((result, value) => {\r\n          if (!left.includes(value)) {\r\n            result.push(value);\r\n          }\r\n          return result;\r\n        }, []);\r\n      }\r\n      acc[key] = left.concat(toMerge);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\r\n}\r\n", "import { CONST_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\r\n * an `enum` array with a single value or there is a `const` defined.\r\n *\r\n * @param schema - The schema for a field\r\n * @returns - True if the `schema` has a single constant value, false otherwise\r\n */\r\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\r\n}\r\n", "import isConstant from '../isConstant';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` combination represents a select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which check for a select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a select, otherwise false\r\n */\r\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  rootSchema: S = {} as S\r\n) {\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  if (Array.isArray(schema.enum)) {\r\n    return true;\r\n  }\r\n  if (Array.isArray(altSchemas)) {\r\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\r\n  }\r\n  return false;\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\nimport isSelect from './isSelect';\r\n\r\n/** Checks to see if the `schema` combination represents a multi-select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for a multi-select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a multi-select, otherwise false\r\n */\r\nexport default function isMultiSelect<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\r\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\r\n    return false;\r\n  }\r\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\r\n}\r\n", "import getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\n\r\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\r\n *\r\n * @param uiSchema - The UI Schema from which to detect if it is customized\r\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\r\n */\r\nexport default function isCustomWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}) {\r\n  return (\r\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\r\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\r\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\r\n  );\r\n}\r\n", "import { UI_WIDGET_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for array of files flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to check the widget\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n */\r\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S\r\n) {\r\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\r\n    return true;\r\n  }\r\n  if (schema.items) {\r\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\r\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\r\n  }\r\n  return false;\r\n}\r\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\r\nimport getSchemaType from '../getSchemaType';\r\nimport getUiOptions from '../getUiOptions';\r\nimport isCustomWidget from '../isCustomWidget';\r\nimport {\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isFilesArray from './isFilesArray';\r\nimport isMultiSelect from './isMultiSelect';\r\n\r\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n * should be displayed in a UI.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the display label flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - True if the label should be displayed or false if it should not\r\n */\r\nexport default function getDisplayLabel<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S,\r\n  globalOptions?: GlobalUISchemaOptions\r\n): boolean {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\r\n  const { label = true } = uiOptions;\r\n  let displayLabel = !!label;\r\n  const schemaType = getSchemaType<S>(schema);\r\n\r\n  if (schemaType === 'array') {\r\n    displayLabel =\r\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\r\n      isCustomWidget(uiSchema);\r\n  }\r\n\r\n  if (schemaType === 'object') {\r\n    displayLabel = false;\r\n  }\r\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  if (uiSchema[UI_FIELD_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  return displayLabel;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from '../mergeObjects';\r\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n *        removed in the next major release.\r\n */\r\nexport default function mergeValidationData<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = validator.toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\n\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\nconst NO_VALUE = Symbol('no Value');\r\n\r\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\r\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\r\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\r\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\r\n *\r\n * - If the new schema is an object that contains a `properties` object then:\r\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\r\n *   - Create an empty `nestedData` object for use in the key filtering below:\r\n *   - Iterate over each key in the `newSchema.properties` as follows:\r\n *     - Get the `formValue` of the key from the `data`\r\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\r\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\r\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\r\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\r\n *       - If type of the key in the new schema is `object`:\r\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\r\n *       - Otherwise, check for default or const values:\r\n *         - Get the old and new `default` values from the schema and check:\r\n *           - If the new `default` value does not match the form value:\r\n *             - If the old `default` value DOES match the form value, then:\r\n *               - Replace `removeOldSchemaData[key]` with the new `default`\r\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\r\n *         - Get the old and new `const` values from the schema and check:\r\n *           - If the new `const` value does not match the form value:\r\n *           - If the old `const` value DOES match the form value, then:\r\n *             - Replace `removeOldSchemaData[key]` with the new `const`\r\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\r\n *   - Once all keys have been processed, return an object built as follows:\r\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\r\n * - If the new and old schema types are array and the `data` is an array then:\r\n *   - If the type of the old and new schema `items` are a non-array objects:\r\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\r\n *     - If the `type`s of both items are the same (or the old does not have a type):\r\n *       - If the type is \"object\", then:\r\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\r\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\r\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\r\n * - Otherwise return `undefined`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param [newSchema] - The new schema for which the data is being sanitized\r\n * @param [oldSchema] - The old schema from which the data originated\r\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n */\r\nexport default function sanitizeDataForNewSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\r\n  // By default, we will clear the form data\r\n  let newFormData;\r\n  // If the new schema is of type object and that object contains a list of properties\r\n  if (has(newSchema, PROPERTIES_KEY)) {\r\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\r\n    const removeOldSchemaData: GenericObjectType = {};\r\n    if (has(oldSchema, PROPERTIES_KEY)) {\r\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\r\n      Object.keys(properties).forEach((key) => {\r\n        if (has(data, key)) {\r\n          removeOldSchemaData[key] = undefined;\r\n        }\r\n      });\r\n    }\r\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\r\n    // Create a place to store nested data that will be a side-effect of the filter\r\n    const nestedData: GenericObjectType = {};\r\n    keys.forEach((key) => {\r\n      const formValue = get(data, key);\r\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\r\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\r\n      // Resolve the refs if they exist\r\n      if (has(oldKeyedSchema, REF_KEY)) {\r\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\r\n      }\r\n      if (has(newKeyedSchema, REF_KEY)) {\r\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\r\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\r\n        if (has(removeOldSchemaData, key)) {\r\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\r\n          delete removeOldSchemaData[key];\r\n        }\r\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\r\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\r\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\r\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\r\n            validator,\r\n            rootSchema,\r\n            newKeyedSchema,\r\n            oldKeyedSchema,\r\n            formValue\r\n          );\r\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\r\n            // only put undefined values for the array type and not the object type\r\n            nestedData[key] = itemData;\r\n          }\r\n        } else {\r\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\r\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\r\n          // value to be properly selected\r\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\r\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\r\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\r\n            if (oldOptionDefault === formValue) {\r\n              // If the old default matches the formValue, we'll update the new value to match the new default\r\n              removeOldSchemaData[key] = newOptionDefault;\r\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\r\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\r\n              removeOldSchemaData[key] = undefined;\r\n            }\r\n          }\r\n\r\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\r\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\r\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\r\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\r\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    newFormData = {\r\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\r\n      ...removeOldSchemaData,\r\n      ...nestedData,\r\n    };\r\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\r\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\r\n    let oldSchemaItems = get(oldSchema, 'items');\r\n    let newSchemaItems = get(newSchema, 'items');\r\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\r\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\r\n    if (\r\n      typeof oldSchemaItems === 'object' &&\r\n      typeof newSchemaItems === 'object' &&\r\n      !Array.isArray(oldSchemaItems) &&\r\n      !Array.isArray(newSchemaItems)\r\n    ) {\r\n      if (has(oldSchemaItems, REF_KEY)) {\r\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      if (has(newSchemaItems, REF_KEY)) {\r\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaType = get(oldSchemaItems, 'type');\r\n      const newSchemaType = get(newSchemaItems, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\r\n        const maxItems = get(newSchema, 'maxItems', -1);\r\n        if (newSchemaType === 'object') {\r\n          newFormData = data.reduce((newValue, aValue) => {\r\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\r\n              validator,\r\n              rootSchema,\r\n              newSchemaItems as S,\r\n              oldSchemaItems as S,\r\n              aValue\r\n            );\r\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\r\n              newValue.push(itemValue);\r\n            }\r\n            return newValue;\r\n          }, []);\r\n        } else {\r\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\r\n        }\r\n      }\r\n    } else if (\r\n      typeof oldSchemaItems === 'boolean' &&\r\n      typeof newSchemaItems === 'boolean' &&\r\n      oldSchemaItems === newSchemaItems\r\n    ) {\r\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\r\n      newFormData = data;\r\n    }\r\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\r\n  }\r\n  return newFormData as T;\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport isObject from '../isObject';\r\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\nimport getSchemaType from '../getSchemaType';\r\n\r\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param idPrefix - The prefix to use for the id\r\n * @param idSeparator - The separator to use for the path segments in the id\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  idPrefix: string,\r\n  idSeparator: string,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): IdSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        idPrefix,\r\n        idSeparator,\r\n        id,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\r\n    return toIdSchemaInternal<T, S, F>(\r\n      validator,\r\n      get(schema, ITEMS_KEY) as S,\r\n      idPrefix,\r\n      idSeparator,\r\n      id,\r\n      rootSchema,\r\n      formData,\r\n      _recurseList\r\n    );\r\n  }\r\n  const $id = id || idPrefix;\r\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\r\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\r\n    for (const name in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, name]);\r\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\r\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        isObject(field) ? field : {},\r\n        idPrefix,\r\n        idSeparator,\r\n        fieldId,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [name]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return idSchema as IdSchema<T>;\r\n}\r\n\r\n/** Generates an `IdSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [idPrefix='root'] - The prefix to use for the id\r\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  idPrefix = 'root',\r\n  idSeparator = '_'\r\n): IdSchema<T> {\r\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\nimport set from 'lodash/set';\r\n\r\nimport {\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  DEPENDENCIES_KEY,\r\n  ITEMS_KEY,\r\n  NAME_KEY,\r\n  ONE_OF_KEY,\r\n  PROPERTIES_KEY,\r\n  REF_KEY,\r\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\r\n} from '../constants';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name: string,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): PathSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        name,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n\r\n  let pathSchema: PathSchema = {\r\n    [NAME_KEY]: name.replace(/^\\./, ''),\r\n  } as PathSchema;\r\n\r\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\r\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\r\n    const _schema: S = xxxOf![index] as S;\r\n    pathSchema = {\r\n      ...pathSchema,\r\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\r\n    };\r\n  }\r\n\r\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\r\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\r\n  }\r\n\r\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\r\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\r\n\r\n    if (Array.isArray(schemaItems)) {\r\n      formData.forEach((element, i: number) => {\r\n        if (schemaItems[i]) {\r\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n            validator,\r\n            schemaItems[i] as S,\r\n            `${name}.${i}`,\r\n            rootSchema,\r\n            element,\r\n            _recurseList\r\n          );\r\n        } else if (schemaAdditionalItems) {\r\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n            validator,\r\n            schemaAdditionalItems as S,\r\n            `${name}.${i}`,\r\n            rootSchema,\r\n            element,\r\n            _recurseList\r\n          );\r\n        } else {\r\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\r\n        }\r\n      });\r\n    } else {\r\n      formData.forEach((element, i: number) => {\r\n        pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n          validator,\r\n          schemaItems as S,\r\n          `${name}.${i}`,\r\n          rootSchema,\r\n          element,\r\n          _recurseList\r\n        );\r\n      });\r\n    }\r\n  } else if (PROPERTIES_KEY in schema) {\r\n    for (const property in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, property]);\r\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        field,\r\n        `${name}.${property}`,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [property]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return pathSchema as PathSchema<T>;\r\n}\r\n\r\n/** Generates an `PathSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name = '',\r\n  rootSchema?: S,\r\n  formData?: T\r\n): PathSchema<T> {\r\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\r\n}\r\n", "import deepEquals from './deepEquals';\r\nimport {\r\n  ErrorSchema,\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  IdSchema,\r\n  PathSchema,\r\n  RJSFSchema,\r\n  SchemaUtilsType,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from './types';\r\nimport {\r\n  getDefaultFormState,\r\n  getDisplayLabel,\r\n  getClosestMatchingOption,\r\n  getFirstMatchingOption,\r\n  getMatchingOption,\r\n  isFilesArray,\r\n  isMultiSelect,\r\n  isSelect,\r\n  mergeValidationData,\r\n  retrieveSchema,\r\n  sanitizeDataForNewSchema,\r\n  toIdSchema,\r\n  toPathSchema,\r\n} from './schema';\r\n\r\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\r\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\r\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\r\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\r\n */\r\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements SchemaUtilsType<T, S, F>\r\n{\r\n  rootSchema: S;\r\n  validator: ValidatorType<T, S, F>;\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\r\n\r\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\r\n   */\r\n  constructor(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\r\n  ) {\r\n    this.rootSchema = rootSchema;\r\n    this.validator = validator;\r\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\r\n  }\r\n\r\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\r\n   *\r\n   * @returns - The `ValidatorType`\r\n   */\r\n  getValidator() {\r\n    return this.validator;\r\n  }\r\n\r\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\r\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\r\n   * of a new `SchemaUtilsType` with incomplete properties.\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\r\n   * @param rootSchema - The root schema that will be compared against the current one\r\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\r\n   */\r\n  doesSchemaUtilsDiffer(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior = {}\r\n  ): boolean {\r\n    if (!validator || !rootSchema) {\r\n      return false;\r\n    }\r\n    return (\r\n      this.validator !== validator ||\r\n      !deepEquals(this.rootSchema, rootSchema) ||\r\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\r\n    );\r\n  }\r\n\r\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n   * computed to have defaults provided in the `schema`.\r\n   *\r\n   * @param schema - The schema for which the default state is desired\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\r\n   *          object properties.\r\n   * @returns - The resulting `formData` with all the defaults provided\r\n   */\r\n  getDefaultFormState(\r\n    schema: S,\r\n    formData?: T,\r\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\r\n  ): T | T[] | undefined {\r\n    return getDefaultFormState<T, S, F>(\r\n      this.validator,\r\n      schema,\r\n      formData,\r\n      this.rootSchema,\r\n      includeUndefinedValues,\r\n      this.experimental_defaultFormStateBehavior\r\n    );\r\n  }\r\n\r\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n   * should be displayed in a UI.\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\r\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n   * @returns - True if the label should be displayed or false if it should not\r\n   */\r\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\r\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\r\n  }\r\n\r\n  /** Determines which of the given `options` provided most closely matches the `formData`.\r\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\r\n   *\r\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\r\n   * matching readOnly, default, or const values.\r\n   *\r\n   * @param formData - The form data associated with the schema\r\n   * @param options - The list of options that can be selected from\r\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n   */\r\n  getClosestMatchingOption(\r\n    formData: T | undefined,\r\n    options: S[],\r\n    selectedOption?: number,\r\n    discriminatorField?: string\r\n  ): number {\r\n    return getClosestMatchingOption<T, S, F>(\r\n      this.validator,\r\n      this.rootSchema,\r\n      formData,\r\n      options,\r\n      selectedOption,\r\n      discriminatorField\r\n    );\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n   * Always returns the first option if there is nothing that matches.\r\n   *\r\n   * @param formData - The current formData, if any, used to figure out a match\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The firstindex of the matched option or 0 if none is available\r\n   */\r\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\r\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n   * Deprecated, use `getFirstMatchingOption()` instead.\r\n   *\r\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the matched option or 0 if none is available\r\n   * @deprecated\r\n   */\r\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\r\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n   *\r\n   * @param schema - The schema for which check for array of files flag is desired\r\n   * @param [uiSchema] - The UI schema from which to check the widget\r\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n   */\r\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\r\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a multi-select\r\n   *\r\n   * @param schema - The schema for which check for a multi-select flag is desired\r\n   * @returns - True if schema contains a multi-select, otherwise false\r\n   */\r\n  isMultiSelect(schema: S) {\r\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a select\r\n   *\r\n   * @param schema - The schema for which check for a select flag is desired\r\n   * @returns - True if schema contains a select, otherwise false\r\n   */\r\n  isSelect(schema: S) {\r\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\r\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\r\n   * then `validationData` is returned.\r\n   *\r\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n   * @param [additionalErrorSchema] - The additional set of errors\r\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n   *        removed in the next major release.\r\n   */\r\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\r\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\r\n  }\r\n\r\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\r\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\r\n   * recursive resolution.\r\n   *\r\n   * @param schema - The schema for which retrieving a schema is desired\r\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n   */\r\n  retrieveSchema(schema: S, rawFormData?: T) {\r\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\r\n  }\r\n\r\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\r\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\r\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\r\n   * old schemas that are non-existent in the new schema are set to `undefined`.\r\n   *\r\n   * @param [newSchema] - The new schema for which the data is being sanitized\r\n   * @param [oldSchema] - The old schema from which the data originated\r\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n   */\r\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\r\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\r\n  }\r\n\r\n  /** Generates an `IdSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [id] - The base id for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [idPrefix='root'] - The prefix to use for the id\r\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n   * @returns - The `IdSchema` object for the `schema`\r\n   */\r\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\r\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\r\n  }\r\n\r\n  /** Generates an `PathSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [name] - The base name for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @returns - The `PathSchema` object for the `schema`\r\n   */\r\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\r\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\r\n  }\r\n}\r\n\r\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\r\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - An implementation of a `SchemaUtilsType` interface\r\n */\r\nexport default function createSchemaUtils<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  experimental_defaultFormStateBehavior = {}\r\n): SchemaUtilsType<T, S, F> {\r\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\r\n}\r\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\r\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\r\n *\r\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\r\n * @returns - an object containing a Blob and its name, extracted from the URI\r\n */\r\nexport default function dataURItoBlob(dataURI: string) {\r\n  // Split metadata from data\r\n  const splitted: string[] = dataURI.split(',');\r\n  // Split params\r\n  const params: string[] = splitted[0].split(';');\r\n  // Get mime-type from params\r\n  const type: string = params[0].replace('data:', '');\r\n  // Filter the name property from params\r\n  const properties = params.filter((param) => {\r\n    return param.split('=')[0] === 'name';\r\n  });\r\n  // Look for the name and use unknown if no name property.\r\n  let name: string;\r\n  if (properties.length !== 1) {\r\n    name = 'unknown';\r\n  } else {\r\n    // Because we filtered out the other property,\r\n    // we only have the name case here, which we decode to make it human-readable\r\n    name = decodeURI(properties[0].split('=')[1]);\r\n  }\r\n\r\n  // Built the Uint8Array Blob parameter from the base64 string.\r\n  try {\r\n    const binary = atob(splitted[1]);\r\n    const array = [];\r\n    for (let i = 0; i < binary.length; i++) {\r\n      array.push(binary.charCodeAt(i));\r\n    }\r\n    // Create the blob object\r\n    const blob = new window.Blob([new Uint8Array(array)], { type });\r\n\r\n    return { blob, name };\r\n  } catch (error) {\r\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\r\n  }\r\n}\r\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\r\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\r\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\r\n *\r\n * @param inputString - The string which will be potentially updated with replacement parameters\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The updated string with any replacement specifiers replaced\r\n */\r\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\r\n  let output = inputString;\r\n  if (Array.isArray(params)) {\r\n    const parts = output.split(/(%\\d)/);\r\n    params.forEach((param, index) => {\r\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\r\n      if (partIndex >= 0) {\r\n        parts[partIndex] = param;\r\n      }\r\n    });\r\n    output = parts.join('');\r\n  }\r\n  return output;\r\n}\r\n", "import { TranslatableString } from './enums';\r\nimport replaceStringParameters from './replaceStringParameters';\r\n\r\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\r\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\r\n * `%2`, etc. replacement specifiers.\r\n *\r\n * @param stringToTranslate - The `TranslatableString` value to convert to english\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\r\n */\r\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\r\n  return replaceStringParameters(stringToTranslate, params);\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\n\r\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\r\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\r\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\r\n * is returned, otherwise the `selected` value is returned.\r\n *\r\n * @param valueIndex - The index of the value to be removed from the selected list or single value\r\n * @param selected - The current (list of) selected value(s)\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\r\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\r\n *        undefined, otherwise `selected`.\r\n */\r\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (Array.isArray(selected)) {\r\n    return selected.filter((v) => !isEqual(v, value));\r\n  }\r\n  return isEqual(value, selected) ? undefined : selected;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\r\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\r\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\r\n * valid values or in the worst case, an empty array.\r\n *\r\n * @param valueIndex - The index(es) of the value(s) that should be returned\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\r\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\r\n *        `emptyValue` or an empty list.\r\n */\r\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number | Array<string | number>,\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  emptyValue?: EnumOptionsType<S>['value']\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  if (Array.isArray(valueIndex)) {\r\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\r\n  }\r\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\r\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\r\n  const option = allEnumOptions[index];\r\n  return option ? option.value : emptyValue;\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Determines whether the given `value` is (one of) the `selected` value(s).\r\n *\r\n * @param value - The value being checked to see if it is selected\r\n * @param selected - The current selected value or list of values\r\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\r\n */\r\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'],\r\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\r\n) {\r\n  if (Array.isArray(selected)) {\r\n    return selected.some((sel) => isEqual(sel, value));\r\n  }\r\n  return isEqual(selected, value);\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\r\n\r\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\r\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\r\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\r\n * returned.\r\n *\r\n * @param value - The single value or list of values for which indexes are desired\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\r\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\r\n *        of indexes for (each of) the value(s) in `value`.\r\n */\r\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  multiple = false\r\n): string | string[] | undefined {\r\n  const selectedIndexes: string[] = allEnumOptions\r\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\r\n    .filter((opt) => typeof opt !== 'undefined') as string[];\r\n  if (!multiple) {\r\n    return selectedIndexes[0];\r\n  }\r\n  return selectedIndexes;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\nimport isNil from 'lodash/isNil';\r\n\r\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\r\n * `allEnumOptions`\r\n *\r\n * @param valueIndex - The index of the value that should be selected\r\n * @param selected - The current list of selected values\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\r\n */\r\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected: EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n) {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (!isNil(value)) {\r\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\r\n    const all = allEnumOptions.map(({ value: val }) => val);\r\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\r\n    // As inserting values at predefined index positions doesn't work with empty\r\n    // arrays, we need to reorder the updated selection to match the initial order\r\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\r\n  }\r\n  return selected;\r\n}\r\n", "import cloneDeep from 'lodash/cloneDeep';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { ErrorSchema } from './types';\r\nimport { ERRORS_KEY } from './constants';\r\n\r\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\r\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\r\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\r\n * get the result and/or reset all the errors back to an initial set and start again.\r\n */\r\nexport default class ErrorSchemaBuilder<T = any> {\r\n  /** The error schema being built\r\n   *\r\n   * @private\r\n   */\r\n  private errorSchema: ErrorSchema<T> = {};\r\n\r\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   */\r\n  constructor(initialSchema?: ErrorSchema<T>) {\r\n    this.resetAllErrors(initialSchema);\r\n  }\r\n\r\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\r\n   */\r\n  get ErrorSchema() {\r\n    return this.errorSchema;\r\n  }\r\n\r\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The error block for the given `pathOfError` or the root if not provided\r\n   * @private\r\n   */\r\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\r\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\r\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\r\n    if (!errorBlock && pathOfError) {\r\n      errorBlock = {};\r\n      set(this.errorSchema, pathOfError, errorBlock);\r\n    }\r\n    return errorBlock;\r\n  }\r\n\r\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\r\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\r\n    return this;\r\n  }\r\n\r\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\r\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    let errorsList = get(errorBlock, ERRORS_KEY);\r\n    if (!Array.isArray(errorsList)) {\r\n      errorsList = [];\r\n      errorBlock[ERRORS_KEY] = errorsList;\r\n    }\r\n\r\n    if (Array.isArray(errorOrList)) {\r\n      errorsList.push(...errorOrList);\r\n    } else {\r\n      errorsList.push(errorOrList);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\r\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\r\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\r\n    set(errorBlock, ERRORS_KEY, listToAdd);\r\n    return this;\r\n  }\r\n\r\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\r\n   * the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  clearErrors(pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    set(errorBlock, ERRORS_KEY, []);\r\n    return this;\r\n  }\r\n}\r\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\r\nimport { RJSFSchema } from './types';\r\n\r\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\r\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\r\n *\r\n * @param schema - The schema from which to extract the range spec\r\n * @returns - A range specification from the schema\r\n */\r\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const spec: RangeSpecType = {};\r\n  if (schema.multipleOf) {\r\n    spec.step = schema.multipleOf;\r\n  }\r\n  if (schema.minimum || schema.minimum === 0) {\r\n    spec.min = schema.minimum;\r\n  }\r\n  if (schema.maximum || schema.maximum === 0) {\r\n    spec.max = schema.maximum;\r\n  }\r\n  return spec;\r\n}\r\n", "import rangeSpec from './rangeSpec';\r\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\r\n\r\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\r\n *\r\n * @param schema - The schema for the field provided by the widget\r\n * @param [defaultType] - The default type, if any, for the field provided by the widget\r\n * @param [options={}] - The UI Options for the field provided by the widget\r\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\r\n * @returns - The extracted `InputPropsType` object\r\n */\r\nexport default function getInputProps<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  schema: RJSFSchema,\r\n  defaultType?: string,\r\n  options: UIOptionsType<T, S, F> = {},\r\n  autoDefaultStepAny = true\r\n): InputPropsType {\r\n  const inputProps: InputPropsType = {\r\n    type: defaultType || 'text',\r\n    ...rangeSpec(schema),\r\n  };\r\n\r\n  // If options.inputType is set use that as the input type\r\n  if (options.inputType) {\r\n    inputProps.type = options.inputType;\r\n  } else if (!defaultType) {\r\n    // If the schema is of type number or integer, set the input type to number\r\n    if (schema.type === 'number') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\r\n      if (autoDefaultStepAny && inputProps.step === undefined) {\r\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\r\n        // allowed in number inputs\r\n        inputProps.step = 'any';\r\n      }\r\n    } else if (schema.type === 'integer') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined\r\n      if (inputProps.step === undefined) {\r\n        // Since this is integer, you always want to step up or down in multiples of 1\r\n        inputProps.step = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (options.autocomplete) {\r\n    inputProps.autoComplete = options.autocomplete;\r\n  }\r\n\r\n  return inputProps;\r\n}\r\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\r\nimport getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\r\n\r\n/** The default submit button options, exported for testing purposes\r\n */\r\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\r\n  props: {\r\n    disabled: false,\r\n  },\r\n  submitText: 'Submit',\r\n  norender: false,\r\n};\r\n\r\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\r\n *\r\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\r\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\r\n */\r\nexport default function getSubmitButtonOptions<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\r\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\r\n    return { ...DEFAULT_OPTIONS, ...options };\r\n  }\r\n\r\n  return DEFAULT_OPTIONS;\r\n}\r\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\r\n\r\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\r\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\r\n *\r\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\r\n * @param registry - The `Registry` from which to read the template\r\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\r\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\r\n */\r\nexport default function getTemplate<\r\n  Name extends keyof TemplatesType<T, S, F>,\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\r\n  const { templates } = registry;\r\n  if (name === 'ButtonTemplates') {\r\n    return templates[name];\r\n  }\r\n  return (\r\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\r\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\r\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\r\n  );\r\n}\r\n", "import { createElement } from 'react';\r\nimport ReactIs from 'react-is';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\r\nimport getSchemaType from './getSchemaType';\r\n\r\n/** The map of schema types to widget type to widget name\r\n */\r\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\r\n  boolean: {\r\n    checkbox: 'CheckboxWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  string: {\r\n    text: 'TextWidget',\r\n    password: 'PasswordWidget',\r\n    email: 'EmailWidget',\r\n    hostname: 'TextWidget',\r\n    ipv4: 'TextWidget',\r\n    ipv6: 'TextWidget',\r\n    uri: 'URLWidget',\r\n    'data-url': 'FileWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    textarea: 'TextareaWidget',\r\n    hidden: 'HiddenWidget',\r\n    date: 'DateWidget',\r\n    datetime: 'DateTimeWidget',\r\n    'date-time': 'DateTimeWidget',\r\n    'alt-date': 'AltDateWidget',\r\n    'alt-datetime': 'AltDateTimeWidget',\r\n    time: 'TimeWidget',\r\n    color: 'ColorWidget',\r\n    file: 'FileWidget',\r\n  },\r\n  number: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  integer: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  array: {\r\n    select: 'SelectWidget',\r\n    checkboxes: 'CheckboxesWidget',\r\n    files: 'FileWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n};\r\n\r\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\r\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\r\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\r\n *\r\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\r\n * @returns - The wrapper widget\r\n */\r\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  AWidget: Widget<T, S, F>\r\n) {\r\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\r\n  // cache return value as property of widget for proper react reconciliation\r\n  if (!MergedWidget) {\r\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\r\n    MergedWidget = ({ options, ...props }) => {\r\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\r\n    };\r\n    set(AWidget, 'MergedWidget', MergedWidget);\r\n  }\r\n  return MergedWidget;\r\n}\r\n\r\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\r\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\r\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\r\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\r\n *\r\n * @param schema - The schema for the field\r\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - The `Widget` component to use\r\n * @throws - An error if there is no `Widget` component that can be returned\r\n */\r\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget?: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n): Widget<T, S, F> {\r\n  const type = getSchemaType(schema);\r\n\r\n  if (\r\n    typeof widget === 'function' ||\r\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\r\n    ReactIs.isMemo(widget)\r\n  ) {\r\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\r\n  }\r\n\r\n  if (typeof widget !== 'string') {\r\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\r\n  }\r\n\r\n  if (widget in registeredWidgets) {\r\n    const registeredWidget = registeredWidgets[widget];\r\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    if (!(type in widgetMap)) {\r\n      throw new Error(`No widget for type '${type}'`);\r\n    }\r\n\r\n    if (widget in widgetMap[type]) {\r\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\r\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n    }\r\n  }\r\n\r\n  throw new Error(`No widget '${widget}' for type '${type}'`);\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** JS has no built-in hashing function, so rolling our own\r\n *  based on Java's hashing fn:\r\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\r\n *\r\n * @param string - The string for which to get the hash\r\n * @returns - The resulting hash of the string in hex format\r\n */\r\nfunction hashString(string: string): string {\r\n  let hash = 0;\r\n  for (let i = 0; i < string.length; i += 1) {\r\n    const chr = string.charCodeAt(i);\r\n    hash = (hash << 5) - hash + chr;\r\n    hash = hash & hash; // Convert to 32bit integer\r\n  }\r\n  return hash.toString(16);\r\n}\r\n\r\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\r\n * in consistent order before stringify to prevent different hash ids for the same schema.\r\n *\r\n * @param schema - The schema for which the hash is desired\r\n * @returns - The string obtained from the hash of the stringified schema\r\n */\r\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const allKeys = new Set<string>();\r\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\r\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\r\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\r\n}\r\n", "import getWidget from './getWidget';\r\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\r\n\r\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\r\n * does, or false if it doesn't.\r\n *\r\n * @param schema - The schema for the field\r\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - True if the widget exists, false otherwise\r\n */\r\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n) {\r\n  try {\r\n    getWidget(schema, widget, registeredWidgets);\r\n    return true;\r\n  } catch (e) {\r\n    const err: Error = e as Error;\r\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\r\n      return false;\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n", "import isString from 'lodash/isString';\r\n\r\nimport { IdSchema } from './types';\r\nimport { ID_KEY } from './constants';\r\n\r\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param suffix - The suffix to append to the id\r\n */\r\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\r\n  const theId = isString(id) ? id : id[ID_KEY];\r\n  return `${theId}__${suffix}`;\r\n}\r\n/** Return a consistent `id` for the field description element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field description element from the given `id`\r\n */\r\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'description');\r\n}\r\n\r\n/** Return a consistent `id` for the field error element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field error element from the given `id`\r\n */\r\nexport function errorId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'error');\r\n}\r\n\r\n/** Return a consistent `id` for the field examples element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field examples element from the given `id`\r\n */\r\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'examples');\r\n}\r\n\r\n/** Return a consistent `id` for the field help element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field help element from the given `id`\r\n */\r\nexport function helpId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'help');\r\n}\r\n\r\n/** Return a consistent `id` for the field title element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field title element from the given `id`\r\n */\r\nexport function titleId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'title');\r\n}\r\n\r\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\r\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\r\n * element.\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\r\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\r\n */\r\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\r\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\r\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\r\n}\r\n\r\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\r\n *\r\n * @param id - The id of the parent component for the option\r\n * @param optionIndex - The index of the option for which the id is desired\r\n * @returns - An id for the option index based on the parent `id`\r\n */\r\nexport function optionId(id: string, optionIndex: number) {\r\n  return `${id}-${optionIndex}`;\r\n}\r\n", "import { ReactElement } from 'react';\r\n\r\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\r\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\r\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\r\n * themes require may `false` and others may require an empty string.\r\n *\r\n * @param [label] - The label string or component to render when not hidden\r\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\r\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\r\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\r\n */\r\n\r\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: ''): undefined | string;\r\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: false): undefined | false | string;\r\nexport default function labelValue(label?: ReactElement, hideLabel?: boolean, fallback?: ''): undefined | ReactElement;\r\nexport default function labelValue(\r\n  label?: ReactElement,\r\n  hideLabel?: boolean,\r\n  fallback?: false\r\n): undefined | false | ReactElement;\r\nexport default function labelValue(\r\n  label?: string | ReactElement,\r\n  hideLabel?: boolean,\r\n  fallback?: false | ''\r\n): undefined | false | string | ReactElement {\r\n  return hideLabel ? fallback : label;\r\n}\r\n", "/** Converts a local Date string into a UTC date string\r\n *\r\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\r\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\r\n */\r\nexport default function localToUTC(dateString: string) {\r\n  return dateString ? new Date(dateString).toJSON() : undefined;\r\n}\r\n", "import { CONST_KEY, ENUM_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\r\n * throws an error.\r\n *\r\n * @param schema - The schema from which to obtain the constant value\r\n * @returns - The constant value for the schema\r\n * @throws - Error when the schema does not have a constant value\r\n */\r\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\r\n    return schema.enum[0];\r\n  }\r\n  if (CONST_KEY in schema) {\r\n    return schema.const;\r\n  }\r\n  throw new Error('schema cannot be inferred as a constant');\r\n}\r\n", "import toConstant from './toConstant';\r\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\r\n\r\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\r\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\r\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\r\n * `const` values from the schema and the label is either the `schema.title` or the value.\r\n *\r\n * @param schema - The schema from which to extract the options list\r\n * @returns - The list of options from the schema\r\n */\r\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S\r\n): EnumOptionsType<S>[] | undefined {\r\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\r\n  // Cast the type to include enumNames so the feature still works.\r\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\r\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\r\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\r\n  }\r\n  if (schema.enum) {\r\n    return schema.enum.map((value, i) => {\r\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\r\n      return { label, value };\r\n    });\r\n  }\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  return (\r\n    altSchemas &&\r\n    altSchemas.map((aSchemaDef) => {\r\n      const aSchema = aSchemaDef as S;\r\n      const value = toConstant(aSchema);\r\n      const label = aSchema.title || String(value);\r\n      return {\r\n        schema: aSchema,\r\n        label,\r\n        value,\r\n      };\r\n    })\r\n  );\r\n}\r\n", "import { GenericObjectType } from './types';\r\n\r\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\r\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\r\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\r\n * places in the location of the `*`.\r\n *\r\n * @param properties - The list of property keys to be ordered\r\n * @param order - An array of property keys to be ordered first, with an optional '*' property\r\n * @returns - A list with the `properties` ordered\r\n * @throws - Error when the properties cannot be ordered correctly\r\n */\r\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\r\n  if (!Array.isArray(order)) {\r\n    return properties;\r\n  }\r\n\r\n  const arrayToHash = (arr: string[]) =>\r\n    arr.reduce((prev: GenericObjectType, curr) => {\r\n      prev[curr] = true;\r\n      return prev;\r\n    }, {});\r\n  const errorPropList = (arr: string[]) =>\r\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\r\n  const propertyHash = arrayToHash(properties);\r\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\r\n  const orderHash = arrayToHash(orderFiltered);\r\n\r\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\r\n  const restIndex = orderFiltered.indexOf('*');\r\n  if (restIndex === -1) {\r\n    if (rest.length) {\r\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\r\n    }\r\n    return orderFiltered;\r\n  }\r\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\r\n    throw new Error('uiSchema order list contains more than one wildcard item');\r\n  }\r\n\r\n  const complete = [...orderFiltered];\r\n  complete.splice(restIndex, 1, ...rest);\r\n  return complete;\r\n}\r\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\r\n *\r\n * @param num - The number to pad\r\n * @param width - The width of the string at which no lead padding is necessary\r\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\r\n */\r\nexport default function pad(num: number, width: number) {\r\n  let s = String(num);\r\n  while (s.length < width) {\r\n    s = '0' + s;\r\n  }\r\n  return s;\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\r\n *\r\n * @param dateString - The date string to parse into a DateObject\r\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\r\n * @returns - The date string converted to a `DateObject`\r\n * @throws - Error when the date cannot be parsed from the string\r\n */\r\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\r\n  if (!dateString) {\r\n    return {\r\n      year: -1,\r\n      month: -1,\r\n      day: -1,\r\n      hour: includeTime ? -1 : 0,\r\n      minute: includeTime ? -1 : 0,\r\n      second: includeTime ? -1 : 0,\r\n    };\r\n  }\r\n  const date = new Date(dateString);\r\n  if (Number.isNaN(date.getTime())) {\r\n    throw new Error('Unable to parse date ' + dateString);\r\n  }\r\n  return {\r\n    year: date.getUTCFullYear(),\r\n    month: date.getUTCMonth() + 1, // oh you, javascript.\r\n    day: date.getUTCDate(),\r\n    hour: includeTime ? date.getUTCHours() : 0,\r\n    minute: includeTime ? date.getUTCMinutes() : 0,\r\n    second: includeTime ? date.getUTCSeconds() : 0,\r\n  };\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\r\n * - `schema.const` is truthy\r\n * - `schema.enum` == `[true]`\r\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\r\n * - `schema.allOf` has at least one value which recursively returns true\r\n *\r\n * @param schema - The schema to check\r\n * @returns - True if the schema specifies a value that must be true, false otherwise\r\n */\r\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\r\n  // Check if const is a truthy value\r\n  if (schema.const) {\r\n    return true;\r\n  }\r\n\r\n  // Check if an enum has a single value of true\r\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\r\n    return true;\r\n  }\r\n\r\n  // If anyOf has a single value, evaluate the subschema\r\n  if (schema.anyOf && schema.anyOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\r\n  }\r\n\r\n  // If oneOf has a single value, evaluate the subschema\r\n  if (schema.oneOf && schema.oneOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\r\n  }\r\n\r\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\r\n  if (schema.allOf) {\r\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\r\n    return schema.allOf.some(schemaSome);\r\n  }\r\n\r\n  return false;\r\n}\r\n", "import React from 'react';\r\n\r\nimport deepEquals from './deepEquals';\r\n\r\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\r\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\r\n *\r\n * @param component - A React component being checked\r\n * @param nextProps - The next set of props against which to check\r\n * @param nextState - The next set of state against which to check\r\n * @returns - True if the component should be re-rendered, false otherwise\r\n */\r\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\r\n  const { props, state } = component;\r\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\r\n * removed.\r\n *\r\n * @param dateObject - The `DateObject` to convert to a date string\r\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\r\n * @returns - The UTC date string\r\n */\r\nexport default function toDateString(dateObject: DateObject, time = true) {\r\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\r\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\r\n  const datetime = new Date(utcTime).toJSON();\r\n  return time ? datetime : datetime.slice(0, 10);\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\r\n\r\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\r\n *\r\n * @param errorSchema - The `ErrorSchema` instance to convert\r\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\r\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\r\n */\r\nexport default function toErrorList<T = any>(\r\n  errorSchema?: ErrorSchema<T>,\r\n  fieldPath: string[] = []\r\n): RJSFValidationError[] {\r\n  if (!errorSchema) {\r\n    return [];\r\n  }\r\n  let errorList: RJSFValidationError[] = [];\r\n  if (ERRORS_KEY in errorSchema) {\r\n    errorList = errorList.concat(\r\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\r\n        const property = `.${fieldPath.join('.')}`;\r\n        return {\r\n          property,\r\n          message,\r\n          stack: `${property} ${message}`,\r\n        };\r\n      })\r\n    );\r\n  }\r\n  return Object.keys(errorSchema).reduce((acc, key) => {\r\n    if (key !== ERRORS_KEY) {\r\n      const childSchema = (errorSchema as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\r\n      }\r\n    }\r\n    return acc;\r\n  }, errorList);\r\n}\r\n", "import toPath from 'lodash/toPath';\r\n\r\nimport { ErrorSchema, RJSFValidationError } from './types';\r\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\r\n\r\n/** Transforms a rjsf validation errors list:\r\n * [\r\n *   {property: '.level1.level2[2].level3', message: 'err a'},\r\n *   {property: '.level1.level2[2].level3', message: 'err b'},\r\n *   {property: '.level1.level2[4].level3', message: 'err b'},\r\n * ]\r\n * Into an error tree:\r\n * {\r\n *   level1: {\r\n *     level2: {\r\n *       2: {level3: {errors: ['err a', 'err b']}},\r\n *       4: {level3: {errors: ['err b']}},\r\n *     }\r\n *   }\r\n * };\r\n *\r\n * @param errors - The list of RJSFValidationError objects\r\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\r\n */\r\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\r\n  const builder = new ErrorSchemaBuilder<T>();\r\n  if (errors.length) {\r\n    errors.forEach((error) => {\r\n      const { property, message } = error;\r\n      // When the property is the root element, just use an empty array for the path\r\n      const path = property === '.' ? [] : toPath(property);\r\n      // If the property is at the root (.level1) then toPath creates\r\n      // an empty array element at the first index. Remove it.\r\n      if (path.length > 0 && path[0] === '') {\r\n        path.splice(0, 1);\r\n      }\r\n      if (message) {\r\n        builder.addErrors(message, path);\r\n      }\r\n    });\r\n  }\r\n  return builder.ErrorSchema;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\r\n *\r\n * @param errorHandler - The `FormValidation` error handling structure\r\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\r\n */\r\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\r\n  return Object.keys(errorHandler).reduce((acc, key) => {\r\n    if (key === 'addError') {\r\n      return acc;\r\n    } else {\r\n      const childSchema = (errorHandler as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        return {\r\n          ...acc,\r\n          [key]: unwrapErrorHandler(childSchema),\r\n        };\r\n      }\r\n      return { ...acc, [key]: childSchema };\r\n    }\r\n  }, {} as ErrorSchema<T>);\r\n}\r\n", "import pad from './pad';\r\n\r\n/** Converts a UTC date string into a local Date format\r\n *\r\n * @param jsonDate - A UTC date string\r\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\r\n */\r\nexport default function utcToLocal(jsonDate: string) {\r\n  if (!jsonDate) {\r\n    return '';\r\n  }\r\n\r\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\r\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\r\n  // > should be a _valid local date and time string_ (not GMT)\r\n\r\n  // Note - date constructor passed local ISO-8601 does not correctly\r\n  // change time to UTC in node pre-8\r\n  const date = new Date(jsonDate);\r\n\r\n  const yyyy = pad(date.getFullYear(), 4);\r\n  const MM = pad(date.getMonth() + 1, 2);\r\n  const dd = pad(date.getDate(), 2);\r\n  const hh = pad(date.getHours(), 2);\r\n  const mm = pad(date.getMinutes(), 2);\r\n  const ss = pad(date.getSeconds(), 2);\r\n  const SSS = pad(date.getMilliseconds(), 3);\r\n\r\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from './mergeObjects';\r\nimport toErrorList from './toErrorList';\r\nimport { ErrorSchema, ValidationData } from './types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n */\r\nexport default function validationDataMerge<T = any>(\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\nimport isObject from 'lodash/isObject';\r\n\r\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\r\n  for (const key in node) {\r\n    const realObj: { [k: string]: any } = node;\r\n    const value = realObj[key];\r\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\r\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\r\n    } else {\r\n      realObj[key] = withIdRefPrefix<S>(value);\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\r\n  for (let i = 0; i < node.length; i++) {\r\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\r\n * This is used in isValid to make references to the rootSchema\r\n *\r\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n * @returns - A copy of the `schemaNode` with updated `$ref`s\r\n */\r\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schemaNode: S | S[] | S[keyof S]\r\n): S | S[] | S[keyof S] {\r\n  if (Array.isArray(schemaNode)) {\r\n    return withIdRefPrefixArray<S>([...schemaNode]);\r\n  }\r\n  if (isObject(schemaNode)) {\r\n    return withIdRefPrefixObject<S>({ ...schemaNode });\r\n  }\r\n  return schemaNode;\r\n}\r\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\r\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\r\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\r\n * parameters is important because some languages may choose to put the second parameter before the first in its\r\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\r\n */\r\nexport enum TranslatableString {\r\n  /** Fallback title of an array item, used by ArrayField */\r\n  ArrayItemTitle = 'Item',\r\n  /** Missing items reason, used by ArrayField */\r\n  MissingItems = 'Missing items definition',\r\n  /** Yes label, used by BooleanField */\r\n  YesLabel = 'Yes',\r\n  /** No label, used by BooleanField */\r\n  NoLabel = 'No',\r\n  /** Close label, used by ErrorList */\r\n  CloseLabel = 'Close',\r\n  /** Errors label, used by ErrorList */\r\n  ErrorsLabel = 'Errors',\r\n  /** New additionalProperties string default value, used by ObjectField */\r\n  NewStringDefault = 'New Value',\r\n  /** Add button title, used by AddButton */\r\n  AddButton = 'Add',\r\n  /** Add button title, used by AddButton */\r\n  AddItemButton = 'Add Item',\r\n  /** Copy button title, used by IconButton */\r\n  CopyButton = 'Copy',\r\n  /** Move down button title, used by IconButton */\r\n  MoveDownButton = 'Move down',\r\n  /** Move up button title, used by IconButton */\r\n  MoveUpButton = 'Move up',\r\n  /** Remove button title, used by IconButton */\r\n  RemoveButton = 'Remove',\r\n  /** Now label, used by AltDateWidget */\r\n  NowLabel = 'Now',\r\n  /** Clear label, used by AltDateWidget */\r\n  ClearLabel = 'Clear',\r\n  /** Aria date label, used by DateWidget */\r\n  AriaDateLabel = 'Select a date',\r\n  /** File preview label, used by FileWidget */\r\n  PreviewLabel = 'Preview',\r\n  /** Decrement button aria label, used by UpDownWidget */\r\n  DecrementAriaLabel = 'Decrease value by 1',\r\n  /** Increment button aria label, used by UpDownWidget */\r\n  IncrementAriaLabel = 'Increase value by 1',\r\n  // Strings with replaceable parameters\r\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\r\n  UnknownFieldType = 'Unknown field type %1',\r\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\r\n  OptionPrefix = 'Option %1',\r\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\r\n   * MultiSchemaField\r\n   */\r\n  TitleOptionPrefix = '%1 option %2',\r\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\r\n  KeyLabel = '%1 Key',\r\n  // Strings with replaceable parameters AND/OR that support markdown and html\r\n  /** Invalid object field configuration as provided by the ObjectField */\r\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\r\n  /** Unsupported field schema, used by UnsupportedField */\r\n  UnsupportedField = 'Unsupported field schema.',\r\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\r\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\r\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\r\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\r\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\r\n   * as provided by UnsupportedField\r\n   */\r\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\r\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\r\n   * provided by FileWidget\r\n   */\r\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\r\n}\r\n", "import forEach from 'lodash/forEach';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\r\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\r\nimport ParserValidator, { SchemaMap } from './ParserValidator';\r\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\r\n\r\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\r\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\r\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\r\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\r\n *\r\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\r\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\r\n * @param rootSchema - The root schema from which the schema parsing began\r\n * @param schema - The current schema element being parsed\r\n */\r\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ParserValidator<T, S, F>,\r\n  recurseList: S[],\r\n  rootSchema: S,\r\n  schema: S\r\n) {\r\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\r\n  schemas.forEach((schema) => {\r\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\r\n    if (sameSchemaIndex === -1) {\r\n      recurseList.push(schema);\r\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\r\n      allOptions.forEach((s) => {\r\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\r\n          forEach(schema[PROPERTIES_KEY], (value) => {\r\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\r\n          });\r\n        }\r\n      });\r\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\r\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\r\n * the hash of the schema to schema/sub-schema.\r\n *\r\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\r\n * @returns - The `SchemaMap` of all schemas that were parsed\r\n */\r\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  rootSchema: S\r\n): SchemaMap<S> {\r\n  const validator = new ParserValidator<T, S, F>(rootSchema);\r\n  const recurseList: S[] = [];\r\n\r\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\r\n\r\n  return validator.getSchemaMap();\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ID_KEY } from '../constants';\r\nimport hashForSchema from '../hashForSchema';\r\nimport {\r\n  CustomValidator,\r\n  ErrorSchema,\r\n  ErrorTransformer,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  RJSFValidationError,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from '../types';\r\n\r\n/** The type of the map of schema hash to schema\r\n */\r\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\r\n  [hash: string]: S;\r\n};\r\n\r\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\r\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\r\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\r\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\r\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\r\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\r\n */\r\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements ValidatorType<T, S, F>\r\n{\r\n  /** The rootSchema provided during construction of the class */\r\n  readonly rootSchema: S;\r\n\r\n  /** The map of schemas encountered by the ParserValidator */\r\n  schemaMap: SchemaMap<S> = {};\r\n\r\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\r\n   * first.\r\n   *\r\n   * @param rootSchema - The root schema against which this validator will be executed\r\n   */\r\n  constructor(rootSchema: S) {\r\n    this.rootSchema = rootSchema;\r\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\r\n  }\r\n\r\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\r\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\r\n   * associated with it's `hash` for future use (by a schema compiler).\r\n   *\r\n   * @param schema - The schema which is to be added to the map\r\n   * @param hash - The hash value at which to map the schema\r\n   */\r\n  addSchema(schema: S, hash: string) {\r\n    const key = get(schema, ID_KEY, hash);\r\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\r\n    const existing = this.schemaMap[key];\r\n    if (!existing) {\r\n      this.schemaMap[key] = identifiedSchema;\r\n    } else if (!isEqual(existing, identifiedSchema)) {\r\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\r\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\r\n      throw new Error(\r\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\r\n      );\r\n    }\r\n  }\r\n\r\n  /** Returns the current `schemaMap` to the caller\r\n   */\r\n  getSchemaMap() {\r\n    return this.schemaMap;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\r\n   * the `rootSchema` is not the same as the root schema provided during construction.\r\n   *\r\n   * @param schema - The schema to record in the `schemaMap`\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param rootSchema - The root schema associated with the schema\r\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\r\n   */\r\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\r\n    if (!isEqual(rootSchema, this.rootSchema)) {\r\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\r\n    }\r\n    this.addSchema(schema, hashForSchema<S>(schema));\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _formData - The formData parameter that is ignored\r\n   */\r\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\r\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _errorSchema - The error schema parameter that is ignored\r\n   * @param _fieldPath - The field path parameter that is ignored\r\n   */\r\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\r\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\r\n   * called\r\n   *\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _customValidate - The customValidate parameter that is ignored\r\n   * @param _transformErrors - The transformErrors parameter that is ignored\r\n   * @param _uiSchema - The uiSchema parameter that is ignored\r\n   */\r\n  validateFormData(\r\n    _formData: T,\r\n    _schema: S,\r\n    _customValidate?: CustomValidator<T, S, F>,\r\n    _transformErrors?: ErrorTransformer<T, S, F>,\r\n    _uiSchema?: UiSchema<T, S, F>\r\n  ): ValidationData<T> {\r\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\r\n  }\r\n}\r\n"],
+  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACMe,SAAR,SAA0B,OAAY;AAC3C,MAAI,OAAO,SAAS,eAAe,iBAAiB,MAAM;AACxD,WAAO;AAAA,EACT;AACA,MAAI,OAAO,SAAS,eAAe,iBAAiB,MAAM;AACxD,WAAO;AAAA,EACT;AACA,SAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK;AAC5E;;;ACLe,SAAR,qBAA+E,QAAW;AAC/F,MAAI,OAAO,oBAAoB,MAAM;AACnC,YAAQ,KAAK,iDAAiD;AAAA,EAChE;AACA,SAAO,SAAS,OAAO,eAAe;AACxC;;;ACLe,SAAR,SAA0B,OAAsB;AACrD,MAAI,UAAU,IAAI;AAChB,WAAO;AAAA,EACT;AACA,MAAI,UAAU,MAAM;AAClB,WAAO;AAAA,EACT;AACA,MAAI,MAAM,KAAK,KAAK,GAAG;AAGrB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,KAAK,KAAK,GAAG;AAEtB,WAAO;AAAA,EACT;AAEA,MAAI,UAAU,KAAK,KAAK,GAAG;AAIzB,WAAO;AAAA,EACT;AAEA,QAAM,IAAI,OAAO,KAAK;AACtB,QAAM,QAAQ,OAAO,MAAM,YAAY,CAAC,OAAO,MAAM,CAAC;AAEtD,SAAO,QAAQ,IAAI;AACrB;;;AChCO,IAAM,2BAA2B;AACjC,IAAM,4BAA4B;AAClC,IAAM,aAAa;AACnB,IAAM,aAAa;AACnB,IAAM,YAAY;AAClB,IAAM,cAAc;AACpB,IAAM,kBAAkB;AACxB,IAAM,mBAAmB;AACzB,IAAM,WAAW;AACjB,IAAM,aAAa;AACnB,IAAM,SAAS;AACf,IAAM,SAAS;AACf,IAAM,YAAY;AAClB,IAAM,iBAAiB;AACvB,IAAM,WAAW;AACjB,IAAM,aAAa;AACnB,IAAM,iBAAiB;AACvB,IAAM,eAAe;AACrB,IAAM,yBAAyB;AAC/B,IAAM,UAAU;AAChB,IAAM,iCAAiC;AACvC,IAAM,qBAAqB;AAC3B,IAAM,eAAe;AACrB,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AACvB,IAAM,wBAAwB;;;ACnBtB,SAAR,aACL,WAA8B,CAAC,GAC/B,gBAAuC,CAAC,GAChB;AACxB,SAAO,OAAO,KAAK,QAAQ,EACxB,OAAO,CAAC,QAAQ,IAAI,QAAQ,KAAK,MAAM,CAAC,EACxC;AAAA,IACC,CAAC,SAAS,QAAQ;AAChB,YAAM,QAAQ,SAAS,GAAG;AAC1B,UAAI,QAAQ,iBAAiB,SAAS,KAAK,GAAG;AAC5C,gBAAQ,MAAM,qFAAqF;AACnG,eAAO;AAAA,MACT;AACA,UAAI,QAAQ,kBAAkB,SAAS,KAAK,GAAG;AAC7C,eAAO,EAAE,GAAG,SAAS,GAAG,MAAM;AAAA,MAChC;AACA,aAAO,EAAE,GAAG,SAAS,CAAC,IAAI,UAAU,CAAC,CAAC,GAAG,MAAM;AAAA,IACjD;AAAA,IACA,EAAE,GAAG,cAAc;AAAA,EACrB;AACJ;;;ACnBe,SAAR,UACL,QACA,WAA8B,CAAC,GAC/B,UACA;AACA,MAAI,CAAC,OAAO,sBAAsB;AAChC,WAAO;AAAA,EACT;AACA,QAAM,EAAE,aAAa,KAAK,IAAI,aAAsB,QAAQ;AAC5D,MAAI,eAAe,OAAO;AACxB,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,kBAAkB,UAAa,UAAU;AAClD,WAAO,OAAO,KAAK,QAAQ,EAAE,SAAS,OAAO;AAAA,EAC/C;AACA,SAAO;AACT;;;AC9BA,2BAA0B;AAUX,SAAR,mBAA6C,UAAgC;AAClF,QAAM,UAA2B;AAAA;AAAA;AAAA;AAAA,IAI/B,CAAC,UAAU,GAAG,CAAC;AAAA,IACf,SAAS,SAAiB;AACxB,WAAK,UAAU,EAAG,KAAK,OAAO;AAAA,IAChC;AAAA,EACF;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,OAAO,CAAC,KAAK,OAAO,QAAQ;AAC1C,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,mBAAmB,KAAK,EAAE;AAAA,IACpD,GAAG,OAAO;AAAA,EACZ;AACA,UAAI,qBAAAA,SAAc,QAAQ,GAAG;AAC3B,UAAM,aAAgC;AACtC,WAAO,OAAO,KAAK,UAAU,EAAE,OAAO,CAAC,KAAK,QAAQ;AAClD,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,mBAAmB,WAAW,GAAG,CAAC,EAAE;AAAA,IAC9D,GAAG,OAA4B;AAAA,EACjC;AACA,SAAO;AACT;;;AChCA,yBAAwB;AAST,SAAR,WAA4B,GAAQ,GAAiB;AAC1D,aAAO,mBAAAC,SAAY,GAAG,GAAG,CAAC,KAAU,UAAe;AACjD,QAAI,OAAO,QAAQ,cAAc,OAAO,UAAU,YAAY;AAG5D,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,CAAC;AACH;;;AClBA,IAAAC,cAAgB;AAChB,qBAAoB;;;ACDpB,yBAAwB;AACxB,kBAAiB;AAaV,SAAS,0BAA0B,KAAa,QAA2B;AAChF,QAAM,QAAQ,OAAO,GAAG;AACxB,QAAM,gBAAY,YAAAC,SAAK,QAAQ,CAAC,GAAG,CAAC;AACpC,SAAO,CAAC,WAAW,KAAK;AAC1B;AAWe,SAAR,qBACL,MACA,aAAgB,CAAC,GACd;AACH,MAAI,MAAM,QAAQ;AAClB,MAAI,IAAI,WAAW,GAAG,GAAG;AAEvB,UAAM,mBAAmB,IAAI,UAAU,CAAC,CAAC;AAAA,EAC3C,OAAO;AACL,UAAM,IAAI,MAAM,mCAAmC,IAAI,GAAG;AAAA,EAC5D;AACA,QAAM,UAAa,mBAAAC,QAAY,IAAI,YAAY,GAAG;AAClD,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI,MAAM,mCAAmC,IAAI,GAAG;AAAA,EAC5D;AACA,MAAI,QAAQ,OAAO,GAAG;AACpB,UAAM,CAAC,WAAW,MAAM,IAAI,0BAA0B,SAAS,OAAO;AACtE,UAAM,YAAY,qBAAwB,QAAQ,UAAU;AAC5D,QAAI,OAAO,KAAK,SAAS,EAAE,SAAS,GAAG;AACrC,aAAO,EAAE,GAAG,WAAW,GAAG,UAAU;AAAA,IACtC;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;;;ACrDA,IAAAC,cAAgB;AAChB,IAAAC,cAAgB;AAChB,IAAAC,mBAAqB;AACrB,IAAAC,mBAAqB;AACrB,IAAAC,mBAAqB;AACrB,oBAAmB;AACnB,IAAAC,gBAAkB;;;ACNlB,IAAAC,cAAgB;AAChB,iBAAgB;AAChB,sBAAqB;;;ACFrB,iBAAgB;AAcD,SAAR,qCACL,UACA,SACA,oBACoB;AACpB,MAAI,YAAY,oBAAoB;AAClC,UAAM,YAAQ,WAAAC,SAAI,UAAU,kBAAkB;AAE9C,QAAI,UAAU,QAAW;AACvB;AAAA,IACF;AAEA,aAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,YAAM,SAAS,QAAQ,CAAC;AACxB,YAAM,oBAAgB,WAAAA,SAAI,QAAQ,CAAC,gBAAgB,kBAAkB,GAAG,CAAC,CAAC;AAE1E,UAAI,cAAc,SAAS,YAAY,cAAc,SAAS,SAAS;AACrE;AAAA,MACF;AAEA,UAAI,cAAc,UAAU,OAAO;AACjC,eAAO;AAAA,MACT;AAEA,UAAI,cAAc,MAAM,SAAS,KAAK,GAAG;AACvC,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AAEA;AACF;;;ADzBe,SAAR,kBAKL,WACA,UACA,SACA,YACA,oBACQ;AAGR,MAAI,aAAa,QAAW;AAC1B,WAAO;AAAA,EACT;AAEA,QAAM,2BAA2B,qCAAqC,UAAU,SAAS,kBAAkB;AAC3G,UAAI,gBAAAC,SAAS,wBAAwB,GAAG;AACtC,WAAO;AAAA,EACT;AAEA,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,UAAM,SAAS,QAAQ,CAAC;AAGxB,QAAI,0BAAsB,WAAAC,SAAI,QAAQ,CAAC,gBAAgB,kBAAkB,CAAC,GAAG;AAC3E,YAAM,YAAQ,YAAAC,SAAI,UAAU,kBAAkB;AAC9C,YAAM,oBAAgB,YAAAA,SAAI,QAAQ,CAAC,gBAAgB,kBAAkB,GAAG,CAAC,CAAC;AAC1E,UAAI,UAAU,QAAQ,eAAe,OAAO,UAAU,GAAG;AACvD,eAAO;AAAA,MACT;AAAA,IACF,WAAW,OAAO,cAAc,GAAG;AAWjC,YAAM,gBAAgB;AAAA,QACpB,OAAO,OAAO,KAAK,OAAO,cAAc,CAAC,EAAE,IAAI,CAAC,SAAS;AAAA,UACvD,UAAU,CAAC,GAAG;AAAA,QAChB,EAAE;AAAA,MACJ;AAEA,UAAI;AAGJ,UAAI,OAAO,OAAO;AAEhB,cAAM,EAAE,GAAG,aAAa,IAAI;AAE5B,YAAI,CAAC,aAAa,OAAO;AACvB,uBAAa,QAAQ,CAAC;AAAA,QACxB,OAAO;AAEL,uBAAa,QAAQ,aAAa,MAAM,MAAM;AAAA,QAChD;AAEA,qBAAa,MAAM,KAAK,aAAa;AAErC,0BAAkB;AAAA,MACpB,OAAO;AACL,0BAAkB,OAAO,OAAO,CAAC,GAAG,QAAQ,aAAa;AAAA,MAC3D;AAIA,aAAO,gBAAgB;AAEvB,UAAI,UAAU,QAAQ,iBAAiB,UAAU,UAAU,GAAG;AAC5D,eAAO;AAAA,MACT;AAAA,IACF,WAAW,UAAU,QAAQ,QAAQ,UAAU,UAAU,GAAG;AAC1D,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;AExFe,SAAR,uBAKL,WACA,UACA,SACA,YACA,oBACQ;AACR,SAAO,kBAA2B,WAAW,UAAU,SAAS,YAAY,kBAAkB;AAChG;;;AC1BA,IAAAC,cAAgB;AAChB,qBAAoB;AACpB,iBAAgB;AAChB,mBAAkB;AAClB,uBAAsB;AACtB,mBAAkB;AAClB,yBAAwB;AACxB,kBAAiB;AACjB,qCAAoC;;;ACRpC,IAAAC,cAAgB;AAChB,sBAAqB;AAUN,SAAR,gCAA0F,QAAW;AAC1G,MAAI;AACJ,QAAM,kBAAc,YAAAC,SAAI,QAAQ,8BAA8B,MAAS;AACvE,UAAI,gBAAAC,SAAS,WAAW,GAAG;AACzB,oBAAgB;AAAA,EAClB,WAAW,gBAAgB,QAAW;AACpC,YAAQ,KAAK,gDAAgD,OAAO,WAAW,WAAW;AAAA,EAC5F;AACA,SAAO;AACT;;;ACde,SAAR,UAA2B,OAAY;AAC5C,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AACA,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,WAAW;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,CAAC,MAAM,KAAK,GAAG;AACjB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,UAAU,UAAU;AAC7B,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AC3BA,mBAAkB;;;ACcH,SAAR,cACL,QAC+B;AAC/B,MAAI,EAAE,KAAK,IAAI;AAEf,MAAI,CAAC,QAAQ,OAAO,OAAO;AACzB,WAAO,UAAU,OAAO,KAAK;AAAA,EAC/B;AAEA,MAAI,CAAC,QAAQ,OAAO,MAAM;AACxB,WAAO;AAAA,EACT;AAEA,MAAI,CAAC,SAAS,OAAO,cAAc,OAAO,uBAAuB;AAC/D,WAAO;AAAA,EACT;AAEA,MAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,QAAI,KAAK,WAAW,KAAK,KAAK,SAAS,MAAM,GAAG;AAC9C,aAAO,KAAK,KAAK,CAACC,UAASA,UAAS,MAAM;AAAA,IAC5C,OAAO;AACL,aAAO,KAAK,CAAC;AAAA,IACf;AAAA,EACF;AAEA,SAAO;AACT;;;ADzBe,SAAR,aAA8B,MAAyB,MAAyB;AACrF,QAAM,MAAM,OAAO,OAAO,CAAC,GAAG,IAAI;AAClC,SAAO,OAAO,KAAK,IAAI,EAAE,OAAO,CAACC,MAAK,QAAQ;AAC5C,UAAM,OAAO,OAAO,KAAK,GAAG,IAAI,CAAC,GAC/B,QAAQ,KAAK,GAAG;AAClB,QAAI,QAAQ,OAAO,QAAQ,SAAS,KAAK,GAAG;AAC1C,MAAAA,KAAI,GAAG,IAAI,aAAa,MAAM,KAAK;AAAA,IACrC,WACE,QACA,SACC,cAAc,IAAI,MAAM,YAAY,cAAc,IAAI,MAAM,aAC7D,QAAQ,gBACR,MAAM,QAAQ,IAAI,KAClB,MAAM,QAAQ,KAAK,GACnB;AAEA,MAAAA,KAAI,GAAG,QAAI,aAAAC,SAAM,MAAM,KAAK;AAAA,IAC9B,OAAO;AACL,MAAAD,KAAI,GAAG,IAAI;AAAA,IACb;AACA,WAAOA;AAAA,EACT,GAAG,GAAG;AACR;;;AHGe,SAAR,eAIL,WAAmC,QAAW,aAAgB,CAAC,GAAQ,aAAoB;AAC3F,SAAO,uBAAgC,WAAW,QAAQ,YAAY,WAAW,EAAE,CAAC;AACtF;AAeO,SAAS,iBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,EAAE,IAAI,YAAY,MAAM,MAAM,WAAW,GAAG,8BAA8B,IAAI;AAEpF,QAAM,iBAAiB,UAAU,QAAQ,YAAiB,YAAa,CAAC,GAAS,UAAU;AAC3F,MAAI,kBAAkB,CAAC,6BAAkC;AACzD,MAAI,UAAe,CAAC;AACpB,MAAI,mBAAmB;AACrB,QAAI,QAAQ,OAAO,SAAS,WAAW;AACrC,gBAAU,QAAQ;AAAA,QAChB,uBAAgC,WAAW,MAAW,YAAY,UAAU,mBAAmB,WAAW;AAAA,MAC5G;AAAA,IACF;AACA,QAAI,aAAa,OAAO,cAAc,WAAW;AAC/C,gBAAU,QAAQ;AAAA,QAChB,uBAAgC,WAAW,WAAgB,YAAY,UAAU,mBAAmB,WAAW;AAAA,MACjH;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,oBAAoB,iBAAiB,OAAO;AAClD,QAAI,qBAAqB,OAAO,sBAAsB,WAAW;AAC/D,gBAAU,QAAQ;AAAA,QAChB;AAAA,UACE;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,QAAQ,QAAQ;AAClB,sBAAkB,QAAQ,IAAI,CAAC,MAAM,aAAa,+BAA+B,CAAC,CAAM;AAAA,EAC1F;AACA,SAAO,gBAAgB;AAAA,IAAQ,CAAC,MAC9B,uBAAgC,WAAW,GAAG,YAAY,UAAU,mBAAmB,WAAW;AAAA,EACpG;AACF;AAgBO,SAAS,0BAAmE,aAAoB;AACrG,QAAM,kBAAyB,YAAY;AAAA,IACzC,CAAC,cAAc,SAAS;AAEtB,UAAI,KAAK,SAAS,GAAG;AACnB,eAAO,KAAK,QAAQ,CAAC,gBAAY,aAAAE,SAAM,aAAa,QAAQ,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,CAAC,EAAE,OAAO,OAAO,CAAC,CAAC;AAAA,MAC1G;AAEA,mBAAa,QAAQ,CAAC,gBAAgB,YAAY,KAAK,KAAK,CAAC,CAAC,CAAC;AAC/D,aAAO;AAAA,IACT;AAAA,IACA,CAAC,CAAC,CAAC;AAAA;AAAA,EACL;AAEA,SAAO;AACT;AAeO,SAAS,cACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,iBAAiB;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,MAAI,eAAe,SAAS,KAAK,eAAe,CAAC,MAAM,QAAQ;AAG7D,WAAO;AAAA,EACT;AACA,MAAI,oBAAoB,QAAQ;AAC9B,UAAM,kBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,gBAAgB,QAAQ,CAAC,MAAM;AACpC,aAAO,uBAAgC,WAAW,GAAG,YAAY,UAAU,mBAAmB,WAAW;AAAA,IAC3G,CAAC;AAAA,EACH;AACA,MAAI,cAAc,UAAU,MAAM,QAAQ,OAAO,KAAK,GAAG;AACvD,UAAM,sBAA6B,OAAO,MAAM;AAAA,MAAI,CAAC,mBACnD;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,kBAAkB,0BAA6B,mBAAmB;AACxE,WAAO,gBAAgB,IAAI,CAAC,iBAAiB,EAAE,GAAG,QAAQ,OAAO,YAAY,EAAE;AAAA,EACjF;AAEA,SAAO,CAAC,MAAM;AAChB;AAeO,SAAS,iBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AACL,QAAM,gBAAgB,qBAAwB,QAAQ,YAAY,WAAW;AAC7E,MAAI,kBAAkB,QAAQ;AAE5B,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,SAAO,CAAC,MAAM;AAChB;AASO,SAAS,qBACd,QACA,YACA,aACG;AACH,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAO;AAAA,EACT;AACA,MAAI,iBAAoB;AAExB,MAAI,WAAW,gBAAgB;AAC7B,UAAM,EAAE,MAAM,GAAG,YAAY,IAAI;AAEjC,QAAI,YAAY,SAAS,IAAK,GAAG;AAC/B,aAAO;AAAA,IACT;AACA,gBAAY,KAAK,IAAK;AAEtB,UAAM,YAAY,qBAAwB,MAAM,UAAU;AAC1D,qBAAiB,EAAE,GAAG,WAAW,GAAG,YAAY;AAAA,EAClD;AAEA,MAAI,kBAAkB,gBAAgB;AACpC,UAAM,gBAA4B,CAAC;AACnC,UAAM,mBAAe,iBAAAC;AAAA,MACnB,eAAe,cAAc;AAAA,MAC7B,CAAC,QAAQ,OAAO,QAAgB;AAC9B,cAAM,YAAsB,CAAC,GAAG,WAAW;AAC3C,eAAO,GAAG,IAAI,qBAAqB,OAAY,YAAY,SAAS;AACpE,sBAAc,KAAK,SAAS;AAAA,MAC9B;AAAA,MACA,CAAC;AAAA,IACH;AACA,qBAAAC,SAAM,iBAAa,YAAAC,aAAK,mBAAAC,SAAY,aAAa,CAAC,CAAC;AACnD,qBAAiB,EAAE,GAAG,gBAAgB,CAAC,cAAc,GAAG,aAAa;AAAA,EACvE;AAEA,MACE,aAAa,kBACb,CAAC,MAAM,QAAQ,eAAe,KAAK,KACnC,OAAO,eAAe,UAAU,WAChC;AACA,qBAAiB;AAAA,MACf,GAAG;AAAA,MACH,OAAO,qBAAqB,eAAe,OAAY,YAAY,WAAW;AAAA,IAChF;AAAA,EACF;AAEA,aAAO,eAAAC,SAAQ,QAAQ,cAAc,IAAI,SAAS;AACpD;AAUO,SAAS,iCAId,WAAmC,WAAc,YAAgB,WAAkB;AAEnF,QAAM,SAAS;AAAA,IACb,GAAG;AAAA,IACH,YAAY,EAAE,GAAG,UAAU,WAAW;AAAA,EACxC;AAGA,QAAM,WAA8B,aAAa,SAAS,SAAS,IAAI,YAAY,CAAC;AACpF,SAAO,KAAK,QAAQ,EAAE,QAAQ,CAAC,QAAQ;AACrC,QAAI,OAAO,OAAO,YAAY;AAE5B;AAAA,IACF;AAEA,QAAI,uBAAkD,CAAC;AACvD,QAAI,OAAO,OAAO,yBAAyB,WAAW;AACpD,UAAI,WAAW,OAAO,sBAAuB;AAC3C,+BAAuB;AAAA,UACrB;AAAA,UACA,EAAE,UAAM,YAAAC,SAAI,OAAO,sBAAsB,CAAC,OAAO,CAAC,EAAE;AAAA,UACpD;AAAA,UACA;AAAA,QACF;AAAA,MACF,WAAW,UAAU,OAAO,sBAAuB;AACjD,+BAAuB,EAAE,GAAG,OAAO,qBAAqB;AAAA,MAC1D,WAAW,cAAc,OAAO,wBAAyB,cAAc,OAAO,sBAAuB;AACnG,+BAAuB;AAAA,UACrB,MAAM;AAAA,UACN,GAAG,OAAO;AAAA,QACZ;AAAA,MACF,OAAO;AACL,+BAAuB,EAAE,MAAM,cAAU,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;AAAA,MACjE;AAAA,IACF,OAAO;AACL,6BAAuB,EAAE,MAAM,cAAU,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;AAAA,IACjE;AAGA,WAAO,WAAW,GAAG,IAAI;AAEzB,mBAAAC,SAAI,OAAO,YAAY,CAAC,KAAK,wBAAwB,GAAG,IAAI;AAAA,EAC9D,CAAC;AAED,SAAO;AACT;AAiBO,SAAS,uBAKd,WACA,QACA,YACA,aACA,oBAAoB,OACpB,cAAwB,CAAC,GACpB;AACL,MAAI,CAAC,SAAS,MAAM,GAAG;AACrB,WAAO,CAAC,CAAC,CAAM;AAAA,EACjB;AACA,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,gBAAgB,QAAQ,CAAC,MAAS;AACvC,QAAI,iBAAiB;AACrB,QAAI,UAAU,gBAAgB;AAC5B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,QAAI,cAAc,gBAAgB;AAEhC,UAAI,mBAAmB;AACrB,cAAM,EAAE,OAAO,GAAG,aAAa,IAAI;AACnC,eAAO,CAAC,GAAI,OAAe,YAAiB;AAAA,MAC9C;AACA,UAAI;AACF,6BAAiB,+BAAAC,SAAW,gBAAgB;AAAA,UAC1C,MAAM;AAAA,QACR,CAAY;AAAA,MACd,SAAS,GAAG;AACV,gBAAQ,KAAK,0CAA0C,CAAC;AACxD,cAAM,EAAE,OAAO,GAAG,2BAA2B,IAAI;AACjD,eAAO;AAAA,MACT;AAAA,IACF;AACA,UAAM,0BACJ,6BAA6B,kBAAkB,eAAe,yBAAyB;AACzF,QAAI,yBAAyB;AAC3B,aAAO,iCAA0C,WAAW,gBAAgB,YAAY,WAAgB;AAAA,IAC1G;AAEA,WAAO;AAAA,EACT,CAAC;AACH;AAcO,SAAS,yBAId,WAAmC,QAAW,YAAe,mBAA4B,aAAiB;AAC1G,MAAI;AACJ,QAAM,EAAE,OAAO,OAAO,GAAG,UAAU,IAAI;AACvC,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,iBAAa;AAAA,EACf,WAAW,MAAM,QAAQ,KAAK,GAAG;AAC/B,iBAAa;AAAA,EACf;AACA,MAAI,YAAY;AAEd,UAAM,WAAW,gBAAgB,UAAa,oBAAqB,CAAC,IAAU;AAC9E,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,iBAAa,WAAW,IAAI,CAAC,MAAM;AAGjC,aAAO,qBAAqB,GAAG,YAAY,CAAC,CAAC;AAAA,IAC/C,CAAC;AAED,UAAM,SAAS,uBAAgC,WAAW,UAAU,YAAY,YAAY,aAAa;AACzG,QAAI,mBAAmB;AACrB,aAAO,WAAW,IAAI,CAAC,SAAS,aAAa,WAAW,IAAI,CAAM;AAAA,IACpE;AACA,aAAS,aAAa,WAAW,WAAW,MAAM,CAAC;AAAA,EACrD;AACA,SAAO,CAAC,MAAM;AAChB;AAcO,SAAS,oBACd,WACA,QACA,YACA,mBACA,aACA,UACK;AAEL,QAAM,EAAE,cAAc,GAAG,gBAAgB,IAAI;AAC7C,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,gBAAgB;AAAA,IAAQ,CAAC,mBAC9B;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAeO,SAAS,oBACd,WACA,cACA,gBACA,YACA,mBACA,aACA,UACK;AACL,MAAI,UAAU,CAAC,cAAc;AAE7B,aAAW,iBAAiB,cAAc;AAExC,QAAI,CAAC,yBAAqB,YAAAF,SAAI,UAAU,CAAC,aAAa,CAAC,MAAM,QAAW;AACtE;AAAA,IACF;AAEA,QAAI,eAAe,cAAc,EAAE,iBAAiB,eAAe,aAAa;AAC9E;AAAA,IACF;AACA,UAAM,CAAC,uBAAuB,eAAe,IAAI;AAAA,MAC/C;AAAA,MACA;AAAA,IACF;AACA,QAAI,MAAM,QAAQ,eAAe,GAAG;AAClC,cAAQ,CAAC,IAAI,wBAA2B,gBAAgB,eAAe;AAAA,IACzE,WAAW,SAAS,eAAe,GAAG;AACpC,gBAAU;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,WAAO,QAAQ;AAAA,MAAQ,CAAC,WACtB;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAQO,SAAS,wBACd,QACA,sBACA;AACA,MAAI,CAAC,sBAAsB;AACzB,WAAO;AAAA,EACT;AACA,QAAM,WAAW,MAAM,QAAQ,OAAO,QAAQ,IAC1C,MAAM,KAAK,oBAAI,IAAI,CAAC,GAAG,OAAO,UAAU,GAAG,oBAAoB,CAAC,CAAC,IACjE;AACJ,SAAO,EAAE,GAAG,QAAQ,SAAmB;AACzC;AAgBO,SAAS,oBACd,WACA,QACA,YACA,eACA,iBACA,mBACA,aACA,UACK;AACL,QAAM,mBAAmB;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,iBAAiB,QAAQ,CAAC,cAAc;AAC7C,UAAM,EAAE,OAAO,GAAG,gBAAgB,IAAI;AACtC,aAAS,aAAa,QAAQ,eAAe;AAE7C,QAAI,UAAU,QAAW;AACvB,aAAO;AAAA,IACT;AAEA,UAAM,iBAAiB,MAAM,IAAI,CAAC,cAAc;AAC9C,UAAI,OAAO,cAAc,aAAa,EAAE,WAAW,YAAY;AAC7D,eAAO,CAAC,SAAc;AAAA,MACxB;AACA,aAAO,iBAA0B,WAAW,WAAgB,YAAY,mBAAmB,aAAa,QAAQ;AAAA,IAClH,CAAC;AACD,UAAM,kBAAkB,0BAA0B,cAAc;AAChE,WAAO,gBAAgB;AAAA,MAAQ,CAAC,kBAC9B;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAiBO,SAAS,wBAKd,WACA,QACA,YACA,eACA,OACA,mBACA,aACA,UACK;AACL,QAAM,kBAAkB,MAAO,OAAO,CAAC,cAAc;AACnD,QAAI,OAAO,cAAc,aAAa,CAAC,aAAa,CAAC,UAAU,YAAY;AACzE,aAAO;AAAA,IACT;AACA,UAAM,EAAE,CAAC,aAAa,GAAG,wBAAwB,IAAI,UAAU;AAC/D,QAAI,yBAAyB;AAC3B,YAAM,kBAAqB;AAAA,QACzB,MAAM;AAAA,QACN,YAAY;AAAA,UACV,CAAC,aAAa,GAAG;AAAA,QACnB;AAAA,MACF;AACA,aAAO,UAAU,QAAQ,iBAAiB,UAAU,UAAU,KAAK;AAAA,IACrE;AACA,WAAO;AAAA,EACT,CAAC;AAED,MAAI,CAAC,qBAAqB,gBAAiB,WAAW,GAAG;AACvD,YAAQ,KAAK,wFAAwF;AACrG,WAAO,CAAC,MAAM;AAAA,EAChB;AACA,SAAO,gBAAgB,QAAQ,CAAC,MAAM;AACpC,UAAM,YAAe;AACrB,UAAM,CAAC,kBAAkB,IAAI,0BAA0B,eAAe,UAAU,UAA+B;AAC/G,UAAM,kBAAkB,EAAE,GAAG,WAAW,YAAY,mBAAmB;AACvE,UAAM,UAAU;AAAA,MACd;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,QAAQ,IAAI,CAACG,OAAM,aAAa,QAAQA,EAAC,CAAM;AAAA,EACxD,CAAC;AACH;;;AJtsBO,IAAM,cAAgC;AAAA,EAC3C,MAAM;AAAA,EACN,KAAK;AAAA,EACL,YAAY;AAAA,IACV,sBAAsB;AAAA,MACpB,MAAM;AAAA,IACR;AAAA,EACF;AACF;AAsBO,SAAS,oBACd,WACA,YACA,QACA,WAAgB,CAAC,GACT;AACR,MAAI,aAAa;AACjB,MAAI,QAAQ;AACV,YAAI,iBAAAC,SAAS,OAAO,UAAU,GAAG;AAC/B,wBAAc,cAAAC;AAAA,QACZ,OAAO;AAAA,QACP,CAAC,OAAO,OAAO,QAAQ;AACrB,gBAAM,gBAAY,YAAAC,SAAI,UAAU,GAAG;AACnC,cAAI,OAAO,UAAU,WAAW;AAC9B,mBAAO;AAAA,UACT;AACA,kBAAI,YAAAC,SAAI,OAAO,OAAO,GAAG;AACvB,kBAAM,YAAY,eAAwB,WAAW,OAAY,YAAY,SAAS;AACtF,mBAAO,QAAQ,oBAA6B,WAAW,YAAY,WAAW,aAAa,CAAC,CAAC;AAAA,UAC/F;AACA,mBAAK,YAAAA,SAAI,OAAO,UAAU,SAAK,YAAAA,SAAI,OAAO,UAAU,MAAM,WAAW;AACnE,kBAAMC,WAAM,YAAAD,SAAI,OAAO,UAAU,IAAI,aAAa;AAClD,kBAAM,gBAAgB,gCAAmC,KAAU;AACnE,mBACE,QACA;AAAA,cACE;AAAA,cACA;AAAA,cACA;AAAA,kBACA,YAAAD,SAAI,OAAOE,IAAG;AAAA,cACd;AAAA,cACA;AAAA,YACF;AAAA,UAEJ;AACA,cAAI,MAAM,SAAS,UAAU;AAC3B,mBAAO,QAAQ,oBAA6B,WAAW,YAAY,OAAY,aAAa,CAAC,CAAC;AAAA,UAChG;AACA,cAAI,MAAM,SAAS,UAAU,SAAS,GAAG;AAEvC,gBAAI,WAAW,QAAQ;AACvB,gBAAI,MAAM,SAAS;AAGjB,0BAAY,cAAc,MAAM,UAAU,IAAI;AAAA,YAChD,WAAW,MAAM,OAAO;AAGtB,0BAAY,cAAc,MAAM,QAAQ,IAAI;AAAA,YAC9C;AAEA,mBAAO;AAAA,UACT;AACA,iBAAO;AAAA,QACT;AAAA,QACA;AAAA,MACF;AAAA,IACF,eAAW,iBAAAC,SAAS,OAAO,IAAI,KAAK,OAAO,SAAS,UAAU,QAAQ,GAAG;AACvE,oBAAc;AAAA,IAChB;AAAA,EACF;AACA,SAAO;AACT;AAwBe,SAAR,yBAKL,WACA,YACA,UACA,SACA,iBAAiB,IACjB,oBACQ;AAER,QAAM,kBAAkB,QAAQ,IAAI,CAAC,WAAW;AAC9C,WAAO,qBAAwB,QAAQ,YAAY,CAAC,CAAC;AAAA,EACvD,CAAC;AAED,QAAM,2BAA2B,qCAAqC,UAAU,SAAS,kBAAkB;AAC3G,UAAI,iBAAAC,SAAS,wBAAwB,GAAG;AACtC,WAAO;AAAA,EACT;AAGA,QAAM,kBAAkB,gBAAgB,OAAO,CAAC,WAAqB,QAAQ,UAAkB;AAC7F,UAAM,cAAmB,CAAC,aAAkB,MAAM;AAClD,UAAM,QAAQ,uBAAgC,WAAW,UAAU,aAAa,YAAY,kBAAkB;AAE9G,QAAI,UAAU,GAAG;AACf,gBAAU,KAAK,KAAK;AAAA,IACtB;AACA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AAGL,MAAI,gBAAgB,WAAW,GAAG;AAChC,WAAO,gBAAgB,CAAC;AAAA,EAC1B;AACA,MAAI,CAAC,gBAAgB,QAAQ;AAE3B,sBAAAC,SAAM,gBAAgB,QAAQ,CAAC,MAAM,gBAAgB,KAAK,CAAC,CAAC;AAAA,EAC9D;AAEA,QAAM,aAAa,oBAAI,IAAY;AAEnC,QAAM,EAAE,UAAU,IAAc,gBAAgB;AAAA,IAC9C,CAAC,WAAqB,UAAkB;AACtC,YAAM,EAAE,UAAU,IAAI;AACtB,YAAM,SAAS,gBAAgB,KAAK;AACpC,YAAM,QAAQ,oBAAoB,WAAW,YAAY,QAAQ,QAAQ;AACzE,iBAAW,IAAI,KAAK;AACpB,UAAI,QAAQ,WAAW;AACrB,eAAO,EAAE,WAAW,OAAO,WAAW,MAAM;AAAA,MAC9C;AACA,aAAO;AAAA,IACT;AAAA,IACA,EAAE,WAAW,gBAAgB,WAAW,EAAE;AAAA,EAC5C;AAEA,MAAI,WAAW,SAAS,KAAK,kBAAkB,GAAG;AAChD,WAAO;AAAA,EACT;AAEA,SAAO;AACT;;;AS7Le,SAAR,aAAuE,QAAW;AACvF,SAAO,MAAM,QAAQ,OAAO,KAAK,KAAK,OAAO,MAAM,SAAS,KAAK,OAAO,MAAM,MAAM,CAAC,SAAS,SAAS,IAAI,CAAC;AAC9G;;;ACXA,IAAAC,cAAgB;AAqBD,SAAR,0BACL,UACA,UACA,0BAA0B,OACX;AACf,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,UAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI,WAAW,CAAC;AAC5D,UAAM,SAAS,SAAS,IAAI,CAAC,OAAO,QAAQ;AAC1C,UAAI,cAAc,GAAG,GAAG;AACtB,eAAO,0BAA+B,cAAc,GAAG,GAAG,OAAO,uBAAuB;AAAA,MAC1F;AACA,aAAO;AAAA,IACT,CAAC;AAED,QAAI,2BAA2B,OAAO,SAAS,cAAc,QAAQ;AACnE,aAAO,KAAK,GAAG,cAAc,MAAM,OAAO,MAAM,CAAC;AAAA,IACnD;AACA,WAAO;AAAA,EACT;AACA,MAAI,SAAS,QAAQ,GAAG;AACtB,UAAM,MAAiC,OAAO,OAAO,CAAC,GAAG,QAAQ;AACjE,WAAO,OAAO,KAAK,QAA6B,EAAE,OAAO,CAACC,MAAK,QAAQ;AACrE,MAAAA,KAAI,GAAc,IAAI;AAAA,QACpB,eAAW,YAAAC,SAAI,UAAU,GAAG,IAAI,CAAC;AAAA,YACjC,YAAAA,SAAI,UAAU,GAAG;AAAA,QACjB;AAAA,MACF;AACA,aAAOD;AAAA,IACT,GAAG,GAAG;AAAA,EACR;AACA,SAAO;AACT;;;ACxCe,SAAR,aACL,MACA,MACA,eAA8C,OAC9C;AACA,SAAO,OAAO,KAAK,IAAI,EAAE,OAAO,CAAC,KAAK,QAAQ;AAC5C,UAAM,OAAO,OAAO,KAAK,GAAG,IAAI,CAAC,GAC/B,QAAQ,KAAK,GAAG;AAClB,QAAI,QAAQ,OAAO,QAAQ,SAAS,KAAK,GAAG;AAC1C,UAAI,GAAG,IAAI,aAAa,MAAM,OAAO,YAAY;AAAA,IACnD,WAAW,gBAAgB,MAAM,QAAQ,IAAI,KAAK,MAAM,QAAQ,KAAK,GAAG;AACtE,UAAI,UAAU;AACd,UAAI,iBAAiB,qBAAqB;AACxC,kBAAU,MAAM,OAAO,CAAC,QAAQ,UAAU;AACxC,cAAI,CAAC,KAAK,SAAS,KAAK,GAAG;AACzB,mBAAO,KAAK,KAAK;AAAA,UACnB;AACA,iBAAO;AAAA,QACT,GAAG,CAAC,CAAC;AAAA,MACP;AACA,UAAI,GAAG,IAAI,KAAK,OAAO,OAAO;AAAA,IAChC,OAAO;AACL,UAAI,GAAG,IAAI;AAAA,IACb;AACA,WAAO;AAAA,EACT,GAAG,OAAO,OAAO,CAAC,GAAG,IAAI,CAAC;AAC5B;;;AC7Be,SAAR,WAAqE,QAAW;AACrF,SAAQ,MAAM,QAAQ,OAAO,IAAI,KAAK,OAAO,KAAK,WAAW,KAAM,aAAa;AAClF;;;ACAe,SAAR,SACL,WACA,WACA,aAAgB,CAAC,GACjB;AACA,QAAM,SAAS,eAAwB,WAAW,WAAW,YAAY,MAAS;AAClF,QAAM,aAAa,OAAO,SAAS,OAAO;AAC1C,MAAI,MAAM,QAAQ,OAAO,IAAI,GAAG;AAC9B,WAAO;AAAA,EACT;AACA,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,WAAW,MAAM,CAACE,gBAAe,OAAOA,gBAAe,aAAa,WAAWA,WAAU,CAAC;AAAA,EACnG;AACA,SAAO;AACT;;;ACde,SAAR,cAIL,WAAmC,QAAW,YAAgB;AAC9D,MAAI,CAAC,OAAO,eAAe,CAAC,OAAO,SAAS,OAAO,OAAO,UAAU,WAAW;AAC7E,WAAO;AAAA,EACT;AACA,SAAO,SAAkB,WAAW,OAAO,OAAY,UAAU;AACnE;;;AhB0CO,SAAS,2BACd,QACA,kBAA2C,gBAC3C,MAAM,IACH;AACH,MAAI,OAAO,GAAG;AACZ,QAAI,MAAM,QAAQ,OAAO,KAAK,KAAK,MAAM,OAAO,MAAM,QAAQ;AAC5D,YAAM,OAAO,OAAO,MAAM,GAAG;AAC7B,UAAI,OAAO,SAAS,WAAW;AAC7B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF,WAAW,OAAO,SAAS,CAAC,MAAM,QAAQ,OAAO,KAAK,KAAK,OAAO,OAAO,UAAU,WAAW;AAC5F,WAAO,OAAO;AAAA,EAChB;AACA,MAAI,oBAAoB,kBAAkC,SAAS,OAAO,eAAe,GAAG;AAC1F,WAAO,OAAO;AAAA,EAChB;AACA,SAAO,CAAC;AACV;AAqBA,SAAS,wBACP,KACA,KACA,iBACA,wBACA,kBACA,iBAA2B,CAAC,GAC5B,wCAA+E,CAAC,GAChF;AACA,QAAM,EAAE,oBAAoB,sBAAsB,IAAI;AACtD,MAAI,wBAAwB;AAC1B,QAAI,GAAG,IAAI;AAAA,EACb,WAAW,sBAAsB,gBAAgB;AAC/C,QAAI,SAAS,eAAe,GAAG;AAG7B,YAAM,yBAAyB,qBAAqB,SAAY,eAAe,SAAS,GAAG,IAAI;AAI/F,WACG,KAAC,eAAAC,SAAQ,eAAe,KAAK,eAAe,SAAS,GAAG,OACxD,0BAA0B,sBAAsB,6BACjD;AACA,YAAI,GAAG,IAAI;AAAA,MACb;AAAA,IACF;AAAA;AAAA;AAAA;AAAA,MAIE,oBAAoB,WACnB,sBAAsB,yBAAyB,eAAe,SAAS,GAAG;AAAA,MAC3E;AACA,UAAI,GAAG,IAAI;AAAA,IACb;AAAA,EACF;AACF;AA6BO,SAAS,gBACd,WACA,WACA;AAAA,EACE;AAAA,EACA;AAAA,EACA,aAAa,CAAC;AAAA,EACd,yBAAyB;AAAA,EACzB,eAAe,CAAC;AAAA,EAChB,wCAAwC;AAAA,EACxC;AACF,IAAgC,CAAC,GACZ;AACrB,QAAM,WAAe,SAAS,WAAW,IAAI,cAAc,CAAC;AAC5D,QAAM,SAAY,SAAS,SAAS,IAAI,YAAa,CAAC;AAEtD,MAAI,WAAgC;AAEpC,MAAI,kBAA4B;AAChC,MAAI,qBAAqB;AAEzB,MAAI,SAAS,QAAQ,KAAK,SAAS,OAAO,OAAO,GAAG;AAGlD,eAAW,aAAa,UAAW,OAAO,OAA4B;AAAA,EACxE,WAAW,eAAe,QAAQ;AAChC,eAAW,OAAO;AAAA,EACpB,WAAW,WAAW,QAAQ;AAC5B,UAAM,UAAU,OAAO,OAAO;AAE9B,QAAI,CAAC,aAAa,SAAS,OAAQ,GAAG;AACpC,2BAAqB,aAAa,OAAO,OAAQ;AACjD,wBAAkB,qBAAwB,SAAS,UAAU;AAAA,IAC/D;AAAA,EACF,WAAW,oBAAoB,QAAQ;AACrC,UAAM,iBAAiB,oBAA6B,WAAW,QAAQ,YAAY,OAAO,CAAC,GAAG,QAAQ;AACtG,sBAAkB,eAAe,CAAC;AAAA,EACpC,WAAW,aAAa,MAAM,GAAG;AAC/B,eAAY,OAAO,MAAe;AAAA,MAAI,CAAC,YAAe,QACpD,gBAAsB,WAAW,YAAY;AAAA,QAC3C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,gBAAgB,MAAM,QAAQ,cAAc,IAAI,eAAe,GAAG,IAAI;AAAA,QACtE,aAAa;AAAA,QACb;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,WAAW,cAAc,QAAQ;AAC/B,UAAM,EAAE,OAAO,GAAG,UAAU,IAAI;AAChC,QAAI,MAAO,WAAW,GAAG;AACvB,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,sBAAkB,MAChB;AAAA,MACE;AAAA,MACA;AAAA,UACA,eAAAA,SAAQ,QAAQ,IAAI,SAAY;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CACF;AACA,sBAAkB,aAAa,WAAW,eAAe;AAAA,EAC3D,WAAW,cAAc,QAAQ;AAC/B,UAAM,EAAE,OAAO,GAAG,UAAU,IAAI;AAChC,QAAI,MAAO,WAAW,GAAG;AACvB,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,sBAAkB,MAChB;AAAA,MACE;AAAA,MACA;AAAA,UACA,eAAAA,SAAQ,QAAQ,IAAI,SAAY;AAAA,MAChC;AAAA,MACA;AAAA,MACA;AAAA,IACF,CACF;AACA,sBAAkB,aAAa,WAAW,eAAe;AAAA,EAC3D;AAEA,MAAI,iBAAiB;AACnB,WAAO,gBAAyB,WAAW,iBAAiB;AAAA,MAC1D;AAAA,MACA;AAAA,MACA,cAAc;AAAA,MACd;AAAA,MACA,gBAAgB;AAAA,MAChB,aAAa;AAAA,MACb;AAAA,IACF,CAAC;AAAA,EACH;AAGA,MAAI,aAAa,QAAW;AAC1B,eAAW,OAAO;AAAA,EACpB;AAEA,UAAQ,cAAiB,MAAM,GAAG;AAAA,IAEhC,KAAK,UAAU;AAGb,YAAM,kBACJ,uCAAuC,UAAU,sBAAsB,cAAc,SACjF,eAAwB,WAAW,QAAQ,YAAY,QAAQ,IAC/D;AACN,YAAM,iBAAiB,OAAO,KAAK,gBAAgB,cAAc,CAAC,CAAC,EAAE;AAAA,QACnE,CAAC,KAAwB,QAAgB;AAGvC,gBAAM,kBAAkB,gBAAyB,eAAW,YAAAC,SAAI,iBAAiB,CAAC,gBAAgB,GAAG,CAAC,GAAG;AAAA,YACvG;AAAA,YACA;AAAA,YACA;AAAA,YACA,wBAAwB,2BAA2B;AAAA,YACnD,oBAAgB,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YACnC,iBAAa,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YAChC,UAAU,gBAAgB,UAAU,SAAS,GAAG;AAAA,UAClD,CAAC;AACD;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB;AAAA,YAChB;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AACA,UAAI,gBAAgB,sBAAsB;AAExC,cAAM,6BAA6B,SAAS,gBAAgB,oBAAoB,IAC5E,gBAAgB,uBAChB,CAAC;AAEL,cAAM,OAAO,oBAAI,IAAY;AAC7B,YAAI,SAAS,QAAQ,GAAG;AACtB,iBAAO,KAAK,QAA6B,EACtC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,cAAc,CAAC,gBAAgB,WAAW,GAAG,CAAC,EAC/E,QAAQ,CAAC,QAAQ,KAAK,IAAI,GAAG,CAAC;AAAA,QACnC;AACA,cAAM,mBAA6B,CAAC;AACpC,eAAO,KAAK,QAA6B,EACtC,OAAO,CAAC,QAAQ,CAAC,gBAAgB,cAAc,CAAC,gBAAgB,WAAW,GAAG,CAAC,EAC/E,QAAQ,CAAC,QAAQ;AAChB,eAAK,IAAI,GAAG;AACZ,2BAAiB,KAAK,GAAG;AAAA,QAC3B,CAAC;AACH,aAAK,QAAQ,CAAC,QAAQ;AACpB,gBAAM,kBAAkB,gBAAgB,WAAW,4BAAiC;AAAA,YAClF;AAAA,YACA;AAAA,YACA;AAAA,YACA,wBAAwB,2BAA2B;AAAA,YACnD,oBAAgB,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YACnC,iBAAa,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,YAChC,UAAU,gBAAgB,UAAU,SAAS,GAAG;AAAA,UAClD,CAAC;AAED;AAAA,YACE;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,IACA,KAAK,SAAS;AAEZ,YAAM,gBACF,OAAO,kCAAkC,uCAAuC;AACpF,YAAM,gBAAgB,eAAe,aAAa;AAClD,YAAM,wBAAwB,eAAe,aAAa;AAG1D,UAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,mBAAW,SAAS,IAAI,CAAC,MAAM,QAAQ;AACrC,gBAAM,aAAgB,2BAA8B,QAAQ,kBAAkC,GAAG;AACjG,iBAAO,gBAAyB,WAAW,YAAY;AAAA,YACrD;AAAA,YACA;AAAA,YACA;AAAA,YACA,gBAAgB;AAAA,YAChB;AAAA,UACF,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAGA,UAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,cAAM,aAAgB,2BAA8B,MAAM;AAC1D,YAAI,eAAe;AACjB,qBAAW;AAAA,QACb,OAAO;AACL,qBAAW,YAAY,IAAI,CAAC,MAAS,QAAgB;AACnD,mBAAO,gBAAyB,WAAW,YAAY;AAAA,cACrD;AAAA,cACA;AAAA,cACA;AAAA,cACA,aAAa;AAAA,cACb,oBAAgB,YAAAA,SAAI,UAAU,CAAC,GAAG,CAAC;AAAA,cACnC;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF;AAEA,UAAI,eAAe;AACjB,eAAO,YAAY,CAAC;AAAA,MACtB;AACA,UAAI,yBAAyB,CAAC,UAAU;AAGtC,eAAO,WAAW,WAAW;AAAA,MAC/B;AAEA,YAAM,iBAAiB,MAAM,QAAQ,QAAQ,IAAI,SAAS,SAAS;AACnE,UACE,CAAC,OAAO,YACR,cAAuB,WAAW,QAAQ,UAAU,KACpD,OAAO,YAAY,gBACnB;AACA,eAAO,WAAW,WAAW,CAAC;AAAA,MAChC;AAEA,YAAM,iBAAuB,YAAY,CAAC;AAC1C,YAAM,eAAkB,2BAA8B,QAAQ,cAA8B;AAC5F,YAAM,gBAAgB,aAAa;AAGnC,YAAM,gBAAqB,IAAI,MAAM,OAAO,WAAW,cAAc,EAAE;AAAA,QACrE,gBAA2B,WAAW,cAAc;AAAA,UAClD,gBAAgB;AAAA,UAChB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO,eAAe,OAAO,aAAa;AAAA,IAC5C;AAAA,EACF;AAEA,SAAO;AACT;AAee,SAAR,oBAKL,WACA,WACA,UACA,YACA,yBAA4D,OAC5D,uCACA;AACA,MAAI,CAAC,SAAS,SAAS,GAAG;AACxB,UAAM,IAAI,MAAM,qBAAqB,SAAS;AAAA,EAChD;AACA,QAAM,SAAS,eAAwB,WAAW,WAAW,YAAY,QAAQ;AACjF,QAAM,WAAW,gBAAyB,WAAW,QAAQ;AAAA,IAC3D;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa;AAAA,EACf,CAAC;AACD,MAAI,aAAa,UAAa,aAAa,QAAS,OAAO,aAAa,YAAY,MAAM,QAAQ,GAAI;AAEpG,WAAO;AAAA,EACT;AAEA,QAAM,gBAAgB,OAAO,kCAAkC,uCAAuC;AAEtG,QAAM,EAAE,mBAAmB,IAAI,iBAAiB,CAAC;AACjD,MAAI,SAAS,QAAQ,GAAG;AACtB,WAAO,0BAA6B,UAAe,UAAU,kBAAkB;AAAA,EACjF;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,0BAA+B,UAAiB,UAAU,kBAAkB;AAAA,EACrF;AACA,SAAO;AACT;;;AiBpde,SAAR,eAIL,WAA8B,CAAC,GAAG;AAClC;AAAA;AAAA;AAAA,IAGE,YAAY,aAAsB,QAAQ,KAAK,aAAsB,QAAQ,EAAE,QAAQ,MAAM;AAAA;AAEjG;;;ACNe,SAAR,aACL,WACA,QACA,WAA8B,CAAC,GAC/B,YACA;AACA,MAAI,SAAS,aAAa,MAAM,SAAS;AACvC,WAAO;AAAA,EACT;AACA,MAAI,OAAO,OAAO;AAChB,UAAM,cAAc,eAAwB,WAAW,OAAO,OAAY,UAAU;AACpF,WAAO,YAAY,SAAS,YAAY,YAAY,WAAW;AAAA,EACjE;AACA,SAAO;AACT;;;ACDe,SAAR,gBAKL,WACA,QACA,WAA8B,CAAC,GAC/B,YACA,eACS;AACT,QAAM,YAAY,aAAsB,UAAU,aAAa;AAC/D,QAAM,EAAE,QAAQ,KAAK,IAAI;AACzB,MAAI,eAAe,CAAC,CAAC;AACrB,QAAM,aAAa,cAAiB,MAAM;AAE1C,MAAI,eAAe,SAAS;AAC1B,mBACE,cAAuB,WAAW,QAAQ,UAAU,KACpD,aAAsB,WAAW,QAAQ,UAAU,UAAU,KAC7D,eAAe,QAAQ;AAAA,EAC3B;AAEA,MAAI,eAAe,UAAU;AAC3B,mBAAe;AAAA,EACjB;AACA,MAAI,eAAe,aAAa,CAAC,SAAS,aAAa,GAAG;AACxD,mBAAe;AAAA,EACjB;AACA,MAAI,SAAS,YAAY,GAAG;AAC1B,mBAAe;AAAA,EACjB;AACA,SAAO;AACT;;;AC1DA,IAAAC,kBAAoB;AAiBL,SAAR,oBAKL,WACA,gBACA,uBACmB;AACnB,MAAI,CAAC,uBAAuB;AAC1B,WAAO;AAAA,EACT;AACA,QAAM,EAAE,QAAQ,WAAW,aAAa,eAAe,IAAI;AAC3D,MAAI,SAAS,UAAU,YAAY,qBAAqB;AACxD,MAAI,cAAc;AAClB,MAAI,KAAC,gBAAAC,SAAQ,cAAc,GAAG;AAC5B,kBAAc,aAAa,gBAAgB,uBAAuB,IAAI;AACtE,aAAS,CAAC,GAAG,SAAS,EAAE,OAAO,MAAM;AAAA,EACvC;AACA,SAAO,EAAE,aAAa,OAAO;AAC/B;;;ACrCA,IAAAC,cAAgB;AAChB,IAAAC,cAAgB;AAMhB,IAAM,WAAW,OAAO,UAAU;AAiDnB,SAAR,yBAIL,WAAmC,YAAe,WAAe,WAAe,OAAY,CAAC,GAAM;AAEnG,MAAI;AAEJ,UAAI,YAAAC,SAAI,WAAW,cAAc,GAAG;AAElC,UAAM,sBAAyC,CAAC;AAChD,YAAI,YAAAA,SAAI,WAAW,cAAc,GAAG;AAClC,YAAM,iBAAa,YAAAC,SAAI,WAAW,gBAAgB,CAAC,CAAC;AACpD,aAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AACvC,gBAAI,YAAAD,SAAI,MAAM,GAAG,GAAG;AAClB,8BAAoB,GAAG,IAAI;AAAA,QAC7B;AAAA,MACF,CAAC;AAAA,IACH;AACA,UAAM,OAAiB,OAAO,SAAK,YAAAC,SAAI,WAAW,gBAAgB,CAAC,CAAC,CAAC;AAErE,UAAM,aAAgC,CAAC;AACvC,SAAK,QAAQ,CAAC,QAAQ;AACpB,YAAM,gBAAY,YAAAA,SAAI,MAAM,GAAG;AAC/B,UAAI,qBAAoB,YAAAA,SAAI,WAAW,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;AAChE,UAAI,qBAAoB,YAAAA,SAAI,WAAW,CAAC,gBAAgB,GAAG,GAAG,CAAC,CAAC;AAEhE,cAAI,YAAAD,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAgB,YAAY,SAAS;AAAA,MAC3F;AACA,cAAI,YAAAA,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAgB,YAAY,SAAS;AAAA,MAC3F;AAEA,YAAM,0BAAsB,YAAAC,SAAI,gBAAgB,MAAM;AACtD,YAAM,0BAAsB,YAAAA,SAAI,gBAAgB,MAAM;AAEtD,UAAI,CAAC,uBAAuB,wBAAwB,qBAAqB;AACvE,gBAAI,YAAAD,SAAI,qBAAqB,GAAG,GAAG;AAEjC,iBAAO,oBAAoB,GAAG;AAAA,QAChC;AAEA,YAAI,wBAAwB,YAAa,wBAAwB,WAAW,MAAM,QAAQ,SAAS,GAAI;AAErG,gBAAM,WAAW;AAAA,YACf;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,cAAI,aAAa,UAAa,wBAAwB,SAAS;AAE7D,uBAAW,GAAG,IAAI;AAAA,UACpB;AAAA,QACF,OAAO;AAIL,gBAAM,uBAAmB,YAAAC,SAAI,gBAAgB,WAAW,QAAQ;AAChE,gBAAM,uBAAmB,YAAAA,SAAI,gBAAgB,WAAW,QAAQ;AAChE,cAAI,qBAAqB,YAAY,qBAAqB,WAAW;AACnE,gBAAI,qBAAqB,WAAW;AAElC,kCAAoB,GAAG,IAAI;AAAA,YAC7B,eAAW,YAAAA,SAAI,gBAAgB,UAAU,MAAM,MAAM;AAEnD,kCAAoB,GAAG,IAAI;AAAA,YAC7B;AAAA,UACF;AAEA,gBAAM,qBAAiB,YAAAA,SAAI,gBAAgB,SAAS,QAAQ;AAC5D,gBAAM,qBAAiB,YAAAA,SAAI,gBAAgB,SAAS,QAAQ;AAC5D,cAAI,mBAAmB,YAAY,mBAAmB,WAAW;AAE/D,gCAAoB,GAAG,IAAI,mBAAmB,YAAY,iBAAiB;AAAA,UAC7E;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,kBAAc;AAAA,MACZ,GAAI,OAAO,QAAQ,YAAY,MAAM,QAAQ,IAAI,IAAI,SAAY;AAAA,MACjE,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AAAA,EAEF,eAAW,YAAAA,SAAI,WAAW,MAAM,MAAM,eAAW,YAAAA,SAAI,WAAW,MAAM,MAAM,WAAW,MAAM,QAAQ,IAAI,GAAG;AAC1G,QAAI,qBAAiB,YAAAA,SAAI,WAAW,OAAO;AAC3C,QAAI,qBAAiB,YAAAA,SAAI,WAAW,OAAO;AAG3C,QACE,OAAO,mBAAmB,YAC1B,OAAO,mBAAmB,YAC1B,CAAC,MAAM,QAAQ,cAAc,KAC7B,CAAC,MAAM,QAAQ,cAAc,GAC7B;AACA,cAAI,YAAAD,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAqB,YAAY,IAAS;AAAA,MAChG;AACA,cAAI,YAAAA,SAAI,gBAAgB,OAAO,GAAG;AAChC,yBAAiB,eAAwB,WAAW,gBAAqB,YAAY,IAAS;AAAA,MAChG;AAEA,YAAM,oBAAgB,YAAAC,SAAI,gBAAgB,MAAM;AAChD,YAAM,oBAAgB,YAAAA,SAAI,gBAAgB,MAAM;AAEhD,UAAI,CAAC,iBAAiB,kBAAkB,eAAe;AACrD,cAAM,eAAW,YAAAA,SAAI,WAAW,YAAY,EAAE;AAC9C,YAAI,kBAAkB,UAAU;AAC9B,wBAAc,KAAK,OAAO,CAAC,UAAU,WAAW;AAC9C,kBAAM,YAAY;AAAA,cAChB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YACF;AACA,gBAAI,cAAc,WAAc,WAAW,KAAK,SAAS,SAAS,WAAW;AAC3E,uBAAS,KAAK,SAAS;AAAA,YACzB;AACA,mBAAO;AAAA,UACT,GAAG,CAAC,CAAC;AAAA,QACP,OAAO;AACL,wBAAc,WAAW,KAAK,KAAK,SAAS,WAAW,KAAK,MAAM,GAAG,QAAQ,IAAI;AAAA,QACnF;AAAA,MACF;AAAA,IACF,WACE,OAAO,mBAAmB,aAC1B,OAAO,mBAAmB,aAC1B,mBAAmB,gBACnB;AAEA,oBAAc;AAAA,IAChB;AAAA,EAEF;AACA,SAAO;AACT;;;ACpMA,IAAAC,cAAgB;AAChB,IAAAC,kBAAoB;AAqBpB,SAAS,mBACP,WACA,QACA,UACA,aACA,IACA,YACA,UACA,eAAoB,CAAC,GACR;AACb,MAAI,WAAW,UAAU,oBAAoB,UAAU,cAAc,QAAQ;AAC3E,UAAM,UAAU,eAAwB,WAAW,QAAQ,YAAY,QAAQ;AAC/E,UAAM,kBAAkB,aAAa,UAAU,CAAC,aAAS,gBAAAC,SAAQ,MAAM,OAAO,CAAC;AAC/E,QAAI,oBAAoB,IAAI;AAC1B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa,OAAO,OAAO;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AACA,MAAI,aAAa,UAAU,KAAC,YAAAC,SAAI,QAAQ,CAAC,WAAW,OAAO,CAAC,GAAG;AAC7D,WAAO;AAAA,MACL;AAAA,UACA,YAAAA,SAAI,QAAQ,SAAS;AAAA,MACrB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,QAAM,MAAM,MAAM;AAClB,QAAM,WAAqB,EAAE,IAAI;AACjC,MAAI,cAAiB,MAAM,MAAM,YAAY,kBAAkB,QAAQ;AACrE,eAAW,QAAQ,OAAO,YAAY;AACpC,YAAM,YAAQ,YAAAA,SAAI,QAAQ,CAAC,gBAAgB,IAAI,CAAC;AAChD,YAAM,UAAU,SAAS,MAAM,IAAI,cAAc;AACjD,eAAS,IAAI,IAAI;AAAA,QACf;AAAA,QACA,SAAS,KAAK,IAAI,QAAQ,CAAC;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA;AAAA,YAGA,YAAAA,SAAI,UAAU,CAAC,IAAI,CAAC;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAae,SAAR,WACL,WACA,QACA,IACA,YACA,UACA,WAAW,QACX,cAAc,KACD;AACb,SAAO,mBAA4B,WAAW,QAAQ,UAAU,aAAa,IAAI,YAAY,QAAQ;AACvG;;;ACxGA,IAAAC,eAAgB;AAChB,IAAAC,kBAAoB;AACpB,IAAAC,cAAgB;AA8BhB,SAAS,qBACP,WACA,QACA,MACA,YACA,UACA,eAAoB,CAAC,GACN;AACf,MAAI,WAAW,UAAU,oBAAoB,UAAU,cAAc,QAAQ;AAC3E,UAAM,UAAU,eAAwB,WAAW,QAAQ,YAAY,QAAQ;AAC/E,UAAM,kBAAkB,aAAa,UAAU,CAAC,aAAS,gBAAAC,SAAQ,MAAM,OAAO,CAAC;AAC/E,QAAI,oBAAoB,IAAI;AAC1B,aAAO;AAAA,QACL;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,aAAa,OAAO,OAAO;AAAA,MAC7B;AAAA,IACF;AAAA,EACF;AAEA,MAAI,aAAyB;AAAA,IAC3B,CAAC,QAAQ,GAAG,KAAK,QAAQ,OAAO,EAAE;AAAA,EACpC;AAEA,MAAI,cAAc,UAAU,cAAc,QAAQ;AAChD,UAAM,QAAa,cAAc,SAAU,OAAO,QAAiB,OAAO;AAC1E,UAAM,gBAAgB,gCAAmC,MAAM;AAC/D,UAAM,QAAQ,yBAAkC,WAAW,YAAa,UAAU,OAAO,GAAG,aAAa;AACzG,UAAM,UAAa,MAAO,KAAK;AAC/B,iBAAa;AAAA,MACX,GAAG;AAAA,MACH,GAAG,qBAA8B,WAAW,SAAS,MAAM,YAAY,UAAU,YAAY;AAAA,IAC/F;AAAA,EACF;AAEA,MAAI,6BAA6B,UAAU,OAAO,yBAAyB,MAAM,OAAO;AACtF,oBAAAC,SAAI,YAAY,gCAAgC,IAAI;AAAA,EACtD;AAEA,MAAI,aAAa,UAAU,MAAM,QAAQ,QAAQ,GAAG;AAClD,UAAM,EAAE,OAAO,aAAa,iBAAiB,sBAAsB,IAAI;AAEvE,QAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,eAAS,QAAQ,CAAC,SAAS,MAAc;AACvC,YAAI,YAAY,CAAC,GAAG;AAClB,qBAAW,CAAC,IAAI;AAAA,YACd;AAAA,YACA,YAAY,CAAC;AAAA,YACb,GAAG,IAAI,IAAI,CAAC;AAAA,YACZ;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF,WAAW,uBAAuB;AAChC,qBAAW,CAAC,IAAI;AAAA,YACd;AAAA,YACA;AAAA,YACA,GAAG,IAAI,IAAI,CAAC;AAAA,YACZ;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,QACF,OAAO;AACL,kBAAQ,KAAK,uCAAuC,IAAI,IAAI,CAAC,6BAA6B;AAAA,QAC5F;AAAA,MACF,CAAC;AAAA,IACH,OAAO;AACL,eAAS,QAAQ,CAAC,SAAS,MAAc;AACvC,mBAAW,CAAC,IAAI;AAAA,UACd;AAAA,UACA;AAAA,UACA,GAAG,IAAI,IAAI,CAAC;AAAA,UACZ;AAAA,UACA;AAAA,UACA;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF,WAAW,kBAAkB,QAAQ;AACnC,eAAW,YAAY,OAAO,YAAY;AACxC,YAAM,YAAQ,aAAAC,SAAI,QAAQ,CAAC,gBAAgB,QAAQ,CAAC;AACpD,iBAAW,QAAQ,IAAI;AAAA,QACrB;AAAA,QACA;AAAA,QACA,GAAG,IAAI,IAAI,QAAQ;AAAA,QACnB;AAAA;AAAA;AAAA,YAGA,aAAAA,SAAI,UAAU,CAAC,QAAQ,CAAC;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAWe,SAAR,aACL,WACA,QACA,OAAO,IACP,YACA,UACe;AACf,SAAO,qBAAqB,WAAW,QAAQ,MAAM,YAAY,QAAQ;AAC3E;;;AChHA,IAAM,cAAN,MAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWE,YACE,WACA,YACA,uCACA;AACA,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,wCAAwC;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe;AACb,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,sBACE,WACA,YACA,wCAAwC,CAAC,GAChC;AACT,QAAI,CAAC,aAAa,CAAC,YAAY;AAC7B,aAAO;AAAA,IACT;AACA,WACE,KAAK,cAAc,aACnB,CAAC,WAAW,KAAK,YAAY,UAAU,KACvC,CAAC,WAAW,KAAK,uCAAuC,qCAAqC;AAAA,EAEjG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,oBACE,QACA,UACA,yBAA4D,OACvC;AACrB,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,gBAAgB,QAAW,UAA8B,eAAuC;AAC9F,WAAO,gBAAyB,KAAK,WAAW,QAAQ,UAAU,KAAK,YAAY,aAAa;AAAA,EAClG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,yBACE,UACA,SACA,gBACA,oBACQ;AACR,WAAO;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,uBAAuB,UAAyB,SAAc,oBAAqC;AACjG,WAAO,uBAAgC,KAAK,WAAW,UAAU,SAAS,KAAK,YAAY,kBAAkB;AAAA,EAC/G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,kBAAkB,UAAyB,SAAc,oBAA6B;AACpF,WAAO,kBAA2B,KAAK,WAAW,UAAU,SAAS,KAAK,YAAY,kBAAkB;AAAA,EAC1G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,aAAa,QAAW,UAA8B;AACpD,WAAO,aAAsB,KAAK,WAAW,QAAQ,UAAU,KAAK,UAAU;AAAA,EAChF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,QAAW;AACvB,WAAO,cAAuB,KAAK,WAAW,QAAQ,KAAK,UAAU;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,QAAW;AAClB,WAAO,SAAkB,KAAK,WAAW,QAAQ,KAAK,UAAU;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,oBAAoB,gBAAmC,uBAA2D;AAChH,WAAO,oBAA6B,KAAK,WAAW,gBAAgB,qBAAqB;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,eAAe,QAAW,aAAiB;AACzC,WAAO,eAAwB,KAAK,WAAW,QAAQ,KAAK,YAAY,WAAW;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,yBAAyB,WAAe,WAAe,MAAe;AACpE,WAAO,yBAAyB,KAAK,WAAW,KAAK,YAAY,WAAW,WAAW,IAAI;AAAA,EAC7F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,WAAW,QAAW,IAAoB,UAAc,WAAW,QAAQ,cAAc,KAAkB;AACzG,WAAO,WAAoB,KAAK,WAAW,QAAQ,IAAI,KAAK,YAAY,UAAU,UAAU,WAAW;AAAA,EACzG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,aAAa,QAAW,MAAe,UAA6B;AAClE,WAAO,aAAsB,KAAK,WAAW,QAAQ,MAAM,KAAK,YAAY,QAAQ;AAAA,EACtF;AACF;AAUe,SAAR,kBAKL,WACA,YACA,wCAAwC,CAAC,GACf;AAC1B,SAAO,IAAI,YAAqB,WAAW,YAAY,qCAAqC;AAC9F;;;ACnSe,SAAR,cAA+B,SAAiB;AAErD,QAAM,WAAqB,QAAQ,MAAM,GAAG;AAE5C,QAAM,SAAmB,SAAS,CAAC,EAAE,MAAM,GAAG;AAE9C,QAAM,OAAe,OAAO,CAAC,EAAE,QAAQ,SAAS,EAAE;AAElD,QAAM,aAAa,OAAO,OAAO,CAAC,UAAU;AAC1C,WAAO,MAAM,MAAM,GAAG,EAAE,CAAC,MAAM;AAAA,EACjC,CAAC;AAED,MAAI;AACJ,MAAI,WAAW,WAAW,GAAG;AAC3B,WAAO;AAAA,EACT,OAAO;AAGL,WAAO,UAAU,WAAW,CAAC,EAAE,MAAM,GAAG,EAAE,CAAC,CAAC;AAAA,EAC9C;AAGA,MAAI;AACF,UAAM,SAAS,KAAK,SAAS,CAAC,CAAC;AAC/B,UAAM,QAAQ,CAAC;AACf,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,YAAM,KAAK,OAAO,WAAW,CAAC,CAAC;AAAA,IACjC;AAEA,UAAM,OAAO,IAAI,OAAO,KAAK,CAAC,IAAI,WAAW,KAAK,CAAC,GAAG,EAAE,KAAK,CAAC;AAE9D,WAAO,EAAE,MAAM,KAAK;AAAA,EACtB,SAAS,OAAO;AACd,WAAO,EAAE,MAAM,EAAE,MAAM,GAAG,MAAO,MAAgB,QAAQ,GAAG,MAAM,QAAQ;AAAA,EAC5E;AACF;;;ACjCe,SAAR,wBAAyC,aAAqB,QAAmB;AACtF,MAAI,SAAS;AACb,MAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,UAAM,QAAQ,OAAO,MAAM,OAAO;AAClC,WAAO,QAAQ,CAAC,OAAO,UAAU;AAC/B,YAAM,YAAY,MAAM,UAAU,CAAC,SAAS,SAAS,IAAI,QAAQ,CAAC,EAAE;AACpE,UAAI,aAAa,GAAG;AAClB,cAAM,SAAS,IAAI;AAAA,MACrB;AAAA,IACF,CAAC;AACD,aAAS,MAAM,KAAK,EAAE;AAAA,EACxB;AACA,SAAO;AACT;;;ACVe,SAAR,wBAAyC,mBAAuC,QAA2B;AAChH,SAAO,wBAAwB,mBAAmB,MAAM;AAC1D;;;ACbA,IAAAC,kBAAoB;;;ACaL,SAAR,yBACL,YACA,iBAAuC,CAAC,GACxC,YACyE;AACzE,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,WAAW,IAAI,CAACC,WAAU,yBAAyBA,QAAO,cAAc,CAAC,EAAE,OAAO,CAAC,QAAQ,GAAG;AAAA,EACvG;AAEA,QAAM,QAAQ,eAAe,MAAM,eAAe,OAAO,KAAK,OAAO,UAAU;AAC/E,QAAM,SAAS,eAAe,KAAK;AACnC,SAAO,SAAS,OAAO,QAAQ;AACjC;;;ADRe,SAAR,yBACL,YACA,UACA,iBAAuC,CAAC,GACiC;AACzE,QAAM,QAAQ,yBAA4B,YAAY,cAAc;AACpE,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,OAAO,CAAC,MAAM,KAAC,gBAAAC,SAAQ,GAAG,KAAK,CAAC;AAAA,EAClD;AACA,aAAO,gBAAAA,SAAQ,OAAO,QAAQ,IAAI,SAAY;AAChD;;;AE3BA,IAAAC,kBAAoB;AAUL,SAAR,sBACL,OACA,UACA;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,WAAO,SAAS,KAAK,CAAC,YAAQ,gBAAAC,SAAQ,KAAK,KAAK,CAAC;AAAA,EACnD;AACA,aAAO,gBAAAA,SAAQ,UAAU,KAAK;AAChC;;;ACJe,SAAR,yBACL,OACA,iBAAuC,CAAC,GACxC,WAAW,OACoB;AAC/B,QAAM,kBAA4B,eAC/B,IAAI,CAAC,KAAK,UAAW,sBAAsB,IAAI,OAAO,KAAK,IAAI,OAAO,KAAK,IAAI,MAAU,EACzF,OAAO,CAAC,QAAQ,OAAO,QAAQ,WAAW;AAC7C,MAAI,CAAC,UAAU;AACb,WAAO,gBAAgB,CAAC;AAAA,EAC1B;AACA,SAAO;AACT;;;ACxBA,mBAAkB;AAUH,SAAR,uBACL,YACA,UACA,iBAAuC,CAAC,GACxC;AACA,QAAM,QAAQ,yBAA4B,YAAY,cAAc;AACpE,MAAI,KAAC,aAAAC,SAAM,KAAK,GAAG;AACjB,UAAM,QAAQ,eAAe,UAAU,CAAC,QAAQ,UAAU,IAAI,KAAK;AACnE,UAAM,MAAM,eAAe,IAAI,CAAC,EAAE,OAAO,IAAI,MAAM,GAAG;AACtD,UAAM,UAAU,SAAS,MAAM,GAAG,KAAK,EAAE,OAAO,OAAO,SAAS,MAAM,KAAK,CAAC;AAG5E,WAAO,QAAQ,KAAK,CAAC,GAAG,MAAM,OAAO,IAAI,QAAQ,CAAC,IAAI,IAAI,QAAQ,CAAC,CAAC,CAAC;AAAA,EACvE;AACA,SAAO;AACT;;;AC3BA,uBAAsB;AACtB,IAAAC,eAAgB;AAChB,IAAAC,cAAgB;AAUhB,IAAqB,qBAArB,MAAiD;AAAA;AAAA;AAAA;AAAA;AAAA,EAW/C,YAAY,eAAgC;AAN5C;AAAA;AAAA;AAAA;AAAA,SAAQ,cAA8B,CAAC;AAOrC,SAAK,eAAe,aAAa;AAAA,EACnC;AAAA;AAAA;AAAA,EAIA,IAAI,cAAc;AAChB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,sBAAsB,aAAiC;AAC7D,UAAM,UAAW,MAAM,QAAQ,WAAW,KAAK,YAAY,SAAS,KAAM,OAAO,gBAAgB;AACjG,QAAI,aAA0B,cAAU,aAAAC,SAAI,KAAK,aAAa,WAAW,IAAI,KAAK;AAClF,QAAI,CAAC,cAAc,aAAa;AAC9B,mBAAa,CAAC;AACd,sBAAAC,SAAI,KAAK,aAAa,aAAa,UAAU;AAAA,IAC/C;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe,eAAgC;AAC7C,SAAK,cAAc,oBAAgB,iBAAAC,SAAU,aAAa,IAAI,CAAC;AAC/D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,aAAgC,aAAiC;AACzE,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AACtE,QAAI,iBAAa,aAAAF,SAAI,YAAY,UAAU;AAC3C,QAAI,CAAC,MAAM,QAAQ,UAAU,GAAG;AAC9B,mBAAa,CAAC;AACd,iBAAW,UAAU,IAAI;AAAA,IAC3B;AAEA,QAAI,MAAM,QAAQ,WAAW,GAAG;AAC9B,iBAAW,KAAK,GAAG,WAAW;AAAA,IAChC,OAAO;AACL,iBAAW,KAAK,WAAW;AAAA,IAC7B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,aAAgC,aAAiC;AACzE,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AAEtE,UAAM,YAAY,MAAM,QAAQ,WAAW,IAAI,CAAC,GAAG,WAAW,IAAI,CAAC,WAAW;AAC9E,oBAAAC,SAAI,YAAY,YAAY,SAAS;AACrC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY,aAAiC;AAC3C,UAAM,aAA0B,KAAK,sBAAsB,WAAW;AACtE,oBAAAA,SAAI,YAAY,YAAY,CAAC,CAAC;AAC9B,WAAO;AAAA,EACT;AACF;;;ACtGe,SAAR,UAAoE,QAAW;AACpF,QAAM,OAAsB,CAAC;AAC7B,MAAI,OAAO,YAAY;AACrB,SAAK,OAAO,OAAO;AAAA,EACrB;AACA,MAAI,OAAO,WAAW,OAAO,YAAY,GAAG;AAC1C,SAAK,MAAM,OAAO;AAAA,EACpB;AACA,MAAI,OAAO,WAAW,OAAO,YAAY,GAAG;AAC1C,SAAK,MAAM,OAAO;AAAA,EACpB;AACA,SAAO;AACT;;;ACVe,SAAR,cAKL,QACA,aACA,UAAkC,CAAC,GACnC,qBAAqB,MACL;AAChB,QAAM,aAA6B;AAAA,IACjC,MAAM,eAAe;AAAA,IACrB,GAAG,UAAU,MAAM;AAAA,EACrB;AAGA,MAAI,QAAQ,WAAW;AACrB,eAAW,OAAO,QAAQ;AAAA,EAC5B,WAAW,CAAC,aAAa;AAEvB,QAAI,OAAO,SAAS,UAAU;AAC5B,iBAAW,OAAO;AAElB,UAAI,sBAAsB,WAAW,SAAS,QAAW;AAGvD,mBAAW,OAAO;AAAA,MACpB;AAAA,IACF,WAAW,OAAO,SAAS,WAAW;AACpC,iBAAW,OAAO;AAElB,UAAI,WAAW,SAAS,QAAW;AAEjC,mBAAW,OAAO;AAAA,MACpB;AAAA,IACF;AAAA,EACF;AAEA,MAAI,QAAQ,cAAc;AACxB,eAAW,eAAe,QAAQ;AAAA,EACpC;AAEA,SAAO;AACT;;;AChDO,IAAM,kBAA+C;AAAA,EAC1D,OAAO;AAAA,IACL,UAAU;AAAA,EACZ;AAAA,EACA,YAAY;AAAA,EACZ,UAAU;AACZ;AAOe,SAAR,uBAIL,WAA8B,CAAC,GAAgC;AAC/D,QAAM,YAAY,aAAsB,QAAQ;AAChD,MAAI,aAAa,UAAU,sBAAsB,GAAG;AAClD,UAAM,UAAU,UAAU,sBAAsB;AAChD,WAAO,EAAE,GAAG,iBAAiB,GAAG,QAAQ;AAAA,EAC1C;AAEA,SAAO;AACT;;;ACrBe,SAAR,YAKL,MAAY,UAA6B,YAAoC,CAAC,GAAiC;AAC/G,QAAM,EAAE,UAAU,IAAI;AACtB,MAAI,SAAS,mBAAmB;AAC9B,WAAO,UAAU,IAAI;AAAA,EACvB;AACA;AAAA;AAAA;AAAA,IAGI,UAAkB,IAAI,KAAsC,UAAU,IAAI;AAAA;AAEhF;;;ACzBA,mBAA8B;AAC9B,sBAAoB;AACpB,IAAAE,eAAgB;AAChB,IAAAC,cAAgB;AA2EH;AApEb,IAAM,YAAsD;AAAA,EAC1D,SAAS;AAAA,IACP,UAAU;AAAA,IACV,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,QAAQ;AAAA,EACV;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,UAAU;AAAA,IACV,OAAO;AAAA,IACP,UAAU;AAAA,IACV,MAAM;AAAA,IACN,MAAM;AAAA,IACN,KAAK;AAAA,IACL,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,UAAU;AAAA,IACV,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,gBAAgB;AAAA,IAChB,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,EACR;AAAA,EACA,QAAQ;AAAA,IACN,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAAA,EACA,SAAS;AAAA,IACP,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AAAA,EACA,OAAO;AAAA,IACL,QAAQ;AAAA,IACR,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,QAAQ;AAAA,EACV;AACF;AASA,SAAS,mBACP,SACA;AACA,MAAI,mBAA4C,aAAAC,SAAI,SAAS,cAAc;AAE3E,MAAI,CAAC,cAAc;AACjB,UAAM,iBAAkB,QAAQ,gBAAgB,QAAQ,aAAa,WAAY,CAAC;AAClF,mBAAe,CAAC,EAAE,SAAS,GAAG,MAAM,MAAM;AACxC,aAAO,4CAAC,WAAQ,SAAS,EAAE,GAAG,gBAAgB,GAAG,QAAQ,GAAI,GAAG,OAAO;AAAA,IACzE;AACA,oBAAAC,SAAI,SAAS,gBAAgB,YAAY;AAAA,EAC3C;AACA,SAAO;AACT;AAae,SAAR,UACL,QACA,QACA,oBAAkD,CAAC,GAClC;AACjB,QAAM,OAAO,cAAc,MAAM;AAEjC,MACE,OAAO,WAAW,cACjB,UAAU,gBAAAC,QAAQ,iBAAa,4BAAc,MAAM,CAAC,KACrD,gBAAAA,QAAQ,OAAO,MAAM,GACrB;AACA,WAAO,mBAA4B,MAAyB;AAAA,EAC9D;AAEA,MAAI,OAAO,WAAW,UAAU;AAC9B,UAAM,IAAI,MAAM,kCAAkC,OAAO,MAAM,EAAE;AAAA,EACnE;AAEA,MAAI,UAAU,mBAAmB;AAC/B,UAAM,mBAAmB,kBAAkB,MAAM;AACjD,WAAO,UAAmB,QAAQ,kBAAkB,iBAAiB;AAAA,EACvE;AAEA,MAAI,OAAO,SAAS,UAAU;AAC5B,QAAI,EAAE,QAAQ,YAAY;AACxB,YAAM,IAAI,MAAM,uBAAuB,IAAI,GAAG;AAAA,IAChD;AAEA,QAAI,UAAU,UAAU,IAAI,GAAG;AAC7B,YAAM,mBAAmB,kBAAkB,UAAU,IAAI,EAAE,MAAM,CAAC;AAClE,aAAO,UAAmB,QAAQ,kBAAkB,iBAAiB;AAAA,IACvE;AAAA,EACF;AAEA,QAAM,IAAI,MAAM,cAAc,MAAM,eAAe,IAAI,GAAG;AAC5D;;;AC3HA,SAAS,WAAW,QAAwB;AAC1C,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACzC,UAAM,MAAM,OAAO,WAAW,CAAC;AAC/B,YAAQ,QAAQ,KAAK,OAAO;AAC5B,WAAO,OAAO;AAAA,EAChB;AACA,SAAO,KAAK,SAAS,EAAE;AACzB;AAQe,SAAR,cAAwE,QAAW;AACxF,QAAM,UAAU,oBAAI,IAAY;AAEhC,OAAK,UAAU,QAAQ,CAAC,KAAK,WAAW,QAAQ,IAAI,GAAG,GAAG,MAAM;AAChE,SAAO,WAAW,KAAK,UAAU,QAAQ,MAAM,KAAK,OAAO,EAAE,KAAK,CAAC,CAAC;AACtE;;;ACnBe,SAAR,UACL,QACA,QACA,oBAAkD,CAAC,GACnD;AACA,MAAI;AACF,cAAU,QAAQ,QAAQ,iBAAiB;AAC3C,WAAO;AAAA,EACT,SAAS,GAAG;AACV,UAAM,MAAa;AACnB,QAAI,IAAI,YAAY,IAAI,QAAQ,WAAW,WAAW,KAAK,IAAI,QAAQ,WAAW,oBAAoB,IAAI;AACxG,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AACF;;;AC1BA,IAAAC,mBAAqB;AAUrB,SAAS,YAAqB,IAA0B,QAAgB;AACtE,QAAM,YAAQ,iBAAAC,SAAS,EAAE,IAAI,KAAK,GAAG,MAAM;AAC3C,SAAO,GAAG,KAAK,KAAK,MAAM;AAC5B;AAMO,SAAS,cAAuB,IAA0B;AAC/D,SAAO,YAAe,IAAI,aAAa;AACzC;AAOO,SAAS,QAAiB,IAA0B;AACzD,SAAO,YAAe,IAAI,OAAO;AACnC;AAOO,SAAS,WAAoB,IAA0B;AAC5D,SAAO,YAAe,IAAI,UAAU;AACtC;AAOO,SAAS,OAAgB,IAA0B;AACxD,SAAO,YAAe,IAAI,MAAM;AAClC;AAOO,SAAS,QAAiB,IAA0B;AACzD,SAAO,YAAe,IAAI,OAAO;AACnC;AAUO,SAAS,mBAA4B,IAA0B,kBAAkB,OAAO;AAC7F,QAAM,WAAW,kBAAkB,IAAI,WAAc,EAAE,CAAC,KAAK;AAC7D,SAAO,GAAG,QAAW,EAAE,CAAC,IAAI,cAAiB,EAAE,CAAC,IAAI,OAAU,EAAE,CAAC,GAAG,QAAQ;AAC9E;AAQO,SAAS,SAAS,IAAY,aAAqB;AACxD,SAAO,GAAG,EAAE,IAAI,WAAW;AAC7B;;;AC3De,SAAR,WACL,OACA,WACA,UAC2C;AAC3C,SAAO,YAAY,WAAW;AAChC;;;ACtBe,SAAR,WAA4B,YAAoB;AACrD,SAAO,aAAa,IAAI,KAAK,UAAU,EAAE,OAAO,IAAI;AACtD;;;ACGe,SAAR,WAAqE,QAAW;AACrF,MAAI,YAAY,UAAU,MAAM,QAAQ,OAAO,IAAI,KAAK,OAAO,KAAK,WAAW,GAAG;AAChF,WAAO,OAAO,KAAK,CAAC;AAAA,EACtB;AACA,MAAI,aAAa,QAAQ;AACvB,WAAO,OAAO;AAAA,EAChB;AACA,QAAM,IAAI,MAAM,yCAAyC;AAC3D;;;ACPe,SAAR,YACL,QACkC;AAGlC,QAAM,sBAAsB;AAC5B,MAAI,oBAAoB,aAAa,MAAuC;AAC1E,YAAQ,KAAK,oFAAoF;AAAA,EACnG;AACA,MAAI,OAAO,MAAM;AACf,WAAO,OAAO,KAAK,IAAI,CAAC,OAAO,MAAM;AACnC,YAAM,QAAS,oBAAoB,aAAa,oBAAoB,UAAU,CAAC,KAAM,OAAO,KAAK;AACjG,aAAO,EAAE,OAAO,MAAM;AAAA,IACxB,CAAC;AAAA,EACH;AACA,QAAM,aAAa,OAAO,SAAS,OAAO;AAC1C,SACE,cACA,WAAW,IAAI,CAAC,eAAe;AAC7B,UAAM,UAAU;AAChB,UAAM,QAAQ,WAAW,OAAO;AAChC,UAAM,QAAQ,QAAQ,SAAS,OAAO,KAAK;AAC3C,WAAO;AAAA,MACL,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AAEL;;;AC5Be,SAAR,gBAAiC,YAAsB,OAA4B;AACxF,MAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,WAAO;AAAA,EACT;AAEA,QAAM,cAAc,CAAC,QACnB,IAAI,OAAO,CAAC,MAAyB,SAAS;AAC5C,SAAK,IAAI,IAAI;AACb,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP,QAAM,gBAAgB,CAAC,QACrB,IAAI,SAAS,IAAI,eAAe,IAAI,KAAK,MAAM,CAAC,MAAM,aAAa,IAAI,CAAC,CAAC;AAC3E,QAAM,eAAe,YAAY,UAAU;AAC3C,QAAM,gBAAgB,MAAM,OAAO,CAAC,SAAS,SAAS,OAAO,aAAa,IAAI,CAAC;AAC/E,QAAM,YAAY,YAAY,aAAa;AAE3C,QAAM,OAAO,WAAW,OAAO,CAAC,SAAiB,CAAC,UAAU,IAAI,CAAC;AACjE,QAAM,YAAY,cAAc,QAAQ,GAAG;AAC3C,MAAI,cAAc,IAAI;AACpB,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,MAAM,wCAAwC,cAAc,IAAI,CAAC,EAAE;AAAA,IAC/E;AACA,WAAO;AAAA,EACT;AACA,MAAI,cAAc,cAAc,YAAY,GAAG,GAAG;AAChD,UAAM,IAAI,MAAM,0DAA0D;AAAA,EAC5E;AAEA,QAAM,WAAW,CAAC,GAAG,aAAa;AAClC,WAAS,OAAO,WAAW,GAAG,GAAG,IAAI;AACrC,SAAO;AACT;;;ACrCe,SAAR,IAAqB,KAAa,OAAe;AACtD,MAAI,IAAI,OAAO,GAAG;AAClB,SAAO,EAAE,SAAS,OAAO;AACvB,QAAI,MAAM;AAAA,EACZ;AACA,SAAO;AACT;;;ACHe,SAAR,gBAAiC,YAAqB,cAAc,MAAkB;AAC3F,MAAI,CAAC,YAAY;AACf,WAAO;AAAA,MACL,MAAM;AAAA,MACN,OAAO;AAAA,MACP,KAAK;AAAA,MACL,MAAM,cAAc,KAAK;AAAA,MACzB,QAAQ,cAAc,KAAK;AAAA,MAC3B,QAAQ,cAAc,KAAK;AAAA,IAC7B;AAAA,EACF;AACA,QAAM,OAAO,IAAI,KAAK,UAAU;AAChC,MAAI,OAAO,MAAM,KAAK,QAAQ,CAAC,GAAG;AAChC,UAAM,IAAI,MAAM,0BAA0B,UAAU;AAAA,EACtD;AACA,SAAO;AAAA,IACL,MAAM,KAAK,eAAe;AAAA,IAC1B,OAAO,KAAK,YAAY,IAAI;AAAA;AAAA,IAC5B,KAAK,KAAK,WAAW;AAAA,IACrB,MAAM,cAAc,KAAK,YAAY,IAAI;AAAA,IACzC,QAAQ,cAAc,KAAK,cAAc,IAAI;AAAA,IAC7C,QAAQ,cAAc,KAAK,cAAc,IAAI;AAAA,EAC/C;AACF;;;ACrBe,SAAR,wBAAkF,QAAoB;AAE3G,MAAI,OAAO,OAAO;AAChB,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,QAAQ,OAAO,KAAK,WAAW,KAAK,OAAO,KAAK,CAAC,MAAM,MAAM;AACtE,WAAO;AAAA,EACT;AAGA,MAAI,OAAO,SAAS,OAAO,MAAM,WAAW,GAAG;AAC7C,WAAO,wBAAwB,OAAO,MAAM,CAAC,CAAM;AAAA,EACrD;AAGA,MAAI,OAAO,SAAS,OAAO,MAAM,WAAW,GAAG;AAC7C,WAAO,wBAAwB,OAAO,MAAM,CAAC,CAAM;AAAA,EACrD;AAGA,MAAI,OAAO,OAAO;AAChB,UAAM,aAAa,CAAC,cAAyC,wBAAwB,SAAc;AACnG,WAAO,OAAO,MAAM,KAAK,UAAU;AAAA,EACrC;AAEA,SAAO;AACT;;;AC3Be,SAAR,aAA8B,WAA4B,WAAgB,WAAgB;AAC/F,QAAM,EAAE,OAAO,MAAM,IAAI;AACzB,SAAO,CAAC,WAAW,OAAO,SAAS,KAAK,CAAC,WAAW,OAAO,SAAS;AACtE;;;ACNe,SAAR,aAA8B,YAAwB,OAAO,MAAM;AACxE,QAAM,EAAE,MAAM,OAAO,KAAK,OAAO,GAAG,SAAS,GAAG,SAAS,EAAE,IAAI;AAC/D,QAAM,UAAU,KAAK,IAAI,MAAM,QAAQ,GAAG,KAAK,MAAM,QAAQ,MAAM;AACnE,QAAM,WAAW,IAAI,KAAK,OAAO,EAAE,OAAO;AAC1C,SAAO,OAAO,WAAW,SAAS,MAAM,GAAG,EAAE;AAC/C;;;ACdA,IAAAC,wBAA0B;AAWX,SAAR,YACL,aACA,YAAsB,CAAC,GACA;AACvB,MAAI,CAAC,aAAa;AAChB,WAAO,CAAC;AAAA,EACV;AACA,MAAI,YAAmC,CAAC;AACxC,MAAI,cAAc,aAAa;AAC7B,gBAAY,UAAU;AAAA,MACpB,YAAY,UAAU,EAAG,IAAI,CAAC,YAAoB;AAChD,cAAM,WAAW,IAAI,UAAU,KAAK,GAAG,CAAC;AACxC,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA,OAAO,GAAG,QAAQ,IAAI,OAAO;AAAA,QAC/B;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AACA,SAAO,OAAO,KAAK,WAAW,EAAE,OAAO,CAAC,KAAK,QAAQ;AACnD,QAAI,QAAQ,YAAY;AACtB,YAAM,cAAe,YAAkC,GAAG;AAC1D,cAAI,sBAAAC,SAAc,WAAW,GAAG;AAC9B,cAAM,IAAI,OAAO,YAAY,aAAa,CAAC,GAAG,WAAW,GAAG,CAAC,CAAC;AAAA,MAChE;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,SAAS;AACd;;;ACxCA,oBAAmB;AAwBJ,SAAR,cAAwC,QAA+C;AAC5F,QAAM,UAAU,IAAI,mBAAsB;AAC1C,MAAI,OAAO,QAAQ;AACjB,WAAO,QAAQ,CAAC,UAAU;AACxB,YAAM,EAAE,UAAU,QAAQ,IAAI;AAE9B,YAAM,OAAO,aAAa,MAAM,CAAC,QAAI,cAAAC,SAAO,QAAQ;AAGpD,UAAI,KAAK,SAAS,KAAK,KAAK,CAAC,MAAM,IAAI;AACrC,aAAK,OAAO,GAAG,CAAC;AAAA,MAClB;AACA,UAAI,SAAS;AACX,gBAAQ,UAAU,SAAS,IAAI;AAAA,MACjC;AAAA,IACF,CAAC;AAAA,EACH;AACA,SAAO,QAAQ;AACjB;;;AC1CA,IAAAC,wBAA0B;AASX,SAAR,mBAA6C,cAAiD;AACnG,SAAO,OAAO,KAAK,YAAY,EAAE,OAAO,CAAC,KAAK,QAAQ;AACpD,QAAI,QAAQ,YAAY;AACtB,aAAO;AAAA,IACT,OAAO;AACL,YAAM,cAAe,aAAmC,GAAG;AAC3D,cAAI,sBAAAC,SAAc,WAAW,GAAG;AAC9B,eAAO;AAAA,UACL,GAAG;AAAA,UACH,CAAC,GAAG,GAAG,mBAAmB,WAAW;AAAA,QACvC;AAAA,MACF;AACA,aAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,YAAY;AAAA,IACtC;AAAA,EACF,GAAG,CAAC,CAAmB;AACzB;;;ACjBe,SAAR,WAA4B,UAAkB;AACnD,MAAI,CAAC,UAAU;AACb,WAAO;AAAA,EACT;AAQA,QAAM,OAAO,IAAI,KAAK,QAAQ;AAE9B,QAAM,OAAO,IAAI,KAAK,YAAY,GAAG,CAAC;AACtC,QAAM,KAAK,IAAI,KAAK,SAAS,IAAI,GAAG,CAAC;AACrC,QAAM,KAAK,IAAI,KAAK,QAAQ,GAAG,CAAC;AAChC,QAAM,KAAK,IAAI,KAAK,SAAS,GAAG,CAAC;AACjC,QAAM,KAAK,IAAI,KAAK,WAAW,GAAG,CAAC;AACnC,QAAM,KAAK,IAAI,KAAK,WAAW,GAAG,CAAC;AACnC,QAAM,MAAM,IAAI,KAAK,gBAAgB,GAAG,CAAC;AAEzC,SAAO,GAAG,IAAI,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,GAAG;AACrD;;;AC7BA,IAAAC,kBAAoB;AAeL,SAAR,oBACL,gBACA,uBACmB;AACnB,MAAI,CAAC,uBAAuB;AAC1B,WAAO;AAAA,EACT;AACA,QAAM,EAAE,QAAQ,WAAW,aAAa,eAAe,IAAI;AAC3D,MAAI,SAAS,YAAY,qBAAqB;AAC9C,MAAI,cAAc;AAClB,MAAI,KAAC,gBAAAC,SAAQ,cAAc,GAAG;AAC5B,kBAAc,aAAa,gBAAgB,uBAAuB,IAAI;AACtE,aAAS,CAAC,GAAG,SAAS,EAAE,OAAO,MAAM;AAAA,EACvC;AACA,SAAO,EAAE,aAAa,OAAO;AAC/B;;;AC5BA,IAAAC,oBAAqB;AAOrB,SAAS,sBAA+D,MAAY;AAClF,aAAW,OAAO,MAAM;AACtB,UAAM,UAAgC;AACtC,UAAM,QAAQ,QAAQ,GAAG;AACzB,QAAI,QAAQ,WAAW,OAAO,UAAU,YAAY,MAAM,WAAW,GAAG,GAAG;AACzE,cAAQ,GAAG,IAAI,qBAAqB;AAAA,IACtC,OAAO;AACL,cAAQ,GAAG,IAAI,gBAAmB,KAAK;AAAA,IACzC;AAAA,EACF;AACA,SAAO;AACT;AAOA,SAAS,qBAA8D,MAAgB;AACrF,WAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,SAAK,CAAC,IAAI,gBAAmB,KAAK,CAAC,CAAC;AAAA,EACtC;AACA,SAAO;AACT;AAQe,SAAR,gBACL,YACsB;AACtB,MAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAO,qBAAwB,CAAC,GAAG,UAAU,CAAC;AAAA,EAChD;AACA,UAAI,kBAAAC,SAAS,UAAU,GAAG;AACxB,WAAO,sBAAyB,EAAE,GAAG,WAAW,CAAC;AAAA,EACnD;AACA,SAAO;AACT;;;AC5CO,IAAK,qBAAL,kBAAKC,wBAAL;AAEL,EAAAA,oBAAA,oBAAiB;AAEjB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,cAAW;AAEX,EAAAA,oBAAA,aAAU;AAEV,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,iBAAc;AAEd,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,eAAY;AAEZ,EAAAA,oBAAA,mBAAgB;AAEhB,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,oBAAiB;AAEjB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,cAAW;AAEX,EAAAA,oBAAA,gBAAa;AAEb,EAAAA,oBAAA,mBAAgB;AAEhB,EAAAA,oBAAA,kBAAe;AAEf,EAAAA,oBAAA,wBAAqB;AAErB,EAAAA,oBAAA,wBAAqB;AAGrB,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,kBAAe;AAIf,EAAAA,oBAAA,uBAAoB;AAEpB,EAAAA,oBAAA,cAAW;AAGX,EAAAA,oBAAA,wBAAqB;AAErB,EAAAA,oBAAA,sBAAmB;AAEnB,EAAAA,oBAAA,4BAAyB;AAEzB,EAAAA,oBAAA,gCAA6B;AAI7B,EAAAA,oBAAA,qCAAkC;AAIlC,EAAAA,oBAAA,eAAY;AAlEF,SAAAA;AAAA,GAAA;;;ACNZ,qBAAoB;AACpB,IAAAC,kBAAoB;;;ACDpB,IAAAC,eAAgB;AAChB,IAAAC,kBAAoB;AA8BpB,IAAqB,kBAArB,MAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYE,YAAY,YAAe;AAP3B;AAAA,qBAA0B,CAAC;AAQzB,SAAK,aAAa;AAClB,SAAK,UAAU,YAAY,cAAiB,UAAU,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,QAAW,MAAc;AACjC,UAAM,UAAM,aAAAC,SAAI,QAAQ,QAAQ,IAAI;AACpC,UAAM,mBAAmB,EAAE,GAAG,QAAQ,CAAC,MAAM,GAAG,IAAI;AACpD,UAAM,WAAW,KAAK,UAAU,GAAG;AACnC,QAAI,CAAC,UAAU;AACb,WAAK,UAAU,GAAG,IAAI;AAAA,IACxB,WAAW,KAAC,gBAAAC,SAAQ,UAAU,gBAAgB,GAAG;AAC/C,cAAQ,MAAM,oBAAoB,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC;AACnE,cAAQ,MAAM,eAAe,KAAK,UAAU,kBAAkB,MAAM,CAAC,CAAC;AACtE,YAAM,IAAI;AAAA,QACR,iDAAiD,GAAG;AAAA,MACtD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA,EAIA,eAAe;AACb,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,QAAQ,QAAW,WAAc,YAAwB;AACvD,QAAI,KAAC,gBAAAA,SAAQ,YAAY,KAAK,UAAU,GAAG;AACzC,YAAM,IAAI,MAAM,gGAAgG;AAAA,IAClH;AACA,SAAK,UAAU,QAAQ,cAAiB,MAAM,CAAC;AAE/C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAA4B,SAAY,WAA+D;AACrG,UAAM,IAAI,MAAM,yEAAyE;AAAA,EAC3F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,cAA+B,YAA8C;AACvF,UAAM,IAAI,MAAM,uEAAuE;AAAA,EACzF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,iBACE,WACA,SACA,iBACA,kBACA,WACmB;AACnB,UAAM,IAAI,MAAM,4EAA4E;AAAA,EAC9F;AACF;;;ADjHA,SAAS,YACP,WACA,aACA,YACA,QACA;AACA,QAAM,UAAU,uBAAgC,WAAW,QAAQ,YAAY,QAAW,IAAI;AAC9F,UAAQ,QAAQ,CAACC,YAAW;AAC1B,UAAM,kBAAkB,YAAY,UAAU,CAAC,aAAS,gBAAAC,SAAQ,MAAMD,OAAM,CAAC;AAC7E,QAAI,oBAAoB,IAAI;AAC1B,kBAAY,KAAKA,OAAM;AACvB,YAAM,aAAa,yBAAkC,WAAWA,SAAQ,YAAY,IAAI;AACxF,iBAAW,QAAQ,CAAC,MAAM;AACxB,YAAI,kBAAkB,KAAK,EAAE,cAAc,GAAG;AAC5C,6BAAAE,SAAQF,QAAO,cAAc,GAAG,CAAC,UAAU;AACzC,wBAAqB,WAAW,aAAa,YAAY,KAAU;AAAA,UACrE,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AACD,UAAI,aAAaA,WAAU,CAAC,MAAM,QAAQA,QAAO,KAAK,KAAK,OAAOA,QAAO,UAAU,WAAW;AAC5F,oBAAqB,WAAW,aAAa,YAAYA,QAAO,KAAU;AAAA,MAC5E;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAQe,SAAR,aACL,YACc;AACd,QAAM,YAAY,IAAI,gBAAyB,UAAU;AACzD,QAAM,cAAmB,CAAC;AAE1B,cAAY,WAAW,aAAa,YAAY,UAAU;AAE1D,SAAO,UAAU,aAAa;AAChC;",
   "names": ["isPlainObject", "isEqualWith", "import_get", "omit", "jsonpointer", "import_get", "import_has", "import_isNumber", "import_isObject", "import_isString", "import_times", "import_get", "get", "isNumber", "has", "get", "import_get", "import_get", "get", "isString", "type", "acc", "union", "times", "transform", "merge", "uniq", "flattenDeep", "isEqual", "get", "set", "mergeAllOf", "s", "isObject", "reduce", "get", "has", "key", "isString", "isNumber", "times", "import_get", "acc", "get", "altSchemas", "isEmpty", "get", "import_isEmpty", "isEmpty", "import_get", "import_has", "has", "get", "import_get", "import_isEqual", "isEqual", "get", "import_get", "import_isEqual", "import_set", "isEqual", "set", "get", "import_isEqual", "index", "isEqual", "import_isEqual", "isEqual", "isNil", "import_get", "import_set", "get", "set", "cloneDeep", "import_get", "import_set", "get", "set", "ReactIs", "import_isString", "isString", "import_isPlainObject", "isPlainObject", "toPath", "import_isPlainObject", "isPlainObject", "import_isEmpty", "isEmpty", "import_isObject", "isObject", "TranslatableString", "import_isEqual", "import_get", "import_isEqual", "get", "isEqual", "schema", "isEqual", "forEach"]
 }
diff --git a/node_modules/@rjsf/utils/dist/utils.esm.js b/node_modules/@rjsf/utils/dist/utils.esm.js
index ea497e0..6b39488 100644
--- a/node_modules/@rjsf/utils/dist/utils.esm.js
+++ b/node_modules/@rjsf/utils/dist/utils.esm.js
@@ -1113,8 +1113,9 @@ function computeDefaults(validator, rawSchema, {
       return objectDefaults;
     }
     case "array": {
-      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "never";
-      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "requiredOnly";
+      const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+      const neverPopulate = arrayMinItems?.populate === "never";
+      const ignoreMinItemsFlagSet = arrayMinItems?.populate === "requiredOnly";
       if (Array.isArray(defaults)) {
         defaults = defaults.map((item, idx) => {
           const schemaItem = getInnerSchemaForArrayItem(schema, 2 /* Fallback */, idx);
@@ -1185,7 +1186,8 @@ function getDefaultFormState(validator, theSchema, formData, rootSchema, include
   if (formData === void 0 || formData === null || typeof formData === "number" && isNaN(formData)) {
     return defaults;
   }
-  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+  const { mergeExtraDefaults } = arrayMinItems || {};
   if (isObject(formData)) {
     return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
   }
diff --git a/node_modules/@rjsf/utils/dist/utils.esm.js.map b/node_modules/@rjsf/utils/dist/utils.esm.js.map
index d802de4..e2bf181 100644
--- a/node_modules/@rjsf/utils/dist/utils.esm.js.map
+++ b/node_modules/@rjsf/utils/dist/utils.esm.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
   "sources": ["../src/isObject.ts", "../src/allowAdditionalItems.ts", "../src/asNumber.ts", "../src/constants.ts", "../src/getUiOptions.ts", "../src/canExpand.ts", "../src/createErrorHandler.ts", "../src/deepEquals.ts", "../src/schema/getDefaultFormState.ts", "../src/findSchemaDefinition.ts", "../src/schema/getClosestMatchingOption.ts", "../src/schema/getMatchingOption.ts", "../src/getOptionMatchingSimpleDiscriminator.ts", "../src/schema/getFirstMatchingOption.ts", "../src/schema/retrieveSchema.ts", "../src/getDiscriminatorFieldFromSchema.ts", "../src/guessType.ts", "../src/mergeSchemas.ts", "../src/getSchemaType.ts", "../src/isFixedItems.ts", "../src/mergeDefaultsWithFormData.ts", "../src/mergeObjects.ts", "../src/isConstant.ts", "../src/schema/isSelect.ts", "../src/schema/isMultiSelect.ts", "../src/isCustomWidget.ts", "../src/schema/isFilesArray.ts", "../src/schema/getDisplayLabel.ts", "../src/schema/mergeValidationData.ts", "../src/schema/sanitizeDataForNewSchema.ts", "../src/schema/toIdSchema.ts", "../src/schema/toPathSchema.ts", "../src/createSchemaUtils.ts", "../src/dataURItoBlob.ts", "../src/replaceStringParameters.ts", "../src/englishStringTranslator.ts", "../src/enumOptionsDeselectValue.ts", "../src/enumOptionsValueForIndex.ts", "../src/enumOptionsIsSelected.ts", "../src/enumOptionsIndexForValue.ts", "../src/enumOptionsSelectValue.ts", "../src/ErrorSchemaBuilder.ts", "../src/rangeSpec.ts", "../src/getInputProps.ts", "../src/getSubmitButtonOptions.ts", "../src/getTemplate.ts", "../src/getWidget.tsx", "../src/hashForSchema.ts", "../src/hasWidget.ts", "../src/idGenerators.ts", "../src/labelValue.ts", "../src/localToUTC.ts", "../src/toConstant.ts", "../src/optionsList.ts", "../src/orderProperties.ts", "../src/pad.ts", "../src/parseDateString.ts", "../src/schemaRequiresTrueValue.ts", "../src/shouldRender.ts", "../src/toDateString.ts", "../src/toErrorList.ts", "../src/toErrorSchema.ts", "../src/unwrapErrorHandler.ts", "../src/utcToLocal.ts", "../src/validationDataMerge.ts", "../src/withIdRefPrefix.ts", "../src/enums.ts", "../src/parser/schemaParser.ts", "../src/parser/ParserValidator.ts"],
-  "sourcesContent": ["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\n * the type `object` but is NOT null, an array or a File.\n *\n * @param thing - The thing to check to see whether it is an object\n * @returns - True if it is a non-null, non-array, non-File object\n */\nexport default function isObject(thing: any) {\n  if (typeof File !== 'undefined' && thing instanceof File) {\n    return false;\n  }\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\n    return false;\n  }\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\n *\n * @param schema - The schema object to check\n * @returns - True if additional items is allowed, otherwise false\n */\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (schema.additionalItems === true) {\n    console.warn('additionalItems=true is currently not supported');\n  }\n  return isObject(schema.additionalItems);\n}\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\n *\n * @param value - The string or null value to convert to a number\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\n */\nexport default function asNumber(value: string | null) {\n  if (value === '') {\n    return undefined;\n  }\n  if (value === null) {\n    return null;\n  }\n  if (/\\.$/.test(value)) {\n    // '3.' can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  const n = Number(value);\n  const valid = typeof n === 'number' && !Number.isNaN(n);\n\n  return valid ? n : value;\n}\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\n * utility.\n */\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\nexport const ALL_OF_KEY = 'allOf';\nexport const ANY_OF_KEY = 'anyOf';\nexport const CONST_KEY = 'const';\nexport const DEFAULT_KEY = 'default';\nexport const DEFINITIONS_KEY = 'definitions';\nexport const DEPENDENCIES_KEY = 'dependencies';\nexport const ENUM_KEY = 'enum';\nexport const ERRORS_KEY = '__errors';\nexport const ID_KEY = '$id';\nexport const IF_KEY = 'if';\nexport const ITEMS_KEY = 'items';\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\nexport const NAME_KEY = '$name';\nexport const ONE_OF_KEY = 'oneOf';\nexport const PROPERTIES_KEY = 'properties';\nexport const REQUIRED_KEY = 'required';\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\nexport const REF_KEY = '$ref';\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\nexport const UI_FIELD_KEY = 'ui:field';\nexport const UI_WIDGET_KEY = 'ui:widget';\nexport const UI_OPTIONS_KEY = 'ui:options';\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\nimport isObject from './isObject';\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\n\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\n *\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\n */\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  uiSchema: UiSchema<T, S, F> = {},\n  globalOptions: GlobalUISchemaOptions = {}\n): UIOptionsType<T, S, F> {\n  return Object.keys(uiSchema)\n    .filter((key) => key.indexOf('ui:') === 0)\n    .reduce(\n      (options, key) => {\n        const value = uiSchema[key];\n        if (key === UI_WIDGET_KEY && isObject(value)) {\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\n          return options;\n        }\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\n          return { ...options, ...value };\n        }\n        return { ...options, [key.substring(3)]: value };\n      },\n      { ...globalOptions }\n    );\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\nimport getUiOptions from './getUiOptions';\n\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\n * `formData` object doesn't already have `schema.maxProperties` elements.\n *\n * @param schema - The schema for the field that is being checked\n * @param [uiSchema={}] - The uiSchema for the field\n * @param [formData] - The formData for the field\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\n */\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  uiSchema: UiSchema<T, S, F> = {},\n  formData?: T\n) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\n  if (expandable === false) {\n    return expandable;\n  }\n  // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n  if (schema.maxProperties !== undefined && formData) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n  return true;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\n\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n *\n * @param formData - The form data around which the error handler is created\n * @returns - A `FormValidation` object based on the `formData` structure\n */\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\n  const handler: FieldValidation = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // 'errors' (see `utils.toErrorSchema`).\n    [ERRORS_KEY]: [],\n    addError(message: string) {\n      this[ERRORS_KEY]!.push(message);\n    },\n  };\n  if (Array.isArray(formData)) {\n    return formData.reduce((acc, value, key) => {\n      return { ...acc, [key]: createErrorHandler(value) };\n    }, handler);\n  }\n  if (isPlainObject(formData)) {\n    const formObject: GenericObjectType = formData as GenericObjectType;\n    return Object.keys(formObject).reduce((acc, key) => {\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\n    }, handler as FormValidation<T>);\n  }\n  return handler as FormValidation<T>;\n}\n", "import isEqualWith from 'lodash/isEqualWith';\n\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\n * assumes all functions are equivalent.\n *\n * @param a - The first element to compare\n * @param b - The second element to compare\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\n */\nexport default function deepEquals(a: any, b: any): boolean {\n  return isEqualWith(a, b, (obj: any, other: any) => {\n    if (typeof obj === 'function' && typeof other === 'function') {\n      // Assume all functions are equivalent\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n      return true;\n    }\n    return undefined; // fallback to default isEquals behavior\n  });\n}\n", "import get from 'lodash/get';\nimport isEmpty from 'lodash/isEmpty';\n\nimport {\n  ANY_OF_KEY,\n  DEFAULT_KEY,\n  DEPENDENCIES_KEY,\n  PROPERTIES_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  ALL_OF_KEY,\n} from '../constants';\nimport findSchemaDefinition from '../findSchemaDefinition';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getSchemaType from '../getSchemaType';\nimport isObject from '../isObject';\nimport isFixedItems from '../isFixedItems';\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\nimport mergeObjects from '../mergeObjects';\nimport mergeSchemas from '../mergeSchemas';\nimport {\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GenericObjectType,\n  RJSFSchema,\n  StrictRJSFSchema,\n  ValidatorType,\n} from '../types';\nimport isMultiSelect from './isMultiSelect';\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\n\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\n */\nexport enum AdditionalItemsHandling {\n  Ignore,\n  Invert,\n  Fallback,\n}\n\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\n *    index and not a boolean, otherwise it falls through to 3.\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\n *    is a schema, otherwise it falls through to 3.\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\n * 4. {} is returned representing an empty schema\n *\n * @param schema - The schema from which to get the particular item\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\n */\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\n  idx = -1\n): S {\n  if (idx >= 0) {\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\n      const item = schema.items[idx];\n      if (typeof item !== 'boolean') {\n        return item as S;\n      }\n    }\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n    return schema.items as S;\n  }\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\n    return schema.additionalItems as S;\n  }\n  return {} as S;\n}\n\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\n * values will be added based on certain conditions.\n *\n * @param obj - The object into which the computed default may be added\n * @param key - The key into the object at which the computed default may be added\n * @param computedDefault - The computed default value that maybe should be added to the obj\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\n * @param requiredFields - The list of fields that are required\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\n *        default form state behavior\n */\nfunction maybeAddDefaultToObject<T = any>(\n  obj: GenericObjectType,\n  key: string,\n  computedDefault: T | T[] | undefined,\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\n  isParentRequired?: boolean,\n  requiredFields: string[] = [],\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\n) {\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\n  if (includeUndefinedValues) {\n    obj[key] = computedDefault;\n  } else if (emptyObjectFields !== 'skipDefaults') {\n    if (isObject(computedDefault)) {\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\n      // the field key itself in the `requiredField` list\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\n      // Condition 1: If computedDefault is not empty or if the key is a required field\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\n      if (\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\n      ) {\n        obj[key] = computedDefault;\n      }\n    } else if (\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\n      // Condition 1: computedDefault is not undefined\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\n      computedDefault !== undefined &&\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\n    ) {\n      obj[key] = computedDefault;\n    }\n  }\n}\n\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\n  parentDefaults?: T;\n  rootSchema?: S;\n  rawFormData?: T;\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\n  _recurseList?: string[];\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\n  required?: boolean;\n}\n\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\n * @param rawSchema - The schema for which the default state is desired\n * @param [props] - Optional props for this function\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rawSchema: S,\n  {\n    parentDefaults,\n    rawFormData,\n    rootSchema = {} as S,\n    includeUndefinedValues = false,\n    _recurseList = [],\n    experimental_defaultFormStateBehavior = undefined,\n    required,\n  }: ComputeDefaultsProps<T, S> = {}\n): T | T[] | undefined {\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\n  // Compute the defaults recursively: give highest priority to deepest nodes.\n  let defaults: T | T[] | undefined = parentDefaults;\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\n  let schemaToCompute: S | null = null;\n  let updatedRecurseList = _recurseList;\n\n  if (isObject(defaults) && isObject(schema.default)) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\n  } else if (DEFAULT_KEY in schema) {\n    defaults = schema.default as unknown as T;\n  } else if (REF_KEY in schema) {\n    const refName = schema[REF_KEY];\n    // Use referenced schema defaults for this node.\n    if (!_recurseList.includes(refName!)) {\n      updatedRecurseList = _recurseList.concat(refName!);\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\n    }\n  } else if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\n  } else if (isFixedItems(schema)) {\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\n      computeDefaults<T, S>(validator, itemSchema, {\n        rootSchema,\n        includeUndefinedValues,\n        _recurseList,\n        experimental_defaultFormStateBehavior,\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\n        rawFormData: formData as T,\n        required,\n      })\n    ) as T[];\n  } else if (ONE_OF_KEY in schema) {\n    const { oneOf, ...remaining } = schema;\n    if (oneOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = oneOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        oneOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  } else if (ANY_OF_KEY in schema) {\n    const { anyOf, ...remaining } = schema;\n    if (anyOf!.length === 0) {\n      return undefined;\n    }\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    schemaToCompute = anyOf![\n      getClosestMatchingOption<T, S, F>(\n        validator,\n        rootSchema,\n        isEmpty(formData) ? undefined : formData,\n        anyOf as S[],\n        0,\n        discriminator\n      )\n    ] as S;\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\n  }\n\n  if (schemaToCompute) {\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\n      rootSchema,\n      includeUndefinedValues,\n      _recurseList: updatedRecurseList,\n      experimental_defaultFormStateBehavior,\n      parentDefaults: defaults as T | undefined,\n      rawFormData: formData as T,\n      required,\n    });\n  }\n\n  // No defaults defined for this node, fallback to generic typed ones.\n  if (defaults === undefined) {\n    defaults = schema.default as unknown as T;\n  }\n\n  switch (getSchemaType<S>(schema)) {\n    // We need to recurse for object schema inner default values.\n    case 'object': {\n      // This is a custom addition that fixes this issue:\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\n      const retrievedSchema =\n        experimental_defaultFormStateBehavior?.allOf === 'populateDefaults' && ALL_OF_KEY in schema\n          ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData)\n          : schema;\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\n        (acc: GenericObjectType, key: string) => {\n          // Compute the defaults for this node, with the parent defaults we might\n          // have from a previous run: defaults[key].\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          maybeAddDefaultToObject<T>(\n            acc,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            retrievedSchema.required,\n            experimental_defaultFormStateBehavior\n          );\n          return acc;\n        },\n        {}\n      ) as T;\n      if (retrievedSchema.additionalProperties) {\n        // as per spec additionalProperties may be either schema or boolean\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\n          ? retrievedSchema.additionalProperties\n          : {};\n\n        const keys = new Set<string>();\n        if (isObject(defaults)) {\n          Object.keys(defaults as GenericObjectType)\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n            .forEach((key) => keys.add(key));\n        }\n        const formDataRequired: string[] = [];\n        Object.keys(formData as GenericObjectType)\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\n          .forEach((key) => {\n            keys.add(key);\n            formDataRequired.push(key);\n          });\n        keys.forEach((key) => {\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            includeUndefinedValues: includeUndefinedValues === true,\n            parentDefaults: get(defaults, [key]),\n            rawFormData: get(formData, [key]),\n            required: retrievedSchema.required?.includes(key),\n          });\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\n          maybeAddDefaultToObject<T>(\n            objectDefaults as GenericObjectType,\n            key,\n            computedDefault,\n            includeUndefinedValues,\n            required,\n            formDataRequired\n          );\n        });\n      }\n      return objectDefaults;\n    }\n    case 'array': {\n      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';\n      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';\n\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map((item, idx) => {\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\n          return computeDefaults<T, S, F>(validator, schemaItem, {\n            rootSchema,\n            _recurseList,\n            experimental_defaultFormStateBehavior,\n            parentDefaults: item,\n            required,\n          });\n        }) as T[];\n      }\n\n      // Deeply inject defaults into already existing form data\n      if (Array.isArray(rawFormData)) {\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\n        if (neverPopulate) {\n          defaults = rawFormData;\n        } else {\n          defaults = rawFormData.map((item: T, idx: number) => {\n            return computeDefaults<T, S, F>(validator, schemaItem, {\n              rootSchema,\n              _recurseList,\n              experimental_defaultFormStateBehavior,\n              rawFormData: item,\n              parentDefaults: get(defaults, [idx]),\n              required,\n            });\n          }) as T[];\n        }\n      }\n\n      if (neverPopulate) {\n        return defaults ?? [];\n      }\n      if (ignoreMinItemsFlagSet && !required) {\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\n        // return form data/defaults\n        return defaults ? defaults : undefined;\n      }\n\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\n      if (\n        !schema.minItems ||\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n        schema.minItems <= defaultsLength\n      ) {\n        return defaults ? defaults : [];\n      }\n\n      const defaultEntries: T[] = (defaults || []) as T[];\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\n      const fillerDefault = fillerSchema.default;\n\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\n        computeDefaults<any, S, F>(validator, fillerSchema, {\n          parentDefaults: fillerDefault,\n          rootSchema,\n          _recurseList,\n          experimental_defaultFormStateBehavior,\n          required,\n        })\n      ) as T[];\n      // then fill up the rest with either the item default or empty, up to minItems\n      return defaultEntries.concat(fillerEntries);\n    }\n  }\n\n  return defaults;\n}\n\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n * computed to have defaults provided in the `schema`.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the default state is desired\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\n *          false when computing defaults for any nested object properties.\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - The resulting `formData` with all the defaults provided\n */\nexport default function getDefaultFormState<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  formData?: T,\n  rootSchema?: S,\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\n) {\n  if (!isObject(theSchema)) {\n    throw new Error('Invalid schema: ' + theSchema);\n  }\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\n    rootSchema,\n    includeUndefinedValues,\n    experimental_defaultFormStateBehavior,\n    rawFormData: formData,\n  });\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};\n  if (isObject(formData)) {\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\n  }\n  if (Array.isArray(formData)) {\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\n  }\n  return formData;\n}\n", "import jsonpointer from 'jsonpointer';\nimport omit from 'lodash/omit';\n\nimport { REF_KEY } from './constants';\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\n * location, the `object` minus the `key: value` and in the second location the `value`.\n *\n * @param key - The key from the object to extract\n * @param object - The object from which to extract the element\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\n *      value from `object[key]`\n */\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\n  const value = object[key];\n  const remaining = omit(object, [key]);\n  return [remaining, value];\n}\n\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\n *\n * @param $ref - The ref string for which the schema definition is desired\n * @param [rootSchema={}] - The root schema in which to search for the definition\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\n * @throws - Error indicating that no schema for that reference exists\n */\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\n  $ref?: string,\n  rootSchema: S = {} as S\n): S {\n  let ref = $ref || '';\n  if (ref.startsWith('#')) {\n    // Decode URI fragment representation.\n    ref = decodeURIComponent(ref.substring(1));\n  } else {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  const current: S = jsonpointer.get(rootSchema, ref);\n  if (current === undefined) {\n    throw new Error(`Could not find a definition for ${$ref}.`);\n  }\n  if (current[REF_KEY]) {\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\n    if (Object.keys(remaining).length > 0) {\n      return { ...remaining, ...subSchema };\n    }\n    return subSchema;\n  }\n  return current;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\nimport isObject from 'lodash/isObject';\nimport isString from 'lodash/isString';\nimport reduce from 'lodash/reduce';\nimport times from 'lodash/times';\n\nimport getFirstMatchingOption from './getFirstMatchingOption';\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\nimport guessType from '../guessType';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\n * the first item\n */\nexport const JUNK_OPTION: StrictRJSFSchema = {\n  type: 'object',\n  $id: JUNK_OPTION_ID,\n  properties: {\n    __not_really_there__: {\n      type: 'number',\n    },\n  },\n};\n\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\n *   the total.\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\n *   `getClosestMatchingOption()` of that oneOf.\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\n *   `value` itself as the sub-schema, and the score is added to the total.\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\n *   is incremented by another 1 otherwise it is decremented by 1.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param schema - The schema for which the score is being calculated\n * @param formData - The form data associated with the schema, used to calculate the score\n * @returns - The score a schema against the formData\n */\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  schema?: S,\n  formData: any = {}\n): number {\n  let totalScore = 0;\n  if (schema) {\n    if (isObject(schema.properties)) {\n      totalScore += reduce(\n        schema.properties,\n        (score, value, key) => {\n          const formValue = get(formData, key);\n          if (typeof value === 'boolean') {\n            return score;\n          }\n          if (has(value, REF_KEY)) {\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\n          }\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\n            return (\n              score +\n              getClosestMatchingOption<T, S, F>(\n                validator,\n                rootSchema,\n                formValue,\n                get(value, key) as S[],\n                -1,\n                discriminator\n              )\n            );\n          }\n          if (value.type === 'object') {\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\n          }\n          if (value.type === guessType(formValue)) {\n            // If the types match, then we bump the score by one\n            let newScore = score + 1;\n            if (value.default) {\n              // If the schema contains a readonly default value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.default ? 1 : -1;\n            } else if (value.const) {\n              // If the schema contains a const value score the value that matches the default higher and\n              // any non-matching value lower\n              newScore += formValue === value.const ? 1 : -1;\n            }\n            // TODO eventually, deal with enums/arrays\n            return newScore;\n          }\n          return score;\n        },\n        0\n      );\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\n      totalScore += 1;\n    }\n  }\n  return totalScore;\n}\n\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\n * matched.\n *\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\n * option with the highest score is determined by iterating over the list of valid options, calling\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\n * eventually has the best score.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param formData - The form data associated with the schema\n * @param options - The list of options that can be selected from\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n */\nexport default function getClosestMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  formData: T | undefined,\n  options: S[],\n  selectedOption = -1,\n  discriminatorField?: string\n): number {\n  // First resolve any refs in the options\n  const resolvedOptions = options.map((option) => {\n    return resolveAllReferences<S>(option, rootSchema, []);\n  });\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  // Reduce the array of options down to a list of the indexes that are considered matching options\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\n    const testOptions: S[] = [JUNK_OPTION as S, option];\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\n    // The match is the real option, so add its index to list of valid indexes\n    if (match === 1) {\n      validList.push(index);\n    }\n    return validList;\n  }, []);\n\n  // There is only one valid index, so return it!\n  if (allValidIndexes.length === 1) {\n    return allValidIndexes[0];\n  }\n  if (!allValidIndexes.length) {\n    // No indexes were valid, so we'll score all the options, add all the indexes\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\n  }\n  type BestType = { bestIndex: number; bestScore: number };\n  const scoreCount = new Set<number>();\n  // Score all the options in the list of valid indexes and return the index with the best score\n  const { bestIndex }: BestType = allValidIndexes.reduce(\n    (scoreData: BestType, index: number) => {\n      const { bestScore } = scoreData;\n      const option = resolvedOptions[index];\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\n      scoreCount.add(score);\n      if (score > bestScore) {\n        return { bestIndex: index, bestScore: score };\n      }\n      return scoreData;\n    },\n    { bestIndex: selectedOption, bestScore: 0 }\n  );\n  // if all scores are the same go with selectedOption\n  if (scoreCount.size === 1 && selectedOption >= 0) {\n    return selectedOption;\n  }\n\n  return bestIndex;\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\nimport isNumber from 'lodash/isNumber';\n\nimport { PROPERTIES_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n * Deprecated, use `getFirstMatchingOption()` instead.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or 0 if none is available\n * @deprecated\n */\nexport default function getMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  // For performance, skip validating subschemas if formData is undefined. We just\n  // want to get the first option in that case.\n  if (formData === undefined) {\n    return 0;\n  }\n\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\n  if (isNumber(simpleDiscriminatorMatch)) {\n    return simpleDiscriminatorMatch;\n  }\n\n  for (let i = 0; i < options.length; i++) {\n    const option = options[i];\n\n    // If we have a discriminator field, then we will use this to make the determination\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\n      const value = get(formData, discriminatorField);\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n      if (validator.isValid(discriminator, value, rootSchema)) {\n        return i;\n      }\n    } else if (option[PROPERTIES_KEY]) {\n      // If the schema describes an object then we need to add slightly more\n      // strict matching to the schema, because unless the schema uses the\n      // \"requires\" keyword, an object will match the schema as long as it\n      // doesn't have matching keys with a conflicting type. To do this we use an\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\n      // schema should match if any of the keys in the schema are present on the\n      // object and pass validation.\n      //\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      const requiresAnyOf = {\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\n          required: [key],\n        })),\n      };\n\n      let augmentedSchema;\n\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        const { ...shallowClone } = option;\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      }\n\n      // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n      delete augmentedSchema.required;\n\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\n        return i;\n      }\n    } else if (validator.isValid(option, formData, rootSchema)) {\n      return i;\n    }\n  }\n  return 0;\n}\n", "import get from 'lodash/get';\nimport { PROPERTIES_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\n *\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the matched option or undefined if there is no match\n */\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\n  formData: T | undefined,\n  options: S[],\n  discriminatorField?: string\n): number | undefined {\n  if (formData && discriminatorField) {\n    const value = get(formData, discriminatorField);\n\n    if (value === undefined) {\n      return;\n    }\n\n    for (let i = 0; i < options.length; i++) {\n      const option = options[i];\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\n\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\n        continue;\n      }\n\n      if (discriminator.const === value) {\n        return i;\n      }\n\n      if (discriminator.enum?.includes(value)) {\n        return i;\n      }\n    }\n  }\n\n  return;\n}\n", "import getMatchingOption from './getMatchingOption';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n * Always returns the first option if there is nothing that matches.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param formData - The current formData, if any, used to figure out a match\n * @param options - The list of options to find a matching options from\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n *          determine which option is selected\n * @returns - The index of the first matched option or 0 if none is available\n */\nexport default function getFirstMatchingOption<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  formData: T | undefined,\n  options: S[],\n  rootSchema: S,\n  discriminatorField?: string\n): number {\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\nimport times from 'lodash/times';\nimport transform from 'lodash/transform';\nimport merge from 'lodash/merge';\nimport flattenDeep from 'lodash/flattenDeep';\nimport uniq from 'lodash/uniq';\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\n\nimport {\n  ADDITIONAL_PROPERTIES_KEY,\n  ADDITIONAL_PROPERTY_FLAG,\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  DEPENDENCIES_KEY,\n  IF_KEY,\n  ONE_OF_KEY,\n  REF_KEY,\n  PROPERTIES_KEY,\n  ITEMS_KEY,\n} from '../constants';\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport guessType from '../guessType';\nimport isObject from '../isObject';\nimport mergeSchemas from '../mergeSchemas';\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getFirstMatchingOption from './getFirstMatchingOption';\n\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\n * potentially recursive resolution.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n */\nexport default function retrieveSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\n}\n\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\n * conditions will be returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\n * @param schema - The schema for which resolving a condition is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\n */\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\n\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\n  let schemas: S[] = [];\n  if (expandAllBranches) {\n    if (then && typeof then !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n    if (otherwise && typeof otherwise !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\n      );\n    }\n  } else {\n    const conditionalSchema = conditionValue ? then : otherwise;\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\n      schemas = schemas.concat(\n        retrieveSchemaInternal<T, S, F>(\n          validator,\n          conditionalSchema as S,\n          rootSchema,\n          formData,\n          expandAllBranches,\n          recurseList\n        )\n      );\n    }\n  }\n  if (schemas.length) {\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\n  }\n  return resolvedSchemas.flatMap((s) =>\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\n  );\n}\n\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\n *\n * For example:\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\n *   C schemas then:\n *   - The permutation for the first row is `[[A]]`\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\n *\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\n */\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\n    (permutations, list) => {\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\n      if (list.length > 1) {\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\n      }\n      // Otherwise just push in the single value into the current set of permutations\n      permutations.forEach((permutation) => permutation.push(list[0]));\n      return permutations;\n    },\n    [[]] as S[][] // Start with an empty list\n  );\n\n  return allPermutations;\n}\n\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\n */\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchemas = resolveReference<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    formData\n  );\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\n    // return the updatedSchemas array if it has either multiple schemas within it\n    // OR the first schema is not the same as the original schema\n    return updatedSchemas;\n  }\n  if (DEPENDENCIES_KEY in schema) {\n    const resolvedSchemas = resolveDependencies<T, S, F>(\n      validator,\n      schema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    );\n    return resolvedSchemas.flatMap((s) => {\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\n    });\n  }\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\n      retrieveSchemaInternal<T, S, F>(\n        validator,\n        allOfSubschema as S,\n        rootSchema,\n        formData,\n        expandAllBranches,\n        recurseList\n      )\n    );\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\n  }\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\n  return [schema];\n}\n\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\n * helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a reference is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list schemas retrieved after having all references resolved\n */\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\n  if (updatedSchema !== schema) {\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\n    return retrieveSchemaInternal<T, S, F>(\n      validator,\n      updatedSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n  }\n  return [schema];\n}\n\n/** Resolves all references within the schema itself as well as any of its properties and array items.\n *\n * @param schema - The schema for which resolving all references is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param recurseList - List of $refs already resolved to prevent recursion\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\n */\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  rootSchema: S,\n  recurseList: string[]\n): S {\n  if (!isObject(schema)) {\n    return schema;\n  }\n  let resolvedSchema: S = schema;\n  // resolve top level ref\n  if (REF_KEY in resolvedSchema) {\n    const { $ref, ...localSchema } = resolvedSchema;\n    // Check for a recursive reference and stop the loop\n    if (recurseList.includes($ref!)) {\n      return resolvedSchema;\n    }\n    recurseList.push($ref!);\n    // Retrieve the referenced schema definition.\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\n    resolvedSchema = { ...refSchema, ...localSchema };\n  }\n\n  if (PROPERTIES_KEY in resolvedSchema) {\n    const childrenLists: string[][] = [];\n    const updatedProps = transform(\n      resolvedSchema[PROPERTIES_KEY]!,\n      (result, value, key: string) => {\n        const childList: string[] = [...recurseList];\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\n        childrenLists.push(childList);\n      },\n      {} as RJSFSchema\n    );\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\n  }\n\n  if (\n    ITEMS_KEY in resolvedSchema &&\n    !Array.isArray(resolvedSchema.items) &&\n    typeof resolvedSchema.items !== 'boolean'\n  ) {\n    resolvedSchema = {\n      ...resolvedSchema,\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\n    };\n  }\n\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\n}\n\n/** Creates new 'properties' items for each key in the `formData`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which the existing additional properties is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\n * @returns - The updated schema with additional properties stubbed\n */\nexport function stubExistingAdditionalProperties<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\n  // Clone the schema so that we don't ruin the consumer's original\n  const schema = {\n    ...theSchema,\n    properties: { ...theSchema.properties },\n  };\n\n  // make sure formData is an object\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\n  Object.keys(formData).forEach((key) => {\n    if (key in schema.properties) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    let additionalProperties: S['additionalProperties'] = {};\n    if (typeof schema.additionalProperties !== 'boolean') {\n      if (REF_KEY in schema.additionalProperties!) {\n        additionalProperties = retrieveSchema<T, S, F>(\n          validator,\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\n          rootSchema,\n          formData as T\n        );\n      } else if ('type' in schema.additionalProperties!) {\n        additionalProperties = { ...schema.additionalProperties };\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\n        additionalProperties = {\n          type: 'object',\n          ...schema.additionalProperties,\n        };\n      } else {\n        additionalProperties = { type: guessType(get(formData, [key])) };\n      }\n    } else {\n      additionalProperties = { type: guessType(get(formData, [key])) };\n    }\n\n    // The type of our new key should match the additionalProperties value;\n    schema.properties[key] = additionalProperties;\n    // Set our additional property flag so we know it was dynamically added\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\n  });\n\n  return schema;\n}\n\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\n * of the schema and its references, conditions and dependencies are returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\n *          dependencies as a list of schemas\n * @param [recurseList=[]] - The optional, list of recursive references already processed\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\n */\nexport function retrieveSchemaInternal<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  rawFormData?: T,\n  expandAllBranches = false,\n  recurseList: string[] = []\n): S[] {\n  if (!isObject(schema)) {\n    return [{} as S];\n  }\n  const resolvedSchemas = resolveSchema<T, S, F>(\n    validator,\n    schema,\n    rootSchema,\n    expandAllBranches,\n    recurseList,\n    rawFormData\n  );\n  return resolvedSchemas.flatMap((s: S) => {\n    let resolvedSchema = s;\n    if (IF_KEY in resolvedSchema) {\n      return resolveCondition<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        rawFormData as T\n      );\n    }\n    if (ALL_OF_KEY in resolvedSchema) {\n      // resolve allOf schemas\n      if (expandAllBranches) {\n        const { allOf, ...restOfSchema } = resolvedSchema;\n        return [...(allOf as S[]), restOfSchema as S];\n      }\n      try {\n        resolvedSchema = mergeAllOf(resolvedSchema, {\n          deep: false,\n        } as Options) as S;\n      } catch (e) {\n        console.warn('could not merge subschemas in allOf:\\n', e);\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\n        return resolvedSchemaWithoutAllOf as S;\n      }\n    }\n    const hasAdditionalProperties =\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\n    if (hasAdditionalProperties) {\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\n    }\n\n    return resolvedSchema;\n  });\n}\n\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\n * options are retrieved and returned.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which retrieving a schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function resolveAnyOrOneOfSchemas<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\n  let anyOrOneOf: S[] | undefined;\n  const { oneOf, anyOf, ...remaining } = schema;\n  if (Array.isArray(oneOf)) {\n    anyOrOneOf = oneOf as S[];\n  } else if (Array.isArray(anyOf)) {\n    anyOrOneOf = anyOf as S[];\n  }\n  if (anyOrOneOf) {\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    anyOrOneOf = anyOrOneOf.map((s) => {\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\n      // can resolve recursive references independently\n      return resolveAllReferences(s, rootSchema, []);\n    });\n    // Call this to trigger the set of isValid() calls that the schema parser will need\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\n    if (expandAllBranches) {\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\n    }\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\n  }\n  return [schema];\n}\n\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependency is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The list of schemas with their dependencies resolved\n */\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  // Drop the dependencies from the source schema.\n  const { dependencies, ...remainingSchema } = schema;\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\n    validator,\n    remainingSchema as S,\n    rootSchema,\n    expandAllBranches,\n    formData\n  );\n  return resolvedSchemas.flatMap((resolvedSchema) =>\n    processDependencies<T, S, F>(\n      validator,\n      dependencies,\n      resolvedSchema,\n      rootSchema,\n      expandAllBranches,\n      recurseList,\n      formData\n    )\n  );\n}\n\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param dependencies - The set of dependencies that needs to be processed\n * @param resolvedSchema - The schema for which processing dependencies is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The schema with the `dependencies` resolved into it\n */\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  dependencies: S['dependencies'],\n  resolvedSchema: S,\n  rootSchema: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  let schemas = [resolvedSchema];\n  // Process dependencies updating the local schema properties as appropriate.\n  for (const dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\n      continue;\n    }\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\n      dependencyKey,\n      dependencies as GenericObjectType\n    );\n    if (Array.isArray(dependencyValue)) {\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      schemas = withDependentSchema<T, S, F>(\n        validator,\n        resolvedSchema,\n        rootSchema,\n        dependencyKey,\n        dependencyValue as S,\n        expandAllBranches,\n        recurseList,\n        formData\n      );\n    }\n    return schemas.flatMap((schema) =>\n      processDependencies<T, S, F>(\n        validator,\n        remainingDependencies,\n        schema,\n        rootSchema,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  }\n  return schemas;\n}\n\n/** Updates a schema with additionally required properties added\n *\n * @param schema - The schema for which resolving a dependent properties is desired\n * @param [additionallyRequired] - An optional array of additionally required names\n * @returns - The schema with the additional required values merged in\n */\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S,\n  additionallyRequired?: string[]\n) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n  const required = Array.isArray(schema.required)\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\n    : additionallyRequired;\n  return { ...schema, required: required };\n}\n\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param schema - The schema for which resolving a dependent schema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the dependency\n * @param dependencyValue - The potentially dependent schema\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData]- The current formData to assist retrieving a schema\n * @returns - The list of schemas with the dependent schema resolved into them\n */\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  dependencyValue: S,\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\n    validator,\n    dependencyValue,\n    rootSchema,\n    formData,\n    expandAllBranches,\n    recurseList\n  );\n  return dependentSchemas.flatMap((dependent) => {\n    const { oneOf, ...dependentSchema } = dependent;\n    schema = mergeSchemas(schema, dependentSchema) as S;\n    // Since it does not contain oneOf, we return the original schema.\n    if (oneOf === undefined) {\n      return schema;\n    }\n    // Resolve $refs inside oneOf.\n    const resolvedOneOfs = oneOf.map((subschema) => {\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\n        return [subschema as S];\n      }\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\n    });\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\n    return allPermutations.flatMap((resolvedOneOf) =>\n      withExactlyOneSubschema<T, S, F>(\n        validator,\n        schema,\n        rootSchema,\n        dependencyKey,\n        resolvedOneOf,\n        expandAllBranches,\n        recurseList,\n        formData\n      )\n    );\n  });\n}\n\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\n * the `retrieveSchemaInternal()` helper call.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\n * @param schema - The schema for which resolving a oneOf subschema is desired\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param dependencyKey - The key name of the oneOf dependency\n * @param oneOf - The list of schemas representing the oneOf options\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\n *          as a list of schemas\n * @param recurseList - The list of recursive references already processed\n * @param [formData] - The current formData to assist retrieving a schema\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\n */\nexport function withExactlyOneSubschema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  rootSchema: S,\n  dependencyKey: string,\n  oneOf: S['oneOf'],\n  expandAllBranches: boolean,\n  recurseList: string[],\n  formData?: T\n): S[] {\n  const validSubschemas = oneOf!.filter((subschema) => {\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\n      return false;\n    }\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\n    if (conditionPropertySchema) {\n      const conditionSchema: S = {\n        type: 'object',\n        properties: {\n          [dependencyKey]: conditionPropertySchema,\n        },\n      } as S;\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\n    }\n    return false;\n  });\n\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return [schema];\n  }\n  return validSubschemas.flatMap((s) => {\n    const subschema: S = s as S;\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\n    const schemas = retrieveSchemaInternal<T, S, F>(\n      validator,\n      dependentSchema,\n      rootSchema,\n      formData,\n      expandAllBranches,\n      recurseList\n    );\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\n  });\n}\n", "import get from 'lodash/get';\nimport isString from 'lodash/isString';\n\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\n *\n * @param schema - The schema from which the discriminator is potentially obtained\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\n */\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  let discriminator: string | undefined;\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\n  if (isString(maybeString)) {\n    discriminator = maybeString;\n  } else if (maybeString !== undefined) {\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\n  }\n  return discriminator;\n}\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\n *  create a schema, it is useful to know what type to use based on the data we are defining.\n *\n * @param value - The value from which to guess the type\n * @returns - The best guess for the object type\n */\nexport default function guessType(value: any) {\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (typeof value === 'string') {\n    return 'string';\n  }\n  if (value == null) {\n    return 'null';\n  }\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n  if (!isNaN(value)) {\n    return 'number';\n  }\n  if (typeof value === 'object') {\n    return 'object';\n  }\n  // Default to string if we can't figure it out\n  return 'string';\n}\n", "import union from 'lodash/union';\n\nimport { REQUIRED_KEY } from './constants';\nimport getSchemaType from './getSchemaType';\nimport isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\n * duplicate values.\n *\n * @param obj1 - The first schema object to merge\n * @param obj2 - The second schema object to merge\n * @returns - The merged schema object\n */\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (\n      obj1 &&\n      obj2 &&\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\n      key === REQUIRED_KEY &&\n      Array.isArray(left) &&\n      Array.isArray(right)\n    ) {\n      // Don't include duplicate values when merging 'required' fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, acc);\n}\n", "import guessType from './guessType';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\n * other elements of the schema as follows:\n * - schema.const: Returns the `guessType()` of that value\n * - schema.enum: Returns `string`\n * - schema.properties: Returns `object`\n * - schema.additionalProperties: Returns `object`\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\n *\n * @param schema - The schema for which to get the type\n * @returns - The type of the schema\n */\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): string | string[] | undefined {\n  let { type } = schema;\n\n  if (!type && schema.const) {\n    return guessType(schema.const);\n  }\n\n  if (!type && schema.enum) {\n    return 'string';\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return 'object';\n  }\n\n  if (Array.isArray(type)) {\n    if (type.length === 2 && type.includes('null')) {\n      type = type.find((type) => type !== 'null');\n    } else {\n      type = type[0];\n    }\n  }\n\n  return type;\n}\n", "import isObject from './isObject';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\n * that only contains objects.\n *\n * @param schema - The schema in which to check for fixed items\n * @returns - True if there are fixed items in the schema, false otherwise\n */\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\n}\n", "import get from 'lodash/get';\n\nimport isObject from './isObject';\nimport { GenericObjectType } from '../src';\n\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\n *\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\n *     which case the extras are appended onto the end of the form data\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n *\n * @param [defaults] - The defaults to merge\n * @param [formData] - The form data into which the defaults will be merged\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\n * @returns - The resulting merged form data with defaults\n */\nexport default function mergeDefaultsWithFormData<T = any>(\n  defaults?: T,\n  formData?: T,\n  mergeExtraArrayDefaults = false\n): T | undefined {\n  if (Array.isArray(formData)) {\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\n    const mapped = formData.map((value, idx) => {\n      if (defaultsArray[idx]) {\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\n      }\n      return value;\n    });\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\n      mapped.push(...defaultsArray.slice(mapped.length));\n    }\n    return mapped as unknown as T;\n  }\n  if (isObject(formData)) {\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\n        defaults ? get(defaults, key) : {},\n        get(formData, key),\n        mergeExtraArrayDefaults\n      );\n      return acc;\n    }, acc);\n  }\n  return formData;\n}\n", "import isObject from './isObject';\nimport { GenericObjectType } from './types';\n\n/** Recursively merge deeply nested objects.\n *\n * @param obj1 - The first object to merge\n * @param obj2 - The second object to merge\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\n *          NOTE: Uses shallow comparison for the duplicate checking.\n * @returns - A new object that is the merge of the two given objects\n */\nexport default function mergeObjects(\n  obj1: GenericObjectType,\n  obj2: GenericObjectType,\n  concatArrays: boolean | 'preventDuplicates' = false\n) {\n  return Object.keys(obj2).reduce((acc, key) => {\n    const left = obj1 ? obj1[key] : {},\n      right = obj2[key];\n    if (obj1 && key in obj1 && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      let toMerge = right;\n      if (concatArrays === 'preventDuplicates') {\n        toMerge = right.reduce((result, value) => {\n          if (!left.includes(value)) {\n            result.push(value);\n          }\n          return result;\n        }, []);\n      }\n      acc[key] = left.concat(toMerge);\n    } else {\n      acc[key] = right;\n    }\n    return acc;\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\n}\n", "import { CONST_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\n * an `enum` array with a single value or there is a `const` defined.\n *\n * @param schema - The schema for a field\n * @returns - True if the `schema` has a single constant value, false otherwise\n */\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\n}\n", "import isConstant from '../isConstant';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` combination represents a select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param theSchema - The schema for which check for a select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a select, otherwise false\n */\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  theSchema: S,\n  rootSchema: S = {} as S\n) {\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\n  const altSchemas = schema.oneOf || schema.anyOf;\n  if (Array.isArray(schema.enum)) {\n    return true;\n  }\n  if (Array.isArray(altSchemas)) {\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\n  }\n  return false;\n}\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\n\nimport isSelect from './isSelect';\n\n/** Checks to see if the `schema` combination represents a multi-select\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for a multi-select flag is desired\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema contains a multi-select, otherwise false\n */\nexport default function isMultiSelect<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\n    return false;\n  }\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\n}\n", "import getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\n\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\n *\n * @param uiSchema - The UI Schema from which to detect if it is customized\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\n */\nexport default function isCustomWidget<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}) {\n  return (\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\n  );\n}\n", "import { UI_WIDGET_KEY } from '../constants';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\n\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which check for array of files flag is desired\n * @param [uiSchema={}] - The UI schema from which to check the widget\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\n */\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S\n) {\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\n    return true;\n  }\n  if (schema.items) {\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\n  }\n  return false;\n}\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\nimport getSchemaType from '../getSchemaType';\nimport getUiOptions from '../getUiOptions';\nimport isCustomWidget from '../isCustomWidget';\nimport {\n  FormContextType,\n  GlobalUISchemaOptions,\n  RJSFSchema,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidatorType,\n} from '../types';\nimport isFilesArray from './isFilesArray';\nimport isMultiSelect from './isMultiSelect';\n\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n * should be displayed in a UI.\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the display label flag is desired\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n * @returns - True if the label should be displayed or false if it should not\n */\nexport default function getDisplayLabel<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  uiSchema: UiSchema<T, S, F> = {},\n  rootSchema?: S,\n  globalOptions?: GlobalUISchemaOptions\n): boolean {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\n  const { label = true } = uiOptions;\n  let displayLabel = !!label;\n  const schemaType = getSchemaType<S>(schema);\n\n  if (schemaType === 'array') {\n    displayLabel =\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\n      isCustomWidget(uiSchema);\n  }\n\n  if (schemaType === 'object') {\n    displayLabel = false;\n  }\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\n    displayLabel = false;\n  }\n  if (uiSchema[UI_FIELD_KEY]) {\n    displayLabel = false;\n  }\n  return displayLabel;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from '../mergeObjects';\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n *        removed in the next major release.\n */\nexport default function mergeValidationData<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = validator.toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import get from 'lodash/get';\nimport has from 'lodash/has';\n\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\nimport retrieveSchema from './retrieveSchema';\n\nconst NO_VALUE = Symbol('no Value');\n\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\n *\n * - If the new schema is an object that contains a `properties` object then:\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\n *   - Create an empty `nestedData` object for use in the key filtering below:\n *   - Iterate over each key in the `newSchema.properties` as follows:\n *     - Get the `formValue` of the key from the `data`\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\n *       - If type of the key in the new schema is `object`:\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\n *       - Otherwise, check for default or const values:\n *         - Get the old and new `default` values from the schema and check:\n *           - If the new `default` value does not match the form value:\n *             - If the old `default` value DOES match the form value, then:\n *               - Replace `removeOldSchemaData[key]` with the new `default`\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\n *         - Get the old and new `const` values from the schema and check:\n *           - If the new `const` value does not match the form value:\n *           - If the old `const` value DOES match the form value, then:\n *             - Replace `removeOldSchemaData[key]` with the new `const`\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\n *   - Once all keys have been processed, return an object built as follows:\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\n * - If the new and old schema types are array and the `data` is an array then:\n *   - If the type of the old and new schema `items` are a non-array objects:\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\n *     - If the `type`s of both items are the same (or the old does not have a type):\n *       - If the type is \"object\", then:\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\n * - Otherwise return `undefined`\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param rootSchema - The root JSON schema of the entire form\n * @param [newSchema] - The new schema for which the data is being sanitized\n * @param [oldSchema] - The old schema from which the data originated\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n */\nexport default function sanitizeDataForNewSchema<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\n  // By default, we will clear the form data\n  let newFormData;\n  // If the new schema is of type object and that object contains a list of properties\n  if (has(newSchema, PROPERTIES_KEY)) {\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\n    const removeOldSchemaData: GenericObjectType = {};\n    if (has(oldSchema, PROPERTIES_KEY)) {\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\n      Object.keys(properties).forEach((key) => {\n        if (has(data, key)) {\n          removeOldSchemaData[key] = undefined;\n        }\n      });\n    }\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\n    // Create a place to store nested data that will be a side-effect of the filter\n    const nestedData: GenericObjectType = {};\n    keys.forEach((key) => {\n      const formValue = get(data, key);\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\n      // Resolve the refs if they exist\n      if (has(oldKeyedSchema, REF_KEY)) {\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\n      }\n      if (has(newKeyedSchema, REF_KEY)) {\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\n        if (has(removeOldSchemaData, key)) {\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\n          delete removeOldSchemaData[key];\n        }\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\n            validator,\n            rootSchema,\n            newKeyedSchema,\n            oldKeyedSchema,\n            formValue\n          );\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\n            // only put undefined values for the array type and not the object type\n            nestedData[key] = itemData;\n          }\n        } else {\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\n          // value to be properly selected\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\n            if (oldOptionDefault === formValue) {\n              // If the old default matches the formValue, we'll update the new value to match the new default\n              removeOldSchemaData[key] = newOptionDefault;\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\n              removeOldSchemaData[key] = undefined;\n            }\n          }\n\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\n          }\n        }\n      }\n    });\n\n    newFormData = {\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\n      ...removeOldSchemaData,\n      ...nestedData,\n    };\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\n    let oldSchemaItems = get(oldSchema, 'items');\n    let newSchemaItems = get(newSchema, 'items');\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\n    if (\n      typeof oldSchemaItems === 'object' &&\n      typeof newSchemaItems === 'object' &&\n      !Array.isArray(oldSchemaItems) &&\n      !Array.isArray(newSchemaItems)\n    ) {\n      if (has(oldSchemaItems, REF_KEY)) {\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\n      }\n      if (has(newSchemaItems, REF_KEY)) {\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\n      }\n      // Now get types and see if they are the same\n      const oldSchemaType = get(oldSchemaItems, 'type');\n      const newSchemaType = get(newSchemaItems, 'type');\n      // Check if the old option has the same key with the same type\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\n        const maxItems = get(newSchema, 'maxItems', -1);\n        if (newSchemaType === 'object') {\n          newFormData = data.reduce((newValue, aValue) => {\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\n              validator,\n              rootSchema,\n              newSchemaItems as S,\n              oldSchemaItems as S,\n              aValue\n            );\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\n              newValue.push(itemValue);\n            }\n            return newValue;\n          }, []);\n        } else {\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\n        }\n      }\n    } else if (\n      typeof oldSchemaItems === 'boolean' &&\n      typeof newSchemaItems === 'boolean' &&\n      oldSchemaItems === newSchemaItems\n    ) {\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\n      newFormData = data;\n    }\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\n  }\n  return newFormData as T;\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\nimport isObject from '../isObject';\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport retrieveSchema from './retrieveSchema';\nimport getSchemaType from '../getSchemaType';\n\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param idPrefix - The prefix to use for the id\n * @param idSeparator - The separator to use for the path segments in the id\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `IdSchema` object for the `schema`\n */\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  idPrefix: string,\n  idSeparator: string,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): IdSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toIdSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        idPrefix,\n        idSeparator,\n        id,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\n    return toIdSchemaInternal<T, S, F>(\n      validator,\n      get(schema, ITEMS_KEY) as S,\n      idPrefix,\n      idSeparator,\n      id,\n      rootSchema,\n      formData,\n      _recurseList\n    );\n  }\n  const $id = id || idPrefix;\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\n    for (const name in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, name]);\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\n        validator,\n        isObject(field) ? field : {},\n        idPrefix,\n        idSeparator,\n        fieldId,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [name]),\n        _recurseList\n      );\n    }\n  }\n  return idSchema as IdSchema<T>;\n}\n\n/** Generates an `IdSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `IdSchema` is desired\n * @param [id] - The base id for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [idPrefix='root'] - The prefix to use for the id\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\n * @returns - The `IdSchema` object for the `schema`\n */\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  id?: string | null,\n  rootSchema?: S,\n  formData?: T,\n  idPrefix = 'root',\n  idSeparator = '_'\n): IdSchema<T> {\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport set from 'lodash/set';\n\nimport {\n  ALL_OF_KEY,\n  ANY_OF_KEY,\n  ADDITIONAL_PROPERTIES_KEY,\n  DEPENDENCIES_KEY,\n  ITEMS_KEY,\n  NAME_KEY,\n  ONE_OF_KEY,\n  PROPERTIES_KEY,\n  REF_KEY,\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\n} from '../constants';\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\nimport getClosestMatchingOption from './getClosestMatchingOption';\nimport retrieveSchema from './retrieveSchema';\n\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\n * infinite recursion\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\n * @returns - The `PathSchema` object for the `schema`\n */\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name: string,\n  rootSchema?: S,\n  formData?: T,\n  _recurseList: S[] = []\n): PathSchema<T> {\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\n    if (sameSchemaIndex === -1) {\n      return toPathSchemaInternal<T, S, F>(\n        validator,\n        _schema,\n        name,\n        rootSchema,\n        formData,\n        _recurseList.concat(_schema)\n      );\n    }\n  }\n\n  let pathSchema: PathSchema = {\n    [NAME_KEY]: name.replace(/^\\./, ''),\n  } as PathSchema;\n\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\n    const _schema: S = xxxOf![index] as S;\n    pathSchema = {\n      ...pathSchema,\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\n    };\n  }\n\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\n  }\n\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\n\n    if (Array.isArray(schemaItems)) {\n      formData.forEach((element, i: number) => {\n        if (schemaItems[i]) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaItems[i] as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else if (schemaAdditionalItems) {\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\n            validator,\n            schemaAdditionalItems as S,\n            `${name}.${i}`,\n            rootSchema,\n            element,\n            _recurseList\n          );\n        } else {\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\n        }\n      });\n    } else {\n      formData.forEach((element, i: number) => {\n        pathSchema[i] = toPathSchemaInternal<T, S, F>(\n          validator,\n          schemaItems as S,\n          `${name}.${i}`,\n          rootSchema,\n          element,\n          _recurseList\n        );\n      });\n    }\n  } else if (PROPERTIES_KEY in schema) {\n    for (const property in schema.properties) {\n      const field = get(schema, [PROPERTIES_KEY, property]);\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\n        validator,\n        field,\n        `${name}.${property}`,\n        rootSchema,\n        // It's possible that formData is not an object -- this can happen if an\n        // array item has just been added, but not populated with data yet\n        get(formData, [property]),\n        _recurseList\n      );\n    }\n  }\n  return pathSchema as PathSchema<T>;\n}\n\n/** Generates an `PathSchema` object for the `schema`, recursively\n *\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\n * @param schema - The schema for which the `PathSchema` is desired\n * @param [name=''] - The base name for the schema\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\n * @param [formData] - The current formData, if any, to assist retrieving a schema\n * @returns - The `PathSchema` object for the `schema`\n */\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ValidatorType<T, S, F>,\n  schema: S,\n  name = '',\n  rootSchema?: S,\n  formData?: T\n): PathSchema<T> {\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\n}\n", "import deepEquals from './deepEquals';\nimport {\n  ErrorSchema,\n  Experimental_DefaultFormStateBehavior,\n  FormContextType,\n  GlobalUISchemaOptions,\n  IdSchema,\n  PathSchema,\n  RJSFSchema,\n  SchemaUtilsType,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from './types';\nimport {\n  getDefaultFormState,\n  getDisplayLabel,\n  getClosestMatchingOption,\n  getFirstMatchingOption,\n  getMatchingOption,\n  isFilesArray,\n  isMultiSelect,\n  isSelect,\n  mergeValidationData,\n  retrieveSchema,\n  sanitizeDataForNewSchema,\n  toIdSchema,\n  toPathSchema,\n} from './schema';\n\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\n */\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements SchemaUtilsType<T, S, F>\n{\n  rootSchema: S;\n  validator: ValidatorType<T, S, F>;\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\n\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\n   */\n  constructor(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\n  ) {\n    this.rootSchema = rootSchema;\n    this.validator = validator;\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\n  }\n\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\n   *\n   * @returns - The `ValidatorType`\n   */\n  getValidator() {\n    return this.validator;\n  }\n\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\n   * of a new `SchemaUtilsType` with incomplete properties.\n   *\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\n   * @param rootSchema - The root schema that will be compared against the current one\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\n   */\n  doesSchemaUtilsDiffer(\n    validator: ValidatorType<T, S, F>,\n    rootSchema: S,\n    experimental_defaultFormStateBehavior = {}\n  ): boolean {\n    if (!validator || !rootSchema) {\n      return false;\n    }\n    return (\n      this.validator !== validator ||\n      !deepEquals(this.rootSchema, rootSchema) ||\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\n    );\n  }\n\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\n   * computed to have defaults provided in the `schema`.\n   *\n   * @param schema - The schema for which the default state is desired\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\n   *          object properties.\n   * @returns - The resulting `formData` with all the defaults provided\n   */\n  getDefaultFormState(\n    schema: S,\n    formData?: T,\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\n  ): T | T[] | undefined {\n    return getDefaultFormState<T, S, F>(\n      this.validator,\n      schema,\n      formData,\n      this.rootSchema,\n      includeUndefinedValues,\n      this.experimental_defaultFormStateBehavior\n    );\n  }\n\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\n   * should be displayed in a UI.\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\n   * @returns - True if the label should be displayed or false if it should not\n   */\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\n  }\n\n  /** Determines which of the given `options` provided most closely matches the `formData`.\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\n   *\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\n   * matching readOnly, default, or const values.\n   *\n   * @param formData - The form data associated with the schema\n   * @param options - The list of options that can be selected from\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\n   */\n  getClosestMatchingOption(\n    formData: T | undefined,\n    options: S[],\n    selectedOption?: number,\n    discriminatorField?: string\n  ): number {\n    return getClosestMatchingOption<T, S, F>(\n      this.validator,\n      this.rootSchema,\n      formData,\n      options,\n      selectedOption,\n      discriminatorField\n    );\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\n   * Always returns the first option if there is nothing that matches.\n   *\n   * @param formData - The current formData, if any, used to figure out a match\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The firstindex of the matched option or 0 if none is available\n   */\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\n   * Deprecated, use `getFirstMatchingOption()` instead.\n   *\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\n   * @param options - The list of options to find a matching options from\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\n   *          determine which option is selected\n   * @returns - The index of the matched option or 0 if none is available\n   * @deprecated\n   */\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\n  }\n\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\n   *\n   * @param schema - The schema for which check for array of files flag is desired\n   * @param [uiSchema] - The UI schema from which to check the widget\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\n   */\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a multi-select\n   *\n   * @param schema - The schema for which check for a multi-select flag is desired\n   * @returns - True if schema contains a multi-select, otherwise false\n   */\n  isMultiSelect(schema: S) {\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Checks to see if the `schema` combination represents a select\n   *\n   * @param schema - The schema for which check for a select flag is desired\n   * @returns - True if schema contains a select, otherwise false\n   */\n  isSelect(schema: S) {\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\n  }\n\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\n   * then `validationData` is returned.\n   *\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\n   * @param [additionalErrorSchema] - The additional set of errors\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\n   *        removed in the next major release.\n   */\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\n  }\n\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\n   * recursive resolution.\n   *\n   * @param schema - The schema for which retrieving a schema is desired\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\n   */\n  retrieveSchema(schema: S, rawFormData?: T) {\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\n  }\n\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\n   * old schemas that are non-existent in the new schema are set to `undefined`.\n   *\n   * @param [newSchema] - The new schema for which the data is being sanitized\n   * @param [oldSchema] - The old schema from which the data originated\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\n   */\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\n  }\n\n  /** Generates an `IdSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [id] - The base id for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @param [idPrefix='root'] - The prefix to use for the id\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\n   * @returns - The `IdSchema` object for the `schema`\n   */\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\n  }\n\n  /** Generates an `PathSchema` object for the `schema`, recursively\n   *\n   * @param schema - The schema for which the display label flag is desired\n   * @param [name] - The base name for the schema\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\n   * @returns - The `PathSchema` object for the `schema`\n   */\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\n  }\n}\n\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\n *\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\n * @param rootSchema - The root schema that will be forwarded to all the APIs\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\n * @returns - An implementation of a `SchemaUtilsType` interface\n */\nexport default function createSchemaUtils<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  validator: ValidatorType<T, S, F>,\n  rootSchema: S,\n  experimental_defaultFormStateBehavior = {}\n): SchemaUtilsType<T, S, F> {\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\n}\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\n *\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\n * @returns - an object containing a Blob and its name, extracted from the URI\n */\nexport default function dataURItoBlob(dataURI: string) {\n  // Split metadata from data\n  const splitted: string[] = dataURI.split(',');\n  // Split params\n  const params: string[] = splitted[0].split(';');\n  // Get mime-type from params\n  const type: string = params[0].replace('data:', '');\n  // Filter the name property from params\n  const properties = params.filter((param) => {\n    return param.split('=')[0] === 'name';\n  });\n  // Look for the name and use unknown if no name property.\n  let name: string;\n  if (properties.length !== 1) {\n    name = 'unknown';\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here, which we decode to make it human-readable\n    name = decodeURI(properties[0].split('=')[1]);\n  }\n\n  // Built the Uint8Array Blob parameter from the base64 string.\n  try {\n    const binary = atob(splitted[1]);\n    const array = [];\n    for (let i = 0; i < binary.length; i++) {\n      array.push(binary.charCodeAt(i));\n    }\n    // Create the blob object\n    const blob = new window.Blob([new Uint8Array(array)], { type });\n\n    return { blob, name };\n  } catch (error) {\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\n  }\n}\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\n *\n * @param inputString - The string which will be potentially updated with replacement parameters\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The updated string with any replacement specifiers replaced\n */\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\n  let output = inputString;\n  if (Array.isArray(params)) {\n    const parts = output.split(/(%\\d)/);\n    params.forEach((param, index) => {\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\n      if (partIndex >= 0) {\n        parts[partIndex] = param;\n      }\n    });\n    output = parts.join('');\n  }\n  return output;\n}\n", "import { TranslatableString } from './enums';\nimport replaceStringParameters from './replaceStringParameters';\n\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\n * `%2`, etc. replacement specifiers.\n *\n * @param stringToTranslate - The `TranslatableString` value to convert to english\n * @param params - The optional list of replaceable parameter values to substitute into the english string\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\n */\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\n  return replaceStringParameters(stringToTranslate, params);\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\n\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\n * is returned, otherwise the `selected` value is returned.\n *\n * @param valueIndex - The index of the value to be removed from the selected list or single value\n * @param selected - The current (list of) selected value(s)\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\n *        undefined, otherwise `selected`.\n */\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (Array.isArray(selected)) {\n    return selected.filter((v) => !isEqual(v, value));\n  }\n  return isEqual(value, selected) ? undefined : selected;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\n * valid values or in the worst case, an empty array.\n *\n * @param valueIndex - The index(es) of the value(s) that should be returned\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\n *        `emptyValue` or an empty list.\n */\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number | Array<string | number>,\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  emptyValue?: EnumOptionsType<S>['value']\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\n  if (Array.isArray(valueIndex)) {\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\n  }\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\n  const option = allEnumOptions[index];\n  return option ? option.value : emptyValue;\n}\n", "import isEqual from 'lodash/isEqual';\n\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Determines whether the given `value` is (one of) the `selected` value(s).\n *\n * @param value - The value being checked to see if it is selected\n * @param selected - The current selected value or list of values\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\n */\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'],\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\n) {\n  if (Array.isArray(selected)) {\n    return selected.some((sel) => isEqual(sel, value));\n  }\n  return isEqual(selected, value);\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\n\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\n * returned.\n *\n * @param value - The single value or list of values for which indexes are desired\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\n *        of indexes for (each of) the value(s) in `value`.\n */\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = [],\n  multiple = false\n): string | string[] | undefined {\n  const selectedIndexes: string[] = allEnumOptions\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\n    .filter((opt) => typeof opt !== 'undefined') as string[];\n  if (!multiple) {\n    return selectedIndexes[0];\n  }\n  return selectedIndexes;\n}\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\nimport isNil from 'lodash/isNil';\n\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\n * `allEnumOptions`\n *\n * @param valueIndex - The index of the value that should be selected\n * @param selected - The current list of selected values\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\n */\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\n  valueIndex: string | number,\n  selected: EnumOptionsType<S>['value'][],\n  allEnumOptions: EnumOptionsType<S>[] = []\n) {\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\n  if (!isNil(value)) {\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\n    const all = allEnumOptions.map(({ value: val }) => val);\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\n    // As inserting values at predefined index positions doesn't work with empty\n    // arrays, we need to reorder the updated selection to match the initial order\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\n  }\n  return selected;\n}\n", "import cloneDeep from 'lodash/cloneDeep';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { ErrorSchema } from './types';\nimport { ERRORS_KEY } from './constants';\n\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\n * get the result and/or reset all the errors back to an initial set and start again.\n */\nexport default class ErrorSchemaBuilder<T = any> {\n  /** The error schema being built\n   *\n   * @private\n   */\n  private errorSchema: ErrorSchema<T> = {};\n\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   */\n  constructor(initialSchema?: ErrorSchema<T>) {\n    this.resetAllErrors(initialSchema);\n  }\n\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\n   */\n  get ErrorSchema() {\n    return this.errorSchema;\n  }\n\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The error block for the given `pathOfError` or the root if not provided\n   * @private\n   */\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\n    if (!errorBlock && pathOfError) {\n      errorBlock = {};\n      set(this.errorSchema, pathOfError, errorBlock);\n    }\n    return errorBlock;\n  }\n\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\n   *\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\n    return this;\n  }\n\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    let errorsList = get(errorBlock, ERRORS_KEY);\n    if (!Array.isArray(errorsList)) {\n      errorsList = [];\n      errorBlock[ERRORS_KEY] = errorsList;\n    }\n\n    if (Array.isArray(errorOrList)) {\n      errorsList.push(...errorOrList);\n    } else {\n      errorsList.push(errorOrList);\n    }\n    return this;\n  }\n\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\n    set(errorBlock, ERRORS_KEY, listToAdd);\n    return this;\n  }\n\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\n   * the `pathOfError`. For more information about how to specify the path see the\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\n   *\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\n   */\n  clearErrors(pathOfError?: string | string[]) {\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\n    set(errorBlock, ERRORS_KEY, []);\n    return this;\n  }\n}\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\nimport { RJSFSchema } from './types';\n\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\n *\n * @param schema - The schema from which to extract the range spec\n * @returns - A range specification from the schema\n */\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const spec: RangeSpecType = {};\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n  return spec;\n}\n", "import rangeSpec from './rangeSpec';\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\n\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\n *\n * @param schema - The schema for the field provided by the widget\n * @param [defaultType] - The default type, if any, for the field provided by the widget\n * @param [options={}] - The UI Options for the field provided by the widget\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\n * @returns - The extracted `InputPropsType` object\n */\nexport default function getInputProps<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(\n  schema: RJSFSchema,\n  defaultType?: string,\n  options: UIOptionsType<T, S, F> = {},\n  autoDefaultStepAny = true\n): InputPropsType {\n  const inputProps: InputPropsType = {\n    type: defaultType || 'text',\n    ...rangeSpec(schema),\n  };\n\n  // If options.inputType is set use that as the input type\n  if (options.inputType) {\n    inputProps.type = options.inputType;\n  } else if (!defaultType) {\n    // If the schema is of type number or integer, set the input type to number\n    if (schema.type === 'number') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\n      if (autoDefaultStepAny && inputProps.step === undefined) {\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\n        // allowed in number inputs\n        inputProps.step = 'any';\n      }\n    } else if (schema.type === 'integer') {\n      inputProps.type = 'number';\n      // Only add step if one isn't already defined\n      if (inputProps.step === undefined) {\n        // Since this is integer, you always want to step up or down in multiples of 1\n        inputProps.step = 1;\n      }\n    }\n  }\n\n  if (options.autocomplete) {\n    inputProps.autoComplete = options.autocomplete;\n  }\n\n  return inputProps;\n}\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\nimport getUiOptions from './getUiOptions';\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\n\n/** The default submit button options, exported for testing purposes\n */\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\n  props: {\n    disabled: false,\n  },\n  submitText: 'Submit',\n  norender: false,\n};\n\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\n *\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\n */\nexport default function getSubmitButtonOptions<\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\n    return { ...DEFAULT_OPTIONS, ...options };\n  }\n\n  return DEFAULT_OPTIONS;\n}\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\n\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\n *\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\n * @param registry - The `Registry` from which to read the template\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\n */\nexport default function getTemplate<\n  Name extends keyof TemplatesType<T, S, F>,\n  T = any,\n  S extends StrictRJSFSchema = RJSFSchema,\n  F extends FormContextType = any\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\n  const { templates } = registry;\n  if (name === 'ButtonTemplates') {\n    return templates[name];\n  }\n  return (\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\n  );\n}\n", "import { createElement } from 'react';\nimport ReactIs from 'react-is';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\nimport getSchemaType from './getSchemaType';\n\n/** The map of schema types to widget type to widget name\n */\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\n  boolean: {\n    checkbox: 'CheckboxWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    hidden: 'HiddenWidget',\n  },\n  string: {\n    text: 'TextWidget',\n    password: 'PasswordWidget',\n    email: 'EmailWidget',\n    hostname: 'TextWidget',\n    ipv4: 'TextWidget',\n    ipv6: 'TextWidget',\n    uri: 'URLWidget',\n    'data-url': 'FileWidget',\n    radio: 'RadioWidget',\n    select: 'SelectWidget',\n    textarea: 'TextareaWidget',\n    hidden: 'HiddenWidget',\n    date: 'DateWidget',\n    datetime: 'DateTimeWidget',\n    'date-time': 'DateTimeWidget',\n    'alt-date': 'AltDateWidget',\n    'alt-datetime': 'AltDateTimeWidget',\n    time: 'TimeWidget',\n    color: 'ColorWidget',\n    file: 'FileWidget',\n  },\n  number: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  integer: {\n    text: 'TextWidget',\n    select: 'SelectWidget',\n    updown: 'UpDownWidget',\n    range: 'RangeWidget',\n    radio: 'RadioWidget',\n    hidden: 'HiddenWidget',\n  },\n  array: {\n    select: 'SelectWidget',\n    checkboxes: 'CheckboxesWidget',\n    files: 'FileWidget',\n    hidden: 'HiddenWidget',\n  },\n};\n\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\n *\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\n * @returns - The wrapper widget\n */\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  AWidget: Widget<T, S, F>\n) {\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\n  // cache return value as property of widget for proper react reconciliation\n  if (!MergedWidget) {\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\n    MergedWidget = ({ options, ...props }) => {\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\n    };\n    set(AWidget, 'MergedWidget', MergedWidget);\n  }\n  return MergedWidget;\n}\n\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\n *\n * @param schema - The schema for the field\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - The `Widget` component to use\n * @throws - An error if there is no `Widget` component that can be returned\n */\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget?: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n): Widget<T, S, F> {\n  const type = getSchemaType(schema);\n\n  if (\n    typeof widget === 'function' ||\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\n    ReactIs.isMemo(widget)\n  ) {\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\n  }\n\n  if (typeof widget !== 'string') {\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\n  }\n\n  if (widget in registeredWidgets) {\n    const registeredWidget = registeredWidgets[widget];\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (typeof type === 'string') {\n    if (!(type in widgetMap)) {\n      throw new Error(`No widget for type '${type}'`);\n    }\n\n    if (widget in widgetMap[type]) {\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\n    }\n  }\n\n  throw new Error(`No widget '${widget}' for type '${type}'`);\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** JS has no built-in hashing function, so rolling our own\n *  based on Java's hashing fn:\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\n *\n * @param string - The string for which to get the hash\n * @returns - The resulting hash of the string in hex format\n */\nfunction hashString(string: string): string {\n  let hash = 0;\n  for (let i = 0; i < string.length; i += 1) {\n    const chr = string.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash.toString(16);\n}\n\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\n * in consistent order before stringify to prevent different hash ids for the same schema.\n *\n * @param schema - The schema for which the hash is desired\n * @returns - The string obtained from the hash of the stringified schema\n */\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  const allKeys = new Set<string>();\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\n}\n", "import getWidget from './getWidget';\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\n\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\n * does, or false if it doesn't.\n *\n * @param schema - The schema for the field\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\n * @returns - True if the widget exists, false otherwise\n */\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  schema: RJSFSchema,\n  widget: Widget<T, S, F> | string,\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\n) {\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    const err: Error = e as Error;\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\n      return false;\n    }\n    throw e;\n  }\n}\n", "import isString from 'lodash/isString';\n\nimport { IdSchema } from './types';\nimport { ID_KEY } from './constants';\n\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param suffix - The suffix to append to the id\n */\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\n  const theId = isString(id) ? id : id[ID_KEY];\n  return `${theId}__${suffix}`;\n}\n/** Return a consistent `id` for the field description element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field description element from the given `id`\n */\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'description');\n}\n\n/** Return a consistent `id` for the field error element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field error element from the given `id`\n */\nexport function errorId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'error');\n}\n\n/** Return a consistent `id` for the field examples element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field examples element from the given `id`\n */\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'examples');\n}\n\n/** Return a consistent `id` for the field help element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field help element from the given `id`\n */\nexport function helpId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'help');\n}\n\n/** Return a consistent `id` for the field title element\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @returns - The consistent id for the field title element from the given `id`\n */\nexport function titleId<T = any>(id: IdSchema<T> | string) {\n  return idGenerator<T>(id, 'title');\n}\n\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\n * element.\n *\n * @param id - Either simple string id or an IdSchema from which to extract it\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\n */\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\n}\n\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\n *\n * @param id - The id of the parent component for the option\n * @param optionIndex - The index of the option for which the id is desired\n * @returns - An id for the option index based on the parent `id`\n */\nexport function optionId(id: string, optionIndex: number) {\n  return `${id}-${optionIndex}`;\n}\n", "import { ReactElement } from 'react';\n\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\n * themes require may `false` and others may require an empty string.\n *\n * @param [label] - The label string or component to render when not hidden\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\n */\n\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: ''): undefined | string;\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: false): undefined | false | string;\nexport default function labelValue(label?: ReactElement, hideLabel?: boolean, fallback?: ''): undefined | ReactElement;\nexport default function labelValue(\n  label?: ReactElement,\n  hideLabel?: boolean,\n  fallback?: false\n): undefined | false | ReactElement;\nexport default function labelValue(\n  label?: string | ReactElement,\n  hideLabel?: boolean,\n  fallback?: false | ''\n): undefined | false | string | ReactElement {\n  return hideLabel ? fallback : label;\n}\n", "/** Converts a local Date string into a UTC date string\n *\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\n */\nexport default function localToUTC(dateString: string) {\n  return dateString ? new Date(dateString).toJSON() : undefined;\n}\n", "import { CONST_KEY, ENUM_KEY } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\n * throws an error.\n *\n * @param schema - The schema from which to obtain the constant value\n * @returns - The constant value for the schema\n * @throws - Error when the schema does not have a constant value\n */\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\n    return schema.enum[0];\n  }\n  if (CONST_KEY in schema) {\n    return schema.const;\n  }\n  throw new Error('schema cannot be inferred as a constant');\n}\n", "import toConstant from './toConstant';\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\n\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\n * `const` values from the schema and the label is either the `schema.title` or the value.\n *\n * @param schema - The schema from which to extract the options list\n * @returns - The list of options from the schema\n */\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\n  schema: S\n): EnumOptionsType<S>[] | undefined {\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\n  // Cast the type to include enumNames so the feature still works.\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\n  }\n  if (schema.enum) {\n    return schema.enum.map((value, i) => {\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\n      return { label, value };\n    });\n  }\n  const altSchemas = schema.oneOf || schema.anyOf;\n  return (\n    altSchemas &&\n    altSchemas.map((aSchemaDef) => {\n      const aSchema = aSchemaDef as S;\n      const value = toConstant(aSchema);\n      const label = aSchema.title || String(value);\n      return {\n        schema: aSchema,\n        label,\n        value,\n      };\n    })\n  );\n}\n", "import { GenericObjectType } from './types';\n\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\n * places in the location of the `*`.\n *\n * @param properties - The list of property keys to be ordered\n * @param order - An array of property keys to be ordered first, with an optional '*' property\n * @returns - A list with the `properties` ordered\n * @throws - Error when the properties cannot be ordered correctly\n */\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  const arrayToHash = (arr: string[]) =>\n    arr.reduce((prev: GenericObjectType, curr) => {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  const errorPropList = (arr: string[]) =>\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\n  const propertyHash = arrayToHash(properties);\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\n  const orderHash = arrayToHash(orderFiltered);\n\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\n  const restIndex = orderFiltered.indexOf('*');\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\n    }\n    return orderFiltered;\n  }\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\n    throw new Error('uiSchema order list contains more than one wildcard item');\n  }\n\n  const complete = [...orderFiltered];\n  complete.splice(restIndex, 1, ...rest);\n  return complete;\n}\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\n *\n * @param num - The number to pad\n * @param width - The width of the string at which no lead padding is necessary\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\n */\nexport default function pad(num: number, width: number) {\n  let s = String(num);\n  while (s.length < width) {\n    s = '0' + s;\n  }\n  return s;\n}\n", "import { DateObject } from './types';\n\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\n *\n * @param dateString - The date string to parse into a DateObject\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\n * @returns - The date string converted to a `DateObject`\n * @throws - Error when the date cannot be parsed from the string\n */\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0,\n    };\n  }\n  const date = new Date(dateString);\n  if (Number.isNaN(date.getTime())) {\n    throw new Error('Unable to parse date ' + dateString);\n  }\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1, // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0,\n  };\n}\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\n\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\n * - `schema.const` is truthy\n * - `schema.enum` == `[true]`\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\n * - `schema.allOf` has at least one value which recursively returns true\n *\n * @param schema - The schema to check\n * @returns - True if the schema specifies a value that must be true, false otherwise\n */\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\n  // Check if const is a truthy value\n  if (schema.const) {\n    return true;\n  }\n\n  // Check if an enum has a single value of true\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\n    return true;\n  }\n\n  // If anyOf has a single value, evaluate the subschema\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\n  }\n\n  // If oneOf has a single value, evaluate the subschema\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\n  }\n\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\n  if (schema.allOf) {\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\n    return schema.allOf.some(schemaSome);\n  }\n\n  return false;\n}\n", "import React from 'react';\n\nimport deepEquals from './deepEquals';\n\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\n *\n * @param component - A React component being checked\n * @param nextProps - The next set of props against which to check\n * @param nextState - The next set of state against which to check\n * @returns - True if the component should be re-rendered, false otherwise\n */\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\n  const { props, state } = component;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\n", "import { DateObject } from './types';\n\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\n * removed.\n *\n * @param dateObject - The `DateObject` to convert to a date string\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\n * @returns - The UTC date string\n */\nexport default function toDateString(dateObject: DateObject, time = true) {\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  const datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ERRORS_KEY } from './constants';\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\n\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n *\n * @param errorSchema - The `ErrorSchema` instance to convert\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\n */\nexport default function toErrorList<T = any>(\n  errorSchema?: ErrorSchema<T>,\n  fieldPath: string[] = []\n): RJSFValidationError[] {\n  if (!errorSchema) {\n    return [];\n  }\n  let errorList: RJSFValidationError[] = [];\n  if (ERRORS_KEY in errorSchema) {\n    errorList = errorList.concat(\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\n        const property = `.${fieldPath.join('.')}`;\n        return {\n          property,\n          message,\n          stack: `${property} ${message}`,\n        };\n      })\n    );\n  }\n  return Object.keys(errorSchema).reduce((acc, key) => {\n    if (key !== ERRORS_KEY) {\n      const childSchema = (errorSchema as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\n      }\n    }\n    return acc;\n  }, errorList);\n}\n", "import toPath from 'lodash/toPath';\n\nimport { ErrorSchema, RJSFValidationError } from './types';\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\n\n/** Transforms a rjsf validation errors list:\n * [\n *   {property: '.level1.level2[2].level3', message: 'err a'},\n *   {property: '.level1.level2[2].level3', message: 'err b'},\n *   {property: '.level1.level2[4].level3', message: 'err b'},\n * ]\n * Into an error tree:\n * {\n *   level1: {\n *     level2: {\n *       2: {level3: {errors: ['err a', 'err b']}},\n *       4: {level3: {errors: ['err b']}},\n *     }\n *   }\n * };\n *\n * @param errors - The list of RJSFValidationError objects\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\n */\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\n  const builder = new ErrorSchemaBuilder<T>();\n  if (errors.length) {\n    errors.forEach((error) => {\n      const { property, message } = error;\n      // When the property is the root element, just use an empty array for the path\n      const path = property === '.' ? [] : toPath(property);\n      // If the property is at the root (.level1) then toPath creates\n      // an empty array element at the first index. Remove it.\n      if (path.length > 0 && path[0] === '') {\n        path.splice(0, 1);\n      }\n      if (message) {\n        builder.addErrors(message, path);\n      }\n    });\n  }\n  return builder.ErrorSchema;\n}\n", "import isPlainObject from 'lodash/isPlainObject';\n\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\n\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\n *\n * @param errorHandler - The `FormValidation` error handling structure\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\n */\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\n  return Object.keys(errorHandler).reduce((acc, key) => {\n    if (key === 'addError') {\n      return acc;\n    } else {\n      const childSchema = (errorHandler as GenericObjectType)[key];\n      if (isPlainObject(childSchema)) {\n        return {\n          ...acc,\n          [key]: unwrapErrorHandler(childSchema),\n        };\n      }\n      return { ...acc, [key]: childSchema };\n    }\n  }, {} as ErrorSchema<T>);\n}\n", "import pad from './pad';\n\n/** Converts a UTC date string into a local Date format\n *\n * @param jsonDate - A UTC date string\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\n */\nexport default function utcToLocal(jsonDate: string) {\n  if (!jsonDate) {\n    return '';\n  }\n\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n  const date = new Date(jsonDate);\n\n  const yyyy = pad(date.getFullYear(), 4);\n  const MM = pad(date.getMonth() + 1, 2);\n  const dd = pad(date.getDate(), 2);\n  const hh = pad(date.getHours(), 2);\n  const mm = pad(date.getMinutes(), 2);\n  const ss = pad(date.getSeconds(), 2);\n  const SSS = pad(date.getMilliseconds(), 3);\n\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\n}\n", "import isEmpty from 'lodash/isEmpty';\n\nimport mergeObjects from './mergeObjects';\nimport toErrorList from './toErrorList';\nimport { ErrorSchema, ValidationData } from './types';\n\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\n * `validationData` is returned.\n *\n * @param validationData - The current `ValidationData` into which to merge the additional errors\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\n */\nexport default function validationDataMerge<T = any>(\n  validationData: ValidationData<T>,\n  additionalErrorSchema?: ErrorSchema<T>\n): ValidationData<T> {\n  if (!additionalErrorSchema) {\n    return validationData;\n  }\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\n  let errors = toErrorList(additionalErrorSchema);\n  let errorSchema = additionalErrorSchema;\n  if (!isEmpty(oldErrorSchema)) {\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\n    errors = [...oldErrors].concat(errors);\n  }\n  return { errorSchema, errors };\n}\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\nimport { RJSFSchema, StrictRJSFSchema } from './types';\nimport isObject from 'lodash/isObject';\n\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\n  for (const key in node) {\n    const realObj: { [k: string]: any } = node;\n    const value = realObj[key];\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\n    } else {\n      realObj[key] = withIdRefPrefix<S>(value);\n    }\n  }\n  return node;\n}\n\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n * `withIdRefPrefix` for any other elements.\n *\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n */\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\n  for (let i = 0; i < node.length; i++) {\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\n  }\n  return node;\n}\n\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\n * This is used in isValid to make references to the rootSchema\n *\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n * @returns - A copy of the `schemaNode` with updated `$ref`s\n */\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(\n  schemaNode: S | S[] | S[keyof S]\n): S | S[] | S[keyof S] {\n  if (Array.isArray(schemaNode)) {\n    return withIdRefPrefixArray<S>([...schemaNode]);\n  }\n  if (isObject(schemaNode)) {\n    return withIdRefPrefixObject<S>({ ...schemaNode });\n  }\n  return schemaNode;\n}\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\n * parameters is important because some languages may choose to put the second parameter before the first in its\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\n */\nexport enum TranslatableString {\n  /** Fallback title of an array item, used by ArrayField */\n  ArrayItemTitle = 'Item',\n  /** Missing items reason, used by ArrayField */\n  MissingItems = 'Missing items definition',\n  /** Yes label, used by BooleanField */\n  YesLabel = 'Yes',\n  /** No label, used by BooleanField */\n  NoLabel = 'No',\n  /** Close label, used by ErrorList */\n  CloseLabel = 'Close',\n  /** Errors label, used by ErrorList */\n  ErrorsLabel = 'Errors',\n  /** New additionalProperties string default value, used by ObjectField */\n  NewStringDefault = 'New Value',\n  /** Add button title, used by AddButton */\n  AddButton = 'Add',\n  /** Add button title, used by AddButton */\n  AddItemButton = 'Add Item',\n  /** Copy button title, used by IconButton */\n  CopyButton = 'Copy',\n  /** Move down button title, used by IconButton */\n  MoveDownButton = 'Move down',\n  /** Move up button title, used by IconButton */\n  MoveUpButton = 'Move up',\n  /** Remove button title, used by IconButton */\n  RemoveButton = 'Remove',\n  /** Now label, used by AltDateWidget */\n  NowLabel = 'Now',\n  /** Clear label, used by AltDateWidget */\n  ClearLabel = 'Clear',\n  /** Aria date label, used by DateWidget */\n  AriaDateLabel = 'Select a date',\n  /** File preview label, used by FileWidget */\n  PreviewLabel = 'Preview',\n  /** Decrement button aria label, used by UpDownWidget */\n  DecrementAriaLabel = 'Decrease value by 1',\n  /** Increment button aria label, used by UpDownWidget */\n  IncrementAriaLabel = 'Increase value by 1',\n  // Strings with replaceable parameters\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\n  UnknownFieldType = 'Unknown field type %1',\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\n  OptionPrefix = 'Option %1',\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\n   * MultiSchemaField\n   */\n  TitleOptionPrefix = '%1 option %2',\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\n  KeyLabel = '%1 Key',\n  // Strings with replaceable parameters AND/OR that support markdown and html\n  /** Invalid object field configuration as provided by the ObjectField */\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\n  /** Unsupported field schema, used by UnsupportedField */\n  UnsupportedField = 'Unsupported field schema.',\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\n   * as provided by UnsupportedField\n   */\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\n   * provided by FileWidget\n   */\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\n}\n", "import forEach from 'lodash/forEach';\nimport isEqual from 'lodash/isEqual';\n\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\nimport ParserValidator, { SchemaMap } from './ParserValidator';\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\n\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\n *\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\n * @param rootSchema - The root schema from which the schema parsing began\n * @param schema - The current schema element being parsed\n */\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  validator: ParserValidator<T, S, F>,\n  recurseList: S[],\n  rootSchema: S,\n  schema: S\n) {\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\n  schemas.forEach((schema) => {\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\n    if (sameSchemaIndex === -1) {\n      recurseList.push(schema);\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\n      allOptions.forEach((s) => {\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\n          forEach(schema[PROPERTIES_KEY], (value) => {\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\n          });\n        }\n      });\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\n      }\n    }\n  });\n}\n\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\n * the hash of the schema to schema/sub-schema.\n *\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\n * @returns - The `SchemaMap` of all schemas that were parsed\n */\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\n  rootSchema: S\n): SchemaMap<S> {\n  const validator = new ParserValidator<T, S, F>(rootSchema);\n  const recurseList: S[] = [];\n\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\n\n  return validator.getSchemaMap();\n}\n", "import get from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\n\nimport { ID_KEY } from '../constants';\nimport hashForSchema from '../hashForSchema';\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FormContextType,\n  RJSFSchema,\n  RJSFValidationError,\n  StrictRJSFSchema,\n  UiSchema,\n  ValidationData,\n  ValidatorType,\n} from '../types';\n\n/** The type of the map of schema hash to schema\n */\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\n  [hash: string]: S;\n};\n\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\n */\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\n  implements ValidatorType<T, S, F>\n{\n  /** The rootSchema provided during construction of the class */\n  readonly rootSchema: S;\n\n  /** The map of schemas encountered by the ParserValidator */\n  schemaMap: SchemaMap<S> = {};\n\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\n   * first.\n   *\n   * @param rootSchema - The root schema against which this validator will be executed\n   */\n  constructor(rootSchema: S) {\n    this.rootSchema = rootSchema;\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\n  }\n\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\n   * associated with it's `hash` for future use (by a schema compiler).\n   *\n   * @param schema - The schema which is to be added to the map\n   * @param hash - The hash value at which to map the schema\n   */\n  addSchema(schema: S, hash: string) {\n    const key = get(schema, ID_KEY, hash);\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\n    const existing = this.schemaMap[key];\n    if (!existing) {\n      this.schemaMap[key] = identifiedSchema;\n    } else if (!isEqual(existing, identifiedSchema)) {\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\n      throw new Error(\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\n      );\n    }\n  }\n\n  /** Returns the current `schemaMap` to the caller\n   */\n  getSchemaMap() {\n    return this.schemaMap;\n  }\n\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\n   * the `rootSchema` is not the same as the root schema provided during construction.\n   *\n   * @param schema - The schema to record in the `schemaMap`\n   * @param _formData - The formData parameter that is ignored\n   * @param rootSchema - The root schema associated with the schema\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\n   */\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\n    if (!isEqual(rootSchema, this.rootSchema)) {\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\n    }\n    this.addSchema(schema, hashForSchema<S>(schema));\n\n    return false;\n  }\n\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\n   *\n   * @param _schema - The schema parameter that is ignored\n   * @param _formData - The formData parameter that is ignored\n   */\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\n   *\n   * @param _errorSchema - The error schema parameter that is ignored\n   * @param _fieldPath - The field path parameter that is ignored\n   */\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\n  }\n\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\n   * called\n   *\n   * @param _formData - The formData parameter that is ignored\n   * @param _schema - The schema parameter that is ignored\n   * @param _customValidate - The customValidate parameter that is ignored\n   * @param _transformErrors - The transformErrors parameter that is ignored\n   * @param _uiSchema - The uiSchema parameter that is ignored\n   */\n  validateFormData(\n    _formData: T,\n    _schema: S,\n    _customValidate?: CustomValidator<T, S, F>,\n    _transformErrors?: ErrorTransformer<T, S, F>,\n    _uiSchema?: UiSchema<T, S, F>\n  ): ValidationData<T> {\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\n  }\n}\n"],
-  "mappings": "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",
+  "sourcesContent": ["/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has\r\n * the type `object` but is NOT null, an array or a File.\r\n *\r\n * @param thing - The thing to check to see whether it is an object\r\n * @returns - True if it is a non-null, non-array, non-File object\r\n */\r\nexport default function isObject(thing: any) {\r\n  if (typeof File !== 'undefined' && thing instanceof File) {\r\n    return false;\r\n  }\r\n  if (typeof Date !== 'undefined' && thing instanceof Date) {\r\n    return false;\r\n  }\r\n  return typeof thing === 'object' && thing !== null && !Array.isArray(thing);\r\n}\r\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an\r\n * object. The user is warned in the console if `schema.additionalItems` has the value `true`.\r\n *\r\n * @param schema - The schema object to check\r\n * @returns - True if additional items is allowed, otherwise false\r\n */\r\nexport default function allowAdditionalItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (schema.additionalItems === true) {\r\n    console.warn('additionalItems=true is currently not supported');\r\n  }\r\n  return isObject(schema.additionalItems);\r\n}\r\n", "/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a\r\n * `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be\r\n * in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned\r\n * because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by\r\n * `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.\r\n *\r\n * @param value - The string or null value to convert to a number\r\n * @returns - The `value` converted to a number when appropriate, otherwise the `value`\r\n */\r\nexport default function asNumber(value: string | null) {\r\n  if (value === '') {\r\n    return undefined;\r\n  }\r\n  if (value === null) {\r\n    return null;\r\n  }\r\n  if (/\\.$/.test(value)) {\r\n    // '3.' can't really be considered a number even if it parses in js. The\r\n    // user is most likely entering a float.\r\n    return value;\r\n  }\r\n  if (/\\.0$/.test(value)) {\r\n    // we need to return this as a string here, to allow for input like 3.07\r\n    return value;\r\n  }\r\n\r\n  if (/\\.\\d*0$/.test(value)) {\r\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\r\n    // with the user when entering dollar amounts or other values (such as those with\r\n    // specific precision or number of significant digits)\r\n    return value;\r\n  }\r\n\r\n  const n = Number(value);\r\n  const valid = typeof n === 'number' && !Number.isNaN(n);\r\n\r\n  return valid ? n : value;\r\n}\r\n", "/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various\r\n * utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and\r\n * `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`\r\n * utility.\r\n */\r\nexport const ADDITIONAL_PROPERTY_FLAG = '__additional_property';\r\nexport const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';\r\nexport const ALL_OF_KEY = 'allOf';\r\nexport const ANY_OF_KEY = 'anyOf';\r\nexport const CONST_KEY = 'const';\r\nexport const DEFAULT_KEY = 'default';\r\nexport const DEFINITIONS_KEY = 'definitions';\r\nexport const DEPENDENCIES_KEY = 'dependencies';\r\nexport const ENUM_KEY = 'enum';\r\nexport const ERRORS_KEY = '__errors';\r\nexport const ID_KEY = '$id';\r\nexport const IF_KEY = 'if';\r\nexport const ITEMS_KEY = 'items';\r\nexport const JUNK_OPTION_ID = '_$junk_option_schema_id$_';\r\nexport const NAME_KEY = '$name';\r\nexport const ONE_OF_KEY = 'oneOf';\r\nexport const PROPERTIES_KEY = 'properties';\r\nexport const REQUIRED_KEY = 'required';\r\nexport const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';\r\nexport const REF_KEY = '$ref';\r\nexport const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';\r\nexport const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';\r\nexport const UI_FIELD_KEY = 'ui:field';\r\nexport const UI_WIDGET_KEY = 'ui:widget';\r\nexport const UI_OPTIONS_KEY = 'ui:options';\r\nexport const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';\r\n", "import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';\r\nimport isObject from './isObject';\r\nimport { FormContextType, GlobalUISchemaOptions, RJSFSchema, StrictRJSFSchema, UIOptionsType, UiSchema } from './types';\r\n\r\n/** Get all passed options from ui:options, and ui:<optionName>, returning them in an object with the `ui:`\r\n * stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.\r\n *\r\n * @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`\r\n */\r\nexport default function getUiOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  globalOptions: GlobalUISchemaOptions = {}\r\n): UIOptionsType<T, S, F> {\r\n  return Object.keys(uiSchema)\r\n    .filter((key) => key.indexOf('ui:') === 0)\r\n    .reduce(\r\n      (options, key) => {\r\n        const value = uiSchema[key];\r\n        if (key === UI_WIDGET_KEY && isObject(value)) {\r\n          console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');\r\n          return options;\r\n        }\r\n        if (key === UI_OPTIONS_KEY && isObject(value)) {\r\n          return { ...options, ...value };\r\n        }\r\n        return { ...options, [key.substring(3)]: value };\r\n      },\r\n      { ...globalOptions }\r\n    );\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\nimport getUiOptions from './getUiOptions';\r\n\r\n/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for\r\n * the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the\r\n * `formData` object doesn't already have `schema.maxProperties` elements.\r\n *\r\n * @param schema - The schema for the field that is being checked\r\n * @param [uiSchema={}] - The uiSchema for the field\r\n * @param [formData] - The formData for the field\r\n * @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit\r\n */\r\nexport default function canExpand<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  formData?: T\r\n) {\r\n  if (!schema.additionalProperties) {\r\n    return false;\r\n  }\r\n  const { expandable = true } = getUiOptions<T, S, F>(uiSchema);\r\n  if (expandable === false) {\r\n    return expandable;\r\n  }\r\n  // if ui:options.expandable was not explicitly set to false, we can add\r\n  // another property if we have not exceeded maxProperties yet\r\n  if (schema.maxProperties !== undefined && formData) {\r\n    return Object.keys(formData).length < schema.maxProperties;\r\n  }\r\n  return true;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { FieldValidation, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\r\n *\r\n * @param formData - The form data around which the error handler is created\r\n * @returns - A `FormValidation` object based on the `formData` structure\r\n */\r\nexport default function createErrorHandler<T = any>(formData: T): FormValidation<T> {\r\n  const handler: FieldValidation = {\r\n    // We store the list of errors for this node in a property named __errors\r\n    // to avoid name collision with a possible sub schema field named\r\n    // 'errors' (see `utils.toErrorSchema`).\r\n    [ERRORS_KEY]: [],\r\n    addError(message: string) {\r\n      this[ERRORS_KEY]!.push(message);\r\n    },\r\n  };\r\n  if (Array.isArray(formData)) {\r\n    return formData.reduce((acc, value, key) => {\r\n      return { ...acc, [key]: createErrorHandler(value) };\r\n    }, handler);\r\n  }\r\n  if (isPlainObject(formData)) {\r\n    const formObject: GenericObjectType = formData as GenericObjectType;\r\n    return Object.keys(formObject).reduce((acc, key) => {\r\n      return { ...acc, [key]: createErrorHandler(formObject[key]) };\r\n    }, handler as FormValidation<T>);\r\n  }\r\n  return handler as FormValidation<T>;\r\n}\r\n", "import isEqualWith from 'lodash/isEqualWith';\r\n\r\n/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that\r\n * assumes all functions are equivalent.\r\n *\r\n * @param a - The first element to compare\r\n * @param b - The second element to compare\r\n * @returns - True if the `a` and `b` are deeply equal, false otherwise\r\n */\r\nexport default function deepEquals(a: any, b: any): boolean {\r\n  return isEqualWith(a, b, (obj: any, other: any) => {\r\n    if (typeof obj === 'function' && typeof other === 'function') {\r\n      // Assume all functions are equivalent\r\n      // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\r\n      return true;\r\n    }\r\n    return undefined; // fallback to default isEquals behavior\r\n  });\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEmpty from 'lodash/isEmpty';\r\n\r\nimport {\r\n  ANY_OF_KEY,\r\n  DEFAULT_KEY,\r\n  DEPENDENCIES_KEY,\r\n  PROPERTIES_KEY,\r\n  ONE_OF_KEY,\r\n  REF_KEY,\r\n  ALL_OF_KEY,\r\n} from '../constants';\r\nimport findSchemaDefinition from '../findSchemaDefinition';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport getSchemaType from '../getSchemaType';\r\nimport isObject from '../isObject';\r\nimport isFixedItems from '../isFixedItems';\r\nimport mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';\r\nimport mergeObjects from '../mergeObjects';\r\nimport mergeSchemas from '../mergeSchemas';\r\nimport {\r\n  Experimental_ArrayMinItems,\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GenericObjectType,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isMultiSelect from './isMultiSelect';\r\nimport retrieveSchema, { resolveDependencies } from './retrieveSchema';\r\n\r\n/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.\r\n */\r\nexport enum AdditionalItemsHandling {\r\n  Ignore,\r\n  Invert,\r\n  Fallback,\r\n}\r\n\r\ndeclare module 'json-schema' {\r\n  export interface JSONSchema7 {\r\n    overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;\r\n  }\r\n}\r\n\r\n/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the\r\n * `additionalItems` enum and the value of `idx`. There are four possible returns:\r\n * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid\r\n *    index and not a boolean, otherwise it falls through to 3.\r\n * 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually\r\n *    is a schema, otherwise it falls through to 3.\r\n * 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then\r\n *    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.\r\n * 4. {} is returned representing an empty schema\r\n *\r\n * @param schema - The schema from which to get the particular item\r\n * @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?\r\n * @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array\r\n * @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers\r\n */\r\nexport function getInnerSchemaForArrayItem<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  additionalItems: AdditionalItemsHandling = AdditionalItemsHandling.Ignore,\r\n  idx = -1\r\n): S {\r\n  if (idx >= 0) {\r\n    if (Array.isArray(schema.items) && idx < schema.items.length) {\r\n      const item = schema.items[idx];\r\n      if (typeof item !== 'boolean') {\r\n        return item as S;\r\n      }\r\n    }\r\n  } else if (schema.items && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\r\n    return schema.items as S;\r\n  }\r\n  if (additionalItems !== AdditionalItemsHandling.Ignore && isObject(schema.additionalItems)) {\r\n    return schema.additionalItems as S;\r\n  }\r\n  return {} as S;\r\n}\r\n\r\n/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of\r\n * `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined\r\n * `computedDefault` values are added only when `includeUndefinedValues` is either true/\"excludeObjectChildren\". If `\r\n * includeUndefinedValues` is false and `emptyObjectFields` is not \"skipDefaults\", then non-undefined and non-empty-object\r\n * values will be added based on certain conditions.\r\n *\r\n * @param obj - The object into which the computed default may be added\r\n * @param key - The key into the object at which the computed default may be added\r\n * @param computedDefault - The computed default value that maybe should be added to the obj\r\n * @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties. If \"allowEmptyObject\", prevents undefined\r\n *          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param isParentRequired - The optional boolean that indicates whether the parent field is required\r\n * @param requiredFields - The list of fields that are required\r\n * @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override\r\n *        default form state behavior\r\n */\r\nfunction maybeAddDefaultToObject<T = any>(\r\n  obj: GenericObjectType,\r\n  key: string,\r\n  computedDefault: T | T[] | undefined,\r\n  includeUndefinedValues: boolean | 'excludeObjectChildren',\r\n  isParentRequired?: boolean,\r\n  requiredFields: string[] = [],\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior = {}\r\n) {\r\n  const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;\r\n  if (includeUndefinedValues) {\r\n    obj[key] = computedDefault;\r\n  } else if (emptyObjectFields !== 'skipDefaults') {\r\n    if (isObject(computedDefault)) {\r\n      // If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of\r\n      // the field key itself in the `requiredField` list\r\n      const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;\r\n      // Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions\r\n      // Condition 1: If computedDefault is not empty or if the key is a required field\r\n      // Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'\r\n      if (\r\n        (!isEmpty(computedDefault) || requiredFields.includes(key)) &&\r\n        (isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')\r\n      ) {\r\n        obj[key] = computedDefault;\r\n      }\r\n    } else if (\r\n      // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions\r\n      // Condition 1: computedDefault is not undefined\r\n      // Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field\r\n      computedDefault !== undefined &&\r\n      (emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))\r\n    ) {\r\n      obj[key] = computedDefault;\r\n    }\r\n  }\r\n}\r\n\r\ninterface ComputeDefaultsProps<T = any, S extends StrictRJSFSchema = RJSFSchema> {\r\n  parentDefaults?: T;\r\n  rootSchema?: S;\r\n  rawFormData?: T;\r\n  includeUndefinedValues?: boolean | 'excludeObjectChildren';\r\n  _recurseList?: string[];\r\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior;\r\n  required?: boolean;\r\n}\r\n\r\n/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into\r\n * each level of the schema, recursively, to fill out every level of defaults provided by the schema.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rawSchema - The schema for which the default state is desired\r\n * @param [props] - Optional props for this function\r\n * @param [props.parentDefaults] - Any defaults provided by the parent field in the schema\r\n * @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s\r\n * @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion\r\n * @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\r\nexport function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rawSchema: S,\r\n  {\r\n    parentDefaults,\r\n    rawFormData,\r\n    rootSchema = {} as S,\r\n    includeUndefinedValues = false,\r\n    _recurseList = [],\r\n    experimental_defaultFormStateBehavior = undefined,\r\n    required,\r\n  }: ComputeDefaultsProps<T, S> = {}\r\n): T | T[] | undefined {\r\n  const formData: T = (isObject(rawFormData) ? rawFormData : {}) as T;\r\n  const schema: S = isObject(rawSchema) ? rawSchema : ({} as S);\r\n  // Compute the defaults recursively: give highest priority to deepest nodes.\r\n  let defaults: T | T[] | undefined = parentDefaults;\r\n  // If we get a new schema, then we need to recompute defaults again for the new schema found.\r\n  let schemaToCompute: S | null = null;\r\n  let updatedRecurseList = _recurseList;\r\n\r\n  if (isObject(defaults) && isObject(schema.default)) {\r\n    // For object defaults, only override parent defaults that are defined in\r\n    // schema.default.\r\n    defaults = mergeObjects(defaults!, schema.default as GenericObjectType) as T;\r\n  } else if (DEFAULT_KEY in schema) {\r\n    defaults = schema.default as unknown as T;\r\n  } else if (REF_KEY in schema) {\r\n    const refName = schema[REF_KEY];\r\n    // Use referenced schema defaults for this node.\r\n    if (!_recurseList.includes(refName!)) {\r\n      updatedRecurseList = _recurseList.concat(refName!);\r\n      schemaToCompute = findSchemaDefinition<S>(refName, rootSchema);\r\n    }\r\n  } else if (DEPENDENCIES_KEY in schema) {\r\n    const resolvedSchema = resolveDependencies<T, S, F>(validator, schema, rootSchema, false, [], formData);\r\n    schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies\r\n  } else if (isFixedItems(schema)) {\r\n    defaults = (schema.items! as S[]).map((itemSchema: S, idx: number) =>\r\n      computeDefaults<T, S>(validator, itemSchema, {\r\n        rootSchema,\r\n        includeUndefinedValues,\r\n        _recurseList,\r\n        experimental_defaultFormStateBehavior,\r\n        parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,\r\n        rawFormData: formData as T,\r\n        required,\r\n      })\r\n    ) as T[];\r\n  } else if (ONE_OF_KEY in schema) {\r\n    const { oneOf, ...remaining } = schema;\r\n    if (oneOf!.length === 0) {\r\n      return undefined;\r\n    }\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    schemaToCompute = oneOf![\r\n      getClosestMatchingOption<T, S, F>(\r\n        validator,\r\n        rootSchema,\r\n        isEmpty(formData) ? undefined : formData,\r\n        oneOf as S[],\r\n        0,\r\n        discriminator\r\n      )\r\n    ] as S;\r\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\r\n  } else if (ANY_OF_KEY in schema) {\r\n    const { anyOf, ...remaining } = schema;\r\n    if (anyOf!.length === 0) {\r\n      return undefined;\r\n    }\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    schemaToCompute = anyOf![\r\n      getClosestMatchingOption<T, S, F>(\r\n        validator,\r\n        rootSchema,\r\n        isEmpty(formData) ? undefined : formData,\r\n        anyOf as S[],\r\n        0,\r\n        discriminator\r\n      )\r\n    ] as S;\r\n    schemaToCompute = mergeSchemas(remaining, schemaToCompute) as S;\r\n  }\r\n\r\n  if (schemaToCompute) {\r\n    return computeDefaults<T, S, F>(validator, schemaToCompute, {\r\n      rootSchema,\r\n      includeUndefinedValues,\r\n      _recurseList: updatedRecurseList,\r\n      experimental_defaultFormStateBehavior,\r\n      parentDefaults: defaults as T | undefined,\r\n      rawFormData: formData as T,\r\n      required,\r\n    });\r\n  }\r\n\r\n  // No defaults defined for this node, fallback to generic typed ones.\r\n  if (defaults === undefined) {\r\n    defaults = schema.default as unknown as T;\r\n  }\r\n\r\n  switch (getSchemaType<S>(schema)) {\r\n    // We need to recurse for object schema inner default values.\r\n    case 'object': {\r\n      // This is a custom addition that fixes this issue:\r\n      // https://github.com/rjsf-team/react-jsonschema-form/issues/3832\r\n      const retrievedSchema =\r\n        experimental_defaultFormStateBehavior?.allOf === 'populateDefaults' && ALL_OF_KEY in schema\r\n          ? retrieveSchema<T, S, F>(validator, schema, rootSchema, formData)\r\n          : schema;\r\n      const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce(\r\n        (acc: GenericObjectType, key: string) => {\r\n          // Compute the defaults for this node, with the parent defaults we might\r\n          // have from a previous run: defaults[key].\r\n          const computedDefault = computeDefaults<T, S, F>(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            includeUndefinedValues: includeUndefinedValues === true,\r\n            parentDefaults: get(defaults, [key]),\r\n            rawFormData: get(formData, [key]),\r\n            required: retrievedSchema.required?.includes(key),\r\n          });\r\n          maybeAddDefaultToObject<T>(\r\n            acc,\r\n            key,\r\n            computedDefault,\r\n            includeUndefinedValues,\r\n            required,\r\n            retrievedSchema.required,\r\n            experimental_defaultFormStateBehavior\r\n          );\r\n          return acc;\r\n        },\r\n        {}\r\n      ) as T;\r\n      if (retrievedSchema.additionalProperties) {\r\n        // as per spec additionalProperties may be either schema or boolean\r\n        const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)\r\n          ? retrievedSchema.additionalProperties\r\n          : {};\r\n\r\n        const keys = new Set<string>();\r\n        if (isObject(defaults)) {\r\n          Object.keys(defaults as GenericObjectType)\r\n            .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\r\n            .forEach((key) => keys.add(key));\r\n        }\r\n        const formDataRequired: string[] = [];\r\n        Object.keys(formData as GenericObjectType)\r\n          .filter((key) => !retrievedSchema.properties || !retrievedSchema.properties[key])\r\n          .forEach((key) => {\r\n            keys.add(key);\r\n            formDataRequired.push(key);\r\n          });\r\n        keys.forEach((key) => {\r\n          const computedDefault = computeDefaults(validator, additionalPropertiesSchema as S, {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            includeUndefinedValues: includeUndefinedValues === true,\r\n            parentDefaults: get(defaults, [key]),\r\n            rawFormData: get(formData, [key]),\r\n            required: retrievedSchema.required?.includes(key),\r\n          });\r\n          // Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop\r\n          maybeAddDefaultToObject<T>(\r\n            objectDefaults as GenericObjectType,\r\n            key,\r\n            computedDefault,\r\n            includeUndefinedValues,\r\n            required,\r\n            formDataRequired\r\n          );\r\n        });\r\n      }\r\n      return objectDefaults;\r\n    }\r\n    case 'array': {\r\n      // On a case by case basis, we may want to override the default behavior of populating array items.\r\n      const arrayMinItems =\r\n          schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\r\n      const neverPopulate = arrayMinItems?.populate === 'never';\r\n      const ignoreMinItemsFlagSet = arrayMinItems?.populate === 'requiredOnly';\r\n\r\n      // Inject defaults into existing array defaults\r\n      if (Array.isArray(defaults)) {\r\n        defaults = defaults.map((item, idx) => {\r\n          const schemaItem: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Fallback, idx);\r\n          return computeDefaults<T, S, F>(validator, schemaItem, {\r\n            rootSchema,\r\n            _recurseList,\r\n            experimental_defaultFormStateBehavior,\r\n            parentDefaults: item,\r\n            required,\r\n          });\r\n        }) as T[];\r\n      }\r\n\r\n      // Deeply inject defaults into already existing form data\r\n      if (Array.isArray(rawFormData)) {\r\n        const schemaItem: S = getInnerSchemaForArrayItem<S>(schema);\r\n        if (neverPopulate) {\r\n          defaults = rawFormData;\r\n        } else {\r\n          defaults = rawFormData.map((item: T, idx: number) => {\r\n            return computeDefaults<T, S, F>(validator, schemaItem, {\r\n              rootSchema,\r\n              _recurseList,\r\n              experimental_defaultFormStateBehavior,\r\n              rawFormData: item,\r\n              parentDefaults: get(defaults, [idx]),\r\n              required,\r\n            });\r\n          }) as T[];\r\n        }\r\n      }\r\n\r\n      if (neverPopulate) {\r\n        return defaults ?? [];\r\n      }\r\n      if (ignoreMinItemsFlagSet && !required) {\r\n        // If no form data exists or defaults are set leave the field empty/non-existent, otherwise\r\n        // return form data/defaults\r\n        return defaults ? defaults : undefined;\r\n      }\r\n\r\n      const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;\r\n      if (\r\n        !schema.minItems ||\r\n        isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n        schema.minItems <= defaultsLength\r\n      ) {\r\n        return defaults ? defaults : [];\r\n      }\r\n\r\n      const defaultEntries: T[] = (defaults || []) as T[];\r\n      const fillerSchema: S = getInnerSchemaForArrayItem<S>(schema, AdditionalItemsHandling.Invert);\r\n      const fillerDefault = fillerSchema.default;\r\n\r\n      // Calculate filler entries for remaining items (minItems - existing raw data/defaults)\r\n      const fillerEntries: T[] = new Array(schema.minItems - defaultsLength).fill(\r\n        computeDefaults<any, S, F>(validator, fillerSchema, {\r\n          parentDefaults: fillerDefault,\r\n          rootSchema,\r\n          _recurseList,\r\n          experimental_defaultFormStateBehavior,\r\n          required,\r\n        })\r\n      ) as T[];\r\n      // then fill up the rest with either the item default or empty, up to minItems\r\n      return defaultEntries.concat(fillerEntries);\r\n    }\r\n  }\r\n\r\n  return defaults;\r\n}\r\n\r\n/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n * computed to have defaults provided in the `schema`.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which the default state is desired\r\n * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n *          If \"excludeObjectChildren\", cause undefined values for this object and pass `includeUndefinedValues` as\r\n *          false when computing defaults for any nested object properties.\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - The resulting `formData` with all the defaults provided\r\n */\r\nexport default function getDefaultFormState<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  formData?: T,\r\n  rootSchema?: S,\r\n  includeUndefinedValues: boolean | 'excludeObjectChildren' = false,\r\n  experimental_defaultFormStateBehavior?: Experimental_DefaultFormStateBehavior\r\n) {\r\n  if (!isObject(theSchema)) {\r\n    throw new Error('Invalid schema: ' + theSchema);\r\n  }\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, formData);\r\n  const defaults = computeDefaults<T, S, F>(validator, schema, {\r\n    rootSchema,\r\n    includeUndefinedValues,\r\n    experimental_defaultFormStateBehavior,\r\n    rawFormData: formData,\r\n  });\r\n  if (formData === undefined || formData === null || (typeof formData === 'number' && isNaN(formData))) {\r\n    // No form data? Use schema defaults.\r\n    return defaults;\r\n  }\r\n  // On a case by case basis, we may want to override the default behavior of populating array items.\r\n  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;\r\n\r\n  const { mergeExtraDefaults } = arrayMinItems || {};\r\n  if (isObject(formData)) {\r\n    return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);\r\n  }\r\n  if (Array.isArray(formData)) {\r\n    return mergeDefaultsWithFormData<T[]>(defaults as T[], formData, mergeExtraDefaults);\r\n  }\r\n  return formData;\r\n}\r\n", "import jsonpointer from 'jsonpointer';\r\nimport omit from 'lodash/omit';\r\n\r\nimport { REF_KEY } from './constants';\r\nimport { GenericObjectType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first\r\n * location, the `object` minus the `key: value` and in the second location the `value`.\r\n *\r\n * @param key - The key from the object to extract\r\n * @param object - The object from which to extract the element\r\n * @returns - An array with the first value being the object minus the `key` element and the second element being the\r\n *      value from `object[key]`\r\n */\r\nexport function splitKeyElementFromObject(key: string, object: GenericObjectType) {\r\n  const value = object[key];\r\n  const remaining = omit(object, [key]);\r\n  return [remaining, value];\r\n}\r\n\r\n/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the\r\n * path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in\r\n * the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.\r\n *\r\n * @param $ref - The ref string for which the schema definition is desired\r\n * @param [rootSchema={}] - The root schema in which to search for the definition\r\n * @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists\r\n * @throws - Error indicating that no schema for that reference exists\r\n */\r\nexport default function findSchemaDefinition<S extends StrictRJSFSchema = RJSFSchema>(\r\n  $ref?: string,\r\n  rootSchema: S = {} as S\r\n): S {\r\n  let ref = $ref || '';\r\n  if (ref.startsWith('#')) {\r\n    // Decode URI fragment representation.\r\n    ref = decodeURIComponent(ref.substring(1));\r\n  } else {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  const current: S = jsonpointer.get(rootSchema, ref);\r\n  if (current === undefined) {\r\n    throw new Error(`Could not find a definition for ${$ref}.`);\r\n  }\r\n  if (current[REF_KEY]) {\r\n    const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);\r\n    const subSchema = findSchemaDefinition<S>(theRef, rootSchema);\r\n    if (Object.keys(remaining).length > 0) {\r\n      return { ...remaining, ...subSchema };\r\n    }\r\n    return subSchema;\r\n  }\r\n  return current;\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\nimport isNumber from 'lodash/isNumber';\r\nimport isObject from 'lodash/isObject';\r\nimport isString from 'lodash/isString';\r\nimport reduce from 'lodash/reduce';\r\nimport times from 'lodash/times';\r\n\r\nimport getFirstMatchingOption from './getFirstMatchingOption';\r\nimport retrieveSchema, { resolveAllReferences } from './retrieveSchema';\r\nimport { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';\r\nimport guessType from '../guessType';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\r\n\r\n/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning\r\n * the first item\r\n */\r\nexport const JUNK_OPTION: StrictRJSFSchema = {\r\n  type: 'object',\r\n  $id: JUNK_OPTION_ID,\r\n  properties: {\r\n    __not_really_there__: {\r\n      type: 'number',\r\n    },\r\n  },\r\n};\r\n\r\n/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly\r\n * simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within\r\n * the object are processed as follows after obtaining the formValue from `formData` using the `key`:\r\n * - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new\r\n *   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to\r\n *   the total.\r\n * - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling\r\n *   `getClosestMatchingOption()` of that oneOf.\r\n * - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the\r\n *   `value` itself as the sub-schema, and the score is added to the total.\r\n * - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the\r\n *   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score\r\n *   is incremented by another 1 otherwise it is decremented by 1.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param schema - The schema for which the score is being calculated\r\n * @param formData - The form data associated with the schema, used to calculate the score\r\n * @returns - The score a schema against the formData\r\n */\r\nexport function calculateIndexScore<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  schema?: S,\r\n  formData: any = {}\r\n): number {\r\n  let totalScore = 0;\r\n  if (schema) {\r\n    if (isObject(schema.properties)) {\r\n      totalScore += reduce(\r\n        schema.properties,\r\n        (score, value, key) => {\r\n          const formValue = get(formData, key);\r\n          if (typeof value === 'boolean') {\r\n            return score;\r\n          }\r\n          if (has(value, REF_KEY)) {\r\n            const newSchema = retrieveSchema<T, S, F>(validator, value as S, rootSchema, formValue);\r\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, newSchema, formValue || {});\r\n          }\r\n          if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) && formValue) {\r\n            const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;\r\n            const discriminator = getDiscriminatorFieldFromSchema<S>(value as S);\r\n            return (\r\n              score +\r\n              getClosestMatchingOption<T, S, F>(\r\n                validator,\r\n                rootSchema,\r\n                formValue,\r\n                get(value, key) as S[],\r\n                -1,\r\n                discriminator\r\n              )\r\n            );\r\n          }\r\n          if (value.type === 'object') {\r\n            return score + calculateIndexScore<T, S, F>(validator, rootSchema, value as S, formValue || {});\r\n          }\r\n          if (value.type === guessType(formValue)) {\r\n            // If the types match, then we bump the score by one\r\n            let newScore = score + 1;\r\n            if (value.default) {\r\n              // If the schema contains a readonly default value score the value that matches the default higher and\r\n              // any non-matching value lower\r\n              newScore += formValue === value.default ? 1 : -1;\r\n            } else if (value.const) {\r\n              // If the schema contains a const value score the value that matches the default higher and\r\n              // any non-matching value lower\r\n              newScore += formValue === value.const ? 1 : -1;\r\n            }\r\n            // TODO eventually, deal with enums/arrays\r\n            return newScore;\r\n          }\r\n          return score;\r\n        },\r\n        0\r\n      );\r\n    } else if (isString(schema.type) && schema.type === guessType(formData)) {\r\n      totalScore += 1;\r\n    }\r\n  }\r\n  return totalScore;\r\n}\r\n\r\n/** Determines which of the given `options` provided most closely matches the `formData`. Using\r\n * `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field\r\n * based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to\r\n * this utility, instead an array of valid option indexes is created by iterating over the list of options, call\r\n * `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered\r\n * matched.\r\n *\r\n * Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are\r\n * no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the\r\n * option with the highest score is determined by iterating over the list of valid options, calling\r\n * `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that\r\n * eventually has the best score.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param formData - The form data associated with the schema\r\n * @param options - The list of options that can be selected from\r\n * @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n */\r\nexport default function getClosestMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  selectedOption = -1,\r\n  discriminatorField?: string\r\n): number {\r\n  // First resolve any refs in the options\r\n  const resolvedOptions = options.map((option) => {\r\n    return resolveAllReferences<S>(option, rootSchema, []);\r\n  });\r\n\r\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\r\n  if (isNumber(simpleDiscriminatorMatch)) {\r\n    return simpleDiscriminatorMatch;\r\n  }\r\n\r\n  // Reduce the array of options down to a list of the indexes that are considered matching options\r\n  const allValidIndexes = resolvedOptions.reduce((validList: number[], option, index: number) => {\r\n    const testOptions: S[] = [JUNK_OPTION as S, option];\r\n    const match = getFirstMatchingOption<T, S, F>(validator, formData, testOptions, rootSchema, discriminatorField);\r\n    // The match is the real option, so add its index to list of valid indexes\r\n    if (match === 1) {\r\n      validList.push(index);\r\n    }\r\n    return validList;\r\n  }, []);\r\n\r\n  // There is only one valid index, so return it!\r\n  if (allValidIndexes.length === 1) {\r\n    return allValidIndexes[0];\r\n  }\r\n  if (!allValidIndexes.length) {\r\n    // No indexes were valid, so we'll score all the options, add all the indexes\r\n    times(resolvedOptions.length, (i) => allValidIndexes.push(i));\r\n  }\r\n  type BestType = { bestIndex: number; bestScore: number };\r\n  const scoreCount = new Set<number>();\r\n  // Score all the options in the list of valid indexes and return the index with the best score\r\n  const { bestIndex }: BestType = allValidIndexes.reduce(\r\n    (scoreData: BestType, index: number) => {\r\n      const { bestScore } = scoreData;\r\n      const option = resolvedOptions[index];\r\n      const score = calculateIndexScore(validator, rootSchema, option, formData);\r\n      scoreCount.add(score);\r\n      if (score > bestScore) {\r\n        return { bestIndex: index, bestScore: score };\r\n      }\r\n      return scoreData;\r\n    },\r\n    { bestIndex: selectedOption, bestScore: 0 }\r\n  );\r\n  // if all scores are the same go with selectedOption\r\n  if (scoreCount.size === 1 && selectedOption >= 0) {\r\n    return selectedOption;\r\n  }\r\n\r\n  return bestIndex;\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\nimport isNumber from 'lodash/isNumber';\r\n\r\nimport { PROPERTIES_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n * Deprecated, use `getFirstMatchingOption()` instead.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the matched option or 0 if none is available\r\n * @deprecated\r\n */\r\nexport default function getMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  // For performance, skip validating subschemas if formData is undefined. We just\r\n  // want to get the first option in that case.\r\n  if (formData === undefined) {\r\n    return 0;\r\n  }\r\n\r\n  const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);\r\n  if (isNumber(simpleDiscriminatorMatch)) {\r\n    return simpleDiscriminatorMatch;\r\n  }\r\n\r\n  for (let i = 0; i < options.length; i++) {\r\n    const option = options[i];\r\n\r\n    // If we have a discriminator field, then we will use this to make the determination\r\n    if (discriminatorField && has(option, [PROPERTIES_KEY, discriminatorField])) {\r\n      const value = get(formData, discriminatorField);\r\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\r\n      if (validator.isValid(discriminator, value, rootSchema)) {\r\n        return i;\r\n      }\r\n    } else if (option[PROPERTIES_KEY]) {\r\n      // If the schema describes an object then we need to add slightly more\r\n      // strict matching to the schema, because unless the schema uses the\r\n      // \"requires\" keyword, an object will match the schema as long as it\r\n      // doesn't have matching keys with a conflicting type. To do this we use an\r\n      // \"anyOf\" with an array of requires. This augmentation expresses that the\r\n      // schema should match if any of the keys in the schema are present on the\r\n      // object and pass validation.\r\n      //\r\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\r\n      // \"properties\" object\r\n      const requiresAnyOf = {\r\n        anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) => ({\r\n          required: [key],\r\n        })),\r\n      };\r\n\r\n      let augmentedSchema;\r\n\r\n      // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\r\n      if (option.anyOf) {\r\n        // Create a shallow clone of the option\r\n        const { ...shallowClone } = option;\r\n\r\n        if (!shallowClone.allOf) {\r\n          shallowClone.allOf = [];\r\n        } else {\r\n          // If \"allOf\" already exists, shallow clone the array\r\n          shallowClone.allOf = shallowClone.allOf.slice();\r\n        }\r\n\r\n        shallowClone.allOf.push(requiresAnyOf);\r\n\r\n        augmentedSchema = shallowClone;\r\n      } else {\r\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\r\n      }\r\n\r\n      // Remove the \"required\" field as it's likely that not all fields have\r\n      // been filled in yet, which will mean that the schema is not valid\r\n      delete augmentedSchema.required;\r\n\r\n      if (validator.isValid(augmentedSchema, formData, rootSchema)) {\r\n        return i;\r\n      }\r\n    } else if (validator.isValid(option, formData, rootSchema)) {\r\n      return i;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n", "import get from 'lodash/get';\r\nimport { PROPERTIES_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.\r\n * Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.\r\n * This function does not work with discriminators of `\"type\": \"object\"` and `\"type\": \"array\"`\r\n *\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the matched option or undefined if there is no match\r\n */\r\nexport default function getOptionMatchingSimpleDiscriminator<T = any, S extends StrictRJSFSchema = RJSFSchema>(\r\n  formData: T | undefined,\r\n  options: S[],\r\n  discriminatorField?: string\r\n): number | undefined {\r\n  if (formData && discriminatorField) {\r\n    const value = get(formData, discriminatorField);\r\n\r\n    if (value === undefined) {\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < options.length; i++) {\r\n      const option = options[i];\r\n      const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});\r\n\r\n      if (discriminator.type === 'object' || discriminator.type === 'array') {\r\n        continue;\r\n      }\r\n\r\n      if (discriminator.const === value) {\r\n        return i;\r\n      }\r\n\r\n      if (discriminator.enum?.includes(value)) {\r\n        return i;\r\n      }\r\n    }\r\n  }\r\n\r\n  return;\r\n}\r\n", "import getMatchingOption from './getMatchingOption';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\n/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n * Always returns the first option if there is nothing that matches.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param formData - The current formData, if any, used to figure out a match\r\n * @param options - The list of options to find a matching options from\r\n * @param rootSchema - The root schema, used to primarily to look up `$ref`s\r\n * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n *          determine which option is selected\r\n * @returns - The index of the first matched option or 0 if none is available\r\n */\r\nexport default function getFirstMatchingOption<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  formData: T | undefined,\r\n  options: S[],\r\n  rootSchema: S,\r\n  discriminatorField?: string\r\n): number {\r\n  return getMatchingOption<T, S, F>(validator, formData, options, rootSchema, discriminatorField);\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\nimport set from 'lodash/set';\r\nimport times from 'lodash/times';\r\nimport transform from 'lodash/transform';\r\nimport merge from 'lodash/merge';\r\nimport flattenDeep from 'lodash/flattenDeep';\r\nimport uniq from 'lodash/uniq';\r\nimport mergeAllOf, { Options } from 'json-schema-merge-allof';\r\n\r\nimport {\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  ADDITIONAL_PROPERTY_FLAG,\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  DEPENDENCIES_KEY,\r\n  IF_KEY,\r\n  ONE_OF_KEY,\r\n  REF_KEY,\r\n  PROPERTIES_KEY,\r\n  ITEMS_KEY,\r\n} from '../constants';\r\nimport findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport guessType from '../guessType';\r\nimport isObject from '../isObject';\r\nimport mergeSchemas from '../mergeSchemas';\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getFirstMatchingOption from './getFirstMatchingOption';\r\n\r\n/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies\r\n * resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the\r\n * potentially recursive resolution.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param [rootSchema={}] - The root schema that will be forwarded to all the APIs\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n */\r\nexport default function retrieveSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S = {} as S, rawFormData?: T): S {\r\n  return retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, rawFormData)[0];\r\n}\r\n\r\n/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch\r\n * with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both\r\n * conditions will be returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions\r\n * @param schema - The schema for which resolving a condition is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and\r\n *          dependencies as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded\r\n */\r\nexport function resolveCondition<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;\r\n\r\n  const conditionValue = validator.isValid(expression as S, formData || ({} as T), rootSchema);\r\n  let resolvedSchemas = [resolvedSchemaLessConditional as S];\r\n  let schemas: S[] = [];\r\n  if (expandAllBranches) {\r\n    if (then && typeof then !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(validator, then as S, rootSchema, formData, expandAllBranches, recurseList)\r\n      );\r\n    }\r\n    if (otherwise && typeof otherwise !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(validator, otherwise as S, rootSchema, formData, expandAllBranches, recurseList)\r\n      );\r\n    }\r\n  } else {\r\n    const conditionalSchema = conditionValue ? then : otherwise;\r\n    if (conditionalSchema && typeof conditionalSchema !== 'boolean') {\r\n      schemas = schemas.concat(\r\n        retrieveSchemaInternal<T, S, F>(\r\n          validator,\r\n          conditionalSchema as S,\r\n          rootSchema,\r\n          formData,\r\n          expandAllBranches,\r\n          recurseList\r\n        )\r\n      );\r\n    }\r\n  }\r\n  if (schemas.length) {\r\n    resolvedSchemas = schemas.map((s) => mergeSchemas(resolvedSchemaLessConditional, s) as S);\r\n  }\r\n  return resolvedSchemas.flatMap((s) =>\r\n    retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList)\r\n  );\r\n}\r\n\r\n/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The\r\n * `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.\r\n * From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.\r\n *\r\n * For example:\r\n * - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three\r\n *   C schemas then:\r\n *   - The permutation for the first row is `[[A]]`\r\n *   - The permutations for the second row are `[[A,B1], [A,B2]]`\r\n *   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`\r\n *\r\n * @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order\r\n * @returns - The list of all permutations of schemas for a set of `xxxOf`s\r\n */\r\nexport function getAllPermutationsOfXxxOf<S extends StrictRJSFSchema = RJSFSchema>(listOfLists: S[][]) {\r\n  const allPermutations: S[][] = listOfLists.reduce<S[][]>(\r\n    (permutations, list) => {\r\n      // When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values\r\n      if (list.length > 1) {\r\n        return list.flatMap((element) => times(permutations.length, (i) => [...permutations[i]].concat(element)));\r\n      }\r\n      // Otherwise just push in the single value into the current set of permutations\r\n      permutations.forEach((permutation) => permutation.push(list[0]));\r\n      return permutations;\r\n    },\r\n    [[]] as S[][] // Start with an empty list\r\n  );\r\n\r\n  return allPermutations;\r\n}\r\n\r\n/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag\r\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If\r\n * `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list of schemas having its references, dependencies and allOf schemas resolved\r\n */\r\nexport function resolveSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const updatedSchemas = resolveReference<T, S, F>(\r\n    validator,\r\n    schema,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    recurseList,\r\n    formData\r\n  );\r\n  if (updatedSchemas.length > 1 || updatedSchemas[0] !== schema) {\r\n    // return the updatedSchemas array if it has either multiple schemas within it\r\n    // OR the first schema is not the same as the original schema\r\n    return updatedSchemas;\r\n  }\r\n  if (DEPENDENCIES_KEY in schema) {\r\n    const resolvedSchemas = resolveDependencies<T, S, F>(\r\n      validator,\r\n      schema,\r\n      rootSchema,\r\n      expandAllBranches,\r\n      recurseList,\r\n      formData\r\n    );\r\n    return resolvedSchemas.flatMap((s) => {\r\n      return retrieveSchemaInternal<T, S, F>(validator, s, rootSchema, formData, expandAllBranches, recurseList);\r\n    });\r\n  }\r\n  if (ALL_OF_KEY in schema && Array.isArray(schema.allOf)) {\r\n    const allOfSchemaElements: S[][] = schema.allOf.map((allOfSubschema) =>\r\n      retrieveSchemaInternal<T, S, F>(\r\n        validator,\r\n        allOfSubschema as S,\r\n        rootSchema,\r\n        formData,\r\n        expandAllBranches,\r\n        recurseList\r\n      )\r\n    );\r\n    const allPermutations = getAllPermutationsOfXxxOf<S>(allOfSchemaElements);\r\n    return allPermutations.map((permutation) => ({ ...schema, allOf: permutation }));\r\n  }\r\n  // No $ref or dependencies or allOf attribute was found, returning the original schema.\r\n  return [schema];\r\n}\r\n\r\n/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is\r\n * actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`\r\n * helper call.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a reference is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list schemas retrieved after having all references resolved\r\n */\r\nexport function resolveReference<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const updatedSchema = resolveAllReferences<S>(schema, rootSchema, recurseList);\r\n  if (updatedSchema !== schema) {\r\n    // Only call this if the schema was actually changed by the `resolveAllReferences()` function\r\n    return retrieveSchemaInternal<T, S, F>(\r\n      validator,\r\n      updatedSchema,\r\n      rootSchema,\r\n      formData,\r\n      expandAllBranches,\r\n      recurseList\r\n    );\r\n  }\r\n  return [schema];\r\n}\r\n\r\n/** Resolves all references within the schema itself as well as any of its properties and array items.\r\n *\r\n * @param schema - The schema for which resolving all references is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param recurseList - List of $refs already resolved to prevent recursion\r\n * @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved\r\n */\r\nexport function resolveAllReferences<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  rootSchema: S,\r\n  recurseList: string[]\r\n): S {\r\n  if (!isObject(schema)) {\r\n    return schema;\r\n  }\r\n  let resolvedSchema: S = schema;\r\n  // resolve top level ref\r\n  if (REF_KEY in resolvedSchema) {\r\n    const { $ref, ...localSchema } = resolvedSchema;\r\n    // Check for a recursive reference and stop the loop\r\n    if (recurseList.includes($ref!)) {\r\n      return resolvedSchema;\r\n    }\r\n    recurseList.push($ref!);\r\n    // Retrieve the referenced schema definition.\r\n    const refSchema = findSchemaDefinition<S>($ref, rootSchema);\r\n    resolvedSchema = { ...refSchema, ...localSchema };\r\n  }\r\n\r\n  if (PROPERTIES_KEY in resolvedSchema) {\r\n    const childrenLists: string[][] = [];\r\n    const updatedProps = transform(\r\n      resolvedSchema[PROPERTIES_KEY]!,\r\n      (result, value, key: string) => {\r\n        const childList: string[] = [...recurseList];\r\n        result[key] = resolveAllReferences(value as S, rootSchema, childList);\r\n        childrenLists.push(childList);\r\n      },\r\n      {} as RJSFSchema\r\n    );\r\n    merge(recurseList, uniq(flattenDeep(childrenLists)));\r\n    resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };\r\n  }\r\n\r\n  if (\r\n    ITEMS_KEY in resolvedSchema &&\r\n    !Array.isArray(resolvedSchema.items) &&\r\n    typeof resolvedSchema.items !== 'boolean'\r\n  ) {\r\n    resolvedSchema = {\r\n      ...resolvedSchema,\r\n      items: resolveAllReferences(resolvedSchema.items as S, rootSchema, recurseList),\r\n    };\r\n  }\r\n\r\n  return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;\r\n}\r\n\r\n/** Creates new 'properties' items for each key in the `formData`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which the existing additional properties is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator\r\n * @param [aFormData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The updated schema with additional properties stubbed\r\n */\r\nexport function stubExistingAdditionalProperties<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, theSchema: S, rootSchema?: S, aFormData?: T): S {\r\n  // Clone the schema so that we don't ruin the consumer's original\r\n  const schema = {\r\n    ...theSchema,\r\n    properties: { ...theSchema.properties },\r\n  };\r\n\r\n  // make sure formData is an object\r\n  const formData: GenericObjectType = aFormData && isObject(aFormData) ? aFormData : {};\r\n  Object.keys(formData).forEach((key) => {\r\n    if (key in schema.properties) {\r\n      // No need to stub, our schema already has the property\r\n      return;\r\n    }\r\n\r\n    let additionalProperties: S['additionalProperties'] = {};\r\n    if (typeof schema.additionalProperties !== 'boolean') {\r\n      if (REF_KEY in schema.additionalProperties!) {\r\n        additionalProperties = retrieveSchema<T, S, F>(\r\n          validator,\r\n          { $ref: get(schema.additionalProperties, [REF_KEY]) } as S,\r\n          rootSchema,\r\n          formData as T\r\n        );\r\n      } else if ('type' in schema.additionalProperties!) {\r\n        additionalProperties = { ...schema.additionalProperties };\r\n      } else if (ANY_OF_KEY in schema.additionalProperties! || ONE_OF_KEY in schema.additionalProperties!) {\r\n        additionalProperties = {\r\n          type: 'object',\r\n          ...schema.additionalProperties,\r\n        };\r\n      } else {\r\n        additionalProperties = { type: guessType(get(formData, [key])) };\r\n      }\r\n    } else {\r\n      additionalProperties = { type: guessType(get(formData, [key])) };\r\n    }\r\n\r\n    // The type of our new key should match the additionalProperties value;\r\n    schema.properties[key] = additionalProperties;\r\n    // Set our additional property flag so we know it was dynamically added\r\n    set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);\r\n  });\r\n\r\n  return schema;\r\n}\r\n\r\n/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,\r\n * references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`\r\n * that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches\r\n * of the schema and its references, conditions and dependencies are returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n * @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and\r\n *          dependencies as a list of schemas\r\n * @param [recurseList=[]] - The optional, list of recursive references already processed\r\n * @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies\r\n *          resolved. Multiple schemas may be returned if `expandAllBranches` is true.\r\n */\r\nexport function retrieveSchemaInternal<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  rawFormData?: T,\r\n  expandAllBranches = false,\r\n  recurseList: string[] = []\r\n): S[] {\r\n  if (!isObject(schema)) {\r\n    return [{} as S];\r\n  }\r\n  const resolvedSchemas = resolveSchema<T, S, F>(\r\n    validator,\r\n    schema,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    recurseList,\r\n    rawFormData\r\n  );\r\n  return resolvedSchemas.flatMap((s: S) => {\r\n    let resolvedSchema = s;\r\n    if (IF_KEY in resolvedSchema) {\r\n      return resolveCondition<T, S, F>(\r\n        validator,\r\n        resolvedSchema,\r\n        rootSchema,\r\n        expandAllBranches,\r\n        recurseList,\r\n        rawFormData as T\r\n      );\r\n    }\r\n    if (ALL_OF_KEY in resolvedSchema) {\r\n      // resolve allOf schemas\r\n      if (expandAllBranches) {\r\n        const { allOf, ...restOfSchema } = resolvedSchema;\r\n        return [...(allOf as S[]), restOfSchema as S];\r\n      }\r\n      try {\r\n        resolvedSchema = mergeAllOf(resolvedSchema, {\r\n          deep: false,\r\n        } as Options) as S;\r\n      } catch (e) {\r\n        console.warn('could not merge subschemas in allOf:\\n', e);\r\n        const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;\r\n        return resolvedSchemaWithoutAllOf as S;\r\n      }\r\n    }\r\n    const hasAdditionalProperties =\r\n      ADDITIONAL_PROPERTIES_KEY in resolvedSchema && resolvedSchema.additionalProperties !== false;\r\n    if (hasAdditionalProperties) {\r\n      return stubExistingAdditionalProperties<T, S, F>(validator, resolvedSchema, rootSchema, rawFormData as T);\r\n    }\r\n\r\n    return resolvedSchema;\r\n  });\r\n}\r\n\r\n/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from\r\n * `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL\r\n * options are retrieved and returned.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which retrieving a schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object\r\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\r\n */\r\nexport function resolveAnyOrOneOfSchemas<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema: S, expandAllBranches: boolean, rawFormData?: T) {\r\n  let anyOrOneOf: S[] | undefined;\r\n  const { oneOf, anyOf, ...remaining } = schema;\r\n  if (Array.isArray(oneOf)) {\r\n    anyOrOneOf = oneOf as S[];\r\n  } else if (Array.isArray(anyOf)) {\r\n    anyOrOneOf = anyOf as S[];\r\n  }\r\n  if (anyOrOneOf) {\r\n    // Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated\r\n    const formData = rawFormData === undefined && expandAllBranches ? ({} as T) : rawFormData;\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    anyOrOneOf = anyOrOneOf.map((s) => {\r\n      // Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option\r\n      // can resolve recursive references independently\r\n      return resolveAllReferences(s, rootSchema, []);\r\n    });\r\n    // Call this to trigger the set of isValid() calls that the schema parser will need\r\n    const option = getFirstMatchingOption<T, S, F>(validator, formData, anyOrOneOf, rootSchema, discriminator);\r\n    if (expandAllBranches) {\r\n      return anyOrOneOf.map((item) => mergeSchemas(remaining, item) as S);\r\n    }\r\n    schema = mergeSchemas(remaining, anyOrOneOf[option]) as S;\r\n  }\r\n  return [schema];\r\n}\r\n\r\n/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to\r\n * the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependency is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The list of schemas with their dependencies resolved\r\n */\r\nexport function resolveDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  // Drop the dependencies from the source schema.\r\n  const { dependencies, ...remainingSchema } = schema;\r\n  const resolvedSchemas = resolveAnyOrOneOfSchemas<T, S, F>(\r\n    validator,\r\n    remainingSchema as S,\r\n    rootSchema,\r\n    expandAllBranches,\r\n    formData\r\n  );\r\n  return resolvedSchemas.flatMap((resolvedSchema) =>\r\n    processDependencies<T, S, F>(\r\n      validator,\r\n      dependencies,\r\n      resolvedSchema,\r\n      rootSchema,\r\n      expandAllBranches,\r\n      recurseList,\r\n      formData\r\n    )\r\n  );\r\n}\r\n\r\n/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the\r\n * `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param dependencies - The set of dependencies that needs to be processed\r\n * @param resolvedSchema - The schema for which processing dependencies is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The schema with the `dependencies` resolved into it\r\n */\r\nexport function processDependencies<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  dependencies: S['dependencies'],\r\n  resolvedSchema: S,\r\n  rootSchema: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  let schemas = [resolvedSchema];\r\n  // Process dependencies updating the local schema properties as appropriate.\r\n  for (const dependencyKey in dependencies) {\r\n    // Skip this dependency if its trigger property is not present.\r\n    if (!expandAllBranches && get(formData, [dependencyKey]) === undefined) {\r\n      continue;\r\n    }\r\n    // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\r\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\r\n      continue;\r\n    }\r\n    const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(\r\n      dependencyKey,\r\n      dependencies as GenericObjectType\r\n    );\r\n    if (Array.isArray(dependencyValue)) {\r\n      schemas[0] = withDependentProperties<S>(resolvedSchema, dependencyValue);\r\n    } else if (isObject(dependencyValue)) {\r\n      schemas = withDependentSchema<T, S, F>(\r\n        validator,\r\n        resolvedSchema,\r\n        rootSchema,\r\n        dependencyKey,\r\n        dependencyValue as S,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      );\r\n    }\r\n    return schemas.flatMap((schema) =>\r\n      processDependencies<T, S, F>(\r\n        validator,\r\n        remainingDependencies,\r\n        schema,\r\n        rootSchema,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      )\r\n    );\r\n  }\r\n  return schemas;\r\n}\r\n\r\n/** Updates a schema with additionally required properties added\r\n *\r\n * @param schema - The schema for which resolving a dependent properties is desired\r\n * @param [additionallyRequired] - An optional array of additionally required names\r\n * @returns - The schema with the additional required values merged in\r\n */\r\nexport function withDependentProperties<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S,\r\n  additionallyRequired?: string[]\r\n) {\r\n  if (!additionallyRequired) {\r\n    return schema;\r\n  }\r\n  const required = Array.isArray(schema.required)\r\n    ? Array.from(new Set([...schema.required, ...additionallyRequired]))\r\n    : additionallyRequired;\r\n  return { ...schema, required: required };\r\n}\r\n\r\n/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag\r\n * down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param schema - The schema for which resolving a dependent schema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the dependency\r\n * @param dependencyValue - The potentially dependent schema\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData]- The current formData to assist retrieving a schema\r\n * @returns - The list of schemas with the dependent schema resolved into them\r\n */\r\nexport function withDependentSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  dependencyKey: string,\r\n  dependencyValue: S,\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const dependentSchemas = retrieveSchemaInternal<T, S, F>(\r\n    validator,\r\n    dependencyValue,\r\n    rootSchema,\r\n    formData,\r\n    expandAllBranches,\r\n    recurseList\r\n  );\r\n  return dependentSchemas.flatMap((dependent) => {\r\n    const { oneOf, ...dependentSchema } = dependent;\r\n    schema = mergeSchemas(schema, dependentSchema) as S;\r\n    // Since it does not contain oneOf, we return the original schema.\r\n    if (oneOf === undefined) {\r\n      return schema;\r\n    }\r\n    // Resolve $refs inside oneOf.\r\n    const resolvedOneOfs = oneOf.map((subschema) => {\r\n      if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {\r\n        return [subschema as S];\r\n      }\r\n      return resolveReference<T, S, F>(validator, subschema as S, rootSchema, expandAllBranches, recurseList, formData);\r\n    });\r\n    const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);\r\n    return allPermutations.flatMap((resolvedOneOf) =>\r\n      withExactlyOneSubschema<T, S, F>(\r\n        validator,\r\n        schema,\r\n        rootSchema,\r\n        dependencyKey,\r\n        resolvedOneOf,\r\n        expandAllBranches,\r\n        recurseList,\r\n        formData\r\n      )\r\n    );\r\n  });\r\n}\r\n\r\n/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is\r\n * true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to\r\n * the `retrieveSchemaInternal()` helper call.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options\r\n * @param schema - The schema for which resolving a oneOf subschema is desired\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param dependencyKey - The key name of the oneOf dependency\r\n * @param oneOf - The list of schemas representing the oneOf options\r\n * @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies\r\n *          as a list of schemas\r\n * @param recurseList - The list of recursive references already processed\r\n * @param [formData] - The current formData to assist retrieving a schema\r\n * @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true\r\n */\r\nexport function withExactlyOneSubschema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  rootSchema: S,\r\n  dependencyKey: string,\r\n  oneOf: S['oneOf'],\r\n  expandAllBranches: boolean,\r\n  recurseList: string[],\r\n  formData?: T\r\n): S[] {\r\n  const validSubschemas = oneOf!.filter((subschema) => {\r\n    if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {\r\n      return false;\r\n    }\r\n    const { [dependencyKey]: conditionPropertySchema } = subschema.properties;\r\n    if (conditionPropertySchema) {\r\n      const conditionSchema: S = {\r\n        type: 'object',\r\n        properties: {\r\n          [dependencyKey]: conditionPropertySchema,\r\n        },\r\n      } as S;\r\n      return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;\r\n    }\r\n    return false;\r\n  });\r\n\r\n  if (!expandAllBranches && validSubschemas!.length !== 1) {\r\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\r\n    return [schema];\r\n  }\r\n  return validSubschemas.flatMap((s) => {\r\n    const subschema: S = s as S;\r\n    const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties as GenericObjectType);\r\n    const dependentSchema = { ...subschema, properties: dependentSubschema };\r\n    const schemas = retrieveSchemaInternal<T, S, F>(\r\n      validator,\r\n      dependentSchema,\r\n      rootSchema,\r\n      formData,\r\n      expandAllBranches,\r\n      recurseList\r\n    );\r\n    return schemas.map((s) => mergeSchemas(schema, s) as S);\r\n  });\r\n}\r\n", "import get from 'lodash/get';\r\nimport isString from 'lodash/isString';\r\n\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when\r\n * it is not a string. Returns `undefined` when a valid discriminator is not present.\r\n *\r\n * @param schema - The schema from which the discriminator is potentially obtained\r\n * @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`\r\n */\r\nexport default function getDiscriminatorFieldFromSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  let discriminator: string | undefined;\r\n  const maybeString = get(schema, 'discriminator.propertyName', undefined);\r\n  if (isString(maybeString)) {\r\n    discriminator = maybeString;\r\n  } else if (maybeString !== undefined) {\r\n    console.warn(`Expecting discriminator to be a string, got \"${typeof maybeString}\" instead`);\r\n  }\r\n  return discriminator;\r\n}\r\n", "/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly\r\n *  create a schema, it is useful to know what type to use based on the data we are defining.\r\n *\r\n * @param value - The value from which to guess the type\r\n * @returns - The best guess for the object type\r\n */\r\nexport default function guessType(value: any) {\r\n  if (Array.isArray(value)) {\r\n    return 'array';\r\n  }\r\n  if (typeof value === 'string') {\r\n    return 'string';\r\n  }\r\n  if (value == null) {\r\n    return 'null';\r\n  }\r\n  if (typeof value === 'boolean') {\r\n    return 'boolean';\r\n  }\r\n  if (!isNaN(value)) {\r\n    return 'number';\r\n  }\r\n  if (typeof value === 'object') {\r\n    return 'object';\r\n  }\r\n  // Default to string if we can't figure it out\r\n  return 'string';\r\n}\r\n", "import union from 'lodash/union';\r\n\r\nimport { REQUIRED_KEY } from './constants';\r\nimport getSchemaType from './getSchemaType';\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that\r\n * `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include\r\n * duplicate values.\r\n *\r\n * @param obj1 - The first schema object to merge\r\n * @param obj2 - The second schema object to merge\r\n * @returns - The merged schema object\r\n */\r\nexport default function mergeSchemas(obj1: GenericObjectType, obj2: GenericObjectType) {\r\n  const acc = Object.assign({}, obj1); // Prevent mutation of source object.\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeSchemas(left, right);\r\n    } else if (\r\n      obj1 &&\r\n      obj2 &&\r\n      (getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &&\r\n      key === REQUIRED_KEY &&\r\n      Array.isArray(left) &&\r\n      Array.isArray(right)\r\n    ) {\r\n      // Don't include duplicate values when merging 'required' fields.\r\n      acc[key] = union(left, right);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, acc);\r\n}\r\n", "import guessType from './guessType';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from\r\n * other elements of the schema as follows:\r\n * - schema.const: Returns the `guessType()` of that value\r\n * - schema.enum: Returns `string`\r\n * - schema.properties: Returns `object`\r\n * - schema.additionalProperties: Returns `object`\r\n * - type is an array with a length of 2 and one type is 'null': Returns the other type\r\n *\r\n * @param schema - The schema for which to get the type\r\n * @returns - The type of the schema\r\n */\r\nexport default function getSchemaType<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S\r\n): string | string[] | undefined {\r\n  let { type } = schema;\r\n\r\n  if (!type && schema.const) {\r\n    return guessType(schema.const);\r\n  }\r\n\r\n  if (!type && schema.enum) {\r\n    return 'string';\r\n  }\r\n\r\n  if (!type && (schema.properties || schema.additionalProperties)) {\r\n    return 'object';\r\n  }\r\n\r\n  if (Array.isArray(type)) {\r\n    if (type.length === 2 && type.includes('null')) {\r\n      type = type.find((type) => type !== 'null');\r\n    } else {\r\n      type = type[0];\r\n    }\r\n  }\r\n\r\n  return type;\r\n}\r\n", "import isObject from './isObject';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array\r\n * that only contains objects.\r\n *\r\n * @param schema - The schema in which to check for fixed items\r\n * @returns - True if there are fixed items in the schema, false otherwise\r\n */\r\nexport default function isFixedItems<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every((item) => isObject(item));\r\n}\r\n", "import get from 'lodash/get';\r\n\r\nimport isObject from './isObject';\r\nimport { GenericObjectType } from '../src';\r\n\r\n/** Merges the `defaults` object of type `T` into the `formData` of type `T`\r\n *\r\n * When merging defaults and form data, we want to merge in this specific way:\r\n * - objects are deeply merged\r\n * - arrays are merged in such a way that:\r\n *   - when the array is set in form data, only array entries set in form data\r\n *     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in\r\n *     which case the extras are appended onto the end of the form data\r\n *   - when the array is not set in form data, the default is copied over\r\n * - scalars are overwritten/set by form data\r\n *\r\n * @param [defaults] - The defaults to merge\r\n * @param [formData] - The form data into which the defaults will be merged\r\n * @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData\r\n * @returns - The resulting merged form data with defaults\r\n */\r\nexport default function mergeDefaultsWithFormData<T = any>(\r\n  defaults?: T,\r\n  formData?: T,\r\n  mergeExtraArrayDefaults = false\r\n): T | undefined {\r\n  if (Array.isArray(formData)) {\r\n    const defaultsArray = Array.isArray(defaults) ? defaults : [];\r\n    const mapped = formData.map((value, idx) => {\r\n      if (defaultsArray[idx]) {\r\n        return mergeDefaultsWithFormData<any>(defaultsArray[idx], value, mergeExtraArrayDefaults);\r\n      }\r\n      return value;\r\n    });\r\n    // Merge any extra defaults when mergeExtraArrayDefaults is true\r\n    if (mergeExtraArrayDefaults && mapped.length < defaultsArray.length) {\r\n      mapped.push(...defaultsArray.slice(mapped.length));\r\n    }\r\n    return mapped as unknown as T;\r\n  }\r\n  if (isObject(formData)) {\r\n    const acc: { [key in keyof T]: any } = Object.assign({}, defaults); // Prevent mutation of source object.\r\n    return Object.keys(formData as GenericObjectType).reduce((acc, key) => {\r\n      acc[key as keyof T] = mergeDefaultsWithFormData<T>(\r\n        defaults ? get(defaults, key) : {},\r\n        get(formData, key),\r\n        mergeExtraArrayDefaults\r\n      );\r\n      return acc;\r\n    }, acc);\r\n  }\r\n  return formData;\r\n}\r\n", "import isObject from './isObject';\r\nimport { GenericObjectType } from './types';\r\n\r\n/** Recursively merge deeply nested objects.\r\n *\r\n * @param obj1 - The first object to merge\r\n * @param obj2 - The second object to merge\r\n * @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use\r\n *          \"preventDuplicates\" to merge arrays in a manner that prevents any duplicate entries from being merged.\r\n *          NOTE: Uses shallow comparison for the duplicate checking.\r\n * @returns - A new object that is the merge of the two given objects\r\n */\r\nexport default function mergeObjects(\r\n  obj1: GenericObjectType,\r\n  obj2: GenericObjectType,\r\n  concatArrays: boolean | 'preventDuplicates' = false\r\n) {\r\n  return Object.keys(obj2).reduce((acc, key) => {\r\n    const left = obj1 ? obj1[key] : {},\r\n      right = obj2[key];\r\n    if (obj1 && key in obj1 && isObject(right)) {\r\n      acc[key] = mergeObjects(left, right, concatArrays);\r\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\r\n      let toMerge = right;\r\n      if (concatArrays === 'preventDuplicates') {\r\n        toMerge = right.reduce((result, value) => {\r\n          if (!left.includes(value)) {\r\n            result.push(value);\r\n          }\r\n          return result;\r\n        }, []);\r\n      }\r\n      acc[key] = left.concat(toMerge);\r\n    } else {\r\n      acc[key] = right;\r\n    }\r\n    return acc;\r\n  }, Object.assign({}, obj1)); // Prevent mutation of source object.\r\n}\r\n", "import { CONST_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has\r\n * an `enum` array with a single value or there is a `const` defined.\r\n *\r\n * @param schema - The schema for a field\r\n * @returns - True if the `schema` has a single constant value, false otherwise\r\n */\r\nexport default function isConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  return (Array.isArray(schema.enum) && schema.enum.length === 1) || CONST_KEY in schema;\r\n}\r\n", "import isConstant from '../isConstant';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` combination represents a select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param theSchema - The schema for which check for a select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a select, otherwise false\r\n */\r\nexport default function isSelect<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  theSchema: S,\r\n  rootSchema: S = {} as S\r\n) {\r\n  const schema = retrieveSchema<T, S, F>(validator, theSchema, rootSchema, undefined);\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  if (Array.isArray(schema.enum)) {\r\n    return true;\r\n  }\r\n  if (Array.isArray(altSchemas)) {\r\n    return altSchemas.every((altSchemas) => typeof altSchemas !== 'boolean' && isConstant(altSchemas));\r\n  }\r\n  return false;\r\n}\r\n", "import { FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\n\r\nimport isSelect from './isSelect';\r\n\r\n/** Checks to see if the `schema` combination represents a multi-select\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for a multi-select flag is desired\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema contains a multi-select, otherwise false\r\n */\r\nexport default function isMultiSelect<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, schema: S, rootSchema?: S) {\r\n  if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {\r\n    return false;\r\n  }\r\n  return isSelect<T, S, F>(validator, schema.items as S, rootSchema);\r\n}\r\n", "import getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema } from './types';\r\n\r\n/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`\r\n *\r\n * @param uiSchema - The UI Schema from which to detect if it is customized\r\n * @returns - True if the `uiSchema` describes a custom widget, false otherwise\r\n */\r\nexport default function isCustomWidget<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}) {\r\n  return (\r\n    // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.\r\n    // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets\r\n    'widget' in getUiOptions<T, S, F>(uiSchema) && getUiOptions<T, S, F>(uiSchema)['widget'] !== 'hidden'\r\n  );\r\n}\r\n", "import { UI_WIDGET_KEY } from '../constants';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which check for array of files flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to check the widget\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n */\r\nexport default function isFilesArray<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S\r\n) {\r\n  if (uiSchema[UI_WIDGET_KEY] === 'files') {\r\n    return true;\r\n  }\r\n  if (schema.items) {\r\n    const itemsSchema = retrieveSchema<T, S, F>(validator, schema.items as S, rootSchema);\r\n    return itemsSchema.type === 'string' && itemsSchema.format === 'data-url';\r\n  }\r\n  return false;\r\n}\r\n", "import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';\r\nimport getSchemaType from '../getSchemaType';\r\nimport getUiOptions from '../getUiOptions';\r\nimport isCustomWidget from '../isCustomWidget';\r\nimport {\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  RJSFSchema,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidatorType,\r\n} from '../types';\r\nimport isFilesArray from './isFilesArray';\r\nimport isMultiSelect from './isMultiSelect';\r\n\r\n/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n * should be displayed in a UI.\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the display label flag is desired\r\n * @param [uiSchema={}] - The UI schema from which to derive potentially displayable information\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n * @returns - True if the label should be displayed or false if it should not\r\n */\r\nexport default function getDisplayLabel<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  uiSchema: UiSchema<T, S, F> = {},\r\n  rootSchema?: S,\r\n  globalOptions?: GlobalUISchemaOptions\r\n): boolean {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema, globalOptions);\r\n  const { label = true } = uiOptions;\r\n  let displayLabel = !!label;\r\n  const schemaType = getSchemaType<S>(schema);\r\n\r\n  if (schemaType === 'array') {\r\n    displayLabel =\r\n      isMultiSelect<T, S, F>(validator, schema, rootSchema) ||\r\n      isFilesArray<T, S, F>(validator, schema, uiSchema, rootSchema) ||\r\n      isCustomWidget(uiSchema);\r\n  }\r\n\r\n  if (schemaType === 'object') {\r\n    displayLabel = false;\r\n  }\r\n  if (schemaType === 'boolean' && !uiSchema[UI_WIDGET_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  if (uiSchema[UI_FIELD_KEY]) {\r\n    displayLabel = false;\r\n  }\r\n  return displayLabel;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from '../mergeObjects';\r\nimport { ErrorSchema, FormContextType, RJSFSchema, StrictRJSFSchema, ValidationData, ValidatorType } from '../types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validator - The validator used to convert an ErrorSchema to a list of errors\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n *        removed in the next major release.\r\n */\r\nexport default function mergeValidationData<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = validator.toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import get from 'lodash/get';\r\nimport has from 'lodash/has';\r\n\r\nimport { FormContextType, GenericObjectType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport { PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\nconst NO_VALUE = Symbol('no Value');\r\n\r\n/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new\r\n * schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature\r\n * of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema\r\n * that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:\r\n *\r\n * - If the new schema is an object that contains a `properties` object then:\r\n *   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined\r\n *   - Create an empty `nestedData` object for use in the key filtering below:\r\n *   - Iterate over each key in the `newSchema.properties` as follows:\r\n *     - Get the `formValue` of the key from the `data`\r\n *     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist\r\n *     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`\r\n *     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old & new are the same then:\r\n *       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property\r\n *       - If type of the key in the new schema is `object`:\r\n *         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`\r\n *       - Otherwise, check for default or const values:\r\n *         - Get the old and new `default` values from the schema and check:\r\n *           - If the new `default` value does not match the form value:\r\n *             - If the old `default` value DOES match the form value, then:\r\n *               - Replace `removeOldSchemaData[key]` with the new `default`\r\n *               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined\r\n *         - Get the old and new `const` values from the schema and check:\r\n *           - If the new `const` value does not match the form value:\r\n *           - If the old `const` value DOES match the form value, then:\r\n *             - Replace `removeOldSchemaData[key]` with the new `const`\r\n *             - Otherwise, replace `removeOldSchemaData[key]` with undefined\r\n *   - Once all keys have been processed, return an object built as follows:\r\n *     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`\r\n * - If the new and old schema types are array and the `data` is an array then:\r\n *   - If the type of the old and new schema `items` are a non-array objects:\r\n *     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`\r\n *     - If the `type`s of both items are the same (or the old does not have a type):\r\n *       - If the type is \"object\", then:\r\n *         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified\r\n *       - Otherwise, just return the `data` removing any values after `maxItems` if it is set\r\n *   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is\r\n * - Otherwise return `undefined`\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param rootSchema - The root JSON schema of the entire form\r\n * @param [newSchema] - The new schema for which the data is being sanitized\r\n * @param [oldSchema] - The old schema from which the data originated\r\n * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n */\r\nexport default function sanitizeDataForNewSchema<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(validator: ValidatorType<T, S, F>, rootSchema: S, newSchema?: S, oldSchema?: S, data: any = {}): T {\r\n  // By default, we will clear the form data\r\n  let newFormData;\r\n  // If the new schema is of type object and that object contains a list of properties\r\n  if (has(newSchema, PROPERTIES_KEY)) {\r\n    // Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data\r\n    const removeOldSchemaData: GenericObjectType = {};\r\n    if (has(oldSchema, PROPERTIES_KEY)) {\r\n      const properties = get(oldSchema, PROPERTIES_KEY, {});\r\n      Object.keys(properties).forEach((key) => {\r\n        if (has(data, key)) {\r\n          removeOldSchemaData[key] = undefined;\r\n        }\r\n      });\r\n    }\r\n    const keys: string[] = Object.keys(get(newSchema, PROPERTIES_KEY, {}));\r\n    // Create a place to store nested data that will be a side-effect of the filter\r\n    const nestedData: GenericObjectType = {};\r\n    keys.forEach((key) => {\r\n      const formValue = get(data, key);\r\n      let oldKeyedSchema: S = get(oldSchema, [PROPERTIES_KEY, key], {});\r\n      let newKeyedSchema: S = get(newSchema, [PROPERTIES_KEY, key], {});\r\n      // Resolve the refs if they exist\r\n      if (has(oldKeyedSchema, REF_KEY)) {\r\n        oldKeyedSchema = retrieveSchema<T, S, F>(validator, oldKeyedSchema, rootSchema, formValue);\r\n      }\r\n      if (has(newKeyedSchema, REF_KEY)) {\r\n        newKeyedSchema = retrieveSchema<T, S, F>(validator, newKeyedSchema, rootSchema, formValue);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');\r\n      const newSchemaTypeForKey = get(newKeyedSchema, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {\r\n        if (has(removeOldSchemaData, key)) {\r\n          // SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas\r\n          delete removeOldSchemaData[key];\r\n        }\r\n        // If it is an object, we'll recurse and store the resulting sanitized data for the key\r\n        if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' && Array.isArray(formValue))) {\r\n          // SIDE-EFFECT: process the new schema type of object recursively to save iterations\r\n          const itemData = sanitizeDataForNewSchema<T, S, F>(\r\n            validator,\r\n            rootSchema,\r\n            newKeyedSchema,\r\n            oldKeyedSchema,\r\n            formValue\r\n          );\r\n          if (itemData !== undefined || newSchemaTypeForKey === 'array') {\r\n            // only put undefined values for the array type and not the object type\r\n            nestedData[key] = itemData;\r\n          }\r\n        } else {\r\n          // Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced\r\n          // with the new default or const. This allows the case where two schemas differ that only by the default/const\r\n          // value to be properly selected\r\n          const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);\r\n          const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);\r\n          if (newOptionDefault !== NO_VALUE && newOptionDefault !== formValue) {\r\n            if (oldOptionDefault === formValue) {\r\n              // If the old default matches the formValue, we'll update the new value to match the new default\r\n              removeOldSchemaData[key] = newOptionDefault;\r\n            } else if (get(newKeyedSchema, 'readOnly') === true) {\r\n              // If the new schema has the default set to read-only, treat it like a const and remove the value\r\n              removeOldSchemaData[key] = undefined;\r\n            }\r\n          }\r\n\r\n          const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);\r\n          const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);\r\n          if (newOptionConst !== NO_VALUE && newOptionConst !== formValue) {\r\n            // Since this is a const, if the old value matches, replace the value with the new const otherwise clear it\r\n            removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    newFormData = {\r\n      ...(typeof data == 'string' || Array.isArray(data) ? undefined : data),\r\n      ...removeOldSchemaData,\r\n      ...nestedData,\r\n    };\r\n    // First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep\r\n  } else if (get(oldSchema, 'type') === 'array' && get(newSchema, 'type') === 'array' && Array.isArray(data)) {\r\n    let oldSchemaItems = get(oldSchema, 'items');\r\n    let newSchemaItems = get(newSchema, 'items');\r\n    // If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data\r\n    // Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations\r\n    if (\r\n      typeof oldSchemaItems === 'object' &&\r\n      typeof newSchemaItems === 'object' &&\r\n      !Array.isArray(oldSchemaItems) &&\r\n      !Array.isArray(newSchemaItems)\r\n    ) {\r\n      if (has(oldSchemaItems, REF_KEY)) {\r\n        oldSchemaItems = retrieveSchema<T, S, F>(validator, oldSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      if (has(newSchemaItems, REF_KEY)) {\r\n        newSchemaItems = retrieveSchema<T, S, F>(validator, newSchemaItems as S, rootSchema, data as T);\r\n      }\r\n      // Now get types and see if they are the same\r\n      const oldSchemaType = get(oldSchemaItems, 'type');\r\n      const newSchemaType = get(newSchemaItems, 'type');\r\n      // Check if the old option has the same key with the same type\r\n      if (!oldSchemaType || oldSchemaType === newSchemaType) {\r\n        const maxItems = get(newSchema, 'maxItems', -1);\r\n        if (newSchemaType === 'object') {\r\n          newFormData = data.reduce((newValue, aValue) => {\r\n            const itemValue = sanitizeDataForNewSchema<T, S, F>(\r\n              validator,\r\n              rootSchema,\r\n              newSchemaItems as S,\r\n              oldSchemaItems as S,\r\n              aValue\r\n            );\r\n            if (itemValue !== undefined && (maxItems < 0 || newValue.length < maxItems)) {\r\n              newValue.push(itemValue);\r\n            }\r\n            return newValue;\r\n          }, []);\r\n        } else {\r\n          newFormData = maxItems > 0 && data.length > maxItems ? data.slice(0, maxItems) : data;\r\n        }\r\n      }\r\n    } else if (\r\n      typeof oldSchemaItems === 'boolean' &&\r\n      typeof newSchemaItems === 'boolean' &&\r\n      oldSchemaItems === newSchemaItems\r\n    ) {\r\n      // If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined\r\n      newFormData = data;\r\n    }\r\n    // Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft\r\n  }\r\n  return newFormData as T;\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';\r\nimport isObject from '../isObject';\r\nimport { FormContextType, IdSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport retrieveSchema from './retrieveSchema';\r\nimport getSchemaType from '../getSchemaType';\r\n\r\n/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param idPrefix - The prefix to use for the id\r\n * @param idSeparator - The separator to use for the path segments in the id\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nfunction toIdSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  idPrefix: string,\r\n  idSeparator: string,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): IdSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        idPrefix,\r\n        idSeparator,\r\n        id,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n  if (ITEMS_KEY in schema && !get(schema, [ITEMS_KEY, REF_KEY])) {\r\n    return toIdSchemaInternal<T, S, F>(\r\n      validator,\r\n      get(schema, ITEMS_KEY) as S,\r\n      idPrefix,\r\n      idSeparator,\r\n      id,\r\n      rootSchema,\r\n      formData,\r\n      _recurseList\r\n    );\r\n  }\r\n  const $id = id || idPrefix;\r\n  const idSchema: IdSchema = { $id } as IdSchema<T>;\r\n  if (getSchemaType<S>(schema) === 'object' && PROPERTIES_KEY in schema) {\r\n    for (const name in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, name]);\r\n      const fieldId = idSchema[ID_KEY] + idSeparator + name;\r\n      idSchema[name] = toIdSchemaInternal<T, S, F>(\r\n        validator,\r\n        isObject(field) ? field : {},\r\n        idPrefix,\r\n        idSeparator,\r\n        fieldId,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [name]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return idSchema as IdSchema<T>;\r\n}\r\n\r\n/** Generates an `IdSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `IdSchema` is desired\r\n * @param [id] - The base id for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [idPrefix='root'] - The prefix to use for the id\r\n * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n * @returns - The `IdSchema` object for the `schema`\r\n */\r\nexport default function toIdSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  id?: string | null,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  idPrefix = 'root',\r\n  idSeparator = '_'\r\n): IdSchema<T> {\r\n  return toIdSchemaInternal<T, S, F>(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\nimport set from 'lodash/set';\r\n\r\nimport {\r\n  ALL_OF_KEY,\r\n  ANY_OF_KEY,\r\n  ADDITIONAL_PROPERTIES_KEY,\r\n  DEPENDENCIES_KEY,\r\n  ITEMS_KEY,\r\n  NAME_KEY,\r\n  ONE_OF_KEY,\r\n  PROPERTIES_KEY,\r\n  REF_KEY,\r\n  RJSF_ADDITONAL_PROPERTIES_FLAG,\r\n} from '../constants';\r\nimport getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';\r\nimport { FormContextType, PathSchema, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';\r\nimport getClosestMatchingOption from './getClosestMatchingOption';\r\nimport retrieveSchema from './retrieveSchema';\r\n\r\n/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against\r\n * infinite recursion\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nfunction toPathSchemaInternal<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name: string,\r\n  rootSchema?: S,\r\n  formData?: T,\r\n  _recurseList: S[] = []\r\n): PathSchema<T> {\r\n  if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {\r\n    const _schema = retrieveSchema<T, S, F>(validator, schema, rootSchema, formData);\r\n    const sameSchemaIndex = _recurseList.findIndex((item) => isEqual(item, _schema));\r\n    if (sameSchemaIndex === -1) {\r\n      return toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        _schema,\r\n        name,\r\n        rootSchema,\r\n        formData,\r\n        _recurseList.concat(_schema)\r\n      );\r\n    }\r\n  }\r\n\r\n  let pathSchema: PathSchema = {\r\n    [NAME_KEY]: name.replace(/^\\./, ''),\r\n  } as PathSchema;\r\n\r\n  if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {\r\n    const xxxOf: S[] = ONE_OF_KEY in schema ? (schema.oneOf as S[]) : (schema.anyOf as S[]);\r\n    const discriminator = getDiscriminatorFieldFromSchema<S>(schema);\r\n    const index = getClosestMatchingOption<T, S, F>(validator, rootSchema!, formData, xxxOf, 0, discriminator);\r\n    const _schema: S = xxxOf![index] as S;\r\n    pathSchema = {\r\n      ...pathSchema,\r\n      ...toPathSchemaInternal<T, S, F>(validator, _schema, name, rootSchema, formData, _recurseList),\r\n    };\r\n  }\r\n\r\n  if (ADDITIONAL_PROPERTIES_KEY in schema && schema[ADDITIONAL_PROPERTIES_KEY] !== false) {\r\n    set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);\r\n  }\r\n\r\n  if (ITEMS_KEY in schema && Array.isArray(formData)) {\r\n    const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;\r\n\r\n    if (Array.isArray(schemaItems)) {\r\n      formData.forEach((element, i: number) => {\r\n        if (schemaItems[i]) {\r\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n            validator,\r\n            schemaItems[i] as S,\r\n            `${name}.${i}`,\r\n            rootSchema,\r\n            element,\r\n            _recurseList\r\n          );\r\n        } else if (schemaAdditionalItems) {\r\n          pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n            validator,\r\n            schemaAdditionalItems as S,\r\n            `${name}.${i}`,\r\n            rootSchema,\r\n            element,\r\n            _recurseList\r\n          );\r\n        } else {\r\n          console.warn(`Unable to generate path schema for \"${name}.${i}\". No schema defined for it`);\r\n        }\r\n      });\r\n    } else {\r\n      formData.forEach((element, i: number) => {\r\n        pathSchema[i] = toPathSchemaInternal<T, S, F>(\r\n          validator,\r\n          schemaItems as S,\r\n          `${name}.${i}`,\r\n          rootSchema,\r\n          element,\r\n          _recurseList\r\n        );\r\n      });\r\n    }\r\n  } else if (PROPERTIES_KEY in schema) {\r\n    for (const property in schema.properties) {\r\n      const field = get(schema, [PROPERTIES_KEY, property]);\r\n      pathSchema[property] = toPathSchemaInternal<T, S, F>(\r\n        validator,\r\n        field,\r\n        `${name}.${property}`,\r\n        rootSchema,\r\n        // It's possible that formData is not an object -- this can happen if an\r\n        // array item has just been added, but not populated with data yet\r\n        get(formData, [property]),\r\n        _recurseList\r\n      );\r\n    }\r\n  }\r\n  return pathSchema as PathSchema<T>;\r\n}\r\n\r\n/** Generates an `PathSchema` object for the `schema`, recursively\r\n *\r\n * @param validator - An implementation of the `ValidatorType` interface that will be used when necessary\r\n * @param schema - The schema for which the `PathSchema` is desired\r\n * @param [name=''] - The base name for the schema\r\n * @param [rootSchema] - The root schema, used to primarily to look up `$ref`s\r\n * @param [formData] - The current formData, if any, to assist retrieving a schema\r\n * @returns - The `PathSchema` object for the `schema`\r\n */\r\nexport default function toPathSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ValidatorType<T, S, F>,\r\n  schema: S,\r\n  name = '',\r\n  rootSchema?: S,\r\n  formData?: T\r\n): PathSchema<T> {\r\n  return toPathSchemaInternal(validator, schema, name, rootSchema, formData);\r\n}\r\n", "import deepEquals from './deepEquals';\r\nimport {\r\n  ErrorSchema,\r\n  Experimental_DefaultFormStateBehavior,\r\n  FormContextType,\r\n  GlobalUISchemaOptions,\r\n  IdSchema,\r\n  PathSchema,\r\n  RJSFSchema,\r\n  SchemaUtilsType,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from './types';\r\nimport {\r\n  getDefaultFormState,\r\n  getDisplayLabel,\r\n  getClosestMatchingOption,\r\n  getFirstMatchingOption,\r\n  getMatchingOption,\r\n  isFilesArray,\r\n  isMultiSelect,\r\n  isSelect,\r\n  mergeValidationData,\r\n  retrieveSchema,\r\n  sanitizeDataForNewSchema,\r\n  toIdSchema,\r\n  toPathSchema,\r\n} from './schema';\r\n\r\n/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such\r\n * that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.\r\n * Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the\r\n * `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.\r\n */\r\nclass SchemaUtils<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements SchemaUtilsType<T, S, F>\r\n{\r\n  rootSchema: S;\r\n  validator: ValidatorType<T, S, F>;\r\n  experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior;\r\n\r\n  /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n   * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n   * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior\r\n   */\r\n  constructor(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior: Experimental_DefaultFormStateBehavior\r\n  ) {\r\n    this.rootSchema = rootSchema;\r\n    this.validator = validator;\r\n    this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;\r\n  }\r\n\r\n  /** Returns the `ValidatorType` in the `SchemaUtilsType`\r\n   *\r\n   * @returns - The `ValidatorType`\r\n   */\r\n  getValidator() {\r\n    return this.validator;\r\n  }\r\n\r\n  /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of\r\n   * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation\r\n   * of a new `SchemaUtilsType` with incomplete properties.\r\n   *\r\n   * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one\r\n   * @param rootSchema - The root schema that will be compared against the current one\r\n   * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n   * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`\r\n   */\r\n  doesSchemaUtilsDiffer(\r\n    validator: ValidatorType<T, S, F>,\r\n    rootSchema: S,\r\n    experimental_defaultFormStateBehavior = {}\r\n  ): boolean {\r\n    if (!validator || !rootSchema) {\r\n      return false;\r\n    }\r\n    return (\r\n      this.validator !== validator ||\r\n      !deepEquals(this.rootSchema, rootSchema) ||\r\n      !deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior)\r\n    );\r\n  }\r\n\r\n  /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have\r\n   * computed to have defaults provided in the `schema`.\r\n   *\r\n   * @param schema - The schema for which the default state is desired\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.\r\n   *          If \"excludeObjectChildren\", pass `includeUndefinedValues` as false when computing defaults for any nested\r\n   *          object properties.\r\n   * @returns - The resulting `formData` with all the defaults provided\r\n   */\r\n  getDefaultFormState(\r\n    schema: S,\r\n    formData?: T,\r\n    includeUndefinedValues: boolean | 'excludeObjectChildren' = false\r\n  ): T | T[] | undefined {\r\n    return getDefaultFormState<T, S, F>(\r\n      this.validator,\r\n      schema,\r\n      formData,\r\n      this.rootSchema,\r\n      includeUndefinedValues,\r\n      this.experimental_defaultFormStateBehavior\r\n    );\r\n  }\r\n\r\n  /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`\r\n   * should be displayed in a UI.\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [uiSchema] - The UI schema from which to derive potentially displayable information\r\n   * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options\r\n   * @returns - True if the label should be displayed or false if it should not\r\n   */\r\n  getDisplayLabel(schema: S, uiSchema?: UiSchema<T, S, F>, globalOptions?: GlobalUISchemaOptions) {\r\n    return getDisplayLabel<T, S, F>(this.validator, schema, uiSchema, this.rootSchema, globalOptions);\r\n  }\r\n\r\n  /** Determines which of the given `options` provided most closely matches the `formData`.\r\n   * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.\r\n   *\r\n   * The closest match is determined using the number of matching properties, and more heavily favors options with\r\n   * matching readOnly, default, or const values.\r\n   *\r\n   * @param formData - The form data associated with the schema\r\n   * @param options - The list of options that can be selected from\r\n   * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match\r\n   */\r\n  getClosestMatchingOption(\r\n    formData: T | undefined,\r\n    options: S[],\r\n    selectedOption?: number,\r\n    discriminatorField?: string\r\n  ): number {\r\n    return getClosestMatchingOption<T, S, F>(\r\n      this.validator,\r\n      this.rootSchema,\r\n      formData,\r\n      options,\r\n      selectedOption,\r\n      discriminatorField\r\n    );\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.\r\n   * Always returns the first option if there is nothing that matches.\r\n   *\r\n   * @param formData - The current formData, if any, used to figure out a match\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The firstindex of the matched option or 0 if none is available\r\n   */\r\n  getFirstMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string): number {\r\n    return getFirstMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.\r\n   * Deprecated, use `getFirstMatchingOption()` instead.\r\n   *\r\n   * @param formData - The current formData, if any, onto which to provide any missing defaults\r\n   * @param options - The list of options to find a matching options from\r\n   * @param [discriminatorField] - The optional name of the field within the options object whose value is used to\r\n   *          determine which option is selected\r\n   * @returns - The index of the matched option or 0 if none is available\r\n   * @deprecated\r\n   */\r\n  getMatchingOption(formData: T | undefined, options: S[], discriminatorField?: string) {\r\n    return getMatchingOption<T, S, F>(this.validator, formData, options, this.rootSchema, discriminatorField);\r\n  }\r\n\r\n  /** Checks to see if the `schema` and `uiSchema` combination represents an array of files\r\n   *\r\n   * @param schema - The schema for which check for array of files flag is desired\r\n   * @param [uiSchema] - The UI schema from which to check the widget\r\n   * @returns - True if schema/uiSchema contains an array of files, otherwise false\r\n   */\r\n  isFilesArray(schema: S, uiSchema?: UiSchema<T, S, F>) {\r\n    return isFilesArray<T, S, F>(this.validator, schema, uiSchema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a multi-select\r\n   *\r\n   * @param schema - The schema for which check for a multi-select flag is desired\r\n   * @returns - True if schema contains a multi-select, otherwise false\r\n   */\r\n  isMultiSelect(schema: S) {\r\n    return isMultiSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Checks to see if the `schema` combination represents a select\r\n   *\r\n   * @param schema - The schema for which check for a select flag is desired\r\n   * @returns - True if schema contains a select, otherwise false\r\n   */\r\n  isSelect(schema: S) {\r\n    return isSelect<T, S, F>(this.validator, schema, this.rootSchema);\r\n  }\r\n\r\n  /** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in\r\n   * the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n   * `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,\r\n   * then `validationData` is returned.\r\n   *\r\n   * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n   * @param [additionalErrorSchema] - The additional set of errors\r\n   * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n   * @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be\r\n   *        removed in the next major release.\r\n   */\r\n  mergeValidationData(validationData: ValidationData<T>, additionalErrorSchema?: ErrorSchema<T>): ValidationData<T> {\r\n    return mergeValidationData<T, S, F>(this.validator, validationData, additionalErrorSchema);\r\n  }\r\n\r\n  /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and\r\n   * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially\r\n   * recursive resolution.\r\n   *\r\n   * @param schema - The schema for which retrieving a schema is desired\r\n   * @param [rawFormData] - The current formData, if any, to assist retrieving a schema\r\n   * @returns - The schema having its conditions, additional properties, references and dependencies resolved\r\n   */\r\n  retrieveSchema(schema: S, rawFormData?: T) {\r\n    return retrieveSchema<T, S, F>(this.validator, schema, this.rootSchema, rawFormData);\r\n  }\r\n\r\n  /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the\r\n   * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the\r\n   * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the\r\n   * old schemas that are non-existent in the new schema are set to `undefined`.\r\n   *\r\n   * @param [newSchema] - The new schema for which the data is being sanitized\r\n   * @param [oldSchema] - The old schema from which the data originated\r\n   * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined\r\n   * @returns - The new form data, with all the fields uniquely associated with the old schema set\r\n   *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.\r\n   */\r\n  sanitizeDataForNewSchema(newSchema?: S, oldSchema?: S, data?: any): T {\r\n    return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);\r\n  }\r\n\r\n  /** Generates an `IdSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [id] - The base id for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @param [idPrefix='root'] - The prefix to use for the id\r\n   * @param [idSeparator='_'] - The separator to use for the path segments in the id\r\n   * @returns - The `IdSchema` object for the `schema`\r\n   */\r\n  toIdSchema(schema: S, id?: string | null, formData?: T, idPrefix = 'root', idSeparator = '_'): IdSchema<T> {\r\n    return toIdSchema<T, S, F>(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);\r\n  }\r\n\r\n  /** Generates an `PathSchema` object for the `schema`, recursively\r\n   *\r\n   * @param schema - The schema for which the display label flag is desired\r\n   * @param [name] - The base name for the schema\r\n   * @param [formData] - The current formData, if any, onto which to provide any missing defaults\r\n   * @returns - The `PathSchema` object for the `schema`\r\n   */\r\n  toPathSchema(schema: S, name?: string, formData?: T): PathSchema<T> {\r\n    return toPathSchema<T, S, F>(this.validator, schema, name, this.rootSchema, formData);\r\n  }\r\n}\r\n\r\n/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The\r\n * resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.\r\n *\r\n * @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs\r\n * @param rootSchema - The root schema that will be forwarded to all the APIs\r\n * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior\r\n * @returns - An implementation of a `SchemaUtilsType` interface\r\n */\r\nexport default function createSchemaUtils<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  validator: ValidatorType<T, S, F>,\r\n  rootSchema: S,\r\n  experimental_defaultFormStateBehavior = {}\r\n): SchemaUtilsType<T, S, F> {\r\n  return new SchemaUtils<T, S, F>(validator, rootSchema, experimental_defaultFormStateBehavior);\r\n}\r\n", "/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name\r\n * of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.\r\n *\r\n * @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob\r\n * @returns - an object containing a Blob and its name, extracted from the URI\r\n */\r\nexport default function dataURItoBlob(dataURI: string) {\r\n  // Split metadata from data\r\n  const splitted: string[] = dataURI.split(',');\r\n  // Split params\r\n  const params: string[] = splitted[0].split(';');\r\n  // Get mime-type from params\r\n  const type: string = params[0].replace('data:', '');\r\n  // Filter the name property from params\r\n  const properties = params.filter((param) => {\r\n    return param.split('=')[0] === 'name';\r\n  });\r\n  // Look for the name and use unknown if no name property.\r\n  let name: string;\r\n  if (properties.length !== 1) {\r\n    name = 'unknown';\r\n  } else {\r\n    // Because we filtered out the other property,\r\n    // we only have the name case here, which we decode to make it human-readable\r\n    name = decodeURI(properties[0].split('=')[1]);\r\n  }\r\n\r\n  // Built the Uint8Array Blob parameter from the base64 string.\r\n  try {\r\n    const binary = atob(splitted[1]);\r\n    const array = [];\r\n    for (let i = 0; i < binary.length; i++) {\r\n      array.push(binary.charCodeAt(i));\r\n    }\r\n    // Create the blob object\r\n    const blob = new window.Blob([new Uint8Array(array)], { type });\r\n\r\n    return { blob, name };\r\n  } catch (error) {\r\n    return { blob: { size: 0, type: (error as Error).message }, name: dataURI };\r\n  }\r\n}\r\n", "/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When\r\n * a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the\r\n * `inputString` using the `%1`, `%2`, etc. replacement specifiers.\r\n *\r\n * @param inputString - The string which will be potentially updated with replacement parameters\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The updated string with any replacement specifiers replaced\r\n */\r\nexport default function replaceStringParameters(inputString: string, params?: string[]) {\r\n  let output = inputString;\r\n  if (Array.isArray(params)) {\r\n    const parts = output.split(/(%\\d)/);\r\n    params.forEach((param, index) => {\r\n      const partIndex = parts.findIndex((part) => part === `%${index + 1}`);\r\n      if (partIndex >= 0) {\r\n        parts[partIndex] = param;\r\n      }\r\n    });\r\n    output = parts.join('');\r\n  }\r\n  return output;\r\n}\r\n", "import { TranslatableString } from './enums';\r\nimport replaceStringParameters from './replaceStringParameters';\r\n\r\n/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each\r\n * value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,\r\n * `%2`, etc. replacement specifiers.\r\n *\r\n * @param stringToTranslate - The `TranslatableString` value to convert to english\r\n * @param params - The optional list of replaceable parameter values to substitute into the english string\r\n * @returns - The `stringToTranslate` itself with any replaceable parameter values substituted\r\n */\r\nexport default function englishStringTranslator(stringToTranslate: TranslatableString, params?: string[]): string {\r\n  return replaceStringParameters(stringToTranslate, params);\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\n\r\n/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is\r\n * a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is\r\n * a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined\r\n * is returned, otherwise the `selected` value is returned.\r\n *\r\n * @param valueIndex - The index of the value to be removed from the selected list or single value\r\n * @param selected - The current (list of) selected value(s)\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,\r\n *        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns\r\n *        undefined, otherwise `selected`.\r\n */\r\nexport default function enumOptionsDeselectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected?: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (Array.isArray(selected)) {\r\n    return selected.filter((v) => !isEqual(v, value));\r\n  }\r\n  return isEqual(value, selected) ? undefined : selected;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an\r\n * array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it\r\n * contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only\r\n * valid values or in the worst case, an empty array.\r\n *\r\n * @param valueIndex - The index(es) of the value(s) that should be returned\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option\r\n * @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,\r\n *        `emptyValue` or an empty list.\r\n */\r\nexport default function enumOptionsValueForIndex<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number | Array<string | number>,\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  emptyValue?: EnumOptionsType<S>['value']\r\n): EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][] | undefined {\r\n  if (Array.isArray(valueIndex)) {\r\n    return valueIndex.map((index) => enumOptionsValueForIndex(index, allEnumOptions)).filter((val) => val);\r\n  }\r\n  // So Number(null) and Number('') both return 0, so use emptyValue for those two values\r\n  const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);\r\n  const option = allEnumOptions[index];\r\n  return option ? option.value : emptyValue;\r\n}\r\n", "import isEqual from 'lodash/isEqual';\r\n\r\nimport { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Determines whether the given `value` is (one of) the `selected` value(s).\r\n *\r\n * @param value - The value being checked to see if it is selected\r\n * @param selected - The current selected value or list of values\r\n * @returns - true if the `value` is one of the `selected` ones, false otherwise\r\n */\r\nexport default function enumOptionsIsSelected<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'],\r\n  selected: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][]\r\n) {\r\n  if (Array.isArray(selected)) {\r\n    return selected.some((sel) => isEqual(sel, value));\r\n  }\r\n  return isEqual(selected, value);\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsIsSelected from './enumOptionsIsSelected';\r\n\r\n/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the\r\n * `enumOptions` are filtered based on whether they are a \"selected\" `value` and the index of each selected one is then\r\n * stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is\r\n * returned.\r\n *\r\n * @param value - The single value or list of values for which indexes are desired\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one\r\n * @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list\r\n *        of indexes for (each of) the value(s) in `value`.\r\n */\r\nexport default function enumOptionsIndexForValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  value: EnumOptionsType<S>['value'] | EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = [],\r\n  multiple = false\r\n): string | string[] | undefined {\r\n  const selectedIndexes: string[] = allEnumOptions\r\n    .map((opt, index) => (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))\r\n    .filter((opt) => typeof opt !== 'undefined') as string[];\r\n  if (!multiple) {\r\n    return selectedIndexes[0];\r\n  }\r\n  return selectedIndexes;\r\n}\r\n", "import { EnumOptionsType, RJSFSchema, StrictRJSFSchema } from './types';\r\nimport enumOptionsValueForIndex from './enumOptionsValueForIndex';\r\nimport isNil from 'lodash/isNil';\r\n\r\n/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by\r\n * `allEnumOptions`\r\n *\r\n * @param valueIndex - The index of the value that should be selected\r\n * @param selected - The current list of selected values\r\n * @param [allEnumOptions=[]] - The list of all the known enumOptions\r\n * @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it\r\n */\r\nexport default function enumOptionsSelectValue<S extends StrictRJSFSchema = RJSFSchema>(\r\n  valueIndex: string | number,\r\n  selected: EnumOptionsType<S>['value'][],\r\n  allEnumOptions: EnumOptionsType<S>[] = []\r\n) {\r\n  const value = enumOptionsValueForIndex<S>(valueIndex, allEnumOptions);\r\n  if (!isNil(value)) {\r\n    const index = allEnumOptions.findIndex((opt) => value === opt.value);\r\n    const all = allEnumOptions.map(({ value: val }) => val);\r\n    const updated = selected.slice(0, index).concat(value, selected.slice(index));\r\n    // As inserting values at predefined index positions doesn't work with empty\r\n    // arrays, we need to reorder the updated selection to match the initial order\r\n    return updated.sort((a, b) => Number(all.indexOf(a) > all.indexOf(b)));\r\n  }\r\n  return selected;\r\n}\r\n", "import cloneDeep from 'lodash/cloneDeep';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { ErrorSchema } from './types';\r\nimport { ERRORS_KEY } from './constants';\r\n\r\n/** The `ErrorSchemaBuilder<T>` is used to build an `ErrorSchema<T>` since the definition of the `ErrorSchema` type is\r\n * designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error\r\n * schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can\r\n * get the result and/or reset all the errors back to an initial set and start again.\r\n */\r\nexport default class ErrorSchemaBuilder<T = any> {\r\n  /** The error schema being built\r\n   *\r\n   * @private\r\n   */\r\n  private errorSchema: ErrorSchema<T> = {};\r\n\r\n  /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   */\r\n  constructor(initialSchema?: ErrorSchema<T>) {\r\n    this.resetAllErrors(initialSchema);\r\n  }\r\n\r\n  /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`\r\n   */\r\n  get ErrorSchema() {\r\n    return this.errorSchema;\r\n  }\r\n\r\n  /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The error block for the given `pathOfError` or the root if not provided\r\n   * @private\r\n   */\r\n  private getOrCreateErrorBlock(pathOfError?: string | string[]) {\r\n    const hasPath = (Array.isArray(pathOfError) && pathOfError.length > 0) || typeof pathOfError === 'string';\r\n    let errorBlock: ErrorSchema = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;\r\n    if (!errorBlock && pathOfError) {\r\n      errorBlock = {};\r\n      set(this.errorSchema, pathOfError, errorBlock);\r\n    }\r\n    return errorBlock;\r\n  }\r\n\r\n  /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.\r\n   *\r\n   * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  resetAllErrors(initialSchema?: ErrorSchema<T>) {\r\n    this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};\r\n    return this;\r\n  }\r\n\r\n  /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within\r\n   * the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to add into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  addErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    let errorsList = get(errorBlock, ERRORS_KEY);\r\n    if (!Array.isArray(errorsList)) {\r\n      errorsList = [];\r\n      errorBlock[ERRORS_KEY] = errorsList;\r\n    }\r\n\r\n    if (Array.isArray(errorOrList)) {\r\n      errorsList.push(...errorOrList);\r\n    } else {\r\n      errorsList.push(errorOrList);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location\r\n   * within the schema described by the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param errorOrList - The error or list of errors to set into the `ErrorSchema`\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  setErrors(errorOrList: string | string[], pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    // Effectively clone the array being given to prevent accidental outside manipulation of the given list\r\n    const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];\r\n    set(errorBlock, ERRORS_KEY, listToAdd);\r\n    return this;\r\n  }\r\n\r\n  /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by\r\n   * the `pathOfError`. For more information about how to specify the path see the\r\n   * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).\r\n   *\r\n   * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)\r\n   * @returns - The `ErrorSchemaBuilder` object for chaining purposes\r\n   */\r\n  clearErrors(pathOfError?: string | string[]) {\r\n    const errorBlock: ErrorSchema = this.getOrCreateErrorBlock(pathOfError);\r\n    set(errorBlock, ERRORS_KEY, []);\r\n    return this;\r\n  }\r\n}\r\n", "import { RangeSpecType, StrictRJSFSchema } from './types';\r\nimport { RJSFSchema } from './types';\r\n\r\n/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML\r\n * input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.\r\n *\r\n * @param schema - The schema from which to extract the range spec\r\n * @returns - A range specification from the schema\r\n */\r\nexport default function rangeSpec<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const spec: RangeSpecType = {};\r\n  if (schema.multipleOf) {\r\n    spec.step = schema.multipleOf;\r\n  }\r\n  if (schema.minimum || schema.minimum === 0) {\r\n    spec.min = schema.minimum;\r\n  }\r\n  if (schema.maximum || schema.maximum === 0) {\r\n    spec.max = schema.maximum;\r\n  }\r\n  return spec;\r\n}\r\n", "import rangeSpec from './rangeSpec';\r\nimport { FormContextType, InputPropsType, RJSFSchema, StrictRJSFSchema, UIOptionsType } from './types';\r\n\r\n/** Using the `schema`, `defaultType` and `options`, extract out the props for the <input> element that make sense.\r\n *\r\n * @param schema - The schema for the field provided by the widget\r\n * @param [defaultType] - The default type, if any, for the field provided by the widget\r\n * @param [options={}] - The UI Options for the field provided by the widget\r\n * @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step\r\n * @returns - The extracted `InputPropsType` object\r\n */\r\nexport default function getInputProps<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(\r\n  schema: RJSFSchema,\r\n  defaultType?: string,\r\n  options: UIOptionsType<T, S, F> = {},\r\n  autoDefaultStepAny = true\r\n): InputPropsType {\r\n  const inputProps: InputPropsType = {\r\n    type: defaultType || 'text',\r\n    ...rangeSpec(schema),\r\n  };\r\n\r\n  // If options.inputType is set use that as the input type\r\n  if (options.inputType) {\r\n    inputProps.type = options.inputType;\r\n  } else if (!defaultType) {\r\n    // If the schema is of type number or integer, set the input type to number\r\n    if (schema.type === 'number') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined and we are auto-defaulting the \"any\" step\r\n      if (autoDefaultStepAny && inputProps.step === undefined) {\r\n        // Setting step to 'any' fixes a bug in Safari where decimals are not\r\n        // allowed in number inputs\r\n        inputProps.step = 'any';\r\n      }\r\n    } else if (schema.type === 'integer') {\r\n      inputProps.type = 'number';\r\n      // Only add step if one isn't already defined\r\n      if (inputProps.step === undefined) {\r\n        // Since this is integer, you always want to step up or down in multiples of 1\r\n        inputProps.step = 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (options.autocomplete) {\r\n    inputProps.autoComplete = options.autocomplete;\r\n  }\r\n\r\n  return inputProps;\r\n}\r\n", "import { SUBMIT_BTN_OPTIONS_KEY } from './constants';\r\nimport getUiOptions from './getUiOptions';\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema, UiSchema, UISchemaSubmitButtonOptions } from './types';\r\n\r\n/** The default submit button options, exported for testing purposes\r\n */\r\nexport const DEFAULT_OPTIONS: UISchemaSubmitButtonOptions = {\r\n  props: {\r\n    disabled: false,\r\n  },\r\n  submitText: 'Submit',\r\n  norender: false,\r\n};\r\n\r\n/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`\r\n *\r\n * @param [uiSchema={}] - the UI Schema from which to extract submit button props\r\n * @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones\r\n */\r\nexport default function getSubmitButtonOptions<\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(uiSchema: UiSchema<T, S, F> = {}): UISchemaSubmitButtonOptions {\r\n  const uiOptions = getUiOptions<T, S, F>(uiSchema);\r\n  if (uiOptions && uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {\r\n    const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY] as UISchemaSubmitButtonOptions;\r\n    return { ...DEFAULT_OPTIONS, ...options };\r\n  }\r\n\r\n  return DEFAULT_OPTIONS;\r\n}\r\n", "import { FormContextType, TemplatesType, Registry, UIOptionsType, StrictRJSFSchema, RJSFSchema } from './types';\r\n\r\n/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`\r\n * otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.\r\n *\r\n * @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`\r\n * @param registry - The `Registry` from which to read the template\r\n * @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template\r\n * @returns - The template from either the `uiSchema` or `registry` for the `name`\r\n */\r\nexport default function getTemplate<\r\n  Name extends keyof TemplatesType<T, S, F>,\r\n  T = any,\r\n  S extends StrictRJSFSchema = RJSFSchema,\r\n  F extends FormContextType = any\r\n>(name: Name, registry: Registry<T, S, F>, uiOptions: UIOptionsType<T, S, F> = {}): TemplatesType<T, S, F>[Name] {\r\n  const { templates } = registry;\r\n  if (name === 'ButtonTemplates') {\r\n    return templates[name];\r\n  }\r\n  return (\r\n    // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent\r\n    // To avoid that, we cast uiOptions to `any` before accessing the name field\r\n    ((uiOptions as any)[name] as TemplatesType<T, S, F>[Name]) || templates[name]\r\n  );\r\n}\r\n", "import { createElement } from 'react';\r\nimport ReactIs from 'react-is';\r\nimport get from 'lodash/get';\r\nimport set from 'lodash/set';\r\n\r\nimport { FormContextType, RJSFSchema, Widget, RegistryWidgetsType, StrictRJSFSchema } from './types';\r\nimport getSchemaType from './getSchemaType';\r\n\r\n/** The map of schema types to widget type to widget name\r\n */\r\nconst widgetMap: { [k: string]: { [j: string]: string } } = {\r\n  boolean: {\r\n    checkbox: 'CheckboxWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  string: {\r\n    text: 'TextWidget',\r\n    password: 'PasswordWidget',\r\n    email: 'EmailWidget',\r\n    hostname: 'TextWidget',\r\n    ipv4: 'TextWidget',\r\n    ipv6: 'TextWidget',\r\n    uri: 'URLWidget',\r\n    'data-url': 'FileWidget',\r\n    radio: 'RadioWidget',\r\n    select: 'SelectWidget',\r\n    textarea: 'TextareaWidget',\r\n    hidden: 'HiddenWidget',\r\n    date: 'DateWidget',\r\n    datetime: 'DateTimeWidget',\r\n    'date-time': 'DateTimeWidget',\r\n    'alt-date': 'AltDateWidget',\r\n    'alt-datetime': 'AltDateTimeWidget',\r\n    time: 'TimeWidget',\r\n    color: 'ColorWidget',\r\n    file: 'FileWidget',\r\n  },\r\n  number: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  integer: {\r\n    text: 'TextWidget',\r\n    select: 'SelectWidget',\r\n    updown: 'UpDownWidget',\r\n    range: 'RangeWidget',\r\n    radio: 'RadioWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n  array: {\r\n    select: 'SelectWidget',\r\n    checkboxes: 'CheckboxesWidget',\r\n    files: 'FileWidget',\r\n    hidden: 'HiddenWidget',\r\n  },\r\n};\r\n\r\n/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the\r\n * `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the\r\n * `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.\r\n *\r\n * @param AWidget - A widget that will be wrapped or one that is already wrapped\r\n * @returns - The wrapper widget\r\n */\r\nfunction mergeWidgetOptions<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  AWidget: Widget<T, S, F>\r\n) {\r\n  let MergedWidget: Widget<T, S, F> | undefined = get(AWidget, 'MergedWidget');\r\n  // cache return value as property of widget for proper react reconciliation\r\n  if (!MergedWidget) {\r\n    const defaultOptions = (AWidget.defaultProps && AWidget.defaultProps.options) || {};\r\n    MergedWidget = ({ options, ...props }) => {\r\n      return <AWidget options={{ ...defaultOptions, ...options }} {...props} />;\r\n    };\r\n    set(AWidget, 'MergedWidget', MergedWidget);\r\n  }\r\n  return MergedWidget;\r\n}\r\n\r\n/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the\r\n * React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped\r\n * with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based\r\n * on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.\r\n *\r\n * @param schema - The schema for the field\r\n * @param [widget] - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - The `Widget` component to use\r\n * @throws - An error if there is no `Widget` component that can be returned\r\n */\r\nexport default function getWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget?: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n): Widget<T, S, F> {\r\n  const type = getSchemaType(schema);\r\n\r\n  if (\r\n    typeof widget === 'function' ||\r\n    (widget && ReactIs.isForwardRef(createElement(widget))) ||\r\n    ReactIs.isMemo(widget)\r\n  ) {\r\n    return mergeWidgetOptions<T, S, F>(widget as Widget<T, S, F>);\r\n  }\r\n\r\n  if (typeof widget !== 'string') {\r\n    throw new Error(`Unsupported widget definition: ${typeof widget}`);\r\n  }\r\n\r\n  if (widget in registeredWidgets) {\r\n    const registeredWidget = registeredWidgets[widget];\r\n    return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n  }\r\n\r\n  if (typeof type === 'string') {\r\n    if (!(type in widgetMap)) {\r\n      throw new Error(`No widget for type '${type}'`);\r\n    }\r\n\r\n    if (widget in widgetMap[type]) {\r\n      const registeredWidget = registeredWidgets[widgetMap[type][widget]];\r\n      return getWidget<T, S, F>(schema, registeredWidget, registeredWidgets);\r\n    }\r\n  }\r\n\r\n  throw new Error(`No widget '${widget}' for type '${type}'`);\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** JS has no built-in hashing function, so rolling our own\r\n *  based on Java's hashing fn:\r\n *  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html\r\n *\r\n * @param string - The string for which to get the hash\r\n * @returns - The resulting hash of the string in hex format\r\n */\r\nfunction hashString(string: string): string {\r\n  let hash = 0;\r\n  for (let i = 0; i < string.length; i += 1) {\r\n    const chr = string.charCodeAt(i);\r\n    hash = (hash << 5) - hash + chr;\r\n    hash = hash & hash; // Convert to 32bit integer\r\n  }\r\n  return hash.toString(16);\r\n}\r\n\r\n/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields\r\n * in consistent order before stringify to prevent different hash ids for the same schema.\r\n *\r\n * @param schema - The schema for which the hash is desired\r\n * @returns - The string obtained from the hash of the stringified schema\r\n */\r\nexport default function hashForSchema<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  const allKeys = new Set<string>();\r\n  // solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328\r\n  JSON.stringify(schema, (key, value) => (allKeys.add(key), value));\r\n  return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));\r\n}\r\n", "import getWidget from './getWidget';\r\nimport { FormContextType, RegistryWidgetsType, RJSFSchema, StrictRJSFSchema, Widget } from './types';\r\n\r\n/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it\r\n * does, or false if it doesn't.\r\n *\r\n * @param schema - The schema for the field\r\n * @param widget - Either the name of the widget OR a `Widget` implementation to use\r\n * @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation\r\n * @returns - True if the widget exists, false otherwise\r\n */\r\nexport default function hasWidget<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  schema: RJSFSchema,\r\n  widget: Widget<T, S, F> | string,\r\n  registeredWidgets: RegistryWidgetsType<T, S, F> = {}\r\n) {\r\n  try {\r\n    getWidget(schema, widget, registeredWidgets);\r\n    return true;\r\n  } catch (e) {\r\n    const err: Error = e as Error;\r\n    if (err.message && (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {\r\n      return false;\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n", "import isString from 'lodash/isString';\r\n\r\nimport { IdSchema } from './types';\r\nimport { ID_KEY } from './constants';\r\n\r\n/** Generates a consistent `id` pattern for a given `id` and a `suffix`\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param suffix - The suffix to append to the id\r\n */\r\nfunction idGenerator<T = any>(id: IdSchema<T> | string, suffix: string) {\r\n  const theId = isString(id) ? id : id[ID_KEY];\r\n  return `${theId}__${suffix}`;\r\n}\r\n/** Return a consistent `id` for the field description element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field description element from the given `id`\r\n */\r\nexport function descriptionId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'description');\r\n}\r\n\r\n/** Return a consistent `id` for the field error element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field error element from the given `id`\r\n */\r\nexport function errorId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'error');\r\n}\r\n\r\n/** Return a consistent `id` for the field examples element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field examples element from the given `id`\r\n */\r\nexport function examplesId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'examples');\r\n}\r\n\r\n/** Return a consistent `id` for the field help element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field help element from the given `id`\r\n */\r\nexport function helpId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'help');\r\n}\r\n\r\n/** Return a consistent `id` for the field title element\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @returns - The consistent id for the field title element from the given `id`\r\n */\r\nexport function titleId<T = any>(id: IdSchema<T> | string) {\r\n  return idGenerator<T>(id, 'title');\r\n}\r\n\r\n/** Return a list of element ids that contain additional information about the field that can be used to as the aria\r\n * description of the field. This is correctly omitting `titleId` which would be \"labeling\" rather than \"describing\" the\r\n * element.\r\n *\r\n * @param id - Either simple string id or an IdSchema from which to extract it\r\n * @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list\r\n * @returns - The string containing the list of ids for use in an `aria-describedBy` attribute\r\n */\r\nexport function ariaDescribedByIds<T = any>(id: IdSchema<T> | string, includeExamples = false) {\r\n  const examples = includeExamples ? ` ${examplesId<T>(id)}` : '';\r\n  return `${errorId<T>(id)} ${descriptionId<T>(id)} ${helpId<T>(id)}${examples}`;\r\n}\r\n\r\n/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget\r\n *\r\n * @param id - The id of the parent component for the option\r\n * @param optionIndex - The index of the option for which the id is desired\r\n * @returns - An id for the option index based on the parent `id`\r\n */\r\nexport function optionId(id: string, optionIndex: number) {\r\n  return `${id}-${optionIndex}`;\r\n}\r\n", "import { ReactElement } from 'react';\r\n\r\n/** Helper function that will return the value to use for a widget `label` based on `hideLabel`. The `fallback` is used\r\n * as the return value from the function when `hideLabel` is true. Due to the implementation of theme components, it\r\n * may be necessary to return something other than `undefined` to cause the theme component to not render a label. Some\r\n * themes require may `false` and others may require an empty string.\r\n *\r\n * @param [label] - The label string or component to render when not hidden\r\n * @param [hideLabel] - Flag, if true, will cause the label to be hidden\r\n * @param [fallback] - One of 3 values, `undefined` (the default), `false` or an empty string\r\n * @returns - `fallback` if `hideLabel` is true, otherwise `label`\r\n */\r\n\r\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: ''): undefined | string;\r\nexport default function labelValue(label?: string, hideLabel?: boolean, fallback?: false): undefined | false | string;\r\nexport default function labelValue(label?: ReactElement, hideLabel?: boolean, fallback?: ''): undefined | ReactElement;\r\nexport default function labelValue(\r\n  label?: ReactElement,\r\n  hideLabel?: boolean,\r\n  fallback?: false\r\n): undefined | false | ReactElement;\r\nexport default function labelValue(\r\n  label?: string | ReactElement,\r\n  hideLabel?: boolean,\r\n  fallback?: false | ''\r\n): undefined | false | string | ReactElement {\r\n  return hideLabel ? fallback : label;\r\n}\r\n", "/** Converts a local Date string into a UTC date string\r\n *\r\n * @param dateString - The string representation of a date as accepted by the `Date()` constructor\r\n * @returns - A UTC date string if `dateString` is truthy, otherwise undefined\r\n */\r\nexport default function localToUTC(dateString: string) {\r\n  return dateString ? new Date(dateString).toJSON() : undefined;\r\n}\r\n", "import { CONST_KEY, ENUM_KEY } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise\r\n * throws an error.\r\n *\r\n * @param schema - The schema from which to obtain the constant value\r\n * @returns - The constant value for the schema\r\n * @throws - Error when the schema does not have a constant value\r\n */\r\nexport default function toConstant<S extends StrictRJSFSchema = RJSFSchema>(schema: S) {\r\n  if (ENUM_KEY in schema && Array.isArray(schema.enum) && schema.enum.length === 1) {\r\n    return schema.enum[0];\r\n  }\r\n  if (CONST_KEY in schema) {\r\n    return schema.const;\r\n  }\r\n  throw new Error('schema cannot be inferred as a constant');\r\n}\r\n", "import toConstant from './toConstant';\r\nimport { RJSFSchema, EnumOptionsType, StrictRJSFSchema } from './types';\r\n\r\n/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The\r\n * labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise\r\n * the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of\r\n * `const` values from the schema and the label is either the `schema.title` or the value.\r\n *\r\n * @param schema - The schema from which to extract the options list\r\n * @returns - The list of options from the schema\r\n */\r\nexport default function optionsList<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schema: S\r\n): EnumOptionsType<S>[] | undefined {\r\n  // enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.\r\n  // Cast the type to include enumNames so the feature still works.\r\n  const schemaWithEnumNames = schema as S & { enumNames?: string[] };\r\n  if (schemaWithEnumNames.enumNames && process.env.NODE_ENV !== 'production') {\r\n    console.warn('The enumNames property is deprecated and may be removed in a future major release.');\r\n  }\r\n  if (schema.enum) {\r\n    return schema.enum.map((value, i) => {\r\n      const label = (schemaWithEnumNames.enumNames && schemaWithEnumNames.enumNames[i]) || String(value);\r\n      return { label, value };\r\n    });\r\n  }\r\n  const altSchemas = schema.oneOf || schema.anyOf;\r\n  return (\r\n    altSchemas &&\r\n    altSchemas.map((aSchemaDef) => {\r\n      const aSchema = aSchemaDef as S;\r\n      const value = toConstant(aSchema);\r\n      const label = aSchema.title || String(value);\r\n      return {\r\n        schema: aSchema,\r\n        label,\r\n        value,\r\n      };\r\n    })\r\n  );\r\n}\r\n", "import { GenericObjectType } from './types';\r\n\r\n/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.\r\n * If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per\r\n * the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be\r\n * places in the location of the `*`.\r\n *\r\n * @param properties - The list of property keys to be ordered\r\n * @param order - An array of property keys to be ordered first, with an optional '*' property\r\n * @returns - A list with the `properties` ordered\r\n * @throws - Error when the properties cannot be ordered correctly\r\n */\r\nexport default function orderProperties(properties: string[], order?: string[]): string[] {\r\n  if (!Array.isArray(order)) {\r\n    return properties;\r\n  }\r\n\r\n  const arrayToHash = (arr: string[]) =>\r\n    arr.reduce((prev: GenericObjectType, curr) => {\r\n      prev[curr] = true;\r\n      return prev;\r\n    }, {});\r\n  const errorPropList = (arr: string[]) =>\r\n    arr.length > 1 ? `properties '${arr.join(\"', '\")}'` : `property '${arr[0]}'`;\r\n  const propertyHash = arrayToHash(properties);\r\n  const orderFiltered = order.filter((prop) => prop === '*' || propertyHash[prop]);\r\n  const orderHash = arrayToHash(orderFiltered);\r\n\r\n  const rest = properties.filter((prop: string) => !orderHash[prop]);\r\n  const restIndex = orderFiltered.indexOf('*');\r\n  if (restIndex === -1) {\r\n    if (rest.length) {\r\n      throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);\r\n    }\r\n    return orderFiltered;\r\n  }\r\n  if (restIndex !== orderFiltered.lastIndexOf('*')) {\r\n    throw new Error('uiSchema order list contains more than one wildcard item');\r\n  }\r\n\r\n  const complete = [...orderFiltered];\r\n  complete.splice(restIndex, 1, ...rest);\r\n  return complete;\r\n}\r\n", "/** Returns a string representation of the `num` that is padded with leading \"0\"s if necessary\r\n *\r\n * @param num - The number to pad\r\n * @param width - The width of the string at which no lead padding is necessary\r\n * @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`\r\n */\r\nexport default function pad(num: number, width: number) {\r\n  let s = String(num);\r\n  while (s.length < width) {\r\n    s = '0' + s;\r\n  }\r\n  return s;\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true\r\n *\r\n * @param dateString - The date string to parse into a DateObject\r\n * @param [includeTime=true] - Optional flag, if false, will not include the time data into the object\r\n * @returns - The date string converted to a `DateObject`\r\n * @throws - Error when the date cannot be parsed from the string\r\n */\r\nexport default function parseDateString(dateString?: string, includeTime = true): DateObject {\r\n  if (!dateString) {\r\n    return {\r\n      year: -1,\r\n      month: -1,\r\n      day: -1,\r\n      hour: includeTime ? -1 : 0,\r\n      minute: includeTime ? -1 : 0,\r\n      second: includeTime ? -1 : 0,\r\n    };\r\n  }\r\n  const date = new Date(dateString);\r\n  if (Number.isNaN(date.getTime())) {\r\n    throw new Error('Unable to parse date ' + dateString);\r\n  }\r\n  return {\r\n    year: date.getUTCFullYear(),\r\n    month: date.getUTCMonth() + 1, // oh you, javascript.\r\n    day: date.getUTCDate(),\r\n    hour: includeTime ? date.getUTCHours() : 0,\r\n    minute: includeTime ? date.getUTCMinutes() : 0,\r\n    second: includeTime ? date.getUTCSeconds() : 0,\r\n  };\r\n}\r\n", "import { RJSFSchema, StrictRJSFSchema } from './types';\r\n\r\n/** Check to see if a `schema` specifies that a value must be true. This happens when:\r\n * - `schema.const` is truthy\r\n * - `schema.enum` == `[true]`\r\n * - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true\r\n * - `schema.allOf` has at least one value which recursively returns true\r\n *\r\n * @param schema - The schema to check\r\n * @returns - True if the schema specifies a value that must be true, false otherwise\r\n */\r\nexport default function schemaRequiresTrueValue<S extends StrictRJSFSchema = RJSFSchema>(schema: S): boolean {\r\n  // Check if const is a truthy value\r\n  if (schema.const) {\r\n    return true;\r\n  }\r\n\r\n  // Check if an enum has a single value of true\r\n  if (schema.enum && schema.enum.length === 1 && schema.enum[0] === true) {\r\n    return true;\r\n  }\r\n\r\n  // If anyOf has a single value, evaluate the subschema\r\n  if (schema.anyOf && schema.anyOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.anyOf[0] as S);\r\n  }\r\n\r\n  // If oneOf has a single value, evaluate the subschema\r\n  if (schema.oneOf && schema.oneOf.length === 1) {\r\n    return schemaRequiresTrueValue(schema.oneOf[0] as S);\r\n  }\r\n\r\n  // Evaluate each subschema in allOf, to see if one of them requires a true value\r\n  if (schema.allOf) {\r\n    const schemaSome = (subSchema: S['additionalProperties']) => schemaRequiresTrueValue(subSchema as S);\r\n    return schema.allOf.some(schemaSome);\r\n  }\r\n\r\n  return false;\r\n}\r\n", "import React from 'react';\r\n\r\nimport deepEquals from './deepEquals';\r\n\r\n/** Determines whether the given `component` should be rerendered by comparing its current set of props and state\r\n * against the next set. If either of those two sets are not the same, then the component should be rerendered.\r\n *\r\n * @param component - A React component being checked\r\n * @param nextProps - The next set of props against which to check\r\n * @param nextState - The next set of state against which to check\r\n * @returns - True if the component should be re-rendered, false otherwise\r\n */\r\nexport default function shouldRender(component: React.Component, nextProps: any, nextState: any) {\r\n  const { props, state } = component;\r\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\r\n}\r\n", "import { DateObject } from './types';\r\n\r\n/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is\r\n * removed.\r\n *\r\n * @param dateObject - The `DateObject` to convert to a date string\r\n * @param [time=true] - Optional flag used to remove the time portion of the date string if false\r\n * @returns - The UTC date string\r\n */\r\nexport default function toDateString(dateObject: DateObject, time = true) {\r\n  const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;\r\n  const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\r\n  const datetime = new Date(utcTime).toJSON();\r\n  return time ? datetime : datetime.slice(0, 10);\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ERRORS_KEY } from './constants';\r\nimport { ErrorSchema, GenericObjectType, RJSFValidationError } from './types';\r\n\r\n/** Converts an `errorSchema` into a list of `RJSFValidationErrors`\r\n *\r\n * @param errorSchema - The `ErrorSchema` instance to convert\r\n * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\r\n * @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`\r\n */\r\nexport default function toErrorList<T = any>(\r\n  errorSchema?: ErrorSchema<T>,\r\n  fieldPath: string[] = []\r\n): RJSFValidationError[] {\r\n  if (!errorSchema) {\r\n    return [];\r\n  }\r\n  let errorList: RJSFValidationError[] = [];\r\n  if (ERRORS_KEY in errorSchema) {\r\n    errorList = errorList.concat(\r\n      errorSchema[ERRORS_KEY]!.map((message: string) => {\r\n        const property = `.${fieldPath.join('.')}`;\r\n        return {\r\n          property,\r\n          message,\r\n          stack: `${property} ${message}`,\r\n        };\r\n      })\r\n    );\r\n  }\r\n  return Object.keys(errorSchema).reduce((acc, key) => {\r\n    if (key !== ERRORS_KEY) {\r\n      const childSchema = (errorSchema as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));\r\n      }\r\n    }\r\n    return acc;\r\n  }, errorList);\r\n}\r\n", "import toPath from 'lodash/toPath';\r\n\r\nimport { ErrorSchema, RJSFValidationError } from './types';\r\nimport ErrorSchemaBuilder from './ErrorSchemaBuilder';\r\n\r\n/** Transforms a rjsf validation errors list:\r\n * [\r\n *   {property: '.level1.level2[2].level3', message: 'err a'},\r\n *   {property: '.level1.level2[2].level3', message: 'err b'},\r\n *   {property: '.level1.level2[4].level3', message: 'err b'},\r\n * ]\r\n * Into an error tree:\r\n * {\r\n *   level1: {\r\n *     level2: {\r\n *       2: {level3: {errors: ['err a', 'err b']}},\r\n *       4: {level3: {errors: ['err b']}},\r\n *     }\r\n *   }\r\n * };\r\n *\r\n * @param errors - The list of RJSFValidationError objects\r\n * @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`\r\n */\r\nexport default function toErrorSchema<T = any>(errors: RJSFValidationError[]): ErrorSchema<T> {\r\n  const builder = new ErrorSchemaBuilder<T>();\r\n  if (errors.length) {\r\n    errors.forEach((error) => {\r\n      const { property, message } = error;\r\n      // When the property is the root element, just use an empty array for the path\r\n      const path = property === '.' ? [] : toPath(property);\r\n      // If the property is at the root (.level1) then toPath creates\r\n      // an empty array element at the first index. Remove it.\r\n      if (path.length > 0 && path[0] === '') {\r\n        path.splice(0, 1);\r\n      }\r\n      if (message) {\r\n        builder.addErrors(message, path);\r\n      }\r\n    });\r\n  }\r\n  return builder.ErrorSchema;\r\n}\r\n", "import isPlainObject from 'lodash/isPlainObject';\r\n\r\nimport { ErrorSchema, FormValidation, GenericObjectType } from './types';\r\n\r\n/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it\r\n *\r\n * @param errorHandler - The `FormValidation` error handling structure\r\n * @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function\r\n */\r\nexport default function unwrapErrorHandler<T = any>(errorHandler: FormValidation<T>): ErrorSchema<T> {\r\n  return Object.keys(errorHandler).reduce((acc, key) => {\r\n    if (key === 'addError') {\r\n      return acc;\r\n    } else {\r\n      const childSchema = (errorHandler as GenericObjectType)[key];\r\n      if (isPlainObject(childSchema)) {\r\n        return {\r\n          ...acc,\r\n          [key]: unwrapErrorHandler(childSchema),\r\n        };\r\n      }\r\n      return { ...acc, [key]: childSchema };\r\n    }\r\n  }, {} as ErrorSchema<T>);\r\n}\r\n", "import pad from './pad';\r\n\r\n/** Converts a UTC date string into a local Date format\r\n *\r\n * @param jsonDate - A UTC date string\r\n * @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format\r\n */\r\nexport default function utcToLocal(jsonDate: string) {\r\n  if (!jsonDate) {\r\n    return '';\r\n  }\r\n\r\n  // required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'\r\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\r\n  // > should be a _valid local date and time string_ (not GMT)\r\n\r\n  // Note - date constructor passed local ISO-8601 does not correctly\r\n  // change time to UTC in node pre-8\r\n  const date = new Date(jsonDate);\r\n\r\n  const yyyy = pad(date.getFullYear(), 4);\r\n  const MM = pad(date.getMonth() + 1, 2);\r\n  const dd = pad(date.getDate(), 2);\r\n  const hh = pad(date.getHours(), 2);\r\n  const mm = pad(date.getMinutes(), 2);\r\n  const ss = pad(date.getSeconds(), 2);\r\n  const SSS = pad(date.getMilliseconds(), 3);\r\n\r\n  return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;\r\n}\r\n", "import isEmpty from 'lodash/isEmpty';\r\n\r\nimport mergeObjects from './mergeObjects';\r\nimport toErrorList from './toErrorList';\r\nimport { ErrorSchema, ValidationData } from './types';\r\n\r\n/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the\r\n * two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling\r\n * `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then\r\n * `validationData` is returned.\r\n *\r\n * @param validationData - The current `ValidationData` into which to merge the additional errors\r\n * @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`\r\n * @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.\r\n */\r\nexport default function validationDataMerge<T = any>(\r\n  validationData: ValidationData<T>,\r\n  additionalErrorSchema?: ErrorSchema<T>\r\n): ValidationData<T> {\r\n  if (!additionalErrorSchema) {\r\n    return validationData;\r\n  }\r\n  const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;\r\n  let errors = toErrorList(additionalErrorSchema);\r\n  let errorSchema = additionalErrorSchema;\r\n  if (!isEmpty(oldErrorSchema)) {\r\n    errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true) as ErrorSchema<T>;\r\n    errors = [...oldErrors].concat(errors);\r\n  }\r\n  return { errorSchema, errors };\r\n}\r\n", "import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';\r\nimport { RJSFSchema, StrictRJSFSchema } from './types';\r\nimport isObject from 'lodash/isObject';\r\n\r\n/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixObject<S extends StrictRJSFSchema = RJSFSchema>(node: S): S {\r\n  for (const key in node) {\r\n    const realObj: { [k: string]: any } = node;\r\n    const value = realObj[key];\r\n    if (key === REF_KEY && typeof value === 'string' && value.startsWith('#')) {\r\n      realObj[key] = ROOT_SCHEMA_PREFIX + value;\r\n    } else {\r\n      realObj[key] = withIdRefPrefix<S>(value);\r\n    }\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\r\n * `withIdRefPrefix` for any other elements.\r\n *\r\n * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n */\r\nfunction withIdRefPrefixArray<S extends StrictRJSFSchema = RJSFSchema>(node: S[]): S[] {\r\n  for (let i = 0; i < node.length; i++) {\r\n    node[i] = withIdRefPrefix<S>(node[i]) as S;\r\n  }\r\n  return node;\r\n}\r\n\r\n/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.\r\n * This is used in isValid to make references to the rootSchema\r\n *\r\n * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\r\n * @returns - A copy of the `schemaNode` with updated `$ref`s\r\n */\r\nexport default function withIdRefPrefix<S extends StrictRJSFSchema = RJSFSchema>(\r\n  schemaNode: S | S[] | S[keyof S]\r\n): S | S[] | S[keyof S] {\r\n  if (Array.isArray(schemaNode)) {\r\n    return withIdRefPrefixArray<S>([...schemaNode]);\r\n  }\r\n  if (isObject(schemaNode)) {\r\n    return withIdRefPrefixObject<S>({ ...schemaNode });\r\n  }\r\n  return schemaNode;\r\n}\r\n", "/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the\r\n * enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values\r\n * as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of\r\n * parameters is important because some languages may choose to put the second parameter before the first in its\r\n * translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.\r\n */\r\nexport enum TranslatableString {\r\n  /** Fallback title of an array item, used by ArrayField */\r\n  ArrayItemTitle = 'Item',\r\n  /** Missing items reason, used by ArrayField */\r\n  MissingItems = 'Missing items definition',\r\n  /** Yes label, used by BooleanField */\r\n  YesLabel = 'Yes',\r\n  /** No label, used by BooleanField */\r\n  NoLabel = 'No',\r\n  /** Close label, used by ErrorList */\r\n  CloseLabel = 'Close',\r\n  /** Errors label, used by ErrorList */\r\n  ErrorsLabel = 'Errors',\r\n  /** New additionalProperties string default value, used by ObjectField */\r\n  NewStringDefault = 'New Value',\r\n  /** Add button title, used by AddButton */\r\n  AddButton = 'Add',\r\n  /** Add button title, used by AddButton */\r\n  AddItemButton = 'Add Item',\r\n  /** Copy button title, used by IconButton */\r\n  CopyButton = 'Copy',\r\n  /** Move down button title, used by IconButton */\r\n  MoveDownButton = 'Move down',\r\n  /** Move up button title, used by IconButton */\r\n  MoveUpButton = 'Move up',\r\n  /** Remove button title, used by IconButton */\r\n  RemoveButton = 'Remove',\r\n  /** Now label, used by AltDateWidget */\r\n  NowLabel = 'Now',\r\n  /** Clear label, used by AltDateWidget */\r\n  ClearLabel = 'Clear',\r\n  /** Aria date label, used by DateWidget */\r\n  AriaDateLabel = 'Select a date',\r\n  /** File preview label, used by FileWidget */\r\n  PreviewLabel = 'Preview',\r\n  /** Decrement button aria label, used by UpDownWidget */\r\n  DecrementAriaLabel = 'Decrease value by 1',\r\n  /** Increment button aria label, used by UpDownWidget */\r\n  IncrementAriaLabel = 'Increase value by 1',\r\n  // Strings with replaceable parameters\r\n  /** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */\r\n  UnknownFieldType = 'Unknown field type %1',\r\n  /** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */\r\n  OptionPrefix = 'Option %1',\r\n  /** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by\r\n   * MultiSchemaField\r\n   */\r\n  TitleOptionPrefix = '%1 option %2',\r\n  /** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */\r\n  KeyLabel = '%1 Key',\r\n  // Strings with replaceable parameters AND/OR that support markdown and html\r\n  /** Invalid object field configuration as provided by the ObjectField */\r\n  InvalidObjectField = 'Invalid \"%1\" object field configuration: <em>%2</em>.',\r\n  /** Unsupported field schema, used by UnsupportedField */\r\n  UnsupportedField = 'Unsupported field schema.',\r\n  /** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */\r\n  UnsupportedFieldWithId = 'Unsupported field schema for field <code>%1</code>.',\r\n  /** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */\r\n  UnsupportedFieldWithReason = 'Unsupported field schema: <em>%1</em>.',\r\n  /** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,\r\n   * as provided by UnsupportedField\r\n   */\r\n  UnsupportedFieldWithIdAndReason = 'Unsupported field schema for field <code>%1</code>: <em>%2</em>.',\r\n  /** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as\r\n   * provided by FileWidget\r\n   */\r\n  FilesInfo = '<strong>%1</strong> (%2, %3 bytes)',\r\n}\r\n", "import forEach from 'lodash/forEach';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { FormContextType, RJSFSchema, StrictRJSFSchema } from '../types';\r\nimport { PROPERTIES_KEY, ITEMS_KEY } from '../constants';\r\nimport ParserValidator, { SchemaMap } from './ParserValidator';\r\nimport { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';\r\n\r\n/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to\r\n * capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the\r\n * `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned\r\n * from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.\r\n *\r\n * @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing\r\n * @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion\r\n * @param rootSchema - The root schema from which the schema parsing began\r\n * @param schema - The current schema element being parsed\r\n */\r\nfunction parseSchema<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  validator: ParserValidator<T, S, F>,\r\n  recurseList: S[],\r\n  rootSchema: S,\r\n  schema: S\r\n) {\r\n  const schemas = retrieveSchemaInternal<T, S, F>(validator, schema, rootSchema, undefined, true);\r\n  schemas.forEach((schema) => {\r\n    const sameSchemaIndex = recurseList.findIndex((item) => isEqual(item, schema));\r\n    if (sameSchemaIndex === -1) {\r\n      recurseList.push(schema);\r\n      const allOptions = resolveAnyOrOneOfSchemas<T, S, F>(validator, schema, rootSchema, true);\r\n      allOptions.forEach((s) => {\r\n        if (PROPERTIES_KEY in s && s[PROPERTIES_KEY]) {\r\n          forEach(schema[PROPERTIES_KEY], (value) => {\r\n            parseSchema<T, S, F>(validator, recurseList, rootSchema, value as S);\r\n          });\r\n        }\r\n      });\r\n      if (ITEMS_KEY in schema && !Array.isArray(schema.items) && typeof schema.items !== 'boolean') {\r\n        parseSchema<T, S, F>(validator, recurseList, rootSchema, schema.items as S);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of\r\n * the hash of the schema to schema/sub-schema.\r\n *\r\n * @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls\r\n * @returns - The `SchemaMap` of all schemas that were parsed\r\n */\r\nexport default function schemaParser<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>(\r\n  rootSchema: S\r\n): SchemaMap<S> {\r\n  const validator = new ParserValidator<T, S, F>(rootSchema);\r\n  const recurseList: S[] = [];\r\n\r\n  parseSchema(validator, recurseList, rootSchema, rootSchema);\r\n\r\n  return validator.getSchemaMap();\r\n}\r\n", "import get from 'lodash/get';\r\nimport isEqual from 'lodash/isEqual';\r\n\r\nimport { ID_KEY } from '../constants';\r\nimport hashForSchema from '../hashForSchema';\r\nimport {\r\n  CustomValidator,\r\n  ErrorSchema,\r\n  ErrorTransformer,\r\n  FormContextType,\r\n  RJSFSchema,\r\n  RJSFValidationError,\r\n  StrictRJSFSchema,\r\n  UiSchema,\r\n  ValidationData,\r\n  ValidatorType,\r\n} from '../types';\r\n\r\n/** The type of the map of schema hash to schema\r\n */\r\nexport type SchemaMap<S extends StrictRJSFSchema = RJSFSchema> = {\r\n  [hash: string]: S;\r\n};\r\n\r\n/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the\r\n * `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.\r\n * An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These\r\n * captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by\r\n * the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the\r\n * schema IF that schema doesn't already have an $id, prior to putting the schema into the map.\r\n */\r\nexport default class ParserValidator<T = any, S extends StrictRJSFSchema = RJSFSchema, F extends FormContextType = any>\r\n  implements ValidatorType<T, S, F>\r\n{\r\n  /** The rootSchema provided during construction of the class */\r\n  readonly rootSchema: S;\r\n\r\n  /** The map of schemas encountered by the ParserValidator */\r\n  schemaMap: SchemaMap<S> = {};\r\n\r\n  /** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`\r\n   * first.\r\n   *\r\n   * @param rootSchema - The root schema against which this validator will be executed\r\n   */\r\n  constructor(rootSchema: S) {\r\n    this.rootSchema = rootSchema;\r\n    this.addSchema(rootSchema, hashForSchema<S>(rootSchema));\r\n  }\r\n\r\n  /** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the\r\n   * schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be\r\n   * associated with it's `hash` for future use (by a schema compiler).\r\n   *\r\n   * @param schema - The schema which is to be added to the map\r\n   * @param hash - The hash value at which to map the schema\r\n   */\r\n  addSchema(schema: S, hash: string) {\r\n    const key = get(schema, ID_KEY, hash);\r\n    const identifiedSchema = { ...schema, [ID_KEY]: key };\r\n    const existing = this.schemaMap[key];\r\n    if (!existing) {\r\n      this.schemaMap[key] = identifiedSchema;\r\n    } else if (!isEqual(existing, identifiedSchema)) {\r\n      console.error('existing schema:', JSON.stringify(existing, null, 2));\r\n      console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));\r\n      throw new Error(\r\n        `Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`\r\n      );\r\n    }\r\n  }\r\n\r\n  /** Returns the current `schemaMap` to the caller\r\n   */\r\n  getSchemaMap() {\r\n    return this.schemaMap;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when\r\n   * the `rootSchema` is not the same as the root schema provided during construction.\r\n   *\r\n   * @param schema - The schema to record in the `schemaMap`\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param rootSchema - The root schema associated with the schema\r\n   * @throws - Error when the given `rootSchema` differs from the root schema provided during construction\r\n   */\r\n  isValid(schema: S, _formData: T, rootSchema: S): boolean {\r\n    if (!isEqual(rootSchema, this.rootSchema)) {\r\n      throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');\r\n    }\r\n    this.addSchema(schema, hashForSchema<S>(schema));\r\n\r\n    return false;\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _formData - The formData parameter that is ignored\r\n   */\r\n  rawValidation<Result = any>(_schema: S, _formData?: T): { errors?: Result[]; validationError?: Error } {\r\n    throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called\r\n   *\r\n   * @param _errorSchema - The error schema parameter that is ignored\r\n   * @param _fieldPath - The field path parameter that is ignored\r\n   */\r\n  toErrorList(_errorSchema?: ErrorSchema<T>, _fieldPath?: string[]): RJSFValidationError[] {\r\n    throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');\r\n  }\r\n\r\n  /** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be\r\n   * called\r\n   *\r\n   * @param _formData - The formData parameter that is ignored\r\n   * @param _schema - The schema parameter that is ignored\r\n   * @param _customValidate - The customValidate parameter that is ignored\r\n   * @param _transformErrors - The transformErrors parameter that is ignored\r\n   * @param _uiSchema - The uiSchema parameter that is ignored\r\n   */\r\n  validateFormData(\r\n    _formData: T,\r\n    _schema: S,\r\n    _customValidate?: CustomValidator<T, S, F>,\r\n    _transformErrors?: ErrorTransformer<T, S, F>,\r\n    _uiSchema?: UiSchema<T, S, F>\r\n  ): ValidationData<T> {\r\n    throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');\r\n  }\r\n}\r\n"],
+  "mappings": "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",
   "names": ["get", "get", "has", "isNumber", "isObject", "isString", "times", "get", "get", "get", "get", "type", "acc", "get", "s", "isObject", "get", "has", "key", "isString", "isNumber", "times", "get", "acc", "get", "altSchemas", "get", "isEmpty", "isEmpty", "get", "has", "has", "get", "get", "isEqual", "isEqual", "get", "get", "isEqual", "set", "isEqual", "set", "get", "isEqual", "index", "isEqual", "isEqual", "get", "set", "get", "set", "get", "set", "get", "set", "isString", "isString", "isPlainObject", "isPlainObject", "isPlainObject", "isEmpty", "isEmpty", "isObject", "TranslatableString", "isEqual", "get", "isEqual", "get", "isEqual", "schema", "isEqual"]
 }
diff --git a/node_modules/@rjsf/utils/dist/utils.umd.js b/node_modules/@rjsf/utils/dist/utils.umd.js
index a1c4fc9..e608ef3 100644
--- a/node_modules/@rjsf/utils/dist/utils.umd.js
+++ b/node_modules/@rjsf/utils/dist/utils.umd.js
@@ -1067,8 +1067,9 @@
         return objectDefaults;
       }
       case "array": {
-        const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "never";
-        const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === "requiredOnly";
+        const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+        const neverPopulate = arrayMinItems?.populate === "never";
+        const ignoreMinItemsFlagSet = arrayMinItems?.populate === "requiredOnly";
         if (Array.isArray(defaults)) {
           defaults = defaults.map((item, idx) => {
             const schemaItem = getInnerSchemaForArrayItem(schema, 2 /* Fallback */, idx);
@@ -1139,7 +1140,8 @@
     if (formData === void 0 || formData === null || typeof formData === "number" && isNaN(formData)) {
       return defaults;
     }
-    const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+    const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+    const { mergeExtraDefaults } = arrayMinItems || {};
     if (isObject(formData)) {
       return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
     }
diff --git a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts
index a767c16..0ec264a 100644
--- a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts
+++ b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.d.ts
@@ -1,4 +1,4 @@
-import { Experimental_DefaultFormStateBehavior, FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';
+import { Experimental_ArrayMinItems, Experimental_DefaultFormStateBehavior, FormContextType, RJSFSchema, StrictRJSFSchema, ValidatorType } from '../types';
 /** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.
  */
 export declare enum AdditionalItemsHandling {
@@ -6,6 +6,11 @@ export declare enum AdditionalItemsHandling {
     Invert = 1,
     Fallback = 2
 }
+declare module 'json-schema' {
+    interface JSONSchema7 {
+        overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;
+    }
+}
 /** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the
  * `additionalItems` enum and the value of `idx`. There are four possible returns:
  * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid
diff --git a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
index 2fbaf23..1ac648f 100644
--- a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
+++ b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js
@@ -117,7 +117,7 @@ function maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValu
  * @returns - The resulting `formData` with all the defaults provided
  */
 export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormData, rootSchema = {}, includeUndefinedValues = false, _recurseList = [], experimental_defaultFormStateBehavior = undefined, required, } = {}) {
-    var _a, _b;
+    var _a;
     const formData = (isObject(rawFormData) ? rawFormData : {});
     const schema = isObject(rawSchema) ? rawSchema : {};
     // Compute the defaults recursively: give highest priority to deepest nodes.
@@ -249,8 +249,10 @@ export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormD
             return objectDefaults;
         }
         case 'array': {
-            const neverPopulate = ((_a = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _a === void 0 ? void 0 : _a.populate) === 'never';
-            const ignoreMinItemsFlagSet = ((_b = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _b === void 0 ? void 0 : _b.populate) === 'requiredOnly';
+            // On a case by case basis, we may want to override the default behavior of populating array items.
+            const arrayMinItems = (_a = schema.overrideArrayMinItemsBehaviour) !== null && _a !== void 0 ? _a : experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems;
+            const neverPopulate = (arrayMinItems === null || arrayMinItems === void 0 ? void 0 : arrayMinItems.populate) === 'never';
+            const ignoreMinItemsFlagSet = (arrayMinItems === null || arrayMinItems === void 0 ? void 0 : arrayMinItems.populate) === 'requiredOnly';
             // Inject defaults into existing array defaults
             if (Array.isArray(defaults)) {
                 defaults = defaults.map((item, idx) => {
@@ -328,6 +330,7 @@ export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormD
  * @returns - The resulting `formData` with all the defaults provided
  */
 export default function getDefaultFormState(validator, theSchema, formData, rootSchema, includeUndefinedValues = false, experimental_defaultFormStateBehavior) {
+    var _a;
     if (!isObject(theSchema)) {
         throw new Error('Invalid schema: ' + theSchema);
     }
@@ -342,7 +345,9 @@ export default function getDefaultFormState(validator, theSchema, formData, root
         // No form data? Use schema defaults.
         return defaults;
     }
-    const { mergeExtraDefaults } = (experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) || {};
+    // On a case by case basis, we may want to override the default behavior of populating array items.
+    const arrayMinItems = (_a = schema.overrideArrayMinItemsBehaviour) !== null && _a !== void 0 ? _a : experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems;
+    const { mergeExtraDefaults } = arrayMinItems || {};
     if (isObject(formData)) {
         return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);
     }
diff --git a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map
index 1295d99..8ea716a 100644
--- a/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map
+++ b/node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js.map
@@ -1 +1 @@
-{"version":3,"file":"getDefaultFormState.js","sourceRoot":"","sources":["../../src/schema/getDefaultFormState.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"getDefaultFormState.js","sourceRoot":"","sources":["../../src/schema/getDefaultFormState.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@rjsf/utils/lib/tsconfig.tsbuildinfo b/node_modules/@rjsf/utils/lib/tsconfig.tsbuildinfo
index fbfec4b..32c6f77 100644
--- a/node_modules/@rjsf/utils/lib/tsconfig.tsbuildinfo
+++ b/node_modules/@rjsf/utils/lib/tsconfig.tsbuildinfo
@@ -1 +1 @@
-{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.es2021.d.ts","../../../node_modules/typescript/lib/lib.es2022.d.ts","../../../node_modules/typescript/lib/lib.esnext.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.dom.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.es2021.promise.d.ts","../../../node_modules/typescript/lib/lib.es2021.string.d.ts","../../../node_modules/typescript/lib/lib.es2021.weakref.d.ts","../../../node_modules/typescript/lib/lib.es2021.intl.d.ts","../../../node_modules/typescript/lib/lib.es2022.array.d.ts","../../../node_modules/typescript/lib/lib.es2022.error.d.ts","../../../node_modules/typescript/lib/lib.es2022.intl.d.ts","../../../node_modules/typescript/lib/lib.es2022.object.d.ts","../../../node_modules/typescript/lib/lib.es2022.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2022.string.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../node_modules/@types/react/global.d.ts","../../../node_modules/csstype/index.d.ts","../../../node_modules/@types/prop-types/index.d.ts","../../../node_modules/@types/scheduler/tracing.d.ts","../../../node_modules/@types/react/index.d.ts","../../../node_modules/@types/react/jsx-runtime.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../../../node_modules/@types/lodash/cloneDeep.d.ts","../../../node_modules/@types/lodash/get.d.ts","../../../node_modules/@types/lodash/set.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../src/enums.ts","../src/types.ts","../src/constants.ts","../src/ErrorSchemaBuilder.ts","../src/isObject.ts","../src/allowAdditionalItems.ts","../src/asNumber.ts","../src/getUiOptions.ts","../src/canExpand.ts","../../../node_modules/@types/lodash/isPlainObject.d.ts","../src/createErrorHandler.ts","../../../node_modules/@types/lodash/isEqualWith.d.ts","../src/deepEquals.ts","../../../node_modules/@types/lodash/isEmpty.d.ts","../../../node_modules/jsonpointer/jsonpointer.d.ts","../../../node_modules/@types/lodash/omit.d.ts","../src/findSchemaDefinition.ts","../../../node_modules/@types/lodash/has.d.ts","../../../node_modules/@types/lodash/isNumber.d.ts","../../../node_modules/@types/lodash/isObject.d.ts","../../../node_modules/@types/lodash/isString.d.ts","../../../node_modules/@types/lodash/reduce.d.ts","../../../node_modules/@types/lodash/times.d.ts","../src/getOptionMatchingSimpleDiscriminator.ts","../src/schema/getMatchingOption.ts","../src/schema/getFirstMatchingOption.ts","../../../node_modules/@types/lodash/isEqual.d.ts","../../../node_modules/@types/lodash/transform.d.ts","../../../node_modules/@types/lodash/merge.d.ts","../../../node_modules/@types/lodash/flattenDeep.d.ts","../../../node_modules/@types/lodash/uniq.d.ts","../../../node_modules/@types/json-schema-merge-allof/index.d.ts","../src/getDiscriminatorFieldFromSchema.ts","../src/guessType.ts","../../../node_modules/@types/lodash/union.d.ts","../src/getSchemaType.ts","../src/mergeSchemas.ts","../src/schema/retrieveSchema.ts","../src/schema/getClosestMatchingOption.ts","../src/isFixedItems.ts","../src/dataURItoBlob.ts","../src/replaceStringParameters.ts","../src/englishStringTranslator.ts","../src/enumOptionsValueForIndex.ts","../src/enumOptionsDeselectValue.ts","../src/enumOptionsIsSelected.ts","../src/enumOptionsIndexForValue.ts","../../../node_modules/@types/lodash/isNil.d.ts","../src/enumOptionsSelectValue.ts","../src/rangeSpec.ts","../src/getInputProps.ts","../src/getSubmitButtonOptions.ts","../src/getTemplate.ts","../node_modules/@types/react-is/index.d.ts","../src/getWidget.tsx","../src/hashForSchema.ts","../src/hasWidget.ts","../src/idGenerators.ts","../src/isConstant.ts","../src/isCustomWidget.ts","../src/labelValue.ts","../src/localToUTC.ts","../src/mergeObjects.ts","../src/toConstant.ts","../src/optionsList.ts","../src/orderProperties.ts","../src/pad.ts","../src/parseDateString.ts","../src/schemaRequiresTrueValue.ts","../src/shouldRender.ts","../src/toDateString.ts","../src/toErrorList.ts","../../../node_modules/@types/lodash/toPath.d.ts","../src/toErrorSchema.ts","../src/unwrapErrorHandler.ts","../src/utcToLocal.ts","../src/validationDataMerge.ts","../src/withIdRefPrefix.ts","../../../node_modules/@types/lodash/forEach.d.ts","../src/parser/ParserValidator.ts","../src/parser/schemaParser.ts","../src/parser/index.ts","../src/index.ts","../src/mergeDefaultsWithFormData.ts","../src/schema/isSelect.ts","../src/schema/isMultiSelect.ts","../src/schema/getDefaultFormState.ts","../src/schema/isFilesArray.ts","../src/schema/getDisplayLabel.ts","../src/schema/mergeValidationData.ts","../src/schema/sanitizeDataForNewSchema.ts","../src/schema/toIdSchema.ts","../src/schema/toPathSchema.ts","../src/schema/index.ts","../src/createSchemaUtils.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/readline/promises.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@types/connect/index.d.ts","../../../node_modules/@types/body-parser/index.d.ts","../../../node_modules/@types/bonjour/index.d.ts","../../../node_modules/@types/mime/index.d.ts","../../../node_modules/@types/send/index.d.ts","../../../node_modules/@types/range-parser/index.d.ts","../../../node_modules/@types/qs/index.d.ts","../../../node_modules/@types/express-serve-static-core/index.d.ts","../../../node_modules/@types/connect-history-api-fallback/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/eslint-scope/index.d.ts","../../../node_modules/@types/http-errors/index.d.ts","../../../node_modules/@types/serve-static/index.d.ts","../../../node_modules/@types/express/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/unist/index.d.ts","../../../node_modules/@types/hast/index.d.ts","../../../node_modules/@types/history/DOMUtils.d.ts","../../../node_modules/@types/history/createBrowserHistory.d.ts","../../../node_modules/@types/history/createHashHistory.d.ts","../../../node_modules/@types/history/createMemoryHistory.d.ts","../../../node_modules/@types/history/LocationUtils.d.ts","../../../node_modules/@types/history/PathUtils.d.ts","../../../node_modules/@types/history/index.d.ts","../../../node_modules/@types/html-minifier-terser/index.d.ts","../../../node_modules/@types/http-proxy/index.d.ts","../../../node_modules/@types/invariant/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/@jest/expect-utils/build/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/@sinclair/typebox/typebox.d.ts","../../../node_modules/@jest/schemas/build/index.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/expect/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/parse5/dist/common/html.d.ts","../../../node_modules/parse5/dist/common/token.d.ts","../../../node_modules/parse5/dist/common/error-codes.d.ts","../../../node_modules/parse5/dist/tokenizer/preprocessor.d.ts","../../../node_modules/parse5/dist/tokenizer/index.d.ts","../../../node_modules/parse5/dist/tree-adapters/interface.d.ts","../../../node_modules/parse5/dist/parser/open-element-stack.d.ts","../../../node_modules/parse5/dist/parser/formatting-element-list.d.ts","../../../node_modules/parse5/dist/parser/index.d.ts","../../../node_modules/parse5/dist/tree-adapters/default.d.ts","../../../node_modules/parse5/dist/serializer/index.d.ts","../../../node_modules/parse5/dist/common/foreign-content.d.ts","../../../node_modules/parse5/dist/index.d.ts","../../../node_modules/@types/tough-cookie/index.d.ts","../../../node_modules/@types/jsdom/base.d.ts","../../../node_modules/@types/jsdom/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/lodash.mergewith/index.d.ts","../../../node_modules/@types/mdast/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/minimist/index.d.ts","../../../node_modules/@types/normalize-package-data/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/parse5/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/react-dom/index.d.ts","../../../node_modules/@types/react-frame-component/index.d.ts","../../../node_modules/@types/react-router/index.d.ts","../../../node_modules/@types/react-router-config/index.d.ts","../../../node_modules/@types/react-router-dom/index.d.ts","../../../node_modules/@types/react-test-renderer/index.d.ts","../../../node_modules/@types/react-transition-group/Transition.d.ts","../../../node_modules/@types/react-transition-group/CSSTransition.d.ts","../../../node_modules/@types/react-transition-group/TransitionGroup.d.ts","../../../node_modules/@types/react-transition-group/SwitchTransition.d.ts","../../../node_modules/@types/react-transition-group/config.d.ts","../../../node_modules/@types/react-transition-group/index.d.ts","../../../node_modules/@types/retry/index.d.ts","../../../node_modules/@types/sax/index.d.ts","../../../node_modules/@types/scheduler/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/serve-index/index.d.ts","../../../node_modules/@types/sockjs/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/warning/index.d.ts","../../../node_modules/@types/ws/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9","746d62152361558ea6d6115cf0da4dd10ede041d14882ede3568bce5dc4b4f1f","d11a03592451da2d1065e09e61f4e2a9bf68f780f4f6623c18b57816a9679d17","aea179452def8a6152f98f63b191b84e7cbd69b0e248c91e61fb2e52328abe8c",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"f3d4da15233e593eacb3965cde7960f3fddf5878528d882bcedd5cbaba0193c7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"6c55633c733c8378db65ac3da7a767c3cf2cf3057f0565a9124a16a3a2019e87","affectsGlobalScope":true},{"version":"fb4416144c1bf0323ccbc9afb0ab289c07312214e8820ad17d709498c865a3fe","affectsGlobalScope":true},{"version":"5b0ca94ec819d68d33da516306c15297acec88efeb0ae9e2b39f71dbd9685ef7","affectsGlobalScope":true},{"version":"34c839eaaa6d78c8674ae2c37af2236dee6831b13db7b4ef4df3ec889a04d4f2","affectsGlobalScope":true},{"version":"34478567f8a80171f88f2f30808beb7da15eac0538ae91282dd33dce928d98ed","affectsGlobalScope":true},{"version":"ab7d58e6161a550ff92e5aff755dc37fe896245348332cd5f1e1203479fe0ed1","affectsGlobalScope":true},{"version":"6bda95ea27a59a276e46043b7065b55bd4b316c25e70e29b572958fa77565d43","affectsGlobalScope":true},{"version":"aedb8de1abb2ff1095c153854a6df7deae4a5709c37297f9d6e9948b6806fa66","affectsGlobalScope":true},{"version":"a4da0551fd39b90ca7ce5f68fb55d4dc0c1396d589b612e1902f68ee090aaada","affectsGlobalScope":true},{"version":"11ffe3c281f375fff9ffdde8bbec7669b4dd671905509079f866f2354a788064","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},{"version":"49a253ec027e56c55c7450a0c331cfe96212b3d1cc215b1710ba94a083404cf3","affectsGlobalScope":true},"4c68749a564a6facdf675416d75789ee5a557afda8960e0803cf6711fa569288","6a386ff939f180ae8ef064699d8b7b6e62bc2731a62d7fbf5e02589383838dea","f5a8b384f182b3851cec3596ccc96cb7464f8d3469f48c74bf2befb782a19de5",{"version":"6a1c1a2911268b0ac9e6b0248ecbcbab53b197431965684491f153ef57e02726","affectsGlobalScope":true},"af7fd2870746deed40e130fc0a3966de74e8f52a97ec114d0fbb35876ab05ca9","675e702f2032766a91eeadee64f51014c64688525da99dccd8178f0c599f13a8","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","da2b6356b84a40111aaecb18304ea4e4fcb43d70efb1c13ca7d7a906445ee0d3","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","98f9d826db9cd99d27a01a59ee5f22863df00ccf1aaf43e1d7db80ebf716f7c3","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","dcd91d3b697cb650b95db5471189b99815af5db2a1cd28760f91e0b12ede8ed5","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","b03afe4bec768ae333582915146f48b161e567a81b5ebc31c4d78af089770ac9","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","30abc554c7ad13063a02ddd06757929b34357aea1f6fcf4ca39114cb0fc19384","a33ea06913b712c529662bee7fd75959781267cf8a307902cc7761307fec0337","8c7bb1d03e5607e5ad3d27f48e53dbe70b61372ea73d75000c9ead7ad2ac0fbd","05dd03486750d327568269b9f84aa51f15a066bcdc2ccefd8b592fb06fa3a371","dca41e86e89dfb2e85e6935260250f02eb6683b86c2fa16bec729ddd1bcd9b4b",{"version":"5c1cc65e524e90d4f029b92644b6e2a540754c7be5a7b34398dca65c805886e7","signature":"fed1b60d5ded0454fd75d01be757106845b8b32294bdd908664a6e3d4abf8eb9"},{"version":"7481023d6eade058ec7a457ced6b0895dd2dfbdb370dc196d9e0e612e49bfff6","signature":"62a4be68358a6f038bed0725bbc97228fa0f1db88615136d044f3681ff816cef"},{"version":"f1ca859299187c58246012e11203ef14f675b3e42d310aa0997af6ed5a5b0bbc","signature":"67c47afaaaa4d0b865bc031fcb8f22513d0f66593f8eb92226dea225ad11b527"},{"version":"c2699e2584dad86db116bd70c612a9b74798ce14cbfd0ad538a06c0330b32689","signature":"8ed3c4c1c117c587a4cfd55b150cb2aa76ecdf6d5af9a3b2d5a3dc2fec4519b4"},{"version":"93cbaf5424eae55cbfe3f603f68ed95524204da7da7b189f41e548c7ac9c540e","signature":"a7a45ff063666e927ec8887359f8c6589dcbfbb38aab374e33843c326c41fcde"},{"version":"a9238bb53460f1812801c4715a8eb1025f0cc3f95be15c0dc722648e7be101bb","signature":"ec009b749ab3a62ff47840bbe9fd296c6bbe49acb1665770f393daa0426a4347"},{"version":"c2a321abaf3da281a3715e34d6277048f15efc441116f05468ceeb71863ce714","signature":"a30dfb306a2ecf72e8a0497e613c3d53e66d96882e7c4bff1e1e3e65400c21dd"},{"version":"5f5caca68a08616ec2fdfc34eab0741f8f085e7d35a737e1cd509a00b96ee73e","signature":"2b99ca04a544be690e8ff5e80dfc26e59f1088fb18e9fe71eb39e716c9317465"},{"version":"4b2346b1a65571f12a8fba212ece0917137bb53d0bdd0aa9b49d9244d28b04c5","signature":"d24b7ea7ed9d73b96884c8e03931c269c53c082387973fe801baa6c2e4ea9ac0"},"6481b0b18d7623bfdd63d1dccefb9019594818c7bbfc735c54ec67779bdd9aa7",{"version":"ea83843b7a8d3a646735811cb520ebc84071a979db1704f3b06c2ec417faab77","signature":"01698efbcad6156ef3e8aa9720d51b3ca49e940d1be7159c67c182c4fbe1cbaf"},"62c492e1fba26f134ff83bfd1afcb0e1af2ac28b4488f38a10d4c89afdba7912",{"version":"6a0c714213f890c4f2cd9c3b445ca5cf671494ceea48c331f9d2902a6467a88e","signature":"237016abdaa923dc5ba32550390f6e826c43e4935feccf09dc7539b81a7b4a6d"},"8dcd8273655aef81be9c273e532a55f56032c7907b20f8ed4d069f7eec44ace8","de34db5191530ba991bda92326932682a62626275f4d47a08c5377130a9b25a3","d51d9d8bb90a13d0b1aeedce422694aecf48e4e699bf3e1891a472a8c83ccd89",{"version":"d1978c8edd73fdbc8dbc685919b42e7e626dca51896ddd35f50a91136984a550","signature":"79cc6f202a16c08ec89f326a2a62cd9cc3f033966a427d4c8e86c4cd022fe8a1"},"4a4eff67dc5860f4b9302e395e3ad2be716d08ed838f5540e32c8ac7b1b4920b","e3602c7ef8cfedd027c02a023075b2c7ba2705d26ec521a8e95f2084f4a138ba","08906ca4df290e78211120ae722953b460e978096c01ab2d42a682088fd1203e","d6f46220d383fb0fd842186b0106c3e3c5b65c7d67a9f45a359ddc6721e22622","011041890a1f073bd0c6342a7493a0be0d1d03c9263879d5467d75d32c4a6790","4b7deb49486f22341efc7417fc672f7c83a402081927d8355833d8fc8f4b65f2",{"version":"82775ea6083efa5e0f15df987fe14e7a325e9797feaf27832b0cf3565e2d45a0","signature":"9a63626c54938574bd7fce9efba10ce2a1c3b93b8ec2572faff8b0dab1c2ca5b"},{"version":"1f9fc72678702feee585c106ed5c30ef271e5c3ad12539cb20870f67f3d669db","signature":"1386e70d8003be4f39e53cba208dbf1a179e86c12c49721784e6c38b932da50e"},{"version":"5fd501c2c4090a97bea8d734a727d9f51cf16a86642d982322fc541cd2452904","signature":"8eca221a51bfa28190c34d1f303f14530e244c69c6875ec706d317ef9a86faa6"},"5ebc6dda07cd1112abcba3da894fafc01c04b37f55bc94bc110da3a662236cee","294c45fd29fdc9833fb3570114b8a47b9a71bf966f9f42e2f4dff033dd297a39","b6f9de62790db96554ad17ff5ff2b37e18e9eecca311430bb200b8318e282113","1d249f1f73dff883fe8b0104ca0cf867970c054fc12d86e9292c79a4c1704f27","2c705ed6e0913da9d7f85665a5f402043def9de30a1595a5cd78cba2ad0f1113","1ef731615b313977734bad46d7badba8952fa9b474bc19e9412bfb6b7395cf84",{"version":"38f7edf77e9492cf8e9dfd0e55e863b59e64dca836e0dc5b1b5e3fec79914c03","signature":"e922c742d7406e0621aec3bf16b20df3a4628f6215098952e43d33967cce5bb7"},{"version":"244f98f1aac2a69211132b9261b29faf2a1f81775b2bf190afe4420dc558ba1e","signature":"0da34c85c5efff1a7b481d65a794e96dddde339bdc33127cba5bb3a6b8225522"},"269323480a68bcae790fb3b88d42fd449f76e12c498ac4266836fdb1357ac48d",{"version":"cf3cfada817e8bd48989ff7c0c031e1e07c7d6b6f4f57fc8d257d71bb7086f9e","signature":"4ec14d99c2c75e1f468340425b3484d412f2ad2a8da986c26b71b019e8d0e1e3"},{"version":"b112f338014f7a724495c80e02ac21173ac53e76cf5c48492e5df69bbf039482","signature":"aa81d7cbdec053a03b49a63367040f2c699bc57d5e8e2e540516fc67f5648d91"},{"version":"8f54552974a8f5378524b44f186de1d542a4753078bb788cfd9bc4ee71f49527","signature":"5c479b857589c3dc9730095798a8210e6182116c34db0dbc4c7774df2e06e7cd"},{"version":"1413ab88217b22d9c78d12afa6b2dfad56284e1c4d4f4c31579b1b9810a1adf1","signature":"7ec93f655e371773ff79d15cc3b2d49924e546eefb1b22db56961983042cb615"},{"version":"05312f33bc92741b60935052d91275f9685acf4bad71bcebab30e4dbe783a896","signature":"4795132bd18e55e274fc95db2d6d7faa6c5cce1894035e19d0c5344e0ef5f208"},{"version":"cb7242f429cbf5b0ea06dbe55928b2f1556626dd7d5e2d557cccb147d7ab67d7","signature":"e300f752ad8ca493068e4e4dc5eaeffaa596b34122c32ee878cfe40a6cb0e92f"},{"version":"decfbc2d969393aab0af73a738a7d04f04c2f92274ba11273ed7507e02bab7a5","signature":"20773d48a109f2c3993259683290f8f3b7c04cb1089c98ec1293bc9436689d21"},{"version":"622a7336def62a9a16a9fc7f2c17f8fe0872cabb858180897afa92a5559071af","signature":"c9f5e2d2807cbed36a170a7303be9e9c6a02d8f0e717f228e50afb50aec96ed7"},{"version":"c7c66f4f710118e051b0c083d2966d1e42691c8d16595e23e2d43a6708136b7e","signature":"e503f183c0ac702838dc0f60bd2e01bffb344426dd2dc40369740a7ae0430574"},{"version":"c38b2716fea9e34a1756778a12cc3ce67742d0d5f6960479cf95eaee252f57b6","signature":"cd334ab582785166eb6470f13dca713125cb4142aae22f1335a36a6ce61aa639"},{"version":"23123903a76272f56705dda2a2eee2ab31d4e775e3e9dcdc9690aba5b51fa4f8","signature":"3479943e26fe617c803016fab3a72583a51e20931a9d52701d7c19e1970fb38f"},{"version":"9f4825d4ca8d16d271446c896729ab541cf2f785ad0ee07abd60cdf6e6280772","signature":"60396ddfdb23d5c538b0c8fdf76963721d7bb895a3ad9bd32ea74be48a5c1cfd"},"d19a1154c39cbc254c0b85fb7707fc478a7a777ba222c2b99dad77a60953b4bb",{"version":"07d1c954682d988879fff0b4a7e2ff5f6fe276a4ae9afb4be086a1520caa2e57","signature":"841e4238dccc7d5e200f80b6f33abdc0955460b5d3c196d2fa7907d0a646d80c"},{"version":"1c329b74ecd9ed7d581a2dfde6bae6a4dc4c3a3fa8689b42eaa4d0b83d34beb5","signature":"50febf6ffc04a441c8f61a8db8412f8f1c34d834a007983271f3c5369fd13471"},{"version":"00cf07fa091384ca96ac7b5080fd62ba3a7facd2803feadd2370a3675eb37d59","signature":"7f3ceccbbe3ee8208a62f938b28ca1934f573e37b06f7b9df71f5714212daac1"},{"version":"facd92d57016298a9803e912c6116bdfc2324e743d4eb5ecdcbadbcb00489204","signature":"e11fe83b5ba519fcc10f62bd672b3f1083117c794fc6f0df2c3125e000574f31"},{"version":"b98bc6ef89f909c822ccb0b35eaf9337d17cd096e157e690771cfd7b0c205949","signature":"fd7fe51baa9c4dc58bcb3674a262f3ec43a783833b82e6d09a8da02505121d62"},"06c2fc0bf929858d3ee5fb8c14f0a39b48d91bb8161b6480d833f787df761672",{"version":"0766b19977764a300722a6a976af0aeecd738466e9b1af382f9faf128395a7f4","signature":"a9b76326910a622d25f6f18127ca7cc88dee6caaeb5af28632d9581e411c7b78"},{"version":"fd91f9095387fa7a98b42412de24acebb4a6309edcda7dc6778f5bf5d5860f09","signature":"c614901624df584d4c1be77c62a2af2fbf65b4ca4ac5212688a2191ca75b5eb5"},{"version":"920b109a502d743dd87d9f03a0e2a18839fc5cc3a93cdb4d35050f8f5036acec","signature":"4b416927c83f403b3042c8112f02be1b0921fa305006928b1498f0c15ade8788"},{"version":"21a652066321e405721985d56aefa9c94d490290aef8096fff3b4e1d6cf6197e","signature":"ddeef8858b8b8e08adcad0d5a507fd15d40ad9883a7586da7d763ecfb2614c61"},{"version":"efb1baf91bfc1f2b4007dc0dc47ddd47cf80e69da1457914cd3621157b60f651","signature":"1d297454335b6edacce0c1c1812957615672c412b49cbc491d0fe995cc25e391"},{"version":"181476067d806f3219f78a7c36fc3bb391d8912323bd501d640d70aad1b459cd","signature":"1fa318f0dffd9fd3ed8d5d89cea19c388d20f7d7ba3449a060cdd6ad46c3560c"},{"version":"b7f55bb5cf1da2358375569e02b768245b395c0e03dbf385b70b7180a2803d9f","signature":"96e237f27ab92b5d4b386f30d1312c270d95d1684782c3c063ef149b3eeef32f"},{"version":"3bcc9bd10543dfff5c62f7c8effae1b08407157512b490e6bb8da9abfbd014b4","signature":"ad2f328fad1477039b2fb73a8a851ba2bf2bfa77f24f2cc976e4b378e2b87fe2"},{"version":"30bce53483f90893e127f904b623bdc44af4a5d1c4ea3178d6990f7588ca1d89","signature":"fa76ea20b4218238f6dca8ab35130c1889784d23cb2075ed1fb36ebc8da3d70b"},{"version":"f5b61ddf9767edc5705841ccba3551ecbd015e9a43d8b608f33c0a73cf159bfe","signature":"ef4ee795c5b262f9a3a3ff4c3eb723d581fde37c0b6aa99b1cba863ff5d4bbc9"},{"version":"a4006b0df11f26cb0b6213a475de3eb98a84b07165fb5ffaa077a40ca827d149","signature":"1f17321e5ec855ab41f818645fd035fe7002701177495a2bfc5e44b181d74887"},{"version":"ca68ec7cabe8576e92c0ce0c0eebdd0748b3dd514a551127baa559982949376c","signature":"37208e76fd609808109257e4c375bc68cecaf0c20aba4d8c47fef87639c53339"},{"version":"28e44543a4ec6151bb8c803e0e366a8b78f83e487d060994a2c602e87ba68fea","signature":"250f85657a04d064d8f0ff02c46e2461e5485576007a06f28cb136411a091c6f"},{"version":"edc43d02a2a32bd695075486eb400410c5741c9cce65e2e054c08beaa58e88a7","signature":"2880c3e39676bcc14969ea26800a8fd0dc9b7366226ca25f3a6ea4ebf274398d"},{"version":"e5d8134a860d2eb716c378145d7e0b0e519cdf1c9177e98b1e2786a4aec0b403","signature":"84a5a9d7d9bf3aae8a79c3003818a5c2407b89ff50652b8c8c0c234a57ac70bf"},{"version":"470c7a7de7e490e3c68ba2d8ef3b45466861b2c42884828e283d48f081589c17","signature":"07e4de2c2c3952a30e5d4c518397e81b73974deda7aacd4b081b84f17ce14aa0"},{"version":"bba8a8c302a34b04e8b0ee67fce074a557875a83bddc53cded8104bdf7c0b67f","signature":"c4b68edf278dfd7df618e1ca416fa5890ec2783753636128c0b9e2f4f568645d"},{"version":"58de324b5334ea14ee03fa148ab95d28c2737df4c18ca02b0c3a98042a5b2959","signature":"e0919c1111cca6bae2198709e74a04756954070f9e89fb97a5ac2cb45cecdef1"},"aba86dc9f51e05011716826d014fe41d8ed74d47c7805250326d0b510e1794d4",{"version":"ce92bfc0c0218f34107bfbce087902aa654b6f64214f8718f9b41752f3ec8868","signature":"8b0cc51881c9571cf949c42219226400a9cd9b55821fcbf6bc3445d508a9f628"},{"version":"f236d6bb187cfdabd711dc1008c8f4c9a21ec8235e98b9aa8f004254daec9a53","signature":"34fd7f2484929663a93fafa40cb66ec4c24294d1bbeafd103aa83dfc61531fcb"},{"version":"9dcfd60d3ca816c170619d68e14722587b7c9d8c3911647d683082bacd43d60d","signature":"2e20c09076f10b8008351c207570c18557b6e1ee27312929acb458044f41178d"},{"version":"7f8670044d407d9a2099a5bc53a7dd4364c226cb721c1c6c7e7d610e3359230e","signature":"894391453bbd660b1b373414bd8eaf79841ae814288d7c8a019b90d890548916"},{"version":"21cff82411d6357e9bcebc53e486eea75eb505f153f5bde3b5a99988c1e250f6","signature":"0cc3f1032baa51412c238d34d5f9d042fe60de5f04386cdd9148138d14ea1bae"},"499acdba626cb8fe0b998f036a930d3ca7ea48583fffb73419af9238527f45f4",{"version":"4040dd7ef971fb00f9eee2909c4a684700716e044729711893836fa96d686481","signature":"435b71de28a54743980c1dedfd4847948f87d0363e5ed6987adc7a325d3dcaed"},{"version":"7403cb95ad4e295f92113cd7ad40967bc1c809ed95f46eac0645bb362de88a97","signature":"8e3862b3985966ebe1e32182ad5fd23617ce547ec262063c34b36bfa85810d8f"},{"version":"aeb86df77be7a8a58c9c6b3e01756c89a9bae87e14a181f57dc77fc21f592549","signature":"3daa519f474d20b429e226f26046f6e0be8572663f5476050d71398e3b0fc3d6"},{"version":"225b5c38c484fbe19101367a17d05cd20eed18b917d5fae854b8efcec02ea7c0","signature":"a522b4959470bf1e6012a36726b05d6f52addd9fad0a84e16b113f6cea91effd"},{"version":"7795ba213fc1b745f9d72c0935ad6d2f0068143916f18269d610d0b3006d65ec","signature":"95e741a02549dbdd749ce7ef32a438f58da8f90c1e8bee831a0af9f9fdbb7cf9"},{"version":"4efc6716573966c0f00a81e4e0c509a0f36e8d31bf07bf9b9ab628ec936f56fc","signature":"4dc10dd84f0051394224fbbac909c01bc550c633e02ffc4c23c57e73addb73a2"},{"version":"9ad7078aa11966ab7ab4b1793bf4117e2c1ad0550973c189000fff2f3e0acfcc","signature":"057622f8d86fd3b0d43e39050315e25ef0c861ebee3042bd4392444f526611f9"},{"version":"fbfcad5b03b2d649daf6611710920ac6647f1a2893aa33e54e73d25618ecd6a6","signature":"084f2cd75de5ef4b35b84acd5bc353bb4d97efe181294ae0e3558c88c914081a"},{"version":"a0f70ee3a6e32ce525a80a4ac6b436eb1f46e0460518679bba1c812393fd22c6","signature":"2752c315eea7b83dc59382aabee59543baa485c2bcdab9c13ce7585ce3bc6e78"},{"version":"8f5acf0d74dbc3774e18834359a6c085953be35e487e02ad5e8c5a74b7ecf8b5","signature":"f72f1339990bc7f1252ee352736b8df8d8c8789eb840d6fbe049f3dd6723f371"},{"version":"45cb100f09311470f592173835c5424ea6cbb73bc63f6e8aa3ff199853ffb11c","signature":"329586c48f54a1d1d6062791fb7ba8b9ec31604095e0fa61e442f540adda8252"},{"version":"90386ca33222d781dc0416f1840905192177db683b84bb033cac7a5a75f98063","signature":"674cf955e4337ce79e3924ba63c6b882be6f12621328eecb554a1d9a31330a56"},{"version":"9373d7deb42f0894c235b6caf1e0ce948977e0aa4e4630d2bde6bdf3f96ccf53","signature":"b6d493994d1cba707cb948dfaa0b723febe990155167ab4c9dab92018e68a548"},{"version":"0275e95ac712ac134367586654fe41a5e8acd6ba56b333a8f5310ca2acce4801","signature":"1824bb1ec810ca93f5b00fb533dc85ecbde6ddfd38d373d13af167d010af1b14"},{"version":"130770755b77d55a9018be54b55ffc7bbaaeaf9292bd391ab815ecdbba205627","signature":"442b0aafa50167cca28f111ff00d437d2bbbb306bb4c09ef4db322b583571575"},{"version":"ea150ca6f95606458d8c1c66e70f8ec98f85ed19a13da397be50f2e71ad9c926","signature":"ad6044ef79cf922b7a57fc715ea54e7f21ccff6a07925e0019a40c71e6cf3ee0"},"f713064ca751dc588bc13832137c418cb70cf0446de92ade60ad631071558fca","cc957354aa3c94c9961ebf46282cfde1e81d107fc5785a61f62c67f1dd3ac2eb","96c23535f4f9dd15beb767e070559ea672f6a35f103152836a67100605136a96","93de1c6dab503f053efe8d304cb522bb3a89feab8c98f307a674a4fae04773e9","6704f0b54df85640baaeebd86c9d4a1dbb661d5a4d57a75bc84162f562f6531d","9d255af1b09c6697089d3c9bf438292a298d8b7a95c68793c9aae80afc9e5ca7","ba8691cf6bea9d53e6bf6cbc22af964a9633a21793981a1be3dce65e7a714d8b","a69c09dbea52352f479d3e7ac949fde3d17b195abe90b045d619f747b38d6d1a",{"version":"bce910d9164785c9f0d4dcea4be359f5f92130c7c7833dea6138ab1db310a1f9","affectsGlobalScope":true},"afddd0617cc7ef650f743c75b868df9d53f17f9ff0cccc255fb5f632e857be38",{"version":"7c387a02bf156d8d45667134d32518ac3ca1b99ca50ca9deff2c1a03eb6d1a81","affectsGlobalScope":true},"3719525a8f6ab731e3dfd585d9f87df55ec7d50d461df84f74eb4d68bb165244","f993522fd7d01ae1ead930091fe35130b8415720d6c2123dc2a7e8eb11bb3cba",{"version":"d5135ad93b33adcce80b18f8065087934cdc1730d63db58562edcf017e1aad9b","affectsGlobalScope":true},"82408ed3e959ddc60d3e9904481b5a8dc16469928257af22a3f7d1a3bc7fd8c4","b787b5b54349a24f07d089b612a9fb8ff024dbbe991ff52ea2b188a6b1230644","bb9c4ffa5e6290c6980b63c815cdd1625876dadb2efaf77edbe82984be93e55e","1cdcfc1f624d6c08aa12c73935f6e13f095919cd99edf95752951796eb225729","df6d4b6ba1e64f682091862faa30104e93891f9e7202d006bf5e7a88ab4a0dbe","14b5aa23c5d0ae1907bc696ac7b6915d88f7d85799cc0dc2dcf98fbce2c5a67c","5c439dafdc09abe4d6c260a96b822fa0ba5be7203c71a63ab1f1423cd9e838ea",{"version":"6b526a5ec4a401ca7c26cfe6a48e641d8f30af76673bad3b06a1b4504594a960","affectsGlobalScope":true},{"version":"c2fcbd6fad600e96fee8c5df1a62e908d477f5b47a9374b2bab7e74f52cfcc92","affectsGlobalScope":true},"dc15cb97f565e378faebd4e92699a56c28d2065f4535045f6c5550261fb83f3a","cc68e79b99f80e4dfd01967ec96be69efb0ff5bd7f779d9a2cc09dfe590ffd28","91d3d8f536f22dcaeeace0fc6f3544d3562e266a27cf3a2fe280b8051af5d006","9503113febdd737095465792cc074d541902c82c0aea3922f940de18784812ad","8d3c583a07e0c37e876908c2d5da575019f689df8d9fa4c081d99119d53dba22","7e5307e29dfd5d5b827203b85cb665d8d5bf932a6c6f393457da8e9ed1906761",{"version":"987b3a9098738f5f40efe9fee5734b55f4c8ac599a045922b1470bb325183ed6","affectsGlobalScope":true},"bcebb922784739bdb34c18ee51095d25a92b560c78ccd2eaacd6bd00f7443d83","7ee6ed878c4528215c82b664fe0cfe80e8b4da6c0d4cc80869367868774db8b1","b0973c3cbcdc59b37bf477731d468696ecaf442593ec51bab497a613a580fe30",{"version":"69e93290f59948789d5fce61cb0b89dde93747a4576744d0d6fae41ee3991646","affectsGlobalScope":true},{"version":"0715e4cd28ad471b2a93f3e552ff51a3ae423417a01a10aa1d3bc7c6b95059d6","affectsGlobalScope":true},"5153a2fd150e46ce57bb3f8db1318d33f6ad3261ed70ceeff92281c0608c74a3","210d54cd652ec0fec8c8916e4af59bb341065576ecda039842f9ffb2e908507c","36b03690b628eab08703d63f04eaa89c5df202e5f1edf3989f13ad389cd2c091","0effadd232a20498b11308058e334d3339cc5bf8c4c858393e38d9d4c0013dcf","25846d43937c672bab7e8195f3d881f93495df712ee901860effc109918938cc","b7998044b77ef376a39c07f038f317d875b3f51b5f8f733384d85ecd083182e7","1b952304137851e45bc009785de89ada562d9376177c97e37702e39e60c2f1ff","69ee23dd0d215b09907ad30d23f88b7790c93329d1faf31d7835552a10cf7cbf","44b8b584a338b190a59f4f6929d072431950c7bd92ec2694821c11bce180c8a5","23b89798789dffbd437c0c423f5d02d11f9736aea73d6abf16db4f812ff36eda",{"version":"a4a2a5596dd7e531ab0ce785ed1c8f6940e0632e5bcaa7e8c144bd0e41029297","affectsGlobalScope":true},{"version":"3c4ba1dd9b12ffa284b565063108f2f031d150ea15b8fafbdc17f5d2a07251f3","affectsGlobalScope":true},"e10177274a35a9d07c825615340b2fcde2f610f53f3fb40269fd196b4288dda6","1422cd9e705adcc09088fda85a900c2b70e3ad36ea85846f68bd1a884cdf4e2b","3c13ef48634e7b5012fcf7e8fce7496352c2d779a7201389ca96a2a81ee4314d","5d0a25ec910fa36595f85a67ac992d7a53dd4064a1ba6aea1c9f14ab73a023f2",{"version":"22d7b95cb63dead43834ae20ee492c9c8b6d90db3957d21665199f0efb1d3e26","affectsGlobalScope":true},{"version":"a9fc1469744055a3435f203123246b96c094e7ff8c4e1c3863829d9b705b7a34","affectsGlobalScope":true},"868831cab82b65dfe1d68180e898af1f2101e89ba9b754d1db6fb8cc2fac1921","5d842e3acce41c978af367a28163cef799170dadd06edf2111cc9ecab6eae968","e59a892d87e72733e2a9ca21611b9beb52977be2696c7ba4b216cbbb9a48f5aa",{"version":"52120bb7e4583612225bdf08e7c12559548170f11e660d33a33623bae9bbdbba","affectsGlobalScope":true},"8a300fa9b698845a1f9c41ecbe2c5966634582a8e2020d51abcace9b55aa959e",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"d5be4343a9ace4611f04a6fffd91ceba91265fa15bfb0149306e0a6963e1a015","82819f9ecc249a6a3e284003540d02ea1b1f56f410c23231797b9e1e4b9622df","afc559c1b93df37c25aef6b3dfa2d64325b0e112e887ee18bf7e6f4ec383fc90","d78e5898c8de5e0f934eee83f680262de005caa268d137101b833fd932f95e07","84e3bbd6f80983d468260fdbfeeb431cc81f7ea98d284d836e4d168e36875e86","aad5ffa61406b8e19524738fcf0e6fda8b3485bba98626268fdf252d1b2b630a","16d51f964ec125ad2024cf03f0af444b3bc3ec3614d9345cc54d09bab45c9a4c","c7da551241b7be719b7bd654ab12a5098c3206fbb189076dd2d8871011a6ab5a",{"version":"4aed81e1115540695f896fa93fb22840fe06086741e94c6859e745f173498213","affectsGlobalScope":true},"87e4358eddd469426393408b4976bee1970c91634faa57a71f1db2c2f8dee9ba",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"bee89e1eb6425eb49894f3f25e4562dc2564e84e5aa7610b7e13d8ecddf8f5db","facc7572c3330810ff4728113a324790679d4ed41fbd9e371028f08f1cad29f3","e050a0afcdbb269720a900c85076d18e0c1ab73e580202a2bf6964978181222a","f463d61cf39c3a6a5f96cdf7adfdb72a0b1d663f7b5d5b6dd042adba835430c2","f7a9cb83c8fbc081a8b605880d191e0d0527cde2c1b2b2b623beca8f0203a2cd","43cdd474c5aa3340da4816bb8f1ae7f3b1bcf9e70d997afc36a0f2c432378c84","bf88ef4208a770ca39a844b182b3695df536326ea566893fdc5b8418702a331e","0670eede14b39fd186fe7e224db70510158af5279528d12292df9b980867c1d0","3d2cd8f3047fff04a71e7037a6a4cb9f4accb28dbd8c0d83164d414811025af0",{"version":"271cde49dfd9b398ccc91bb3aaa43854cf76f4d14e10fed91cbac649aa6cbc63","affectsGlobalScope":true},"2bcecd31f1b4281710c666843fc55133a0ee25b143e59f35f49c62e168123f4b","a6273756fa05f794b64fe1aff45f4371d444f51ed0257f9364a8b25f3501915d","9c4e644fe9bf08d93c93bd892705842189fe345163f8896849d5964d21b56b78","25d91fb9ed77a828cc6c7a863236fb712dafcd52f816eec481bd0c1f589f4404","4cd14cea22eed1bfb0dc76183e56989f897ac5b14c0e2a819e5162eafdcfe243","8d32432f68ca4ce93ad717823976f2db2add94c70c19602bf87ee67fe51df48b","ee65fe452abe1309389c5f50710f24114e08a302d40708101c4aa950a2a7d044","1d96568a72657f762763c920d3804868db48d638abd87ddcd82bcb200ef9625c","6acf8a984c2728906edeba2098c5c51f44a4520bc4a48c65b973bd785537178f","8b06ac3faeacb8484d84ddb44571d8f410697f98d7bfa86c0fda60373a9f5215","7eb06594824ada538b1d8b48c3925a83e7db792f47a081a62cf3e5c4e23cf0ee","f5638f7c2f12a9a1a57b5c41b3c1ea7db3876c003bab68e6a57afd6bcc169af0","cdcc132f207d097d7d3aa75615ab9a2e71d6a478162dde8b67f88ea19f3e54de","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","c085e9aa62d1ae1375794c1fb927a445fa105fed891a7e24edbb1c3300f7384a","f315e1e65a1f80992f0509e84e4ae2df15ecd9ef73df975f7c98813b71e4c8da","5b9586e9b0b6322e5bfbd2c29bd3b8e21ab9d871f82346cb71020e3d84bae73e","3e70a7e67c2cb16f8cd49097360c0309fe9d1e3210ff9222e9dac1f8df9d4fb6","ab68d2a3e3e8767c3fba8f80de099a1cfc18c0de79e42cb02ae66e22dfe14a66","d96cc6598148bf1a98fb2e8dcf01c63a4b3558bdaec6ef35e087fd0562eb40ec",{"version":"7607da500c00af67a93aacb928552afd08d519f8e68eca30d4c624a69fd28ee9","affectsGlobalScope":true},"ba600bf38b5c1a5dffa1b99dd7a783549082bbba3b4fe9497eaaf5e4c1764b20","ae8cd6af37275eac75f5369cdb5f01063bcf1f48d74cb434303ee50ec446acfe","2518830a2fda9c272ba48798d0e7b857037443b06594db8e42c87e86944ee9e4","95c1cf650d16b197525b5bfdf8dd7abba0a49d99ddb12a4ba66466a8a6903e49","1fe0aabe758d56ad72495d6e6c7b6ae75619faaeaaf03f0ddf1948eea4cfac84","bbc57966c8c48ee78fd58aadb893784025be056ae538ae22d1e83c502a987e68","5e5d6f6697e378b0660b567866bf67d099d0ea754f8810c0dabe737805f5cf03","99ab49d4732fdc98cf5c495925e65e796544cb4086fe42afc235dfc02bcf2351","af8339d509c40da075088e544c28ed37b519876e5c4d36a48644ebfb3c6ae6c8","d393adc32e520d4274bb4c3dfdcdb342b806a230b66ef0f82b35bffbc4aa2590","c26af7eaedb4f710984634e419ab15e54e5bb99a0b3cae71188c2fff572276de","38b58ef018d0aeee42ef74c42978bb5805503233fdeeb82cd2aed2199fb0d013","3b6040253231d44e6778eb6861cc86c1758562e77783d21b7ecbc73322ded539","cc256fd958b33576ed32c7338c64adb0d08fc0c2c6525010202fab83f32745da","fd0589ca571ad090b531d8c095e26caa53d4825c64d3ff2b2b1ab95d72294175",{"version":"669843ecafb89ae1e944df06360e8966219e4c1c34c0d28aa2503272cdd444a7","affectsGlobalScope":true},"96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","68b7968bfe692bb273debb1d38ed534b695f8b387d36b7b7a75a81b03f8bf238","5774751340e987a6a9e4a5dcc03ff68a6515adc2b91423e1af2f660fc8f30e81","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","209e814e8e71aec74f69686a9506dd7610b97ab59dcee9446266446f72a76d05","6fa0008bf91a4cc9c8963bace4bba0bd6865cbfa29c3e3ccc461155660fb113a","2b8264b2fefd7367e0f20e2c04eed5d3038831fe00f5efbc110ff0131aab899b","c555dd691dd05955e99cd93dd99c685a65e5287813ccb5e6bfde951183248e26","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","77cc95898fd0cf2a6b1a3cb4eaac854f1de93f55de0b052386195bd179090a22","5101a8cfdbce4781dddc2d55ab5c13bba9712e6c2faf9d7417ddd04e6c0e4848","1d4bc73751d6ec6285331d1ca378904f55d9e5e8aeaa69bc45b675c3df83e778","2ffcb0c75e294706a4d425ee3ead87826a4cda729fa901c6c605e68948adaf55","8017277c3843df85296d8730f9edf097d68d7d5f9bc9d8124fcacf17ecfd487e","45000d5f6b9b9e2881eb9e2f54b1f44a5fc33b0b1beb793a6370be9f7b9a17a5","332c7ccf95426d3156ebedb7295979ef2435bd1c1a940024a4d068da3418718f","e03334588c63840b7054accd0b90f29c5890db6a6555ac0869a78a23297f1396","c3052485f32a96bfde75a2976c1238995522584ba464f04ff16a8a40af5e50d1","c220410b8e956fa157ce4e5e6ac871f0f433aa120c334d906ff1f5e2c7369e95","960a68ced7820108787135bdae5265d2cc4b511b7dcfd5b8f213432a8483daf1","5e8db4872785292074b394d821ae2fc10e4f8edc597776368aebbe8aefb24422","199f9ead0daf25ae4c5632e3d1f42570af59685294a38123eef457407e13f365","8b3ba0006858bfefa8fd045d446377e0fb1738baa819a1f7e4a520644a0dc131","7ccce4adb23a87a044c257685613126b47160f6975b224cea5f6af36c7f37514","2b93035328f7778d200252681c1d86285d501ed424825a18f81e4c3028aa51d9","2ac9c8332c5f8510b8bdd571f8271e0f39b0577714d5e95c1e79a12b2616f069","42c21aa963e7b86fa00801d96e88b36803188018d5ad91db2a9101bccd40b3ff","d31eb848cdebb4c55b4893b335a7c0cca95ad66dee13cbb7d0893810c0a9c301","55e103448f452988dbdf65e293607c77fb91a967744bad2a72f1a36765e7e88d","7a9e0a564fee396cacf706523b5aeed96e04c6b871a8bebefad78499fbffc5bc","906c751ef5822ec0dadcea2f0e9db64a33fb4ee926cc9f7efa38afe5d5371b2a","5387c049e9702f2d2d7ece1a74836a14b47fbebe9bbeb19f94c580a37c855351","c68391fb9efad5d99ff332c65b1606248c4e4a9f1dd9a087204242b56c7126d6","e9cf02252d3a0ced987d24845dcb1f11c1be5541f17e5daa44c6de2d18138d0c","e8b02b879754d85f48489294f99147aeccc352c760d95a6fe2b6e49cd400b2fe","9f6908ab3d8a86c68b86e38578afc7095114e66b2fc36a2a96e9252aac3998e0","0eedb2344442b143ddcd788f87096961cd8572b64f10b4afc3356aa0460171c6","71405cc70f183d029cc5018375f6c35117ffdaf11846c35ebf85ee3956b1b2a6","c68baff4d8ba346130e9753cefe2e487a16731bf17e05fdacc81e8c9a26aae9d","2cd15528d8bb5d0453aa339b4b52e0696e8b07e790c153831c642c3dea5ac8af","479d622e66283ffa9883fbc33e441f7fc928b2277ff30aacbec7b7761b4e9579","ade307876dc5ca267ca308d09e737b611505e015c535863f22420a11fffc1c54","f8cdefa3e0dee639eccbe9794b46f90291e5fd3989fcba60d2f08fde56179fb9","86c5a62f99aac7053976e317dbe9acb2eaf903aaf3d2e5bb1cafe5c2df7b37a8","2b300954ce01a8343866f737656e13243e86e5baef51bd0631b21dcef1f6e954","a2d409a9ffd872d6b9d78ead00baa116bbc73cfa959fce9a2f29d3227876b2a1","b288936f560cd71f4a6002953290de9ff8dfbfbf37f5a9391be5c83322324898","61178a781ef82e0ff54f9430397e71e8f365fc1e3725e0e5346f2de7b0d50dfa","6a6ccb37feb3aad32d9be026a3337db195979cd5727a616fc0f557e974101a54","c649ea79205c029a02272ef55b7ab14ada0903db26144d2205021f24727ac7a3","38e2b02897c6357bbcff729ef84c736727b45cc152abe95a7567caccdfad2a1d","d6610ea7e0b1a7686dba062a1e5544dd7d34140f4545305b7c6afaebfb348341","3dee35db743bdba2c8d19aece7ac049bde6fa587e195d86547c882784e6ba34c","b15e55c5fa977c2f25ca0b1db52cfa2d1fd4bf0baf90a8b90d4a7678ca462ff1","f41d30972724714763a2698ae949fbc463afb203b5fa7c4ad7e4de0871129a17","843dd7b6a7c6269fd43827303f5cbe65c1fecabc30b4670a50d5a15d57daeeb9","f06d8b8567ee9fd799bf7f806efe93b67683ef24f4dea5b23ef12edff4434d9d","6017384f697ff38bc3ef6a546df5b230c3c31329db84cbfe686c83bec011e2b2","e1a5b30d9248549ca0c0bb1d653bafae20c64c4aa5928cc4cd3017b55c2177b0","a593632d5878f17295bd53e1c77f27bf4c15212822f764a2bfc1702f4b413fa0","a868a534ba1c2ca9060b8a13b0ffbbbf78b4be7b0ff80d8c75b02773f7192c29","da7545aba8f54a50fde23e2ede00158dc8112560d934cee58098dfb03aae9b9d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","a1a261624efb3a00ff346b13580f70f3463b8cdcc58b60f5793ff11785d52cab","acebfe99678cf7cddcddc3435222cf132052b1226e902daac9fbb495c321a9b5","82b1f9a6eefef7386aebe22ac49f23b806421e82dbf35c6e5b7132d79e4165da","b0d10e46cfe3f6c476b69af02eaa38e4ccc7430221ce3109ae84bb9fb8282298","abd79d61be476addd783d0e0bace2e3c02bb3e38ec23bdfd236adc421b038939","2dd1d4cea14cead7a7fc9eec8f40593089dff0de8c0199458446143c9b8c4ea9","70e9a18da08294f75bf23e46c7d69e67634c0765d355887b9b41f0d959e1426e","e9eb1b173aa166892f3eddab182e49cfe59aa2e14d33aedb6b49d175ed6a3750"],"options":{"allowSyntheticDefaultImports":true,"alwaysStrict":true,"composite":true,"declaration":true,"esModuleInterop":true,"importHelpers":false,"jsx":4,"module":99,"noFallthroughCasesInSwitch":true,"noImplicitAny":true,"noImplicitReturns":true,"noImplicitThis":true,"noUnusedLocals":true,"noUnusedParameters":true,"outDir":"./","rootDir":"../src","sourceMap":true,"strict":true,"strictFunctionTypes":true,"strictNullChecks":true,"strictPropertyInitialization":true,"target":5},"fileIdsList":[[175,227],[227],[227,269],[175,176,177,178,179,227],[175,177,227],[200,227,234,235],[191,227,234],[226,227,234,242],[200,227,234],[227,245,246],[79,227,244,245],[197,200,227,234,239,240,241],[227,236,241,242,249],[198,227,234],[227,252],[227,260],[227,254,260],[227,255,256,257,258,259],[197,200,202,205,215,226,227,234],[227,264],[227,265],[227,271,274],[197,227,229,234,288,289,291],[227,290],[79,227],[75,227],[63,65,66,67,68,69,70,71,72,73,74,75,227],[63,64,66,67,68,69,70,71,72,73,74,75,227],[64,65,66,67,68,69,70,71,72,73,74,75,227],[63,64,65,67,68,69,70,71,72,73,74,75,227],[63,64,65,66,68,69,70,71,72,73,74,75,227],[63,64,65,66,67,69,70,71,72,73,74,75,227],[63,64,65,66,67,68,70,71,72,73,74,75,227],[63,64,65,66,67,68,69,71,72,73,74,75,227],[63,64,65,66,67,68,69,70,72,73,74,75,227],[63,64,65,66,67,68,69,70,71,73,74,75,227],[63,64,65,66,67,68,69,70,71,72,74,75,227],[63,64,65,66,67,68,69,70,71,72,73,75,227],[63,64,65,66,67,68,69,70,71,72,73,74,227],[181,227],[184,227],[185,190,218,227],[186,197,198,205,215,226,227],[186,187,197,205,227],[188,227],[189,190,198,206,227],[190,215,223,227],[191,193,197,205,227],[192,227],[193,194,227],[197,227],[195,197,227],[197,198,199,215,226,227],[197,198,199,212,215,218,227],[227,231],[193,197,200,205,215,226,227],[197,198,200,201,205,215,223,226,227],[200,202,215,223,226,227],[181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233],[197,203,227],[204,226,227,231],[193,197,205,215,227],[206,227],[207,227],[184,208,227],[209,225,227,231],[210,227],[211,227],[197,212,213,227],[212,214,227,229],[185,197,215,216,217,218,227],[185,215,217,227],[215,216,227],[218,227],[219,227],[184,215,227],[197,221,222,227],[221,222,227],[190,205,215,223,227],[224,227],[205,225,227],[185,200,211,226,227],[190,227],[215,227,228],[204,227,229],[227,230],[185,190,197,199,208,215,226,227,229,231],[215,227,232],[61,227],[61,227,260,303],[61,227,260],[61,227,307],[227,307,308,309,310,311],[57,58,59,60,227],[215,227,234],[227,316,355],[227,316,340,355],[227,355],[227,316],[227,316,341,355],[227,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354],[227,341,355],[198,215,227,234,238],[198,227,250],[200,227,234,238,248],[197,200,202,215,223,226,227,232,234],[227,361],[227,267,273],[227,271],[227,268,272],[227,277],[227,276,277],[227,276],[227,276,277,278,280,281,284,285,286,287],[227,277,281],[227,276,277,278,280,281,282,283],[227,276,281],[227,281,285],[227,277,278,279],[227,278],[227,276,277,281],[227,270],[62,76,77,78,81,82,227],[62,81,84,227],[62,227],[62,81,87,227],[62,81,82,89,227],[62,81,92,173,227],[62,91,227],[62,80,121,227],[62,81,106,123,227],[62,81,125,227],[62,81,106,227],[62,81,123,127,227],[62,81,227],[62,81,82,94,95,227],[62,77,81,100,227],[62,81,129,227],[62,77,81,82,227],[62,81,113,227],[62,81,82,87,227],[62,81,82,84,227],[61,62,77,78,81,115,133,227],[62,81,134,227],[62,81,82,100,227],[62,80,81,82,83,84,85,86,87,88,90,92,96,103,112,113,115,116,119,120,121,122,123,124,125,126,128,129,130,131,132,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,161,163,173,174,227],[62,81,82,227],[61,62,227],[62,77,84,162,227],[62,81,82,84,114,115,227],[62,81,143,227],[62,77,81,82,106,135,227],[62,159,160,227],[62,81,82,106,117,158,159,227],[62,77,81,82,97,98,99,100,101,102,103,105,112,113,117,227],[62,77,81,82,84,93,96,112,115,116,117,118,119,142,163,165,227],[62,81,82,87,115,139,165,167,227],[62,81,104,227],[62,77,81,82,97,98,103,227],[62,104,105,117,118,164,165,166,167,168,169,170,171,172,227],[62,81,82,117,227],[62,81,164,227],[62,81,117,138,227],[62,81,93,142,227],[62,77,78,81,82,84,96,102,105,106,107,108,109,110,111,112,113,116,227],[62,77,81,82,97,117,227],[62,77,81,82,84,106,115,117,227],[62,77,78,81,82,106,112,117,118,227],[61,62,92,227],[62,81,83,152,227],[61,62,79,80,227],[62,81,89,227],[62,146,227],[62,81,93,142,151,227],[62,81,82,99,227],[81],[80],[80,81,82,83,84,85,86,87,88,90,92,96,103,112,113,115,116,119,120,121,122,123,124,125,126,128,129,130,131,132,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,161,163,173,174],[61],[159,160],[81,159],[104,105,117,118,164,165,166,167,168,169,170,171,172],[79,81],[61,79,80]],"referencedMap":[[177,1],[175,2],[267,2],[270,3],[269,2],[180,4],[176,1],[178,5],[179,1],[236,6],[237,7],[243,8],[235,9],[247,10],[244,2],[246,11],[245,2],[242,12],[250,13],[251,14],[253,15],[254,2],[258,16],[259,16],[255,17],[256,17],[257,17],[260,18],[261,2],[248,2],[262,19],[263,2],[264,2],[265,20],[266,21],[275,22],[290,23],[291,24],[111,25],[79,2],[292,2],[293,26],[76,26],[64,27],[65,28],[63,29],[66,30],[67,31],[68,32],[69,33],[70,34],[71,35],[72,36],[73,37],[74,38],[109,26],[158,26],[77,26],[97,26],[75,39],[93,26],[106,26],[91,26],[127,26],[98,26],[99,26],[89,26],[100,26],[108,26],[95,26],[101,26],[78,26],[102,26],[152,26],[107,26],[114,26],[110,26],[294,15],[238,2],[295,2],[296,2],[181,40],[182,40],[184,41],[185,42],[186,43],[187,44],[188,45],[189,46],[190,47],[191,48],[192,49],[193,50],[194,50],[196,51],[195,52],[197,51],[198,53],[199,54],[183,55],[233,2],[200,56],[201,57],[202,58],[234,59],[203,60],[204,61],[205,62],[206,63],[207,64],[208,65],[209,66],[210,67],[211,68],[212,69],[213,69],[214,70],[215,71],[217,72],[216,73],[218,74],[219,75],[220,76],[221,77],[222,78],[223,79],[224,80],[225,81],[226,82],[227,83],[228,84],[229,85],[230,86],[231,87],[232,88],[297,2],[298,2],[299,2],[300,2],[59,2],[241,2],[240,2],[301,89],[302,89],[304,90],[305,90],[303,91],[306,89],[308,92],[310,89],[307,89],[309,92],[311,2],[312,93],[57,2],[61,94],[62,89],[313,2],[314,95],[315,2],[60,2],[340,96],[341,97],[316,98],[319,98],[338,96],[339,96],[329,96],[328,99],[326,96],[321,96],[334,96],[332,96],[336,96],[320,96],[333,96],[337,96],[322,96],[323,96],[335,96],[317,96],[324,96],[325,96],[327,96],[331,96],[342,100],[330,96],[318,96],[355,101],[354,2],[349,100],[351,102],[350,100],[343,100],[344,100],[346,100],[348,100],[352,102],[353,102],[345,102],[347,102],[239,103],[356,104],[249,105],[357,9],[358,2],[289,2],[252,2],[359,2],[360,106],[361,2],[362,107],[268,2],[58,2],[274,108],[272,109],[273,110],[94,2],[278,111],[287,112],[276,2],[277,113],[288,114],[283,115],[284,116],[282,117],[286,118],[280,119],[279,120],[285,121],[281,112],[271,122],[11,2],[12,2],[14,2],[13,2],[2,2],[15,2],[16,2],[17,2],[18,2],[19,2],[20,2],[21,2],[22,2],[3,2],[4,2],[26,2],[23,2],[24,2],[25,2],[27,2],[28,2],[29,2],[5,2],[30,2],[31,2],[32,2],[33,2],[6,2],[37,2],[34,2],[35,2],[36,2],[38,2],[7,2],[39,2],[44,2],[45,2],[40,2],[41,2],[42,2],[43,2],[8,2],[49,2],[46,2],[47,2],[48,2],[50,2],[9,2],[51,2],[52,2],[53,2],[54,2],[55,2],[1,2],[10,2],[56,2],[133,89],[83,123],[85,124],[86,125],[88,126],[82,125],[90,127],[174,128],[120,125],[92,129],[122,130],[124,131],[126,132],[125,133],[128,134],[123,135],[80,125],[96,136],[112,137],[130,138],[103,139],[115,140],[131,141],[132,135],[87,142],[134,143],[113,125],[136,144],[135,135],[137,145],[162,146],[138,147],[139,126],[119,124],[84,125],[140,148],[141,125],[163,149],[142,124],[116,150],[144,151],[145,135],[146,125],[147,135],[159,152],[161,153],[160,154],[129,135],[121,125],[118,155],[166,156],[168,157],[105,158],[104,159],[173,160],[167,161],[165,162],[164,163],[169,164],[117,165],[170,166],[171,167],[172,168],[148,135],[149,169],[143,147],[150,135],[151,127],[153,170],[81,171],[154,172],[155,173],[156,174],[157,175]],"exportedModulesMap":[[177,1],[175,2],[267,2],[270,3],[269,2],[180,4],[176,1],[178,5],[179,1],[236,6],[237,7],[243,8],[235,9],[247,10],[244,2],[246,11],[245,2],[242,12],[250,13],[251,14],[253,15],[254,2],[258,16],[259,16],[255,17],[256,17],[257,17],[260,18],[261,2],[248,2],[262,19],[263,2],[264,2],[265,20],[266,21],[275,22],[290,23],[291,24],[111,25],[79,2],[292,2],[293,26],[76,26],[64,27],[65,28],[63,29],[66,30],[67,31],[68,32],[69,33],[70,34],[71,35],[72,36],[73,37],[74,38],[109,26],[158,26],[77,26],[97,26],[75,39],[93,26],[106,26],[91,26],[127,26],[98,26],[99,26],[89,26],[100,26],[108,26],[95,26],[101,26],[78,26],[102,26],[152,26],[107,26],[114,26],[110,26],[294,15],[238,2],[295,2],[296,2],[181,40],[182,40],[184,41],[185,42],[186,43],[187,44],[188,45],[189,46],[190,47],[191,48],[192,49],[193,50],[194,50],[196,51],[195,52],[197,51],[198,53],[199,54],[183,55],[233,2],[200,56],[201,57],[202,58],[234,59],[203,60],[204,61],[205,62],[206,63],[207,64],[208,65],[209,66],[210,67],[211,68],[212,69],[213,69],[214,70],[215,71],[217,72],[216,73],[218,74],[219,75],[220,76],[221,77],[222,78],[223,79],[224,80],[225,81],[226,82],[227,83],[228,84],[229,85],[230,86],[231,87],[232,88],[297,2],[298,2],[299,2],[300,2],[59,2],[241,2],[240,2],[301,89],[302,89],[304,90],[305,90],[303,91],[306,89],[308,92],[310,89],[307,89],[309,92],[311,2],[312,93],[57,2],[61,94],[62,89],[313,2],[314,95],[315,2],[60,2],[340,96],[341,97],[316,98],[319,98],[338,96],[339,96],[329,96],[328,99],[326,96],[321,96],[334,96],[332,96],[336,96],[320,96],[333,96],[337,96],[322,96],[323,96],[335,96],[317,96],[324,96],[325,96],[327,96],[331,96],[342,100],[330,96],[318,96],[355,101],[354,2],[349,100],[351,102],[350,100],[343,100],[344,100],[346,100],[348,100],[352,102],[353,102],[345,102],[347,102],[239,103],[356,104],[249,105],[357,9],[358,2],[289,2],[252,2],[359,2],[360,106],[361,2],[362,107],[268,2],[58,2],[274,108],[272,109],[273,110],[94,2],[278,111],[287,112],[276,2],[277,113],[288,114],[283,115],[284,116],[282,117],[286,118],[280,119],[279,120],[285,121],[281,112],[271,122],[11,2],[12,2],[14,2],[13,2],[2,2],[15,2],[16,2],[17,2],[18,2],[19,2],[20,2],[21,2],[22,2],[3,2],[4,2],[26,2],[23,2],[24,2],[25,2],[27,2],[28,2],[29,2],[5,2],[30,2],[31,2],[32,2],[33,2],[6,2],[37,2],[34,2],[35,2],[36,2],[38,2],[7,2],[39,2],[44,2],[45,2],[40,2],[41,2],[42,2],[43,2],[8,2],[49,2],[46,2],[47,2],[48,2],[50,2],[9,2],[51,2],[52,2],[53,2],[54,2],[55,2],[1,2],[10,2],[56,2],[133,89],[83,176],[85,176],[88,176],[90,176],[174,176],[122,177],[124,176],[126,176],[125,176],[128,176],[123,176],[96,176],[112,176],[130,176],[103,176],[115,176],[131,176],[132,176],[87,176],[134,176],[136,176],[135,176],[137,176],[162,178],[138,176],[139,176],[119,176],[140,179],[142,176],[116,176],[144,176],[147,176],[159,176],[161,180],[160,181],[129,176],[118,176],[166,176],[168,176],[105,176],[104,176],[173,182],[167,176],[165,176],[164,176],[169,176],[117,176],[170,176],[171,176],[172,176],[148,176],[149,179],[143,183],[150,176],[151,176],[153,176],[81,184],[154,176],[156,176],[157,176]],"semanticDiagnosticsPerFile":[177,175,267,270,269,180,176,178,179,236,237,243,235,247,244,246,245,242,250,251,253,254,258,259,255,256,257,260,261,248,262,263,264,265,266,275,290,291,111,79,292,293,76,64,65,63,66,67,68,69,70,71,72,73,74,109,158,77,97,75,93,106,91,127,98,99,89,100,108,95,101,78,102,152,107,114,110,294,238,295,296,181,182,184,185,186,187,188,189,190,191,192,193,194,196,195,197,198,199,183,233,200,201,202,234,203,204,205,206,207,208,209,210,211,212,213,214,215,217,216,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,297,298,299,300,59,241,240,301,302,304,305,303,306,308,310,307,309,311,312,57,61,62,313,314,315,60,340,341,316,319,338,339,329,328,326,321,334,332,336,320,333,337,322,323,335,317,324,325,327,331,342,330,318,355,354,349,351,350,343,344,346,348,352,353,345,347,239,356,249,357,358,289,252,359,360,361,362,268,58,274,272,273,94,278,287,276,277,288,283,284,282,286,280,279,285,281,271,11,12,14,13,2,15,16,17,18,19,20,21,22,3,4,26,23,24,25,27,28,29,5,30,31,32,33,6,37,34,35,36,38,7,39,44,45,40,41,42,43,8,49,46,47,48,50,9,51,52,53,54,55,1,10,56,133,83,85,86,88,82,90,174,120,92,122,124,126,125,128,123,80,96,112,130,103,115,131,132,87,134,113,136,135,137,162,138,139,119,84,140,141,163,142,116,144,145,146,147,159,161,160,129,121,118,166,168,105,104,173,167,165,164,169,117,170,171,172,148,149,143,150,151,153,81,154,155,156,157],"latestChangedDtsFile":"./createSchemaUtils.d.ts"},"version":"4.9.5"}
\ No newline at end of file
+{"program":{"fileNames":["../../../node_modules/typescript/lib/lib.es5.d.ts","../../../node_modules/typescript/lib/lib.es2015.d.ts","../../../node_modules/typescript/lib/lib.es2016.d.ts","../../../node_modules/typescript/lib/lib.es2017.d.ts","../../../node_modules/typescript/lib/lib.es2018.d.ts","../../../node_modules/typescript/lib/lib.es2019.d.ts","../../../node_modules/typescript/lib/lib.es2020.d.ts","../../../node_modules/typescript/lib/lib.es2021.d.ts","../../../node_modules/typescript/lib/lib.es2022.d.ts","../../../node_modules/typescript/lib/lib.esnext.d.ts","../../../node_modules/typescript/lib/lib.dom.d.ts","../../../node_modules/typescript/lib/lib.dom.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.core.d.ts","../../../node_modules/typescript/lib/lib.es2015.collection.d.ts","../../../node_modules/typescript/lib/lib.es2015.generator.d.ts","../../../node_modules/typescript/lib/lib.es2015.iterable.d.ts","../../../node_modules/typescript/lib/lib.es2015.promise.d.ts","../../../node_modules/typescript/lib/lib.es2015.proxy.d.ts","../../../node_modules/typescript/lib/lib.es2015.reflect.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2015.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2016.array.include.d.ts","../../../node_modules/typescript/lib/lib.es2017.object.d.ts","../../../node_modules/typescript/lib/lib.es2017.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2017.string.d.ts","../../../node_modules/typescript/lib/lib.es2017.intl.d.ts","../../../node_modules/typescript/lib/lib.es2017.typedarrays.d.ts","../../../node_modules/typescript/lib/lib.es2018.asyncgenerator.d.ts","../../../node_modules/typescript/lib/lib.es2018.asynciterable.d.ts","../../../node_modules/typescript/lib/lib.es2018.intl.d.ts","../../../node_modules/typescript/lib/lib.es2018.promise.d.ts","../../../node_modules/typescript/lib/lib.es2018.regexp.d.ts","../../../node_modules/typescript/lib/lib.es2019.array.d.ts","../../../node_modules/typescript/lib/lib.es2019.object.d.ts","../../../node_modules/typescript/lib/lib.es2019.string.d.ts","../../../node_modules/typescript/lib/lib.es2019.symbol.d.ts","../../../node_modules/typescript/lib/lib.es2019.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.bigint.d.ts","../../../node_modules/typescript/lib/lib.es2020.date.d.ts","../../../node_modules/typescript/lib/lib.es2020.promise.d.ts","../../../node_modules/typescript/lib/lib.es2020.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2020.string.d.ts","../../../node_modules/typescript/lib/lib.es2020.symbol.wellknown.d.ts","../../../node_modules/typescript/lib/lib.es2020.intl.d.ts","../../../node_modules/typescript/lib/lib.es2020.number.d.ts","../../../node_modules/typescript/lib/lib.es2021.promise.d.ts","../../../node_modules/typescript/lib/lib.es2021.string.d.ts","../../../node_modules/typescript/lib/lib.es2021.weakref.d.ts","../../../node_modules/typescript/lib/lib.es2021.intl.d.ts","../../../node_modules/typescript/lib/lib.es2022.array.d.ts","../../../node_modules/typescript/lib/lib.es2022.error.d.ts","../../../node_modules/typescript/lib/lib.es2022.intl.d.ts","../../../node_modules/typescript/lib/lib.es2022.object.d.ts","../../../node_modules/typescript/lib/lib.es2022.sharedmemory.d.ts","../../../node_modules/typescript/lib/lib.es2022.string.d.ts","../../../node_modules/typescript/lib/lib.esnext.intl.d.ts","../../../node_modules/@types/react/global.d.ts","../../../node_modules/csstype/index.d.ts","../../../node_modules/@types/prop-types/index.d.ts","../../../node_modules/@types/scheduler/tracing.d.ts","../../../node_modules/@types/react/index.d.ts","../../../node_modules/@types/react/jsx-runtime.d.ts","../../../node_modules/@types/lodash/common/common.d.ts","../../../node_modules/@types/lodash/common/array.d.ts","../../../node_modules/@types/lodash/common/collection.d.ts","../../../node_modules/@types/lodash/common/date.d.ts","../../../node_modules/@types/lodash/common/function.d.ts","../../../node_modules/@types/lodash/common/lang.d.ts","../../../node_modules/@types/lodash/common/math.d.ts","../../../node_modules/@types/lodash/common/number.d.ts","../../../node_modules/@types/lodash/common/object.d.ts","../../../node_modules/@types/lodash/common/seq.d.ts","../../../node_modules/@types/lodash/common/string.d.ts","../../../node_modules/@types/lodash/common/util.d.ts","../../../node_modules/@types/lodash/index.d.ts","../../../node_modules/@types/lodash/clonedeep.d.ts","../../../node_modules/@types/lodash/get.d.ts","../../../node_modules/@types/lodash/set.d.ts","../../../node_modules/@types/json-schema/index.d.ts","../src/enums.ts","../src/types.ts","../src/constants.ts","../src/errorschemabuilder.ts","../src/isobject.ts","../src/allowadditionalitems.ts","../src/asnumber.ts","../src/getuioptions.ts","../src/canexpand.ts","../../../node_modules/@types/lodash/isplainobject.d.ts","../src/createerrorhandler.ts","../../../node_modules/@types/lodash/isequalwith.d.ts","../src/deepequals.ts","../../../node_modules/@types/lodash/isempty.d.ts","../../../node_modules/jsonpointer/jsonpointer.d.ts","../../../node_modules/@types/lodash/omit.d.ts","../src/findschemadefinition.ts","../../../node_modules/@types/lodash/has.d.ts","../../../node_modules/@types/lodash/isnumber.d.ts","../../../node_modules/@types/lodash/isobject.d.ts","../../../node_modules/@types/lodash/isstring.d.ts","../../../node_modules/@types/lodash/reduce.d.ts","../../../node_modules/@types/lodash/times.d.ts","../src/getoptionmatchingsimplediscriminator.ts","../src/schema/getmatchingoption.ts","../src/schema/getfirstmatchingoption.ts","../../../node_modules/@types/lodash/isequal.d.ts","../../../node_modules/@types/lodash/transform.d.ts","../../../node_modules/@types/lodash/merge.d.ts","../../../node_modules/@types/lodash/flattendeep.d.ts","../../../node_modules/@types/lodash/uniq.d.ts","../../../node_modules/@types/json-schema-merge-allof/index.d.ts","../src/getdiscriminatorfieldfromschema.ts","../src/guesstype.ts","../../../node_modules/@types/lodash/union.d.ts","../src/getschematype.ts","../src/mergeschemas.ts","../src/schema/retrieveschema.ts","../src/schema/getclosestmatchingoption.ts","../src/isfixeditems.ts","../src/datauritoblob.ts","../src/replacestringparameters.ts","../src/englishstringtranslator.ts","../src/enumoptionsvalueforindex.ts","../src/enumoptionsdeselectvalue.ts","../src/enumoptionsisselected.ts","../src/enumoptionsindexforvalue.ts","../../../node_modules/@types/lodash/isnil.d.ts","../src/enumoptionsselectvalue.ts","../src/rangespec.ts","../src/getinputprops.ts","../src/getsubmitbuttonoptions.ts","../src/gettemplate.ts","../node_modules/@types/react-is/index.d.ts","../src/getwidget.tsx","../src/hashforschema.ts","../src/haswidget.ts","../src/idgenerators.ts","../src/isconstant.ts","../src/iscustomwidget.ts","../src/labelvalue.ts","../src/localtoutc.ts","../src/mergeobjects.ts","../src/toconstant.ts","../src/optionslist.ts","../src/orderproperties.ts","../src/pad.ts","../src/parsedatestring.ts","../src/schemarequirestruevalue.ts","../src/shouldrender.ts","../src/todatestring.ts","../src/toerrorlist.ts","../../../node_modules/@types/lodash/topath.d.ts","../src/toerrorschema.ts","../src/unwraperrorhandler.ts","../src/utctolocal.ts","../src/validationdatamerge.ts","../src/withidrefprefix.ts","../../../node_modules/@types/lodash/foreach.d.ts","../src/parser/parservalidator.ts","../src/parser/schemaparser.ts","../src/parser/index.ts","../src/index.ts","../src/mergedefaultswithformdata.ts","../src/schema/isselect.ts","../src/schema/ismultiselect.ts","../src/schema/getdefaultformstate.ts","../src/schema/isfilesarray.ts","../src/schema/getdisplaylabel.ts","../src/schema/mergevalidationdata.ts","../src/schema/sanitizedatafornewschema.ts","../src/schema/toidschema.ts","../src/schema/topathschema.ts","../src/schema/index.ts","../src/createschemautils.ts","../../../node_modules/@babel/types/lib/index.d.ts","../../../node_modules/@types/babel__generator/index.d.ts","../../../node_modules/@babel/parser/typings/babel-parser.d.ts","../../../node_modules/@types/babel__template/index.d.ts","../../../node_modules/@types/babel__traverse/index.d.ts","../../../node_modules/@types/babel__core/index.d.ts","../../../node_modules/@types/node/assert.d.ts","../../../node_modules/@types/node/assert/strict.d.ts","../../../node_modules/@types/node/globals.d.ts","../../../node_modules/@types/node/async_hooks.d.ts","../../../node_modules/@types/node/buffer.d.ts","../../../node_modules/@types/node/child_process.d.ts","../../../node_modules/@types/node/cluster.d.ts","../../../node_modules/@types/node/console.d.ts","../../../node_modules/@types/node/constants.d.ts","../../../node_modules/@types/node/crypto.d.ts","../../../node_modules/@types/node/dgram.d.ts","../../../node_modules/@types/node/diagnostics_channel.d.ts","../../../node_modules/@types/node/dns.d.ts","../../../node_modules/@types/node/dns/promises.d.ts","../../../node_modules/@types/node/domain.d.ts","../../../node_modules/@types/node/dom-events.d.ts","../../../node_modules/@types/node/events.d.ts","../../../node_modules/@types/node/fs.d.ts","../../../node_modules/@types/node/fs/promises.d.ts","../../../node_modules/@types/node/http.d.ts","../../../node_modules/@types/node/http2.d.ts","../../../node_modules/@types/node/https.d.ts","../../../node_modules/@types/node/inspector.d.ts","../../../node_modules/@types/node/module.d.ts","../../../node_modules/@types/node/net.d.ts","../../../node_modules/@types/node/os.d.ts","../../../node_modules/@types/node/path.d.ts","../../../node_modules/@types/node/perf_hooks.d.ts","../../../node_modules/@types/node/process.d.ts","../../../node_modules/@types/node/punycode.d.ts","../../../node_modules/@types/node/querystring.d.ts","../../../node_modules/@types/node/readline.d.ts","../../../node_modules/@types/node/readline/promises.d.ts","../../../node_modules/@types/node/repl.d.ts","../../../node_modules/@types/node/stream.d.ts","../../../node_modules/@types/node/stream/promises.d.ts","../../../node_modules/@types/node/stream/consumers.d.ts","../../../node_modules/@types/node/stream/web.d.ts","../../../node_modules/@types/node/string_decoder.d.ts","../../../node_modules/@types/node/test.d.ts","../../../node_modules/@types/node/timers.d.ts","../../../node_modules/@types/node/timers/promises.d.ts","../../../node_modules/@types/node/tls.d.ts","../../../node_modules/@types/node/trace_events.d.ts","../../../node_modules/@types/node/tty.d.ts","../../../node_modules/@types/node/url.d.ts","../../../node_modules/@types/node/util.d.ts","../../../node_modules/@types/node/v8.d.ts","../../../node_modules/@types/node/vm.d.ts","../../../node_modules/@types/node/wasi.d.ts","../../../node_modules/@types/node/worker_threads.d.ts","../../../node_modules/@types/node/zlib.d.ts","../../../node_modules/@types/node/globals.global.d.ts","../../../node_modules/@types/node/index.d.ts","../../../node_modules/@types/connect/index.d.ts","../../../node_modules/@types/body-parser/index.d.ts","../../../node_modules/@types/bonjour/index.d.ts","../../../node_modules/@types/mime/index.d.ts","../../../node_modules/@types/send/index.d.ts","../../../node_modules/@types/range-parser/index.d.ts","../../../node_modules/@types/qs/index.d.ts","../../../node_modules/@types/express-serve-static-core/index.d.ts","../../../node_modules/@types/connect-history-api-fallback/index.d.ts","../../../node_modules/@types/eslint/helpers.d.ts","../../../node_modules/@types/estree/index.d.ts","../../../node_modules/@types/eslint/index.d.ts","../../../node_modules/@types/eslint-scope/index.d.ts","../../../node_modules/@types/http-errors/index.d.ts","../../../node_modules/@types/serve-static/index.d.ts","../../../node_modules/@types/express/index.d.ts","../../../node_modules/@types/graceful-fs/index.d.ts","../../../node_modules/@types/unist/index.d.ts","../../../node_modules/@types/hast/index.d.ts","../../../node_modules/@types/history/domutils.d.ts","../../../node_modules/@types/history/createbrowserhistory.d.ts","../../../node_modules/@types/history/createhashhistory.d.ts","../../../node_modules/@types/history/creatememoryhistory.d.ts","../../../node_modules/@types/history/locationutils.d.ts","../../../node_modules/@types/history/pathutils.d.ts","../../../node_modules/@types/history/index.d.ts","../../../node_modules/@types/html-minifier-terser/index.d.ts","../../../node_modules/@types/http-proxy/index.d.ts","../../../node_modules/@types/invariant/index.d.ts","../../../node_modules/@types/istanbul-lib-coverage/index.d.ts","../../../node_modules/@types/istanbul-lib-report/index.d.ts","../../../node_modules/@types/istanbul-reports/index.d.ts","../../../node_modules/@jest/expect-utils/build/index.d.ts","../../../node_modules/chalk/index.d.ts","../../../node_modules/@sinclair/typebox/typebox.d.ts","../../../node_modules/@jest/schemas/build/index.d.ts","../../../node_modules/pretty-format/build/index.d.ts","../../../node_modules/jest-diff/build/index.d.ts","../../../node_modules/jest-matcher-utils/build/index.d.ts","../../../node_modules/expect/build/index.d.ts","../../../node_modules/@types/jest/index.d.ts","../../../node_modules/parse5/dist/common/html.d.ts","../../../node_modules/parse5/dist/common/token.d.ts","../../../node_modules/parse5/dist/common/error-codes.d.ts","../../../node_modules/parse5/dist/tokenizer/preprocessor.d.ts","../../../node_modules/parse5/dist/tokenizer/index.d.ts","../../../node_modules/parse5/dist/tree-adapters/interface.d.ts","../../../node_modules/parse5/dist/parser/open-element-stack.d.ts","../../../node_modules/parse5/dist/parser/formatting-element-list.d.ts","../../../node_modules/parse5/dist/parser/index.d.ts","../../../node_modules/parse5/dist/tree-adapters/default.d.ts","../../../node_modules/parse5/dist/serializer/index.d.ts","../../../node_modules/parse5/dist/common/foreign-content.d.ts","../../../node_modules/parse5/dist/index.d.ts","../../../node_modules/@types/tough-cookie/index.d.ts","../../../node_modules/@types/jsdom/base.d.ts","../../../node_modules/@types/jsdom/index.d.ts","../../../node_modules/@types/json5/index.d.ts","../../../node_modules/@types/lodash.mergewith/index.d.ts","../../../node_modules/@types/mdast/index.d.ts","../../../node_modules/@types/minimatch/index.d.ts","../../../node_modules/@types/minimist/index.d.ts","../../../node_modules/@types/normalize-package-data/index.d.ts","../../../node_modules/@types/parse-json/index.d.ts","../../../node_modules/@types/parse5/index.d.ts","../../../node_modules/@types/prettier/index.d.ts","../../../node_modules/@types/react-dom/index.d.ts","../../../node_modules/@types/react-frame-component/index.d.ts","../../../node_modules/@types/react-router/index.d.ts","../../../node_modules/@types/react-router-config/index.d.ts","../../../node_modules/@types/react-router-dom/index.d.ts","../../../node_modules/@types/react-test-renderer/index.d.ts","../../../node_modules/@types/react-transition-group/transition.d.ts","../../../node_modules/@types/react-transition-group/csstransition.d.ts","../../../node_modules/@types/react-transition-group/transitiongroup.d.ts","../../../node_modules/@types/react-transition-group/switchtransition.d.ts","../../../node_modules/@types/react-transition-group/config.d.ts","../../../node_modules/@types/react-transition-group/index.d.ts","../../../node_modules/@types/retry/index.d.ts","../../../node_modules/@types/sax/index.d.ts","../../../node_modules/@types/scheduler/index.d.ts","../../../node_modules/@types/semver/classes/semver.d.ts","../../../node_modules/@types/semver/functions/parse.d.ts","../../../node_modules/@types/semver/functions/valid.d.ts","../../../node_modules/@types/semver/functions/clean.d.ts","../../../node_modules/@types/semver/functions/inc.d.ts","../../../node_modules/@types/semver/functions/diff.d.ts","../../../node_modules/@types/semver/functions/major.d.ts","../../../node_modules/@types/semver/functions/minor.d.ts","../../../node_modules/@types/semver/functions/patch.d.ts","../../../node_modules/@types/semver/functions/prerelease.d.ts","../../../node_modules/@types/semver/functions/compare.d.ts","../../../node_modules/@types/semver/functions/rcompare.d.ts","../../../node_modules/@types/semver/functions/compare-loose.d.ts","../../../node_modules/@types/semver/functions/compare-build.d.ts","../../../node_modules/@types/semver/functions/sort.d.ts","../../../node_modules/@types/semver/functions/rsort.d.ts","../../../node_modules/@types/semver/functions/gt.d.ts","../../../node_modules/@types/semver/functions/lt.d.ts","../../../node_modules/@types/semver/functions/eq.d.ts","../../../node_modules/@types/semver/functions/neq.d.ts","../../../node_modules/@types/semver/functions/gte.d.ts","../../../node_modules/@types/semver/functions/lte.d.ts","../../../node_modules/@types/semver/functions/cmp.d.ts","../../../node_modules/@types/semver/functions/coerce.d.ts","../../../node_modules/@types/semver/classes/comparator.d.ts","../../../node_modules/@types/semver/classes/range.d.ts","../../../node_modules/@types/semver/functions/satisfies.d.ts","../../../node_modules/@types/semver/ranges/max-satisfying.d.ts","../../../node_modules/@types/semver/ranges/min-satisfying.d.ts","../../../node_modules/@types/semver/ranges/to-comparators.d.ts","../../../node_modules/@types/semver/ranges/min-version.d.ts","../../../node_modules/@types/semver/ranges/valid.d.ts","../../../node_modules/@types/semver/ranges/outside.d.ts","../../../node_modules/@types/semver/ranges/gtr.d.ts","../../../node_modules/@types/semver/ranges/ltr.d.ts","../../../node_modules/@types/semver/ranges/intersects.d.ts","../../../node_modules/@types/semver/ranges/simplify.d.ts","../../../node_modules/@types/semver/ranges/subset.d.ts","../../../node_modules/@types/semver/internals/identifiers.d.ts","../../../node_modules/@types/semver/index.d.ts","../../../node_modules/@types/serve-index/index.d.ts","../../../node_modules/@types/sockjs/index.d.ts","../../../node_modules/@types/stack-utils/index.d.ts","../../../node_modules/@types/warning/index.d.ts","../../../node_modules/@types/ws/index.d.ts","../../../node_modules/@types/yargs-parser/index.d.ts","../../../node_modules/@types/yargs/index.d.ts"],"fileInfos":[{"version":"8730f4bf322026ff5229336391a18bcaa1f94d4f82416c8b2f3954e2ccaae2ba","affectsGlobalScope":true},"dc47c4fa66b9b9890cf076304de2a9c5201e94b740cffdf09f87296d877d71f6","7a387c58583dfca701b6c85e0adaf43fb17d590fb16d5b2dc0a2fbd89f35c467","8a12173c586e95f4433e0c6dc446bc88346be73ffe9ca6eec7aa63c8f3dca7f9","5f4e733ced4e129482ae2186aae29fde948ab7182844c3a5a51dd346182c7b06","4b421cbfb3a38a27c279dec1e9112c3d1da296f77a1a85ddadf7e7a425d45d18","1fc5ab7a764205c68fa10d381b08417795fc73111d6dd16b5b1ed36badb743d9","746d62152361558ea6d6115cf0da4dd10ede041d14882ede3568bce5dc4b4f1f","d11a03592451da2d1065e09e61f4e2a9bf68f780f4f6623c18b57816a9679d17","aea179452def8a6152f98f63b191b84e7cbd69b0e248c91e61fb2e52328abe8c",{"version":"3aafcb693fe5b5c3bd277bd4c3a617b53db474fe498fc5df067c5603b1eebde7","affectsGlobalScope":true},{"version":"f3d4da15233e593eacb3965cde7960f3fddf5878528d882bcedd5cbaba0193c7","affectsGlobalScope":true},{"version":"adb996790133eb33b33aadb9c09f15c2c575e71fb57a62de8bf74dbf59ec7dfb","affectsGlobalScope":true},{"version":"8cc8c5a3bac513368b0157f3d8b31cfdcfe78b56d3724f30f80ed9715e404af8","affectsGlobalScope":true},{"version":"cdccba9a388c2ee3fd6ad4018c640a471a6c060e96f1232062223063b0a5ac6a","affectsGlobalScope":true},{"version":"c5c05907c02476e4bde6b7e76a79ffcd948aedd14b6a8f56e4674221b0417398","affectsGlobalScope":true},{"version":"5f406584aef28a331c36523df688ca3650288d14f39c5d2e555c95f0d2ff8f6f","affectsGlobalScope":true},{"version":"22f230e544b35349cfb3bd9110b6ef37b41c6d6c43c3314a31bd0d9652fcec72","affectsGlobalScope":true},{"version":"7ea0b55f6b315cf9ac2ad622b0a7813315bb6e97bf4bb3fbf8f8affbca7dc695","affectsGlobalScope":true},{"version":"3013574108c36fd3aaca79764002b3717da09725a36a6fc02eac386593110f93","affectsGlobalScope":true},{"version":"eb26de841c52236d8222f87e9e6a235332e0788af8c87a71e9e210314300410a","affectsGlobalScope":true},{"version":"3be5a1453daa63e031d266bf342f3943603873d890ab8b9ada95e22389389006","affectsGlobalScope":true},{"version":"17bb1fc99591b00515502d264fa55dc8370c45c5298f4a5c2083557dccba5a2a","affectsGlobalScope":true},{"version":"7ce9f0bde3307ca1f944119f6365f2d776d281a393b576a18a2f2893a2d75c98","affectsGlobalScope":true},{"version":"6a6b173e739a6a99629a8594bfb294cc7329bfb7b227f12e1f7c11bc163b8577","affectsGlobalScope":true},{"version":"81cac4cbc92c0c839c70f8ffb94eb61e2d32dc1c3cf6d95844ca099463cf37ea","affectsGlobalScope":true},{"version":"b0124885ef82641903d232172577f2ceb5d3e60aed4da1153bab4221e1f6dd4e","affectsGlobalScope":true},{"version":"0eb85d6c590b0d577919a79e0084fa1744c1beba6fd0d4e951432fa1ede5510a","affectsGlobalScope":true},{"version":"da233fc1c8a377ba9e0bed690a73c290d843c2c3d23a7bd7ec5cd3d7d73ba1e0","affectsGlobalScope":true},{"version":"d154ea5bb7f7f9001ed9153e876b2d5b8f5c2bb9ec02b3ae0d239ec769f1f2ae","affectsGlobalScope":true},{"version":"bb2d3fb05a1d2ffbca947cc7cbc95d23e1d053d6595391bd325deb265a18d36c","affectsGlobalScope":true},{"version":"c80df75850fea5caa2afe43b9949338ce4e2de086f91713e9af1a06f973872b8","affectsGlobalScope":true},{"version":"9d57b2b5d15838ed094aa9ff1299eecef40b190722eb619bac4616657a05f951","affectsGlobalScope":true},{"version":"6c51b5dd26a2c31dbf37f00cfc32b2aa6a92e19c995aefb5b97a3a64f1ac99de","affectsGlobalScope":true},{"version":"6e7997ef61de3132e4d4b2250e75343f487903ddf5370e7ce33cf1b9db9a63ed","affectsGlobalScope":true},{"version":"2ad234885a4240522efccd77de6c7d99eecf9b4de0914adb9a35c0c22433f993","affectsGlobalScope":true},{"version":"5e5e095c4470c8bab227dbbc61374878ecead104c74ab9960d3adcccfee23205","affectsGlobalScope":true},{"version":"09aa50414b80c023553090e2f53827f007a301bc34b0495bfb2c3c08ab9ad1eb","affectsGlobalScope":true},{"version":"d7f680a43f8cd12a6b6122c07c54ba40952b0c8aa140dcfcf32eb9e6cb028596","affectsGlobalScope":true},{"version":"3787b83e297de7c315d55d4a7c546ae28e5f6c0a361b7a1dcec1f1f50a54ef11","affectsGlobalScope":true},{"version":"e7e8e1d368290e9295ef18ca23f405cf40d5456fa9f20db6373a61ca45f75f40","affectsGlobalScope":true},{"version":"faf0221ae0465363c842ce6aa8a0cbda5d9296940a8e26c86e04cc4081eea21e","affectsGlobalScope":true},{"version":"06393d13ea207a1bfe08ec8d7be562549c5e2da8983f2ee074e00002629d1871","affectsGlobalScope":true},{"version":"2768ef564cfc0689a1b76106c421a2909bdff0acbe87da010785adab80efdd5c","affectsGlobalScope":true},{"version":"b248e32ca52e8f5571390a4142558ae4f203ae2f94d5bac38a3084d529ef4e58","affectsGlobalScope":true},{"version":"6c55633c733c8378db65ac3da7a767c3cf2cf3057f0565a9124a16a3a2019e87","affectsGlobalScope":true},{"version":"fb4416144c1bf0323ccbc9afb0ab289c07312214e8820ad17d709498c865a3fe","affectsGlobalScope":true},{"version":"5b0ca94ec819d68d33da516306c15297acec88efeb0ae9e2b39f71dbd9685ef7","affectsGlobalScope":true},{"version":"34c839eaaa6d78c8674ae2c37af2236dee6831b13db7b4ef4df3ec889a04d4f2","affectsGlobalScope":true},{"version":"34478567f8a80171f88f2f30808beb7da15eac0538ae91282dd33dce928d98ed","affectsGlobalScope":true},{"version":"ab7d58e6161a550ff92e5aff755dc37fe896245348332cd5f1e1203479fe0ed1","affectsGlobalScope":true},{"version":"6bda95ea27a59a276e46043b7065b55bd4b316c25e70e29b572958fa77565d43","affectsGlobalScope":true},{"version":"aedb8de1abb2ff1095c153854a6df7deae4a5709c37297f9d6e9948b6806fa66","affectsGlobalScope":true},{"version":"a4da0551fd39b90ca7ce5f68fb55d4dc0c1396d589b612e1902f68ee090aaada","affectsGlobalScope":true},{"version":"11ffe3c281f375fff9ffdde8bbec7669b4dd671905509079f866f2354a788064","affectsGlobalScope":true},{"version":"52d1bb7ab7a3306fd0375c8bff560feed26ed676a5b0457fa8027b563aecb9a4","affectsGlobalScope":true},{"version":"49a253ec027e56c55c7450a0c331cfe96212b3d1cc215b1710ba94a083404cf3","affectsGlobalScope":true},"4c68749a564a6facdf675416d75789ee5a557afda8960e0803cf6711fa569288","6a386ff939f180ae8ef064699d8b7b6e62bc2731a62d7fbf5e02589383838dea","f5a8b384f182b3851cec3596ccc96cb7464f8d3469f48c74bf2befb782a19de5",{"version":"6a1c1a2911268b0ac9e6b0248ecbcbab53b197431965684491f153ef57e02726","affectsGlobalScope":true},"af7fd2870746deed40e130fc0a3966de74e8f52a97ec114d0fbb35876ab05ca9","675e702f2032766a91eeadee64f51014c64688525da99dccd8178f0c599f13a8","458111fc89d11d2151277c822dfdc1a28fa5b6b2493cf942e37d4cd0a6ee5f22","da2b6356b84a40111aaecb18304ea4e4fcb43d70efb1c13ca7d7a906445ee0d3","187119ff4f9553676a884e296089e131e8cc01691c546273b1d0089c3533ce42","febf0b2de54781102b00f61653b21377390a048fbf5262718c91860d11ff34a6","98f9d826db9cd99d27a01a59ee5f22863df00ccf1aaf43e1d7db80ebf716f7c3","0aaef8cded245bf5036a7a40b65622dd6c4da71f7a35343112edbe112b348a1e","00baffbe8a2f2e4875367479489b5d43b5fc1429ecb4a4cc98cfc3009095f52a","dcd91d3b697cb650b95db5471189b99815af5db2a1cd28760f91e0b12ede8ed5","3c92b6dfd43cc1c2485d9eba5ff0b74a19bb8725b692773ef1d66dac48cda4bd","b03afe4bec768ae333582915146f48b161e567a81b5ebc31c4d78af089770ac9","df996e25faa505f85aeb294d15ebe61b399cf1d1e49959cdfaf2cc0815c203f9","30abc554c7ad13063a02ddd06757929b34357aea1f6fcf4ca39114cb0fc19384","a33ea06913b712c529662bee7fd75959781267cf8a307902cc7761307fec0337","8c7bb1d03e5607e5ad3d27f48e53dbe70b61372ea73d75000c9ead7ad2ac0fbd","05dd03486750d327568269b9f84aa51f15a066bcdc2ccefd8b592fb06fa3a371","dca41e86e89dfb2e85e6935260250f02eb6683b86c2fa16bec729ddd1bcd9b4b",{"version":"82084875b54da7cfe47b476e919c357b88d012ef46d67f560b6f8a21d9c9f6d0","signature":"6d6b6f1047b49859b061c56c93d92f244e4339e2a707757df64722488d7fbab1"},{"version":"070f2cb25f58ece59e91094539ab71ad59821f2d5a44eb92a772e55f1ade10f8","signature":"f08aaf5836d316e29e4ef8d29261a8b4526fb69c13013a8114bee3bbd1677ca3"},{"version":"107811847a5b3690d09fde7f3553758afe2c4f2e8dfe97f65d7defa8e35f1da8","signature":"014f0c53f92df1c7843875ae4e13ed345c6f0ce9d86343adc05b4f265622cc26"},{"version":"da69da39fd47522e504ef2d6d041a8b9ac7a9d7a54710d399bf9133b1261db0d","signature":"1d52f1b984fa9e99ce425542bc2e0eebd5f25ec4faee3aa6cdf7b61b4d4d89d3"},{"version":"84e35186c4ed1fd31276ad2cb2c542784d4442df074ef9c6d5dbbd803a83327e","signature":"58d42160a43791a11314ee16c8851f2fb1a78def2149f8c9dba304f2a3d5b2d8"},{"version":"61a559cf34d7e1f3427150cebc2ab80a6ecd7081e065ab16a3b70ad1c9fd5ec2","signature":"e519f83f61ffb2e2e1cabd9faba6e52958e9a1a1a48a993ecb110b5192297b94"},{"version":"33428ca777c2e716dde0f860fb1c2ab3daaade4fd3946f4fd616638fbcad659f","signature":"1b80a6b4081497ce02cb2946b6bc8d52c31274682ebffefb0a143e40c9d63a7e"},{"version":"6585bcfc59785259b92095d4120a118eefab6e56bbab7acce0a28fe0f10707e1","signature":"2b3ba064f623119ee97ebf3fd378716c186380895c4295dcf7ca2fb090ff8045"},{"version":"5e2f5a9f866b628cb6b05b433ccb09f3f8635593579651a22f230a454070d780","signature":"2ca4d5e6a35e9578c859eb3cec70a4516446561fea15ef3579740ff2e2246fac"},"6481b0b18d7623bfdd63d1dccefb9019594818c7bbfc735c54ec67779bdd9aa7",{"version":"7d2d050133444aceb7bc12554370bcdb834d5326f54237cdb64f611418cb7f59","signature":"030069a1a9c22135c4303d4282e18071ea446b3e4dc7cc58c2402f4a0275a3ec"},"62c492e1fba26f134ff83bfd1afcb0e1af2ac28b4488f38a10d4c89afdba7912",{"version":"3034e315f1cb0ffa800a903381387bb35633eaf6e41d293002c8538e3acee504","signature":"052c4327ff70d0c5f77dea1aa6722d86e4878ee3e6f8b8d2f4c69e2fe9881049"},"8dcd8273655aef81be9c273e532a55f56032c7907b20f8ed4d069f7eec44ace8","de34db5191530ba991bda92326932682a62626275f4d47a08c5377130a9b25a3","d51d9d8bb90a13d0b1aeedce422694aecf48e4e699bf3e1891a472a8c83ccd89",{"version":"2f2fceb02e12119cd2328390e8005fa64f71cc19932ebafe2fb1bb95efe389d6","signature":"7499746e03b60b6a22be32dc575165c49dd292d44c3922e1546dbc738e315129"},"4a4eff67dc5860f4b9302e395e3ad2be716d08ed838f5540e32c8ac7b1b4920b","e3602c7ef8cfedd027c02a023075b2c7ba2705d26ec521a8e95f2084f4a138ba","08906ca4df290e78211120ae722953b460e978096c01ab2d42a682088fd1203e","d6f46220d383fb0fd842186b0106c3e3c5b65c7d67a9f45a359ddc6721e22622","011041890a1f073bd0c6342a7493a0be0d1d03c9263879d5467d75d32c4a6790","4b7deb49486f22341efc7417fc672f7c83a402081927d8355833d8fc8f4b65f2",{"version":"afdd11953a64e2aaae374d5de12d356657b56d8e4020c635dc6007b5156ff84f","signature":"4ecdca42088b614272a3ac72641592cee105a6d331ec9ef71065a458b8e08e5b"},{"version":"54fb7c2808d13e60db600a7a5d01522cb8bf296c37f6fe07905c556cfa5d9f65","signature":"13abf3fb9538830791a72fb5691d3a739297a372815149af51a05d3b69b4769a"},{"version":"eff3cfcf08690feb7791a089ba4953238a7012173e1ab8a5db4a23de0b0ce90f","signature":"88b97594012922bd8dd259ade728682917379c0d8deb4465d74eed78971843b4"},"5ebc6dda07cd1112abcba3da894fafc01c04b37f55bc94bc110da3a662236cee","294c45fd29fdc9833fb3570114b8a47b9a71bf966f9f42e2f4dff033dd297a39","b6f9de62790db96554ad17ff5ff2b37e18e9eecca311430bb200b8318e282113","1d249f1f73dff883fe8b0104ca0cf867970c054fc12d86e9292c79a4c1704f27","2c705ed6e0913da9d7f85665a5f402043def9de30a1595a5cd78cba2ad0f1113","1ef731615b313977734bad46d7badba8952fa9b474bc19e9412bfb6b7395cf84",{"version":"7faa926faf71feca9206c1821155f2ff859c9f3226c9f8397b862fa7780c7448","signature":"f6512b98e519a8faba37dda4dbbbe4c2157e5470ea07449987a447a1c60f8ad3"},{"version":"a176bd4044aeb92980449c6f3aab1209c756ae2ccc0ebac839999f5cec6730f3","signature":"493abf890e318e12d188bd6e2dcd5c16cc5837ed1484347b14d8f50f743d2c65"},"269323480a68bcae790fb3b88d42fd449f76e12c498ac4266836fdb1357ac48d",{"version":"cb3d64498f1442cc43d75159bb7d1c2b1532559167e35f6c92e2bb7bb53c94e7","signature":"551650eb9e57b54a9fc48a6339832fe28a67e310a6d0d082926999d13f56e5a9"},{"version":"84a500001854ac65b15fdb30f20c0f12a49f8524e0300679d50c1dc11ddc7469","signature":"045a35382881c9ef0dc019effa2ea05b9db77f7fc02f9d0db7d44a13bd57b725"},{"version":"8770382170df1f17dc92d7659b72d937db8b3cb551fd497ff2cb0f8b3d75e91b","signature":"5612145e8dd65b7da38f6db63940162a741d8cde8c35276df916da0aaf9b3612"},{"version":"e0862da04c2a393a851dc094bcc7221f301488c0d8b3d05899d07e5afb67b5ac","signature":"d8bcab5bd548f76c3eae464894e9772071205c154b3f60bb11dc2a6474941f8a"},{"version":"27b0894490fd333053d223733dbbc4670c02245c06ce2864c70869e03fdde74b","signature":"38e87c7eac3adc89ff2eb71ed8e04568beebd02836d4faaef9a0c7a235130480"},{"version":"53fd5d13d12bae76642bc9a3a60e8c90d6226dba8f9c38aa2ad64dc79a1c2819","signature":"513472f7fe14e40d2f5f1b72f3e4d667444e987e1cd1391cc916d8993fdf767b"},{"version":"3e687b0b5b0315e01c3af810a92b27b132c5741e85a06692cd136ab9b283803f","signature":"1a2156dd63290f57fe58932c8957975ad21cbbb5e8e59e79d7eafaa2b6a94ac2"},{"version":"755a0c5c6fd5d57b5a48300f0910e0d91e5670a000d00b5dac558b385a9de605","signature":"536efdf3f6ba366b175652e61f3fbe6e52f85f8cd0bcdaa0d4f9ac2bcf71aa8a"},{"version":"c07e41a7f6f2b74a431afa997b1f4d99e0dc61b36dd514dff06276011bbdd231","signature":"cf0b51879a8b20113780766cb512e9facb864100ee7cceb96665915c1fa4d511"},{"version":"cf13b93de2bd41320b57cb1a6d8a9f01f98e558628a9c1cf4f69ca80660db1e7","signature":"db14f20ef77f107fc1c61bc3a3f55f2df786cba4a21ebae1aaa7d4b5151b2c05"},{"version":"094d157b45b1a94554ad308ab9484368366d23a793cad92ae04b9fd8b34e314d","signature":"8b1cb9b4627465654d3acb8fe2d2e4838b41385c089e43bff3c5979f3c011a0b"},{"version":"12baf5e5efe09a379f14fb38a634b1738593f90ee598daa2c2e8015e9b827d24","signature":"9a099457c002f787ec7a9b32f26ea26c4e3688b361f070bd22a5ed4e3c128939"},"d19a1154c39cbc254c0b85fb7707fc478a7a777ba222c2b99dad77a60953b4bb",{"version":"6bc6f3d61c73688f2a5fbf835d836a845420863f0dcea443d396fb3195484d42","signature":"5064e95a5938200560badd8f88e8d1d2114e092e53167ce480f1124b892a8d49"},{"version":"c7468bb12595d9830dc6dc0e9204706ae5c30e5a4ac5d03f43918c672795d386","signature":"5f09e3cd3bc5558befbcb8ce44106ab4b0c71a67760dfd6d2095d5dca8976716"},{"version":"249c65627f5edc662b5dbe911523f2ab2d60d9aaaf632fec5894b216c38127bb","signature":"baa55222c405626f43a4afeba764e4fe8757c8ab6906ea9190682b19abb4a597"},{"version":"598aff1bd0a55202914975dfb612240f22aa50efe19db025688f8a7db2869255","signature":"9cfb8c2611f9ef8ef558351c535162de1ca4349c717a0f3b8503d18a86ee3f7a"},{"version":"fc330a5b6175ac4419685e304b1bcbf7eda6fcd8375fc349d0aadfe57753b794","signature":"c097e154057687a75210df46dcbedfe156b65eccf16301bc826da6bc5ba4d376"},"06c2fc0bf929858d3ee5fb8c14f0a39b48d91bb8161b6480d833f787df761672",{"version":"0a567d4b186084b4a035f676db60e1bd2c364b119446201e522079bc193a0384","signature":"cb6c3c0907cec5322cb8ffd7d7bebb55df33b359c54d50f02cdfd2d6bb8b0a16"},{"version":"03f0fa1dd7fa1dde3731822476e32dc8a677704c57c88292b5c904f39a607b07","signature":"bff78e16a75e43f9184c640ce49e45575263caf1dd67a49edc5d7cd669a8490f"},{"version":"310add30c8bdd2aaf63ef810d796344e7f231d467c8803d70dce00c52a60a7f8","signature":"0fa12249904799586bbc29de28ef8e83be81c61f9dc48bf2ed03b7c341f778e9"},{"version":"becd7f1fdd768f228052f1c69c6f72c1f1b311aa3acc91da48f12467bb5d41d5","signature":"6674ac246afe30c8514aa725af495f6004410b9ed6c805539bdde09570c37afb"},{"version":"23cecde765c7494cee19481ad9d3216ff513e013448217c84e06751776502857","signature":"7752171e06edb64884aedfe8355117af3891a432d79927667394a66d205900c6"},{"version":"5d3daec87af238a3c3ec9fe46c457ff7e125cab1cc3c1daa5b36da5217305b39","signature":"d6b002743674757bab52580ab18f9371df27f6e26d47b11483877d926964d4f6"},{"version":"d477b8463aa405c9432de1344c87af3b6fddbc5f25beea8e13d798a7e2151810","signature":"d1a54bd7d5b87bab17dbbf481232f26654c08e958009219e168c84c26f99daf8"},{"version":"3f5279181c8d5a7fb497949945d37888a4edd92c46847394cec507dac604afb9","signature":"847a8e758ee97f3c51ba7bb639d74892d302a5e2e9688e0ef44e458f15a09264"},{"version":"8d1310042bbc245721debba1a45639c65a6ff9c618a105c477bfe3ec6b0cfa74","signature":"753f9b07cd720df56d9bbffcca61f519ad48a476d4b4a61d5df2fb9bb9a3fc75"},{"version":"c81f77fc1ea69dad689ffd57a3aa4b342158065c51282bc81b45579a18429db1","signature":"a6e14085434c6ff570156e2c66baa72d9bb4a63e13d6dd4ceb2303313cb518b6"},{"version":"15111a3e03d82880aeafdede77cae777866c4536bb8e7a6ce40b515233333169","signature":"7276248cdea4ef668229e38f1b373f8f0bf8d7a976eee67c2aba05c5bac0b5cf"},{"version":"08fbeb76b11691929b458aa7cf4992cb8f261ec3c60dafaecca364277ec7a492","signature":"aab5fc41e13606eec5b3b31fcf7805ec3a24ec0d7d058491c29ec5a39a95ee1f"},{"version":"cca5408fd32a89ce1eddbbf5a6ff02b7e244928fd264e5b0d6893abdaa2f97f8","signature":"e6b1038928f84d8eadd53885c49980e6a1a65c0c2a4d04748f4112e50c0f9a9d"},{"version":"7a3b4a745ec4806d4418162b4b01281b550923c9c72c48cc11da1c88cc73d9b1","signature":"b26a27741472eaef966afe2c1016ae7352410fcbf006897c3bf8c7efef440e73"},{"version":"20c07a8464fe4f1b5e7928fa573969af27bdcd346fa7c9befec6224078355491","signature":"bd1c40a1d9e7410830653a24247f5fd07cfa1963f8006a3d8e7117fd4fcddb29"},{"version":"6ba11334c222d0fabd3eb87dddfb1f0b079d38d26acdc19a3a2c1f98907d08d3","signature":"f64c22a890f50697ee833e5f8c49bc81e09e92db0838fbc33be5e90068fae7b7"},{"version":"766666a6631ad0e5425ac065ea73879ad506768f2f20324f59ccd45d330a4459","signature":"460f84a97f5175638eaf1d3811dba0b418e8a0edd5044061e86000b37c36f055"},{"version":"f9ba6cdf80fba413a2c458a30bcde90688b323312099a6ab3ab3b2998cf36e44","signature":"27ef99ed4d349177105912ba4d2524ef9af88277947e8f1804e7ab594a7526d8"},"aba86dc9f51e05011716826d014fe41d8ed74d47c7805250326d0b510e1794d4",{"version":"c71f3873bd1dcadc172201125c50dd15adc4055bd96be3bd0b0b30cdbffac497","signature":"6a783aa014deb5e0f195debc44247a3701b9005a1db50b035bea2046b0e5835c"},{"version":"24f7bd2917fabf94e8dafa3c8e6c639630bb19ccb2bc7339e4304d71661c3904","signature":"1a40c28dc7e7ced9627d4e7a8443a8c5b0df4b37177cec0dc957cef3cec49b71"},{"version":"32a1610ac6225ee69353c71edf731588de92bdc58b76717f6d0a9bb1b1e59e48","signature":"be9536aef488ef493684c490ea5d46e1a3bca1fcb25e387eaf9488f41003fae4"},{"version":"15825253a8accb899427d1743e0ece29f84cbc131e75a632e1fa0e5775a39aad","signature":"37c4cb179af3d25c4c71332e4670357f6577947e306a691770f8e92a06107f7f"},{"version":"523644fc3ceef0d7cc28f5ba59909c767a3701dcd348c9fd2b6534f188bc50d8","signature":"493b3cb90b1a5fcd5c4574f14a6314df1d7e538c0e8cf2c9db4e843806fddae1"},"499acdba626cb8fe0b998f036a930d3ca7ea48583fffb73419af9238527f45f4",{"version":"75ad4daf64036f97992ecfd608bb6d24bcf7aa32821a13bd73533bf812dd6c28","signature":"27863f45920abc69cf455660dc7111ebd495318034caa143651c8b20249f8160"},{"version":"04d0f9de25e722587050c60574859d80ffadafea7205319848d60e4bdc375235","signature":"0b60ff4df97682c68e50f0f219806fb3db6d0aa633b6f7910506b4d3b32ebd86"},{"version":"46f9ff7da6a54eb36fc3fd7085aa150631c1190ad25d2edbf0db7fb7d85e1373","signature":"228c90aabbfe384be2f23d78ac05724e1d8e3159559f1c74340ffbe08cc2f6fa"},{"version":"1ab796050b6ae4fa2f0917bcc300d5e1de0d92c93c6757659a8e66e8d6ef9e3e","signature":"715f109e2ca10d038ac344133e83e3db113421f448b895d9e0c50a686bbe201e"},{"version":"563b1c29305451939c8ff3404fb87e3d2e3ea2a1bc73b123285b4362ff8ed0ea","signature":"fd537a623766a657ff9f29ef2c46ae74f730c40b1bcbf42883016b97a1128d5e"},{"version":"55971a4bd81190d9dda26b62b12d0e1f87192f1238d19c4142205989765ade23","signature":"396ed33aa615f99e23ea05b520f08e8d7708ebf3d80f3e9f8850983f97626870"},{"version":"081fc2a7faad58b4acb16046bc772c18ea66ed2b3b60412009cece5df2ab4508","signature":"fe99b059bb0a55715054b9aa5e952889a4f71af0ea45c65e03d3047079c634bd"},{"version":"ad22cce8ee71d2328e37a9363fd82fd5517512d8387db0b5ddad0ab6ea02365f","signature":"acdeca705db3675ee777b457d27d4efde96a6b4a85d46d12a7a5c63d607be76e"},{"version":"db67ef02ce637c18e4653f630f05664eb4b479d263e77ffef6898e3661c8c29c","signature":"b2bb96f795bd773d934d00b4f09dd4213b1364e865a8a44bf7f2bb6239fcd68e"},{"version":"b34ea66861f1711b76d9b88090b0ea2a8b2006798a1907be768782f06eb41767","signature":"b56e60f4cc5d1bf6299068b97d98626228bb924d8d0c09cd040d3f7127662da0"},{"version":"7c71d6c70fba67c29184383419337d2518af2d4b9f0addca98edcab9264b0e5e","signature":"30534eacfaf428891ab0af0193dbddee506b42766d52ea292c1180e786f200bf"},{"version":"59c64aaf89653640cf0194abf4283ab431b6864e56006b802dede530b1ada406","signature":"41976bb081049ebfac939b533fd3a13de5ea499c2e3771e3d246f60e0f077777"},{"version":"899614bff4aa78546c7571e95541497bca5649a13916500fa9fd2a5a5857ae2c","signature":"dde13a482d9f8ec9682d65979e69c49399e7f8b680b81953d373b6d82db7ca7b"},{"version":"3aae15fe0534e7534f8418fa25a1c3235823256fbaa311c56c91bbca7c67d2af","signature":"17903bfc456f55af887f1d80213ce8589d3aaf002e9e57e123624368bfcb00f5"},{"version":"17c79980aab1a1e01f886c28380895c4cb7bacbe5a0fa01bec11422b7a17549b","signature":"5e34d7bde72b3ebbdbfd624327d81d135340edfe9801014e7c9e8acd2e89242a"},{"version":"e286b20fe26c5a2dacc64ebea326fb1b803fee28efdd52380cf3c6e41c06984e","signature":"11133bb8dcf25a68c8bf3ed8b51f0ae076b638f254276f60ccbc533c58e349ac"},"f713064ca751dc588bc13832137c418cb70cf0446de92ade60ad631071558fca","cc957354aa3c94c9961ebf46282cfde1e81d107fc5785a61f62c67f1dd3ac2eb","96c23535f4f9dd15beb767e070559ea672f6a35f103152836a67100605136a96","93de1c6dab503f053efe8d304cb522bb3a89feab8c98f307a674a4fae04773e9","6704f0b54df85640baaeebd86c9d4a1dbb661d5a4d57a75bc84162f562f6531d","9d255af1b09c6697089d3c9bf438292a298d8b7a95c68793c9aae80afc9e5ca7","ba8691cf6bea9d53e6bf6cbc22af964a9633a21793981a1be3dce65e7a714d8b","a69c09dbea52352f479d3e7ac949fde3d17b195abe90b045d619f747b38d6d1a",{"version":"bce910d9164785c9f0d4dcea4be359f5f92130c7c7833dea6138ab1db310a1f9","affectsGlobalScope":true},"afddd0617cc7ef650f743c75b868df9d53f17f9ff0cccc255fb5f632e857be38",{"version":"7c387a02bf156d8d45667134d32518ac3ca1b99ca50ca9deff2c1a03eb6d1a81","affectsGlobalScope":true},"3719525a8f6ab731e3dfd585d9f87df55ec7d50d461df84f74eb4d68bb165244","f993522fd7d01ae1ead930091fe35130b8415720d6c2123dc2a7e8eb11bb3cba",{"version":"d5135ad93b33adcce80b18f8065087934cdc1730d63db58562edcf017e1aad9b","affectsGlobalScope":true},"82408ed3e959ddc60d3e9904481b5a8dc16469928257af22a3f7d1a3bc7fd8c4","b787b5b54349a24f07d089b612a9fb8ff024dbbe991ff52ea2b188a6b1230644","bb9c4ffa5e6290c6980b63c815cdd1625876dadb2efaf77edbe82984be93e55e","1cdcfc1f624d6c08aa12c73935f6e13f095919cd99edf95752951796eb225729","df6d4b6ba1e64f682091862faa30104e93891f9e7202d006bf5e7a88ab4a0dbe","14b5aa23c5d0ae1907bc696ac7b6915d88f7d85799cc0dc2dcf98fbce2c5a67c","5c439dafdc09abe4d6c260a96b822fa0ba5be7203c71a63ab1f1423cd9e838ea",{"version":"6b526a5ec4a401ca7c26cfe6a48e641d8f30af76673bad3b06a1b4504594a960","affectsGlobalScope":true},{"version":"c2fcbd6fad600e96fee8c5df1a62e908d477f5b47a9374b2bab7e74f52cfcc92","affectsGlobalScope":true},"dc15cb97f565e378faebd4e92699a56c28d2065f4535045f6c5550261fb83f3a","cc68e79b99f80e4dfd01967ec96be69efb0ff5bd7f779d9a2cc09dfe590ffd28","91d3d8f536f22dcaeeace0fc6f3544d3562e266a27cf3a2fe280b8051af5d006","9503113febdd737095465792cc074d541902c82c0aea3922f940de18784812ad","8d3c583a07e0c37e876908c2d5da575019f689df8d9fa4c081d99119d53dba22","7e5307e29dfd5d5b827203b85cb665d8d5bf932a6c6f393457da8e9ed1906761",{"version":"987b3a9098738f5f40efe9fee5734b55f4c8ac599a045922b1470bb325183ed6","affectsGlobalScope":true},"bcebb922784739bdb34c18ee51095d25a92b560c78ccd2eaacd6bd00f7443d83","7ee6ed878c4528215c82b664fe0cfe80e8b4da6c0d4cc80869367868774db8b1","b0973c3cbcdc59b37bf477731d468696ecaf442593ec51bab497a613a580fe30",{"version":"69e93290f59948789d5fce61cb0b89dde93747a4576744d0d6fae41ee3991646","affectsGlobalScope":true},{"version":"0715e4cd28ad471b2a93f3e552ff51a3ae423417a01a10aa1d3bc7c6b95059d6","affectsGlobalScope":true},"5153a2fd150e46ce57bb3f8db1318d33f6ad3261ed70ceeff92281c0608c74a3","210d54cd652ec0fec8c8916e4af59bb341065576ecda039842f9ffb2e908507c","36b03690b628eab08703d63f04eaa89c5df202e5f1edf3989f13ad389cd2c091","0effadd232a20498b11308058e334d3339cc5bf8c4c858393e38d9d4c0013dcf","25846d43937c672bab7e8195f3d881f93495df712ee901860effc109918938cc","b7998044b77ef376a39c07f038f317d875b3f51b5f8f733384d85ecd083182e7","1b952304137851e45bc009785de89ada562d9376177c97e37702e39e60c2f1ff","69ee23dd0d215b09907ad30d23f88b7790c93329d1faf31d7835552a10cf7cbf","44b8b584a338b190a59f4f6929d072431950c7bd92ec2694821c11bce180c8a5","23b89798789dffbd437c0c423f5d02d11f9736aea73d6abf16db4f812ff36eda",{"version":"a4a2a5596dd7e531ab0ce785ed1c8f6940e0632e5bcaa7e8c144bd0e41029297","affectsGlobalScope":true},{"version":"3c4ba1dd9b12ffa284b565063108f2f031d150ea15b8fafbdc17f5d2a07251f3","affectsGlobalScope":true},"e10177274a35a9d07c825615340b2fcde2f610f53f3fb40269fd196b4288dda6","1422cd9e705adcc09088fda85a900c2b70e3ad36ea85846f68bd1a884cdf4e2b","3c13ef48634e7b5012fcf7e8fce7496352c2d779a7201389ca96a2a81ee4314d","5d0a25ec910fa36595f85a67ac992d7a53dd4064a1ba6aea1c9f14ab73a023f2",{"version":"22d7b95cb63dead43834ae20ee492c9c8b6d90db3957d21665199f0efb1d3e26","affectsGlobalScope":true},{"version":"a9fc1469744055a3435f203123246b96c094e7ff8c4e1c3863829d9b705b7a34","affectsGlobalScope":true},"868831cab82b65dfe1d68180e898af1f2101e89ba9b754d1db6fb8cc2fac1921","5d842e3acce41c978af367a28163cef799170dadd06edf2111cc9ecab6eae968","e59a892d87e72733e2a9ca21611b9beb52977be2696c7ba4b216cbbb9a48f5aa",{"version":"52120bb7e4583612225bdf08e7c12559548170f11e660d33a33623bae9bbdbba","affectsGlobalScope":true},"8a300fa9b698845a1f9c41ecbe2c5966634582a8e2020d51abcace9b55aa959e",{"version":"ab9b9a36e5284fd8d3bf2f7d5fcbc60052f25f27e4d20954782099282c60d23e","affectsGlobalScope":true},"d5be4343a9ace4611f04a6fffd91ceba91265fa15bfb0149306e0a6963e1a015","82819f9ecc249a6a3e284003540d02ea1b1f56f410c23231797b9e1e4b9622df","afc559c1b93df37c25aef6b3dfa2d64325b0e112e887ee18bf7e6f4ec383fc90","d78e5898c8de5e0f934eee83f680262de005caa268d137101b833fd932f95e07","84e3bbd6f80983d468260fdbfeeb431cc81f7ea98d284d836e4d168e36875e86","aad5ffa61406b8e19524738fcf0e6fda8b3485bba98626268fdf252d1b2b630a","16d51f964ec125ad2024cf03f0af444b3bc3ec3614d9345cc54d09bab45c9a4c","c7da551241b7be719b7bd654ab12a5098c3206fbb189076dd2d8871011a6ab5a",{"version":"4aed81e1115540695f896fa93fb22840fe06086741e94c6859e745f173498213","affectsGlobalScope":true},"87e4358eddd469426393408b4976bee1970c91634faa57a71f1db2c2f8dee9ba",{"version":"64d4b35c5456adf258d2cf56c341e203a073253f229ef3208fc0d5020253b241","affectsGlobalScope":true},"bee89e1eb6425eb49894f3f25e4562dc2564e84e5aa7610b7e13d8ecddf8f5db","facc7572c3330810ff4728113a324790679d4ed41fbd9e371028f08f1cad29f3","e050a0afcdbb269720a900c85076d18e0c1ab73e580202a2bf6964978181222a","f463d61cf39c3a6a5f96cdf7adfdb72a0b1d663f7b5d5b6dd042adba835430c2","f7a9cb83c8fbc081a8b605880d191e0d0527cde2c1b2b2b623beca8f0203a2cd","43cdd474c5aa3340da4816bb8f1ae7f3b1bcf9e70d997afc36a0f2c432378c84","bf88ef4208a770ca39a844b182b3695df536326ea566893fdc5b8418702a331e","0670eede14b39fd186fe7e224db70510158af5279528d12292df9b980867c1d0","3d2cd8f3047fff04a71e7037a6a4cb9f4accb28dbd8c0d83164d414811025af0",{"version":"271cde49dfd9b398ccc91bb3aaa43854cf76f4d14e10fed91cbac649aa6cbc63","affectsGlobalScope":true},"2bcecd31f1b4281710c666843fc55133a0ee25b143e59f35f49c62e168123f4b","a6273756fa05f794b64fe1aff45f4371d444f51ed0257f9364a8b25f3501915d","9c4e644fe9bf08d93c93bd892705842189fe345163f8896849d5964d21b56b78","25d91fb9ed77a828cc6c7a863236fb712dafcd52f816eec481bd0c1f589f4404","4cd14cea22eed1bfb0dc76183e56989f897ac5b14c0e2a819e5162eafdcfe243","8d32432f68ca4ce93ad717823976f2db2add94c70c19602bf87ee67fe51df48b","ee65fe452abe1309389c5f50710f24114e08a302d40708101c4aa950a2a7d044","1d96568a72657f762763c920d3804868db48d638abd87ddcd82bcb200ef9625c","6acf8a984c2728906edeba2098c5c51f44a4520bc4a48c65b973bd785537178f","8b06ac3faeacb8484d84ddb44571d8f410697f98d7bfa86c0fda60373a9f5215","7eb06594824ada538b1d8b48c3925a83e7db792f47a081a62cf3e5c4e23cf0ee","f5638f7c2f12a9a1a57b5c41b3c1ea7db3876c003bab68e6a57afd6bcc169af0","cdcc132f207d097d7d3aa75615ab9a2e71d6a478162dde8b67f88ea19f3e54de","0d14fa22c41fdc7277e6f71473b20ebc07f40f00e38875142335d5b63cdfc9d2","c085e9aa62d1ae1375794c1fb927a445fa105fed891a7e24edbb1c3300f7384a","f315e1e65a1f80992f0509e84e4ae2df15ecd9ef73df975f7c98813b71e4c8da","5b9586e9b0b6322e5bfbd2c29bd3b8e21ab9d871f82346cb71020e3d84bae73e","3e70a7e67c2cb16f8cd49097360c0309fe9d1e3210ff9222e9dac1f8df9d4fb6","ab68d2a3e3e8767c3fba8f80de099a1cfc18c0de79e42cb02ae66e22dfe14a66","d96cc6598148bf1a98fb2e8dcf01c63a4b3558bdaec6ef35e087fd0562eb40ec",{"version":"7607da500c00af67a93aacb928552afd08d519f8e68eca30d4c624a69fd28ee9","affectsGlobalScope":true},"ba600bf38b5c1a5dffa1b99dd7a783549082bbba3b4fe9497eaaf5e4c1764b20","ae8cd6af37275eac75f5369cdb5f01063bcf1f48d74cb434303ee50ec446acfe","2518830a2fda9c272ba48798d0e7b857037443b06594db8e42c87e86944ee9e4","95c1cf650d16b197525b5bfdf8dd7abba0a49d99ddb12a4ba66466a8a6903e49","1fe0aabe758d56ad72495d6e6c7b6ae75619faaeaaf03f0ddf1948eea4cfac84","bbc57966c8c48ee78fd58aadb893784025be056ae538ae22d1e83c502a987e68","5e5d6f6697e378b0660b567866bf67d099d0ea754f8810c0dabe737805f5cf03","99ab49d4732fdc98cf5c495925e65e796544cb4086fe42afc235dfc02bcf2351","af8339d509c40da075088e544c28ed37b519876e5c4d36a48644ebfb3c6ae6c8","d393adc32e520d4274bb4c3dfdcdb342b806a230b66ef0f82b35bffbc4aa2590","c26af7eaedb4f710984634e419ab15e54e5bb99a0b3cae71188c2fff572276de","38b58ef018d0aeee42ef74c42978bb5805503233fdeeb82cd2aed2199fb0d013","3b6040253231d44e6778eb6861cc86c1758562e77783d21b7ecbc73322ded539","cc256fd958b33576ed32c7338c64adb0d08fc0c2c6525010202fab83f32745da","fd0589ca571ad090b531d8c095e26caa53d4825c64d3ff2b2b1ab95d72294175",{"version":"669843ecafb89ae1e944df06360e8966219e4c1c34c0d28aa2503272cdd444a7","affectsGlobalScope":true},"96d14f21b7652903852eef49379d04dbda28c16ed36468f8c9fa08f7c14c9538","68b7968bfe692bb273debb1d38ed534b695f8b387d36b7b7a75a81b03f8bf238","5774751340e987a6a9e4a5dcc03ff68a6515adc2b91423e1af2f660fc8f30e81","8841e2aa774b89bd23302dede20663306dc1b9902431ac64b24be8b8d0e3f649","209e814e8e71aec74f69686a9506dd7610b97ab59dcee9446266446f72a76d05","6fa0008bf91a4cc9c8963bace4bba0bd6865cbfa29c3e3ccc461155660fb113a","2b8264b2fefd7367e0f20e2c04eed5d3038831fe00f5efbc110ff0131aab899b","c555dd691dd05955e99cd93dd99c685a65e5287813ccb5e6bfde951183248e26","d88a5e779faf033be3d52142a04fbe1cb96009868e3bbdd296b2bc6c59e06c0e","77cc95898fd0cf2a6b1a3cb4eaac854f1de93f55de0b052386195bd179090a22","5101a8cfdbce4781dddc2d55ab5c13bba9712e6c2faf9d7417ddd04e6c0e4848","1d4bc73751d6ec6285331d1ca378904f55d9e5e8aeaa69bc45b675c3df83e778","2ffcb0c75e294706a4d425ee3ead87826a4cda729fa901c6c605e68948adaf55","8017277c3843df85296d8730f9edf097d68d7d5f9bc9d8124fcacf17ecfd487e","45000d5f6b9b9e2881eb9e2f54b1f44a5fc33b0b1beb793a6370be9f7b9a17a5","332c7ccf95426d3156ebedb7295979ef2435bd1c1a940024a4d068da3418718f","e03334588c63840b7054accd0b90f29c5890db6a6555ac0869a78a23297f1396","c3052485f32a96bfde75a2976c1238995522584ba464f04ff16a8a40af5e50d1","c220410b8e956fa157ce4e5e6ac871f0f433aa120c334d906ff1f5e2c7369e95","960a68ced7820108787135bdae5265d2cc4b511b7dcfd5b8f213432a8483daf1","5e8db4872785292074b394d821ae2fc10e4f8edc597776368aebbe8aefb24422","199f9ead0daf25ae4c5632e3d1f42570af59685294a38123eef457407e13f365","8b3ba0006858bfefa8fd045d446377e0fb1738baa819a1f7e4a520644a0dc131","7ccce4adb23a87a044c257685613126b47160f6975b224cea5f6af36c7f37514","2b93035328f7778d200252681c1d86285d501ed424825a18f81e4c3028aa51d9","2ac9c8332c5f8510b8bdd571f8271e0f39b0577714d5e95c1e79a12b2616f069","42c21aa963e7b86fa00801d96e88b36803188018d5ad91db2a9101bccd40b3ff","d31eb848cdebb4c55b4893b335a7c0cca95ad66dee13cbb7d0893810c0a9c301","55e103448f452988dbdf65e293607c77fb91a967744bad2a72f1a36765e7e88d","7a9e0a564fee396cacf706523b5aeed96e04c6b871a8bebefad78499fbffc5bc","906c751ef5822ec0dadcea2f0e9db64a33fb4ee926cc9f7efa38afe5d5371b2a","5387c049e9702f2d2d7ece1a74836a14b47fbebe9bbeb19f94c580a37c855351","c68391fb9efad5d99ff332c65b1606248c4e4a9f1dd9a087204242b56c7126d6","e9cf02252d3a0ced987d24845dcb1f11c1be5541f17e5daa44c6de2d18138d0c","e8b02b879754d85f48489294f99147aeccc352c760d95a6fe2b6e49cd400b2fe","9f6908ab3d8a86c68b86e38578afc7095114e66b2fc36a2a96e9252aac3998e0","0eedb2344442b143ddcd788f87096961cd8572b64f10b4afc3356aa0460171c6","71405cc70f183d029cc5018375f6c35117ffdaf11846c35ebf85ee3956b1b2a6","c68baff4d8ba346130e9753cefe2e487a16731bf17e05fdacc81e8c9a26aae9d","2cd15528d8bb5d0453aa339b4b52e0696e8b07e790c153831c642c3dea5ac8af","479d622e66283ffa9883fbc33e441f7fc928b2277ff30aacbec7b7761b4e9579","ade307876dc5ca267ca308d09e737b611505e015c535863f22420a11fffc1c54","f8cdefa3e0dee639eccbe9794b46f90291e5fd3989fcba60d2f08fde56179fb9","86c5a62f99aac7053976e317dbe9acb2eaf903aaf3d2e5bb1cafe5c2df7b37a8","2b300954ce01a8343866f737656e13243e86e5baef51bd0631b21dcef1f6e954","a2d409a9ffd872d6b9d78ead00baa116bbc73cfa959fce9a2f29d3227876b2a1","b288936f560cd71f4a6002953290de9ff8dfbfbf37f5a9391be5c83322324898","61178a781ef82e0ff54f9430397e71e8f365fc1e3725e0e5346f2de7b0d50dfa","6a6ccb37feb3aad32d9be026a3337db195979cd5727a616fc0f557e974101a54","c649ea79205c029a02272ef55b7ab14ada0903db26144d2205021f24727ac7a3","38e2b02897c6357bbcff729ef84c736727b45cc152abe95a7567caccdfad2a1d","d6610ea7e0b1a7686dba062a1e5544dd7d34140f4545305b7c6afaebfb348341","3dee35db743bdba2c8d19aece7ac049bde6fa587e195d86547c882784e6ba34c","b15e55c5fa977c2f25ca0b1db52cfa2d1fd4bf0baf90a8b90d4a7678ca462ff1","f41d30972724714763a2698ae949fbc463afb203b5fa7c4ad7e4de0871129a17","843dd7b6a7c6269fd43827303f5cbe65c1fecabc30b4670a50d5a15d57daeeb9","f06d8b8567ee9fd799bf7f806efe93b67683ef24f4dea5b23ef12edff4434d9d","6017384f697ff38bc3ef6a546df5b230c3c31329db84cbfe686c83bec011e2b2","e1a5b30d9248549ca0c0bb1d653bafae20c64c4aa5928cc4cd3017b55c2177b0","a593632d5878f17295bd53e1c77f27bf4c15212822f764a2bfc1702f4b413fa0","a868a534ba1c2ca9060b8a13b0ffbbbf78b4be7b0ff80d8c75b02773f7192c29","da7545aba8f54a50fde23e2ede00158dc8112560d934cee58098dfb03aae9b9d","34baf65cfee92f110d6653322e2120c2d368ee64b3c7981dff08ed105c4f19b0","a1a261624efb3a00ff346b13580f70f3463b8cdcc58b60f5793ff11785d52cab","acebfe99678cf7cddcddc3435222cf132052b1226e902daac9fbb495c321a9b5","82b1f9a6eefef7386aebe22ac49f23b806421e82dbf35c6e5b7132d79e4165da","b0d10e46cfe3f6c476b69af02eaa38e4ccc7430221ce3109ae84bb9fb8282298","abd79d61be476addd783d0e0bace2e3c02bb3e38ec23bdfd236adc421b038939","2dd1d4cea14cead7a7fc9eec8f40593089dff0de8c0199458446143c9b8c4ea9","70e9a18da08294f75bf23e46c7d69e67634c0765d355887b9b41f0d959e1426e","e9eb1b173aa166892f3eddab182e49cfe59aa2e14d33aedb6b49d175ed6a3750"],"options":{"allowSyntheticDefaultImports":true,"alwaysStrict":true,"composite":true,"declaration":true,"esModuleInterop":true,"importHelpers":false,"jsx":4,"module":99,"noFallthroughCasesInSwitch":true,"noImplicitAny":true,"noImplicitReturns":true,"noImplicitThis":true,"noUnusedLocals":true,"noUnusedParameters":true,"outDir":"./","rootDir":"../src","sourceMap":true,"strict":true,"strictFunctionTypes":true,"strictNullChecks":true,"strictPropertyInitialization":true,"target":5},"fileIdsList":[[175,227],[227],[227,269],[175,176,177,178,179,227],[175,177,227],[200,227,234,235],[191,227,234],[226,227,234,242],[200,227,234],[227,245,246],[79,166,227,244,245],[197,200,227,234,239,240,241],[227,236,241,242,249],[198,227,234],[227,252],[227,254,260],[227,255,256,257,258,259],[227,260],[197,200,202,205,215,226,227,234],[227,264],[227,265],[227,271,274],[197,227,229,234,288,289,291],[227,290],[79,166,227],[75,227],[63,65,66,67,68,69,70,71,72,73,74,75,227],[63,64,66,67,68,69,70,71,72,73,74,75,227],[64,65,66,67,68,69,70,71,72,73,74,75,227],[63,64,65,67,68,69,70,71,72,73,74,75,227],[63,64,65,66,68,69,70,71,72,73,74,75,227],[63,64,65,66,67,69,70,71,72,73,74,75,227],[63,64,65,66,67,68,70,71,72,73,74,75,227],[63,64,65,66,67,68,69,71,72,73,74,75,227],[63,64,65,66,67,68,69,70,72,73,74,75,227],[63,64,65,66,67,68,69,70,71,73,74,75,227],[63,64,65,66,67,68,69,70,71,72,74,75,227],[63,64,65,66,67,68,69,70,71,72,73,75,227],[63,64,65,66,67,68,69,70,71,72,73,74,227],[181,227],[184,227],[185,190,218,227],[186,197,198,205,215,226,227],[186,187,197,205,227],[188,227],[189,190,198,206,227],[190,215,223,227],[191,193,197,205,227],[192,227],[193,194,227],[197,227],[195,197,227],[197,198,199,215,226,227],[197,198,199,212,215,218,227],[227,231],[193,197,200,205,215,226,227],[197,198,200,201,205,215,223,226,227],[200,202,215,223,226,227],[181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233],[197,203,227],[204,226,227,231],[193,197,205,215,227],[206,227],[207,227],[184,208,227],[209,225,227,231],[210,227],[211,227],[197,212,213,227],[212,214,227,229],[185,197,215,216,217,218,227],[185,215,217,227],[215,216,227],[218,227],[219,227],[184,215,227],[197,221,222,227],[221,222,227],[190,205,215,223,227],[224,227],[205,225,227],[185,200,211,226,227],[190,227],[215,227,228],[204,227,229],[227,230],[185,190,197,199,208,215,226,227,229,231],[215,227,232],[61,227],[61,227,260,303],[61,227,260],[61,227,307],[227,307,308,309,310,311],[57,58,59,60,227],[215,227,234],[227,316,355],[227,316,340,355],[227,355],[227,316],[227,316,341,355],[227,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354],[227,341,355],[198,215,227,234,238],[198,227,250],[200,227,234,238,248],[197,200,202,215,223,226,227,232,234],[227,361],[227,267,273],[227,271],[227,268,272],[227,277],[227,276,277],[227,276],[227,276,277,278,280,281,284,285,286,287],[227,277,281],[227,276,277,278,280,281,282,283],[227,276,281],[227,281,285],[227,277,278,279],[227,278],[227,276,277,281],[227,270],[62,81,84,227],[62,227],[62,81,87,227],[62,81,82,89,227],[62,81,92,173,227],[62,91,227],[62,80,121,227],[62,81,106,123,227],[62,81,125,227],[62,81,106,227],[62,81,123,127,227],[62,81,227],[62,76,77,78,81,82,227],[62,81,82,94,95,227],[62,77,81,100,227],[62,81,129,227],[62,77,81,82,227],[62,81,113,227],[62,81,82,87,227],[62,81,82,84,227],[61,62,77,78,81,115,133,227],[62,81,134,227],[62,81,82,100,227],[62,80,81,82,83,84,85,86,87,88,90,92,96,103,112,113,115,116,119,120,121,122,123,124,125,126,128,129,130,131,132,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,161,163,173,174,227],[62,81,82,227],[61,62,227],[62,77,84,162,227],[62,81,82,84,114,115,227],[62,81,143,227],[62,159,160,227],[62,77,81,82,106,135,227],[62,81,82,106,117,158,159,227],[62,77,81,82,97,98,99,100,101,102,103,105,112,113,117,227],[62,77,79,81,82,84,93,96,112,115,116,117,118,119,142,163,165,227],[62,81,82,87,115,139,165,167,227],[62,81,104,227],[62,77,81,82,97,98,103,227],[62,104,105,117,118,164,165,166,167,168,169,170,171,172,227],[62,81,82,117,227],[62,81,164,227],[62,81,117,138,227],[62,81,93,142,227],[62,77,78,81,82,84,96,102,105,106,107,108,109,110,111,112,113,116,227],[62,77,81,82,97,117,227],[62,77,81,82,84,106,115,117,227],[62,77,78,81,82,106,112,117,118,227],[61,62,92,227],[62,81,83,152,227],[61,62,79,80,166,227],[62,81,89,227],[62,146,227],[62,81,93,142,151,227],[62,81,82,99,227],[81],[80],[80,81,82,83,84,85,86,87,88,90,92,96,103,112,113,115,116,119,120,121,122,123,124,125,126,128,129,130,131,132,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,161,163,173,174],[61],[159,160],[81,159],[79,81,166],[104,105,117,118,164,165,166,167,168,169,170,171,172],[61,79,80,166]],"referencedMap":[[177,1],[175,2],[267,2],[270,3],[269,2],[180,4],[176,1],[178,5],[179,1],[236,6],[237,7],[243,8],[235,9],[247,10],[244,2],[246,11],[245,2],[242,12],[250,13],[251,14],[253,15],[255,16],[256,16],[257,16],[254,2],[260,17],[258,18],[259,18],[261,2],[248,2],[262,19],[263,2],[264,2],[265,20],[266,21],[275,22],[290,23],[291,24],[111,25],[79,2],[292,2],[293,26],[76,26],[64,27],[65,28],[63,29],[66,30],[67,31],[68,32],[69,33],[70,34],[71,35],[72,36],[73,37],[74,38],[109,26],[158,26],[77,26],[97,26],[75,39],[93,26],[106,26],[91,26],[127,26],[98,26],[99,26],[89,26],[100,26],[108,26],[95,26],[101,26],[78,26],[102,26],[152,26],[107,26],[114,26],[110,26],[294,15],[238,2],[295,2],[296,2],[181,40],[182,40],[184,41],[185,42],[186,43],[187,44],[188,45],[189,46],[190,47],[191,48],[192,49],[193,50],[194,50],[196,51],[195,52],[197,51],[198,53],[199,54],[183,55],[233,2],[200,56],[201,57],[202,58],[234,59],[203,60],[204,61],[205,62],[206,63],[207,64],[208,65],[209,66],[210,67],[211,68],[212,69],[213,69],[214,70],[215,71],[217,72],[216,73],[218,74],[219,75],[220,76],[221,77],[222,78],[223,79],[224,80],[225,81],[226,82],[227,83],[228,84],[229,85],[230,86],[231,87],[232,88],[297,2],[298,2],[299,2],[300,2],[59,2],[241,2],[240,2],[301,89],[302,89],[304,90],[305,90],[303,91],[306,89],[311,2],[308,92],[312,93],[310,89],[307,89],[309,92],[57,2],[61,94],[62,89],[313,2],[314,95],[315,2],[60,2],[340,96],[341,97],[316,98],[319,98],[338,96],[339,96],[329,96],[328,99],[326,96],[321,96],[334,96],[332,96],[336,96],[320,96],[333,96],[337,96],[322,96],[323,96],[335,96],[317,96],[324,96],[325,96],[327,96],[331,96],[342,100],[330,96],[318,96],[355,101],[354,2],[349,100],[351,102],[350,100],[343,100],[344,100],[346,100],[348,100],[352,102],[353,102],[345,102],[347,102],[239,103],[356,104],[249,105],[357,9],[358,2],[289,2],[252,2],[359,2],[360,106],[361,2],[362,107],[268,2],[58,2],[274,108],[272,109],[273,110],[94,2],[278,111],[287,112],[276,2],[277,113],[288,114],[283,115],[284,116],[282,117],[286,118],[280,119],[279,120],[285,121],[281,112],[271,122],[11,2],[12,2],[14,2],[13,2],[2,2],[15,2],[16,2],[17,2],[18,2],[19,2],[20,2],[21,2],[22,2],[3,2],[4,2],[26,2],[23,2],[24,2],[25,2],[27,2],[28,2],[29,2],[5,2],[30,2],[31,2],[32,2],[33,2],[6,2],[37,2],[34,2],[35,2],[36,2],[38,2],[7,2],[39,2],[44,2],[45,2],[40,2],[41,2],[42,2],[43,2],[8,2],[49,2],[46,2],[47,2],[48,2],[50,2],[9,2],[51,2],[52,2],[53,2],[54,2],[55,2],[1,2],[10,2],[56,2],[133,89],[85,123],[86,124],[88,125],[82,124],[90,126],[174,127],[120,124],[92,128],[122,129],[124,130],[126,131],[125,132],[128,133],[123,134],[80,124],[83,135],[96,136],[112,137],[130,138],[103,139],[115,140],[131,141],[132,134],[87,142],[134,143],[113,124],[135,134],[136,144],[137,145],[162,146],[138,147],[139,125],[119,123],[84,124],[140,148],[141,124],[163,149],[142,123],[116,150],[144,151],[145,134],[146,124],[147,134],[161,152],[159,153],[160,154],[129,134],[121,124],[118,155],[166,156],[168,157],[105,158],[104,159],[173,160],[167,161],[165,162],[164,163],[169,164],[117,165],[170,166],[171,167],[172,168],[148,134],[149,169],[143,147],[150,134],[151,126],[153,170],[81,171],[154,172],[155,173],[156,174],[157,175]],"exportedModulesMap":[[177,1],[175,2],[267,2],[270,3],[269,2],[180,4],[176,1],[178,5],[179,1],[236,6],[237,7],[243,8],[235,9],[247,10],[244,2],[246,11],[245,2],[242,12],[250,13],[251,14],[253,15],[255,16],[256,16],[257,16],[254,2],[260,17],[258,18],[259,18],[261,2],[248,2],[262,19],[263,2],[264,2],[265,20],[266,21],[275,22],[290,23],[291,24],[111,25],[79,2],[292,2],[293,26],[76,26],[64,27],[65,28],[63,29],[66,30],[67,31],[68,32],[69,33],[70,34],[71,35],[72,36],[73,37],[74,38],[109,26],[158,26],[77,26],[97,26],[75,39],[93,26],[106,26],[91,26],[127,26],[98,26],[99,26],[89,26],[100,26],[108,26],[95,26],[101,26],[78,26],[102,26],[152,26],[107,26],[114,26],[110,26],[294,15],[238,2],[295,2],[296,2],[181,40],[182,40],[184,41],[185,42],[186,43],[187,44],[188,45],[189,46],[190,47],[191,48],[192,49],[193,50],[194,50],[196,51],[195,52],[197,51],[198,53],[199,54],[183,55],[233,2],[200,56],[201,57],[202,58],[234,59],[203,60],[204,61],[205,62],[206,63],[207,64],[208,65],[209,66],[210,67],[211,68],[212,69],[213,69],[214,70],[215,71],[217,72],[216,73],[218,74],[219,75],[220,76],[221,77],[222,78],[223,79],[224,80],[225,81],[226,82],[227,83],[228,84],[229,85],[230,86],[231,87],[232,88],[297,2],[298,2],[299,2],[300,2],[59,2],[241,2],[240,2],[301,89],[302,89],[304,90],[305,90],[303,91],[306,89],[311,2],[308,92],[312,93],[310,89],[307,89],[309,92],[57,2],[61,94],[62,89],[313,2],[314,95],[315,2],[60,2],[340,96],[341,97],[316,98],[319,98],[338,96],[339,96],[329,96],[328,99],[326,96],[321,96],[334,96],[332,96],[336,96],[320,96],[333,96],[337,96],[322,96],[323,96],[335,96],[317,96],[324,96],[325,96],[327,96],[331,96],[342,100],[330,96],[318,96],[355,101],[354,2],[349,100],[351,102],[350,100],[343,100],[344,100],[346,100],[348,100],[352,102],[353,102],[345,102],[347,102],[239,103],[356,104],[249,105],[357,9],[358,2],[289,2],[252,2],[359,2],[360,106],[361,2],[362,107],[268,2],[58,2],[274,108],[272,109],[273,110],[94,2],[278,111],[287,112],[276,2],[277,113],[288,114],[283,115],[284,116],[282,117],[286,118],[280,119],[279,120],[285,121],[281,112],[271,122],[11,2],[12,2],[14,2],[13,2],[2,2],[15,2],[16,2],[17,2],[18,2],[19,2],[20,2],[21,2],[22,2],[3,2],[4,2],[26,2],[23,2],[24,2],[25,2],[27,2],[28,2],[29,2],[5,2],[30,2],[31,2],[32,2],[33,2],[6,2],[37,2],[34,2],[35,2],[36,2],[38,2],[7,2],[39,2],[44,2],[45,2],[40,2],[41,2],[42,2],[43,2],[8,2],[49,2],[46,2],[47,2],[48,2],[50,2],[9,2],[51,2],[52,2],[53,2],[54,2],[55,2],[1,2],[10,2],[56,2],[133,89],[85,176],[88,176],[90,176],[174,176],[122,177],[124,176],[126,176],[125,176],[128,176],[123,176],[83,176],[96,176],[112,176],[130,176],[103,176],[115,176],[131,176],[132,176],[87,176],[134,176],[135,176],[136,176],[137,176],[162,178],[138,176],[139,176],[119,176],[140,179],[142,176],[116,176],[144,176],[147,176],[161,180],[159,176],[160,181],[129,176],[118,176],[166,182],[168,176],[105,176],[104,176],[173,183],[167,176],[165,176],[164,176],[169,176],[117,176],[170,176],[171,176],[172,176],[148,176],[149,179],[143,182],[150,176],[151,176],[153,176],[81,184],[154,176],[156,176],[157,176]],"semanticDiagnosticsPerFile":[177,175,267,270,269,180,176,178,179,236,237,243,235,247,244,246,245,242,250,251,253,255,256,257,254,260,258,259,261,248,262,263,264,265,266,275,290,291,111,79,292,293,76,64,65,63,66,67,68,69,70,71,72,73,74,109,158,77,97,75,93,106,91,127,98,99,89,100,108,95,101,78,102,152,107,114,110,294,238,295,296,181,182,184,185,186,187,188,189,190,191,192,193,194,196,195,197,198,199,183,233,200,201,202,234,203,204,205,206,207,208,209,210,211,212,213,214,215,217,216,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,297,298,299,300,59,241,240,301,302,304,305,303,306,311,308,312,310,307,309,57,61,62,313,314,315,60,340,341,316,319,338,339,329,328,326,321,334,332,336,320,333,337,322,323,335,317,324,325,327,331,342,330,318,355,354,349,351,350,343,344,346,348,352,353,345,347,239,356,249,357,358,289,252,359,360,361,362,268,58,274,272,273,94,278,287,276,277,288,283,284,282,286,280,279,285,281,271,11,12,14,13,2,15,16,17,18,19,20,21,22,3,4,26,23,24,25,27,28,29,5,30,31,32,33,6,37,34,35,36,38,7,39,44,45,40,41,42,43,8,49,46,47,48,50,9,51,52,53,54,55,1,10,56,133,85,86,88,82,90,174,120,92,122,124,126,125,128,123,80,83,96,112,130,103,115,131,132,87,134,113,135,136,137,162,138,139,119,84,140,141,163,142,116,144,145,146,147,161,159,160,129,121,118,166,168,105,104,173,167,165,164,169,117,170,171,172,148,149,143,150,151,153,81,154,155,156,157],"latestChangedDtsFile":"./createSchemaUtils.d.ts"},"version":"4.9.5"}
\ No newline at end of file
diff --git a/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts b/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts
index 7095e84..5e0d1d4 100644
--- a/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts
+++ b/node_modules/@rjsf/utils/src/schema/getDefaultFormState.ts
@@ -20,6 +20,7 @@ import mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';
 import mergeObjects from '../mergeObjects';
 import mergeSchemas from '../mergeSchemas';
 import {
+  Experimental_ArrayMinItems,
   Experimental_DefaultFormStateBehavior,
   FormContextType,
   GenericObjectType,
@@ -38,6 +39,12 @@ export enum AdditionalItemsHandling {
   Fallback,
 }

+declare module 'json-schema' {
+  export interface JSONSchema7 {
+    overrideArrayMinItemsBehaviour?: Experimental_ArrayMinItems;
+  }
+}
+
 /** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the
  * `additionalItems` enum and the value of `idx`. There are four possible returns:
  * 1. If `idx` is >= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid
@@ -338,8 +345,11 @@ export function computeDefaults<T = any, S extends StrictRJSFSchema = RJSFSchema
       return objectDefaults;
     }
     case 'array': {
-      const neverPopulate = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'never';
-      const ignoreMinItemsFlagSet = experimental_defaultFormStateBehavior?.arrayMinItems?.populate === 'requiredOnly';
+      // On a case by case basis, we may want to override the default behavior of populating array items.
+      const arrayMinItems =
+          schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+      const neverPopulate = arrayMinItems?.populate === 'never';
+      const ignoreMinItemsFlagSet = arrayMinItems?.populate === 'requiredOnly';

       // Inject defaults into existing array defaults
       if (Array.isArray(defaults)) {
@@ -453,7 +463,10 @@ export default function getDefaultFormState<
     // No form data? Use schema defaults.
     return defaults;
   }
-  const { mergeExtraDefaults } = experimental_defaultFormStateBehavior?.arrayMinItems || {};
+  // On a case by case basis, we may want to override the default behavior of populating array items.
+  const arrayMinItems = schema.overrideArrayMinItemsBehaviour ?? experimental_defaultFormStateBehavior?.arrayMinItems;
+
+  const { mergeExtraDefaults } = arrayMinItems || {};
   if (isObject(formData)) {
     return mergeDefaultsWithFormData<T>(defaults as T, formData, mergeExtraDefaults);
   }
