type Base64 = string
type Uuid = string

/* tslint:disable */
/* eslint-disable */
/**
 * slovensko.sk API
 * slovensko.sk API je proxy REST API komponent k službám www.slovensko.sk (Ústredný portál verejnej správy – ÚPVS), pomocou ktorých je možné:  **Komunitná verzia** (EUPL 1.2 licencia) - uskutočniť prihlásenie pomocou ÚPVS (pomocou elektronického občianskeho preukazu) a získať údaje o prihlásenom subjekte, - manipulovať s obsahom el. schránky a preberať poštu do vlastných rúk, - podávať podania v mene subjektu, ktorý sa prihlásil cez ÚPVS alebo pomocou technického účtu, - vyhľadávať subjekty (právnické a fyzické osoby) za účelom zasielania správ (dostupné len pre OVM), - skontrolovať či je daná správa vo formáte SKTalk validná voči aktuálnej definícii formuláru (podporná funkcia).  **Prémium verzia** (komerčná licencia) - ukladať záznamy do dlhodobého úložiska registratúrnych záznamov, - zverejnovať dokumenty na centrálnej úradnej tabuli (dostupné len pre OVM), - podpisovať správy pomocou kvalifikovanej pečate uloženej v úložisku na slovensko.sk, - pridávať kvalifikované časové pečiatky elektronicky podpísaným dokumentom, - informatívne overovať podpisy na elektronicky podpísaných dokumentoch, - získať informácie o type a forme podpisov elektronicky podpísaných dokumentov.
 *
 * The version of the OpenAPI document: 3.7.3 (Komunitná verzia) 8.8.2 (Prémium verzia)
 * Contact: ekosystem@slovensko.digital
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface AdministrationCertificatesIdGet200Response
 */
export interface AdministrationCertificatesIdGet200Response {
  /**
   *
   * @type {string}
   * @memberof AdministrationCertificatesIdGet200Response
   */
  certificate: string
  /**
   *
   * @type {string}
   * @memberof AdministrationCertificatesIdGet200Response
   */
  fingerprint: string
  /**
   *
   * @type {string}
   * @memberof AdministrationCertificatesIdGet200Response
   */
  not_after: string
  /**
   *
   * @type {string}
   * @memberof AdministrationCertificatesIdGet200Response
   */
  subject: string
}
/**
 *
 * @export
 * @interface AdministrationCertificatesPostRequest
 */
export interface AdministrationCertificatesPostRequest {
  /**
   * Identifikátor certifikátu.
   * @type {string}
   * @memberof AdministrationCertificatesPostRequest
   */
  id: string
  /**
   * Identifikačné číslo organizácie.
   * @type {string}
   * @memberof AdministrationCertificatesPostRequest
   */
  cin: string
}
/**
 *
 * @export
 * @interface ApiCepAddTimestampPost200Response
 */
export interface ApiCepAddTimestampPost200Response {
  /**
   * Výsledok pridania časovej pečiatky, hodnota `0` znamená úspešné pridanie časovej pečiatky.
   * @type {string}
   * @memberof ApiCepAddTimestampPost200Response
   */
  add_timestamp_result?: string
  /**
   * Popis výsledku.
   * @type {string}
   * @memberof ApiCepAddTimestampPost200Response
   */
  add_timestamp_description?: string
  /**
   * Dáta rozšírené o kvalifikovanú časovú pečiatku.
   * @type {Base64}
   * @memberof ApiCepAddTimestampPost200Response
   */
  timestamped_data?: Base64
}
/**
 *
 * @export
 * @interface ApiCepAddTimestampPostRequest
 */
export interface ApiCepAddTimestampPostRequest {
  /**
   * Base64 kódovaná štruktúra jednoduchého podpisu XAdES, zloženého podpisu XAdES, CAdES, PAdES alebo ASIC obálky.
   * @type {string}
   * @memberof ApiCepAddTimestampPostRequest
   */
  content: string
}
/**
 *
 * @export
 * @interface ApiCepSignPost200Response
 */
export interface ApiCepSignPost200Response {
  /**
   * Identifikátor požiadavky.
   * @type {string}
   * @memberof ApiCepSignPost200Response
   */
  request_id?: string
  /**
   * Kód výsledku podpísania.
   * @type {number}
   * @memberof ApiCepSignPost200Response
   */
  sign_result: number
  /**
   * Popis výsledku podpísania.
   * @type {string}
   * @memberof ApiCepSignPost200Response
   */
  sign_description: string
  /**
   * Podpísané objekty.
   * @type {Array<CepSignedObject>}
   * @memberof ApiCepSignPost200Response
   */
  signed_objects?: Array<CepSignedObject>
}
/**
 *
 * @export
 * @interface ApiCepSignPostRequest
 */
export interface ApiCepSignPostRequest {
  /**
   * Identifikátor požiadavky.
   * @type {string}
   * @memberof ApiCepSignPostRequest
   */
  request_id?: string
  /**
   * Verzia profilu XAdES-ZEP 1.0, 1.1 alebo 2.0 podpisu.
   * @type {string}
   * @memberof ApiCepSignPostRequest
   */
  signature_version?: ApiCepSignPostRequestSignatureVersionEnum
  /**
   *
   * @type {Array<ApiCepSignPostRequestObjectsInner>}
   * @memberof ApiCepSignPostRequest
   */
  objects: Array<ApiCepSignPostRequestObjectsInner>
  /**
   * Typ podpisovej vizualizácie. Poznámka, v prípade hodnoty `XML` sa použije `TXT` vizualizácia.
   * @type {string}
   * @memberof ApiCepSignPostRequest
   */
  visualization_type?: ApiCepSignPostRequestVisualizationTypeEnum
  /**
   * Identifikátor podpisovej vizualizácie.
   * @type {string}
   * @memberof ApiCepSignPostRequest
   */
  visualization_uri?: string
  /**
   * Indikátor overenia obsahu objektu podľa štandardu PDF/A-1a.
   * @type {boolean}
   * @memberof ApiCepSignPostRequest
   */
  pdf_verification?: boolean
}

export const ApiCepSignPostRequestSignatureVersionEnum = {
  _10: '1.0',
  _11: '1.1',
  _20: '2.0',
} as const

export type ApiCepSignPostRequestSignatureVersionEnum =
  (typeof ApiCepSignPostRequestSignatureVersionEnum)[keyof typeof ApiCepSignPostRequestSignatureVersionEnum]
export const ApiCepSignPostRequestVisualizationTypeEnum = {
  Html: 'HTML',
  Xhtml: 'XHTML',
  Xml: 'XML',
} as const

export type ApiCepSignPostRequestVisualizationTypeEnum =
  (typeof ApiCepSignPostRequestVisualizationTypeEnum)[keyof typeof ApiCepSignPostRequestVisualizationTypeEnum]

/**
 *
 * @export
 * @interface ApiCepSignPostRequestObjectsInner
 */
export interface ApiCepSignPostRequestObjectsInner {
  /**
   * Identifikátor objektu.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  id?: string
  /**
   * Názov objektu.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  name?: string | null
  /**
   * Popis objektu.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  description?: string | null
  /**
   * Typ objektu v súlade s [Dokumentáciou funkčnosti Centrálnej elektronickej podateľne](https://www.slovensko.sk/_img/CMS4/Dokumentacia_funkcnosti_CEP.pdf).
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  class: string
  /**
   * Indikátor či je obsah objektu podpísaný.
   * @type {boolean}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  signed?: boolean | null
  /**
   * Typ internetového média v súlade s typom a obsahom objektu.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  mime_type: string
  /**
   * Kódovanie obsahu objektu v súlade s hodnotou v atribúte `content`.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  encoding: ApiCepSignPostRequestObjectsInnerEncodingEnum
  /**
   * Obsah objektu zakódovaný podľa hodnoty v atribúte `encoding`.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  content: string
  /**
   * Typ výberu podpisového certifikátu:   - `Issuer` znamená výber certifikátu podľa vydavateľa a sériového čísla, ktoré sú uvedené v atribúte `certificate_issuer`,   - `Subject` znamená výber certifikátu podľa subjektu v certifikáte, ktorý je uvedený v atribúte `certificate_subject`,   - `UPVS` znamená výber certifikátu podateľne,   - `URI` znamená výber certifikátu podľa URI evidovaného na strane ÚPVS, ktorý je uvedený v atribúte `certificate_uri`.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  certificate_type: ApiCepSignPostRequestObjectsInnerCertificateTypeEnum
  /**
   * Vydavateľ podpisového certifikátu, iba pre typ `Issuer`.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  certificate_issuer?: string
  /**
   * Sériové číslo podpisového certifikátu, iba pre typ `Issuer`.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  certificate_serial_number?: string
  /**
   * Subjekt podpisového certifikátu, iba pre typ `Subject`.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  certificate_subject?: string
  /**
   * URI podpisového certifikátu, iba pre typ `URI`.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  certificate_uri?: string
  /**
   * Typ podpisu.
   * @type {string}
   * @memberof ApiCepSignPostRequestObjectsInner
   */
  signature_type: ApiCepSignPostRequestObjectsInnerSignatureTypeEnum
}

export const ApiCepSignPostRequestObjectsInnerEncodingEnum = {
  Base64: 'Base64',
  Xml: 'XML',
} as const

export type ApiCepSignPostRequestObjectsInnerEncodingEnum =
  (typeof ApiCepSignPostRequestObjectsInnerEncodingEnum)[keyof typeof ApiCepSignPostRequestObjectsInnerEncodingEnum]
export const ApiCepSignPostRequestObjectsInnerCertificateTypeEnum = {
  Issuer: 'Issuer',
  Subject: 'Subject',
  Upvs: 'UPVS',
  Uri: 'URI',
} as const

export type ApiCepSignPostRequestObjectsInnerCertificateTypeEnum =
  (typeof ApiCepSignPostRequestObjectsInnerCertificateTypeEnum)[keyof typeof ApiCepSignPostRequestObjectsInnerCertificateTypeEnum]
export const ApiCepSignPostRequestObjectsInnerSignatureTypeEnum = {
  AsiCECadEs: 'ASiC-E CAdES',
  AsiCEXadEs: 'ASiC-E XAdES',
  CadEs: 'CAdES',
  PadEs: 'PAdES',
  XadEs: 'XAdES',
} as const

export type ApiCepSignPostRequestObjectsInnerSignatureTypeEnum =
  (typeof ApiCepSignPostRequestObjectsInnerSignatureTypeEnum)[keyof typeof ApiCepSignPostRequestObjectsInnerSignatureTypeEnum]

/**
 *
 * @export
 * @interface ApiCepSignV2Post200Response
 */
export interface ApiCepSignV2Post200Response {
  /**
   * Kód výsledku podpísania.
   * @type {number}
   * @memberof ApiCepSignV2Post200Response
   */
  sign_result: number
  /**
   * Popis výsledku podpísania.
   * @type {string}
   * @memberof ApiCepSignV2Post200Response
   */
  sign_description: string
  /**
   * Podpísané objekty.
   * @type {Array<CepSignedObjectGroup>}
   * @memberof ApiCepSignV2Post200Response
   */
  signed_object_groups?: Array<CepSignedObjectGroup>
}
/**
 *
 * @export
 * @interface ApiCepSignV2PostRequest
 */
export interface ApiCepSignV2PostRequest {
  /**
   * Skupiny objektov, ktoré sa majú podpisovať spolu.
   * @type {Array<CepSigningV2ObjectGroup>}
   * @memberof ApiCepSignV2PostRequest
   */
  object_groups: Array<CepSigningV2ObjectGroup>
  /**
   * Indikátor overenia obsahu objektu podľa štandardu PDF/A-1a.
   * @type {boolean}
   * @memberof ApiCepSignV2PostRequest
   */
  pdf_verification?: boolean
}
/**
 *
 * @export
 * @interface ApiCepSignaturesInfoPost200Response
 */
export interface ApiCepSignaturesInfoPost200Response {
  /**
   * Výsledok zistenie prítomnosti podpisu.
   * @type {boolean}
   * @memberof ApiCepSignaturesInfoPost200Response
   */
  is_signed: boolean
  /**
   * Popis výsledku.
   * @type {string}
   * @memberof ApiCepSignaturesInfoPost200Response
   */
  description: string
  /**
   * MimeType podpisovej obálky.
   * @type {string}
   * @memberof ApiCepSignaturesInfoPost200Response
   */
  mime_type?: string
  /**
   *
   * @type {Array<ApiCepSignaturesInfoPost200ResponseSignaturesInner>}
   * @memberof ApiCepSignaturesInfoPost200Response
   */
  signatures?: Array<ApiCepSignaturesInfoPost200ResponseSignaturesInner>
}
/**
 * Objekt podpisu.
 * @export
 * @interface ApiCepSignaturesInfoPost200ResponseSignaturesInner
 */
export interface ApiCepSignaturesInfoPost200ResponseSignaturesInner {
  /**
   * Typ podpisu.
   * @type {string}
   * @memberof ApiCepSignaturesInfoPost200ResponseSignaturesInner
   */
  type?: ApiCepSignaturesInfoPost200ResponseSignaturesInnerTypeEnum
  /**
   * Formát podpisu.
   * @type {string}
   * @memberof ApiCepSignaturesInfoPost200ResponseSignaturesInner
   */
  format?: ApiCepSignaturesInfoPost200ResponseSignaturesInnerFormatEnum
  /**
   * Príznak, či ide o formát podpisu obsahujúci časovú pečiatku (bez ohľadu na jej platnosť).
   * @type {boolean}
   * @memberof ApiCepSignaturesInfoPost200ResponseSignaturesInner
   */
  with_timestamp?: boolean
}

export const ApiCepSignaturesInfoPost200ResponseSignaturesInnerTypeEnum = {
  XadesZepEpes: 'XadesZepEpes',
  XadesZepT: 'XadesZepT',
  XadesZepA: 'XadesZepA',
  XadesZepX1: 'XadesZepX1',
  PadEs: 'PAdES',
  PadEsT: 'PAdES_T',
  PadEsA: 'PAdES_A',
  XadesBpLevelB: 'XadesBPLevelB',
  XadesBpLevelT: 'XadesBPLevelT',
  XadesBpLevelLt: 'XadesBPLevelLT',
  XadesBpLevelLta: 'XadesBPLevelLTA',
  CadEsBes: 'CAdES_BES',
  CadEsEpes: 'CAdES_EPES',
  CadEsT: 'CAdES_T',
  CadEsXl: 'CAdES_XL',
  CadEsA: 'CAdES_A',
  Unknown: 'Unknown',
} as const

export type ApiCepSignaturesInfoPost200ResponseSignaturesInnerTypeEnum =
  (typeof ApiCepSignaturesInfoPost200ResponseSignaturesInnerTypeEnum)[keyof typeof ApiCepSignaturesInfoPost200ResponseSignaturesInnerTypeEnum]
export const ApiCepSignaturesInfoPost200ResponseSignaturesInnerFormatEnum = {
  XadEsZep: 'XAdES_ZEP',
  CadEsZep: 'CAdES_ZEP',
  PadEs: 'PAdES',
  XadEsBp: 'XAdES-BP',
  CadEsBp: 'CAdES-BP',
} as const

export type ApiCepSignaturesInfoPost200ResponseSignaturesInnerFormatEnum =
  (typeof ApiCepSignaturesInfoPost200ResponseSignaturesInnerFormatEnum)[keyof typeof ApiCepSignaturesInfoPost200ResponseSignaturesInnerFormatEnum]

/**
 *
 * @export
 * @interface ApiCepSignaturesInfoPostRequest
 */
export interface ApiCepSignaturesInfoPostRequest {
  /**
   * Obsah objektu zakódovaný podľa Base64. Môže ísť o objekt XADES_ZEP-DataEnvelope, XADES_ZEP-DataSignatures, ZEPfZIP, PAdES alebo ASIC.
   * @type {string}
   * @memberof ApiCepSignaturesInfoPostRequest
   */
  content: string
}
/**
 *
 * @export
 * @interface ApiCepVerifyPost200Response
 */
export interface ApiCepVerifyPost200Response {
  /**
   * Kód výsledku overenia.
   * @type {number}
   * @memberof ApiCepVerifyPost200Response
   */
  verify_result: number
  /**
   * Popis výsledku overenia.
   * @type {string}
   * @memberof ApiCepVerifyPost200Response
   */
  verify_description: string
  /**
   * Overené objekty.
   * @type {Array<ApiCepVerifyPost200ResponseVerifiedObjectsInner>}
   * @memberof ApiCepVerifyPost200Response
   */
  verified_objects?: Array<ApiCepVerifyPost200ResponseVerifiedObjectsInner>
}
/**
 * @type ApiCepVerifyPost200ResponseVerifiedObjectsInner
 * @export
 */
export type ApiCepVerifyPost200ResponseVerifiedObjectsInner =
  | CepVerifiedAsicCadesObject
  | CepVerifiedAsicXadesObject
  | CepVerifiedCadesObject
  | CepVerifiedPadesObject
  | CepVerifiedXadesObject

/**
 *
 * @export
 * @interface ApiCepVerifyPostRequest
 */
export interface ApiCepVerifyPostRequest {
  /**
   * Obsah objektu zakódovaný podľa Base64. Môže ísť o objekt ASiC-E CAdES, ASiC-E XAdES, CAdES, PAdES, XAdES alebo MessageContainer.
   * @type {string}
   * @memberof ApiCepVerifyPostRequest
   */
  content: string
}
/**
 *
 * @export
 * @interface ApiEdeskMessagesIdAuthorizePost200Response
 */
export interface ApiEdeskMessagesIdAuthorizePost200Response {
  /**
   * Identifikátor prevzatej správy.
   * @type {number}
   * @memberof ApiEdeskMessagesIdAuthorizePost200Response
   */
  authorized_message_id: number
}
/**
 *
 * @export
 * @interface ApiEdeskMessagesIdPatchRequest
 */
export interface ApiEdeskMessagesIdPatchRequest {
  /**
   * Identifikátor cieľového priečinka v schránke.
   * @type {number}
   * @memberof ApiEdeskMessagesIdPatchRequest
   */
  folder_id: number
}
/**
 *
 * @export
 * @interface ApiEformFormTemplateRelatedDocumentGet200Response
 */
export interface ApiEformFormTemplateRelatedDocumentGet200Response {
  /**
   *
   * @type {string}
   * @memberof ApiEformFormTemplateRelatedDocumentGet200Response
   */
  document: string
}
/**
 *
 * @export
 * @interface ApiEformStatusGet200Response
 */
export interface ApiEformStatusGet200Response {
  /**
   *
   * @type {string}
   * @memberof ApiEformStatusGet200Response
   */
  status: string
}
/**
 *
 * @export
 * @interface ApiEformValidatePost200Response
 */
export interface ApiEformValidatePost200Response {
  /**
   *
   * @type {boolean}
   * @memberof ApiEformValidatePost200Response
   */
  valid: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof ApiEformValidatePost200Response
   */
  errors?: Array<string>
}
/**
 *
 * @export
 * @interface ApiEformValidatePostRequest
 */
export interface ApiEformValidatePostRequest {
  /**
   * Dáta formuláru vo formáte XML.
   * @type {string}
   * @memberof ApiEformValidatePostRequest
   */
  form: string
}
/**
 * @type ApiIamIdentitiesIdGet200Response
 * @export
 */
export type ApiIamIdentitiesIdGet200Response = UpvsCorporateBody | UpvsNaturalPerson

/**
 *
 * @export
 * @interface ApiIamIdentitiesSearchPostRequest
 */
export interface ApiIamIdentitiesSearchPostRequest {
  /**
   * ID identít.
   * @type {Array<string>}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  ids?: Array<string>
  /**
   * URI identít.
   * @type {Array<string>}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  uris?: Array<string>
  /**
   * Identifikátor schránky.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  en?: string
  /**
   * Typ identity:   - `natural_person` fyzická osoba,   - `legal_entity` právnická osoba,   - `technical_account` technický účet,   - `employee_of_public_administration` zamestnanec verejnej správy,   - `institution_of_public_administration` orgán verejnej moci.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  type?: ApiIamIdentitiesSearchPostRequestTypeEnum
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  phone?: string
  /**
   *
   * @type {ApiIamIdentitiesSearchPostRequestAddress}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  address?: ApiIamIdentitiesSearchPostRequestAddress
  /**
   *
   * @type {ApiIamIdentitiesSearchPostRequestLegalEntity}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  legal_entity?: ApiIamIdentitiesSearchPostRequestLegalEntity
  /**
   *
   * @type {ApiIamIdentitiesSearchPostRequestNaturalPerson}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  natural_person?: ApiIamIdentitiesSearchPostRequestNaturalPerson
  /**
   * Spôsob vyhľadávania atribútov `corporate_body.name`, `natural_person.given_name` a `natural_person.family_name`.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  match?: ApiIamIdentitiesSearchPostRequestMatchEnum
  /**
   * Číslo stránky zoznamu identít.
   * @type {number}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  page?: number
  /**
   * Počet identít na stránke zoznamu.
   * @type {number}
   * @memberof ApiIamIdentitiesSearchPostRequest
   */
  per_page?: number
}

export const ApiIamIdentitiesSearchPostRequestTypeEnum = {
  NaturalPerson: 'natural_person',
  LegalEntity: 'legal_entity',
  TechnicalAccount: 'technical_account',
  AdministratorCrap: 'administrator_crap',
  EmployeeOfPublicAdministration: 'employee_of_public_administration',
  InstitutionOfPublicAdministration: 'institution_of_public_administration',
  EdemocracyUser: 'edemocracy_user',
} as const

export type ApiIamIdentitiesSearchPostRequestTypeEnum =
  (typeof ApiIamIdentitiesSearchPostRequestTypeEnum)[keyof typeof ApiIamIdentitiesSearchPostRequestTypeEnum]
export const ApiIamIdentitiesSearchPostRequestMatchEnum = {
  Exact: 'exact',
  Prefix: 'prefix',
  Infix: 'infix',
} as const

export type ApiIamIdentitiesSearchPostRequestMatchEnum =
  (typeof ApiIamIdentitiesSearchPostRequestMatchEnum)[keyof typeof ApiIamIdentitiesSearchPostRequestMatchEnum]

/**
 * Adresa trvalého pobytu alebo kontaktná adresa.
 * @export
 * @interface ApiIamIdentitiesSearchPostRequestAddress
 */
export interface ApiIamIdentitiesSearchPostRequestAddress {
  /**
   * Typ adresy:   - `contact` kontaktná adresa,   - `resident` adresa trvalého pobytu.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddress
   */
  type: ApiIamIdentitiesSearchPostRequestAddressTypeEnum
  /**
   *
   * @type {ApiIamIdentitiesSearchPostRequestAddressCountry}
   * @memberof ApiIamIdentitiesSearchPostRequestAddress
   */
  country?: ApiIamIdentitiesSearchPostRequestAddressCountry
  /**
   *
   * @type {ApiIamIdentitiesSearchPostRequestAddressDistrict}
   * @memberof ApiIamIdentitiesSearchPostRequestAddress
   */
  district?: ApiIamIdentitiesSearchPostRequestAddressDistrict
  /**
   *
   * @type {ApiIamIdentitiesSearchPostRequestAddressMunicipality}
   * @memberof ApiIamIdentitiesSearchPostRequestAddress
   */
  municipality?: ApiIamIdentitiesSearchPostRequestAddressMunicipality
  /**
   * Ulica.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddress
   */
  street?: string
  /**
   * Orientačné číslo budovy.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddress
   */
  building_number?: string
  /**
   * Súpisné číslo budovy.
   * @type {number}
   * @memberof ApiIamIdentitiesSearchPostRequestAddress
   */
  registration_number?: number
}

export const ApiIamIdentitiesSearchPostRequestAddressTypeEnum = {
  Contact: 'contact',
  Resident: 'resident',
} as const

export type ApiIamIdentitiesSearchPostRequestAddressTypeEnum =
  (typeof ApiIamIdentitiesSearchPostRequestAddressTypeEnum)[keyof typeof ApiIamIdentitiesSearchPostRequestAddressTypeEnum]

/**
 * Krajina podľa číselníka ŠÚSR 0086
 * @export
 * @interface ApiIamIdentitiesSearchPostRequestAddressCountry
 */
export interface ApiIamIdentitiesSearchPostRequestAddressCountry {
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddressCountry
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddressCountry
   */
  name?: string
}
/**
 * Okres podľa číselníka ŠÚSR 0024.
 * @export
 * @interface ApiIamIdentitiesSearchPostRequestAddressDistrict
 */
export interface ApiIamIdentitiesSearchPostRequestAddressDistrict {
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddressDistrict
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddressDistrict
   */
  name?: string
}
/**
 * Obec podľa číselníka ŠÚSR 0025.
 * @export
 * @interface ApiIamIdentitiesSearchPostRequestAddressMunicipality
 */
export interface ApiIamIdentitiesSearchPostRequestAddressMunicipality {
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddressMunicipality
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestAddressMunicipality
   */
  name?: string
}
/**
 * Právnická osoba.
 * @export
 * @interface ApiIamIdentitiesSearchPostRequestLegalEntity
 */
export interface ApiIamIdentitiesSearchPostRequestLegalEntity {
  /**
   * IČO.
   * @type {number}
   * @memberof ApiIamIdentitiesSearchPostRequestLegalEntity
   */
  cin?: number
  /**
   * DIČ.
   * @type {number}
   * @memberof ApiIamIdentitiesSearchPostRequestLegalEntity
   */
  tin?: number
  /**
   * Názov.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestLegalEntity
   */
  name?: string
}
/**
 * Fyzická osoba.
 * @export
 * @interface ApiIamIdentitiesSearchPostRequestNaturalPerson
 */
export interface ApiIamIdentitiesSearchPostRequestNaturalPerson {
  /**
   * Meno. Pozri `match`.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestNaturalPerson
   */
  given_name?: string
  /**
   * Priezvisko. Pozri `match`.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestNaturalPerson
   */
  family_name?: string
  /**
   * Dátum narodenia.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestNaturalPerson
   */
  date_of_birth?: string
  /**
   * Miesto narodenia.
   * @type {string}
   * @memberof ApiIamIdentitiesSearchPostRequestNaturalPerson
   */
  place_of_birth?: string
}
/**
 *
 * @export
 * @interface ApiMdurzRecordsIdDeleteRequest
 */
export interface ApiMdurzRecordsIdDeleteRequest {
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsIdDeleteRequest
   */
  message_id: string
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsIdDeleteRequest
   */
  correlation_id: string
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsIdDeleteRequest
   */
  sender_uri: string
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsIdDeleteRequest
   */
  recipient_uri: string
}
/**
 *
 * @export
 * @interface ApiMdurzRecordsPostRequest
 */
export interface ApiMdurzRecordsPostRequest {
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsPostRequest
   */
  message_id: string
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsPostRequest
   */
  correlation_id: string
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsPostRequest
   */
  sender_uri: string
  /**
   *
   * @type {string}
   * @memberof ApiMdurzRecordsPostRequest
   */
  recipient_uri: string
  /**
   *
   * @type {Array<EdeskMessageObject>}
   * @memberof ApiMdurzRecordsPostRequest
   */
  objects: Array<EdeskMessageObject>
}
/**
 *
 * @export
 * @interface ApiSktalkReceivePostRequest
 */
export interface ApiSktalkReceivePostRequest {
  /**
   * SKTalk správa vo formáte XML.
   * @type {string}
   * @memberof ApiSktalkReceivePostRequest
   */
  message: string
}
/**
 *
 * @export
 * @interface ApiUsrPostRequest
 */
export interface ApiUsrPostRequest {
  /**
   * Názov služby.
   * @type {string}
   * @memberof ApiUsrPostRequest
   */
  service: string
  /**
   * Požiadavka služby vo formáte XML.
   * @type {string}
   * @memberof ApiUsrPostRequest
   */
  request: string
}
/**
 * Podpísaný objekt v rámci modulu CEP. Napríklad ASiC-E kontajner.
 * @export
 * @interface CepSignedObject
 */
export interface CepSignedObject {
  /**
   * Certifikát časovej pečiatky podpisu objektu.
   * @type {string}
   * @memberof CepSignedObject
   */
  timestamp_certificate: string
  /**
   * Identifikátor objektu.
   * @type {string}
   * @memberof CepSignedObject
   */
  id: string
  /**
   * Názov objektu.
   * @type {string}
   * @memberof CepSignedObject
   */
  name?: string | null
  /**
   * Popis objektu.
   * @type {string}
   * @memberof CepSignedObject
   */
  description?: string | null
  /**
   * Typ objektu v súlade s [Dokumentáciou funkčnosti Centrálnej elektronickej podateľne](https://www.slovensko.sk/_img/CMS4/Dokumentacia_funkcnosti_CEP.pdf).
   * @type {string}
   * @memberof CepSignedObject
   */
  class: string
  /**
   * Indikátor či je obsah objektu podpísaný.
   * @type {boolean}
   * @memberof CepSignedObject
   */
  signed?: boolean | null
  /**
   * Typ internetového média v súlade s typom a obsahom objektu.
   * @type {string}
   * @memberof CepSignedObject
   */
  mime_type: string
  /**
   * Kódovanie obsahu objektu v súlade s hodnotou v atribúte `content`.
   * @type {string}
   * @memberof CepSignedObject
   */
  encoding: CepSignedObjectEncodingEnum
  /**
   * Obsah objektu zakódovaný podľa hodnoty v atribúte `encoding`.
   * @type {string}
   * @memberof CepSignedObject
   */
  content: string
}

export const CepSignedObjectEncodingEnum = {
  Base64: 'Base64',
  Xml: 'XML',
} as const

export type CepSignedObjectEncodingEnum =
  (typeof CepSignedObjectEncodingEnum)[keyof typeof CepSignedObjectEncodingEnum]

/**
 * Podpísaná množina objektov ako ASiC kontajner.
 * @export
 * @interface CepSignedObjectGroup
 */
export interface CepSignedObjectGroup {
  /**
   * Identifikátor podpisového konatjnera.
   * @type {string}
   * @memberof CepSignedObjectGroup
   */
  id?: string
  /**
   * MimeType podpisového kontajnera.
   * @type {string}
   * @memberof CepSignedObjectGroup
   */
  mime_type?: string
  /**
   * Obsah ASiC kontajnera zakódovaný v base64.
   * @type {string}
   * @memberof CepSignedObjectGroup
   */
  data?: string
  /**
   * Certifikát poslednej časovej pečiatky v base64.
   * @type {string}
   * @memberof CepSignedObjectGroup
   */
  timestamp_certificate?: string
}
/**
 * Štruktúra pre výber podpisového certifkátu.
 * @export
 * @interface CepSigningCertificate
 */
export interface CepSigningCertificate {
  /**
   * Typ výberu podpisového certifikátu:   - `Issuer` znamená výber certifikátu podľa vydavateľa a sériového čísla, ktoré sú uvedené v atribúte `issuer`,   - `Subject` znamená výber certifikátu podľa subjektu v certifikáte, ktorý je uvedený v atribúte `subject`,   - `URI` znamená výber certifikátu podľa URI evidovaného na strane ÚPVS, ktorý je uvedený v atribúte `uri`.
   * @type {string}
   * @memberof CepSigningCertificate
   */
  type: CepSigningCertificateTypeEnum
  /**
   * Vydavateľ podpisového certifikátu, iba pre typ `Issuer`.
   * @type {string}
   * @memberof CepSigningCertificate
   */
  issuer?: string
  /**
   * Sériové číslo podpisového certifikátu, iba pre typ `Issuer`.
   * @type {string}
   * @memberof CepSigningCertificate
   */
  issuer_serial_number?: string
  /**
   * Subjekt podpisového certifikátu, iba pre typ `Subject`.
   * @type {string}
   * @memberof CepSigningCertificate
   */
  subject?: string
  /**
   * URI podpisového certifikátu, iba pre typ `URI`.
   * @type {string}
   * @memberof CepSigningCertificate
   */
  uri?: string
}

export const CepSigningCertificateTypeEnum = {
  Issuer: 'Issuer',
  Subject: 'Subject',
  Uri: 'URI',
} as const

export type CepSigningCertificateTypeEnum =
  (typeof CepSigningCertificateTypeEnum)[keyof typeof CepSigningCertificateTypeEnum]

/**
 * Podpisovaný objekt v rámci modulu CEP. Napríklad PDF príloha alebo XML formulár.
 * @export
 * @interface CepSigningObject
 */
export interface CepSigningObject {
  /**
   * Identifikátor objektu.
   * @type {string}
   * @memberof CepSigningObject
   */
  id?: string
  /**
   * Názov objektu.
   * @type {string}
   * @memberof CepSigningObject
   */
  name?: string | null
  /**
   * Popis objektu.
   * @type {string}
   * @memberof CepSigningObject
   */
  description?: string | null
  /**
   * Typ objektu v súlade s [Dokumentáciou funkčnosti Centrálnej elektronickej podateľne](https://www.slovensko.sk/_img/CMS4/Dokumentacia_funkcnosti_CEP.pdf).
   * @type {string}
   * @memberof CepSigningObject
   */
  class: string
  /**
   * Indikátor či je obsah objektu podpísaný.
   * @type {boolean}
   * @memberof CepSigningObject
   */
  signed?: boolean | null
  /**
   * Typ internetového média v súlade s typom a obsahom objektu.
   * @type {string}
   * @memberof CepSigningObject
   */
  mime_type: string
  /**
   * Kódovanie obsahu objektu v súlade s hodnotou v atribúte `content`.
   * @type {string}
   * @memberof CepSigningObject
   */
  encoding: CepSigningObjectEncodingEnum
  /**
   * Obsah objektu zakódovaný podľa hodnoty v atribúte `encoding`.
   * @type {string}
   * @memberof CepSigningObject
   */
  content: string
}

export const CepSigningObjectEncodingEnum = {
  Base64: 'Base64',
  Xml: 'XML',
} as const

export type CepSigningObjectEncodingEnum =
  (typeof CepSigningObjectEncodingEnum)[keyof typeof CepSigningObjectEncodingEnum]

/**
 * Objekt na podpis v rámci modulu CEP pre volanie metódy `POST /api/cep/sign_v2`.
 * @export
 * @interface CepSigningObjectV2
 */
export interface CepSigningObjectV2 {
  /**
   * Identifikátor objektu v tvare URI. Hodnota z evidencie dátových objektov.
   * @type {string}
   * @memberof CepSigningObjectV2
   */
  id: string
  /**
   * Obsah objektu zakódovaný podľa hodnoty v base64.
   * @type {string}
   * @memberof CepSigningObjectV2
   */
  data: string
  /**
   * Názov objektu.
   * @type {string}
   * @memberof CepSigningObjectV2
   */
  name?: string | null
  /**
   * Identifikátor podpisovej vizualizácie.
   * @type {string}
   * @memberof CepSigningObjectV2
   */
  visualization_uri?: string
}
/**
 * Množina objektov, ktoré majú byť spoločne podpísané.
 * @export
 * @interface CepSigningV2ObjectGroup
 */
export interface CepSigningV2ObjectGroup {
  /**
   *
   * @type {CepSigningCertificate}
   * @memberof CepSigningV2ObjectGroup
   */
  signing_certificate: CepSigningCertificate
  /**
   *
   * @type {Array<CepSigningObjectV2>}
   * @memberof CepSigningV2ObjectGroup
   */
  unsigned_objects?: Array<CepSigningObjectV2>
  /**
   * Už podpísaný ASiC kontajner určený na podpis - obsah ASiC kontajnera zakódovaný v base64
   * @type {string}
   * @memberof CepSigningV2ObjectGroup
   */
  signed_object?: string
  /**
   * Identifikátor množiny objektov.
   * @type {string}
   * @memberof CepSigningV2ObjectGroup
   */
  id: string
}
/**
 * Overený ASiC CAdES objekt v rámci modulu CEP.
 * @export
 * @interface CepVerifiedAsicCadesObject
 */
export interface CepVerifiedAsicCadesObject {
  /**
   * Autorizácie objektu.
   * @type {Array<object>}
   * @memberof CepVerifiedAsicCadesObject
   */
  authorizations?: Array<object>
  /**
   * Identifikátor objektu v rámci MessageContainer.
   * @type {string}
   * @memberof CepVerifiedAsicCadesObject
   */
  id?: string | null
}
/**
 * Overený ASiC XAdES objekt v rámci modulu CEP.
 * @export
 * @interface CepVerifiedAsicXadesObject
 */
export interface CepVerifiedAsicXadesObject {
  /**
   * Autorizácie objektu.
   * @type {Array<object>}
   * @memberof CepVerifiedAsicXadesObject
   */
  authorizations?: Array<object>
  /**
   * Identifikátor objektu v rámci MessageContainer.
   * @type {string}
   * @memberof CepVerifiedAsicXadesObject
   */
  id?: string | null
}
/**
 * Overený CAdES objekt v rámci modulu CEP.
 * @export
 * @interface CepVerifiedCadesObject
 */
export interface CepVerifiedCadesObject {
  /**
   * Autorizácie objektu.
   * @type {Array<object>}
   * @memberof CepVerifiedCadesObject
   */
  authorizations?: Array<object>
  /**
   * Identifikátor objektu v rámci MessageContainer.
   * @type {string}
   * @memberof CepVerifiedCadesObject
   */
  id?: string | null
}
/**
 * Overený objekt v rámci modulu CEP.
 * @export
 * @interface CepVerifiedObject
 */
export interface CepVerifiedObject {
  /**
   * Identifikátor objektu v rámci MessageContainer.
   * @type {string}
   * @memberof CepVerifiedObject
   */
  id?: string | null
  /**
   * Autorizácie objektu.
   * @type {Array<CepVerifiedObjectAuthorizationsInner>}
   * @memberof CepVerifiedObject
   */
  authorizations?: Array<CepVerifiedObjectAuthorizationsInner>
}
/**
 *
 * @export
 * @interface CepVerifiedObjectAuthorizationsInner
 */
export interface CepVerifiedObjectAuthorizationsInner {
  /**
   *
   * @type {CepVerifiedObjectAuthorizationsInnerSignature}
   * @memberof CepVerifiedObjectAuthorizationsInner
   */
  signature?: CepVerifiedObjectAuthorizationsInnerSignature
  /**
   *
   * @type {CepVerifiedObjectAuthorizationsInnerTimestamp}
   * @memberof CepVerifiedObjectAuthorizationsInner
   */
  timestamp?: CepVerifiedObjectAuthorizationsInnerTimestamp
  /**
   *
   * @type {CepVerifiedObjectAuthorizationsInnerVerification}
   * @memberof CepVerifiedObjectAuthorizationsInner
   */
  verification?: CepVerifiedObjectAuthorizationsInnerVerification
  /**
   * Podpísané objekty.
   * @type {Array<object>}
   * @memberof CepVerifiedObjectAuthorizationsInner
   */
  objects?: Array<object>
}
/**
 * Podpis objektu.
 * @export
 * @interface CepVerifiedObjectAuthorizationsInnerSignature
 */
export interface CepVerifiedObjectAuthorizationsInnerSignature {
  /**
   * Typ podpisu. Pozri [Dokumentáciou funkčnosti Centrálnej elektronickej podateľne](https://www.slovensko.sk/_img/CMS4/Dokumentacia_funkcnosti_CEP.pdf).
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignature
   */
  type?: string
  /**
   * Formát podpisu. Pozri [Dokumentáciou funkčnosti Centrálnej elektronickej podateľne](https://www.slovensko.sk/_img/CMS4/Dokumentacia_funkcnosti_CEP.pdf).
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignature
   */
  format?: string
  /**
   *
   * @type {CepVerifiedObjectAuthorizationsInnerSignatureCertificate}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignature
   */
  certificate?: CepVerifiedObjectAuthorizationsInnerSignatureCertificate
  /**
   * Indikátor či podpis obsahuje časovú pečiatku.
   * @type {boolean}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignature
   */
  timestamped?: boolean
  /**
   * Čas vytvorenia podpisu.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignature
   */
  signed_at?: string
}
/**
 * Podpisový certifikát.
 * @export
 * @interface CepVerifiedObjectAuthorizationsInnerSignatureCertificate
 */
export interface CepVerifiedObjectAuthorizationsInnerSignatureCertificate {
  /**
   * Sériové číslo podpisového certifikátu.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignatureCertificate
   */
  serial_number?: string
  /**
   * Vydavateľ podpisového certifikátu.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignatureCertificate
   */
  issuer?: string
  /**
   * Subjekt podpisového certifikátu.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignatureCertificate
   */
  subject?: string
  /**
   * Informácie o mandáte podpisového certifikátu.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerSignatureCertificate
   */
  mandate?: string
}
/**
 * Časová pečiatka podpisu objektu.
 * @export
 * @interface CepVerifiedObjectAuthorizationsInnerTimestamp
 */
export interface CepVerifiedObjectAuthorizationsInnerTimestamp {
  /**
   *
   * @type {CepVerifiedObjectAuthorizationsInnerTimestampCertificate}
   * @memberof CepVerifiedObjectAuthorizationsInnerTimestamp
   */
  certificate?: CepVerifiedObjectAuthorizationsInnerTimestampCertificate | null
  /**
   * Čas vytvorenia časovej pečiatky.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerTimestamp
   */
  timestamped_at?: string | null
}
/**
 * Certifikát časovej pečiatky.
 * @export
 * @interface CepVerifiedObjectAuthorizationsInnerTimestampCertificate
 */
export interface CepVerifiedObjectAuthorizationsInnerTimestampCertificate {
  /**
   * Sériové číslo certifikátu časovej pečiatky.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerTimestampCertificate
   */
  serial_number?: string
  /**
   * Vydavateľ certifikátu časovej pečiatky.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerTimestampCertificate
   */
  issuer?: string
  /**
   * Subjekt certifikátu časovej pečiatky.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerTimestampCertificate
   */
  subject?: string
}
/**
 * Overenie objektu.
 * @export
 * @interface CepVerifiedObjectAuthorizationsInnerVerification
 */
export interface CepVerifiedObjectAuthorizationsInnerVerification {
  /**
   * Kód výsledku overenia:   - `1` platná,   - `2` neplatná,   - `3` predbežne platná,   - `4` pravdepodobne platná,   - `5` neoverená.
   * @type {number}
   * @memberof CepVerifiedObjectAuthorizationsInnerVerification
   */
  result?: number
  /**
   * Popis výsledku overenia.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerVerification
   */
  description?: CepVerifiedObjectAuthorizationsInnerVerificationDescriptionEnum
  /**
   *
   * @type {CepVerifiedObjectAuthorizationsInnerVerificationVerifier}
   * @memberof CepVerifiedObjectAuthorizationsInnerVerification
   */
  verifier?: CepVerifiedObjectAuthorizationsInnerVerificationVerifier
  /**
   * Čas overenia podpisu.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerVerification
   */
  verified_at?: string
}

export const CepVerifiedObjectAuthorizationsInnerVerificationDescriptionEnum = {
  Platn: 'Platná',
  Neplatn: 'Neplatná',
  PredbenePlatn: 'Predbežne platná',
  PravdepodobnePlatn: 'Pravdepodobne platná',
  Neoveren: 'Neoverená',
} as const

export type CepVerifiedObjectAuthorizationsInnerVerificationDescriptionEnum =
  (typeof CepVerifiedObjectAuthorizationsInnerVerificationDescriptionEnum)[keyof typeof CepVerifiedObjectAuthorizationsInnerVerificationDescriptionEnum]

/**
 * Výstup z overovača.
 * @export
 * @interface CepVerifiedObjectAuthorizationsInnerVerificationVerifier
 */
export interface CepVerifiedObjectAuthorizationsInnerVerificationVerifier {
  /**
   * Kód výsledku z overovača na základe ktorého bol stanovený výsledok overenia.
   * @type {number}
   * @memberof CepVerifiedObjectAuthorizationsInnerVerificationVerifier
   */
  result?: number
  /**
   * Popis výsledku z overovača na základe ktorého bol stanovený výsledok overenia.
   * @type {string}
   * @memberof CepVerifiedObjectAuthorizationsInnerVerificationVerifier
   */
  description?: string
}
/**
 * Overený PAdES objekt v rámci modulu CEP.
 * @export
 * @interface CepVerifiedPadesObject
 */
export interface CepVerifiedPadesObject {
  /**
   * Autorizácie objektu.
   * @type {Array<object>}
   * @memberof CepVerifiedPadesObject
   */
  authorizations?: Array<object>
  /**
   * Identifikátor objektu v rámci MessageContainer.
   * @type {string}
   * @memberof CepVerifiedPadesObject
   */
  id?: string | null
}
/**
 * Overený XAdES objekt v rámci modulu CEP.
 * @export
 * @interface CepVerifiedXadesObject
 */
export interface CepVerifiedXadesObject {
  /**
   * Autorizácie objektu.
   * @type {Array<object>}
   * @memberof CepVerifiedXadesObject
   */
  authorizations?: Array<object>
  /**
   * Identifikátor objektu v rámci MessageContainer.
   * @type {string}
   * @memberof CepVerifiedXadesObject
   */
  id?: string | null
}
/**
 * Doručenka na prevzatie správy.
 * @export
 * @interface EdeskDeliveryNotification
 */
export interface EdeskDeliveryNotification {
  /**
   * URL na autorizáciu doručenky.
   * @type {string}
   * @memberof EdeskDeliveryNotification
   */
  authorize_url: string
  /**
   * Lehota na prevzatie správy v dňoch.
   * @type {number}
   * @memberof EdeskDeliveryNotification
   */
  delivery_period?: number | null
  /**
   * Čas vypršania lehoty na prevzatie správy.
   * @type {string}
   * @memberof EdeskDeliveryNotification
   */
  delivery_period_end_at?: string | null
  /**
   * Čas doručenia doručenky.
   * @type {string}
   * @memberof EdeskDeliveryNotification
   */
  received_at?: string | null
  /**
   *
   * @type {EdeskDeliveryNotificationConsignment}
   * @memberof EdeskDeliveryNotification
   */
  consignment: EdeskDeliveryNotificationConsignment
}
/**
 * Informácie o správe na prevzatie.
 * @export
 * @interface EdeskDeliveryNotificationConsignment
 */
export interface EdeskDeliveryNotificationConsignment {
  /**
   * SKTalk identifikátor správy na prevzatie.
   * @type {string}
   * @memberof EdeskDeliveryNotificationConsignment
   */
  message_id: string
  /**
   * Typ správy na prevzatie.
   * @type {string}
   * @memberof EdeskDeliveryNotificationConsignment
   */
  message_type: string
  /**
   * Predmet správy na prevzatie.
   * @type {string}
   * @memberof EdeskDeliveryNotificationConsignment
   */
  message_subject: string
  /**
   * Prílohy správy na prevzatie.
   * @type {Array<EdeskDeliveryNotificationConsignmentAttachmentsInner>}
   * @memberof EdeskDeliveryNotificationConsignment
   */
  attachments: Array<EdeskDeliveryNotificationConsignmentAttachmentsInner>
  /**
   * Poznámka k doručenke. Obsahuje napríklad informáciu, či sa uplatňuje fikcia doručenia.
   * @type {string}
   * @memberof EdeskDeliveryNotificationConsignment
   */
  note?: string | null
}
/**
 *
 * @export
 * @interface EdeskDeliveryNotificationConsignmentAttachmentsInner
 */
export interface EdeskDeliveryNotificationConsignmentAttachmentsInner {
  /**
   * Identifikátor prílohy v správe na prevzatie.
   * @type {string}
   * @memberof EdeskDeliveryNotificationConsignmentAttachmentsInner
   */
  id: string
  /**
   * Názov prílohy v správe na prevzatie.
   * @type {string}
   * @memberof EdeskDeliveryNotificationConsignmentAttachmentsInner
   */
  name: string
}
/**
 * Priečinok v schránke.
 * @export
 * @interface EdeskFolder
 */
export interface EdeskFolder {
  /**
   * eDesk identifikátor priečinka.
   * @type {number}
   * @memberof EdeskFolder
   */
  id: number
  /**
   * eDesk identifikátor rodičovského priečinka.
   * @type {number}
   * @memberof EdeskFolder
   */
  parent_id?: number | null
  /**
   * Názov priečinka.
   * @type {string}
   * @memberof EdeskFolder
   */
  name: string
  /**
   * Indikátor či ide o systémový priečinok alebo priečinok vytvorený používateľom.
   * @type {boolean}
   * @memberof EdeskFolder
   */
  system: boolean
}
/**
 * Správa v schránke bez obsahu a extrahovaných príloh.
 * @export
 * @interface EdeskHeader
 */
export interface EdeskHeader {
  /**
   * eDesk identifikátor správy.
   * @type {number}
   * @memberof EdeskHeader
   */
  id: number
  /**
   * SKTalk trieda správy.
   * @type {string}
   * @memberof EdeskHeader
   */
  class: string
  /**
   * SKTalk identifikátor správy. Správa odoslaná viacerým adresátom má rovnaké `message_id`, no rôzne eDesk `id` u každého adresáta.
   * @type {string}
   * @memberof EdeskHeader
   */
  message_id: string
  /**
   * SKTalk identifikátor vlákna správ.
   * @type {string}
   * @memberof EdeskHeader
   */
  correlation_id: string
  /**
   * Predmet správy.
   * @type {string}
   * @memberof EdeskHeader
   */
  subject: string
  /**
   * Čas doručenia správy.
   * @type {string}
   * @memberof EdeskHeader
   */
  delivered_at: string
}
/**
 * Správa v schránke s obsahom a extrahovanými prílohami.
 * @export
 * @interface EdeskMessage
 */
export interface EdeskMessage {
  /**
   * SKTalk identifikátor referenčnej správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  reference_id?: string | null
  /**
   * Identifikátor obsiahnutého formulára správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  posp_id?: string | null
  /**
   * Verzia obsiahnutého formulára správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  posp_version?: string | null
  /**
   * Identifikátor odosielateľa správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  sender_uri?: string | null
  /**
   * Identifikátor prijímateľa správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  recipient_uri?: string | null
  /**
   * Typ správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  type?: string | null
  /**
   *
   * @type {string}
   * @memberof EdeskMessage
   */
  sender_business_reference?: string | null
  /**
   *
   * @type {string}
   * @memberof EdeskMessage
   */
  recipient_business_reference?: string | null
  /**
   *
   * @type {EdeskDeliveryNotification}
   * @memberof EdeskMessage
   */
  delivery_notification?: EdeskDeliveryNotification
  /**
   * Extrahované prílohy správy.
   * @type {Array<EdeskMessageObject>}
   * @memberof EdeskMessage
   */
  objects: Array<EdeskMessageObject>
  /**
   * HTML vizualizácia správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  original_html: string
  /**
   * Pôvodný obsah správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  original_xml: string
  /**
   * Indikátor či došlo k chybe pri spracovaní správy na strane komponentu.
   * @type {boolean}
   * @memberof EdeskMessage
   */
  parse_error: boolean
  /**
   * eDesk identifikátor správy.
   * @type {number}
   * @memberof EdeskMessage
   */
  id: number
  /**
   * SKTalk trieda správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  class: string
  /**
   * SKTalk identifikátor správy. Správa odoslaná viacerým adresátom má rovnaké `message_id`, no rôzne eDesk `id` u každého adresáta.
   * @type {string}
   * @memberof EdeskMessage
   */
  message_id: string
  /**
   * SKTalk identifikátor vlákna správ.
   * @type {string}
   * @memberof EdeskMessage
   */
  correlation_id: string
  /**
   * Predmet správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  subject: string
  /**
   * Čas doručenia správy.
   * @type {string}
   * @memberof EdeskMessage
   */
  delivered_at: string
}
/**
 * Objekt v správe. Napríklad PDF príloha, podpísaný kontajner (ASiC, ZEP) alebo XML formulár.
 * @export
 * @interface EdeskMessageObject
 */
export interface EdeskMessageObject {
  /**
   * Identifikátor objektu.
   * @type {string}
   * @memberof EdeskMessageObject
   */
  id: string
  /**
   * Názov objektu.
   * @type {string}
   * @memberof EdeskMessageObject
   */
  name?: string | null
  /**
   * Popis objektu.
   * @type {string}
   * @memberof EdeskMessageObject
   */
  description?: string | null
  /**
   * Typ objektu.
   * @type {string}
   * @memberof EdeskMessageObject
   */
  class: EdeskMessageObjectClassEnum
  /**
   * Indikátor či je obsah objektu podpísaný.
   * @type {boolean}
   * @memberof EdeskMessageObject
   */
  signed?: boolean | null
  /**
   * Typ internetového média v súlade s typom a obsahom objektu.
   * @type {string}
   * @memberof EdeskMessageObject
   */
  mime_type: string
  /**
   * Kódovanie obsahu objektu v súlade s hodnotou v atribúte `content`.
   * @type {string}
   * @memberof EdeskMessageObject
   */
  encoding: EdeskMessageObjectEncodingEnum
  /**
   * Obsah objektu zakódovaný podľa hodnoty v atribúte `encoding`.
   * @type {string}
   * @memberof EdeskMessageObject
   */
  content: string
}

export const EdeskMessageObjectClassEnum = {
  Form: 'FORM',
  Attachment: 'ATTACHMENT',
} as const

export type EdeskMessageObjectClassEnum =
  (typeof EdeskMessageObjectClassEnum)[keyof typeof EdeskMessageObjectClassEnum]
export const EdeskMessageObjectEncodingEnum = {
  Base64: 'Base64',
  Xml: 'XML',
} as const

export type EdeskMessageObjectEncodingEnum =
  (typeof EdeskMessageObjectEncodingEnum)[keyof typeof EdeskMessageObjectEncodingEnum]

/**
 * Porucha ÚPVS integrácie.
 * @export
 * @interface ErrorFault
 */
export interface ErrorFault {
  /**
   * Kód poruchy ÚPVS integrácie.
   * @type {string}
   * @memberof ErrorFault
   */
  code?: string | null
  /**
   * Dôvod poruchy ÚPVS integrácie.
   * @type {string}
   * @memberof ErrorFault
   */
  reason?: string | null
}
/**
 * Zdravie komponentu.
 * @export
 * @interface Health
 */
export interface Health {
  /**
   * Názov komponentu.
   * @type {string}
   * @memberof Health
   */
  description?: string
  /**
   * Verzia komponentu.
   * @type {string}
   * @memberof Health
   */
  version?: string
  /**
   * Stav komponentu.
   * @type {string}
   * @memberof Health
   */
  status?: HealthStatusEnum
  /**
   *
   * @type {HealthChecks}
   * @memberof Health
   */
  checks?: HealthChecks
  /**
   *
   * @type {HealthLinks}
   * @memberof Health
   */
  links?: HealthLinks
}

export const HealthStatusEnum = {
  Pass: 'pass',
  Warn: 'warn',
  Fail: 'fail',
} as const

export type HealthStatusEnum = (typeof HealthStatusEnum)[keyof typeof HealthStatusEnum]

/**
 * Kontroly komponentu.
 * @export
 * @interface HealthChecks
 */
export interface HealthChecks {
  /**
   * Kontrola premenných prostredia.
   * @type {any}
   * @memberof HealthChecks
   */
  'environment:variables'?: any
  /**
   * Kontrola spojenia s PostgreSQL databázou.
   * @type {any}
   * @memberof HealthChecks
   */
  'postgresql:connection'?: any
  /**
   * Kontrola spojenia s Redis úložiskom.
   * @type {any}
   * @memberof HealthChecks
   */
  'redis:connection'?: any
  /**
   * Kontrola autentifikátora API tokenov.
   * @type {any}
   * @memberof HealthChecks
   */
  'authenticator:api'?: any
  /**
   * Kontrola autentifikátora OBO tokenov. Vykoná sa iba ak je podpora ÚPVS SSO zapnutá.
   * @type {any}
   * @memberof HealthChecks
   */
  'authenticator:obo'?: any
  /**
   * Kontrola expirácie STS certifikátu pre synchronizáciu formulárov. Vykoná sa iba ak je nastavená premenná `EFORM_SYNC_SUBJECT`.
   * @type {any}
   * @memberof HealthChecks
   */
  'eform:sync_certificate'?: any
  /**
   * Kontrola vykonávania synchronizácie formulárov. Vykoná sa iba ak je nastavená premenná `EFORM_SYNC_SUBJECT`.
   * @type {any}
   * @memberof HealthChecks
   */
  'eform:sync_task'?: any
  /**
   * Kontrola expirácie SSO SP certifikátu. Vykoná sa iba ak je podpora ÚPVS SSO zapnutá.
   * @type {any}
   * @memberof HealthChecks
   */
  'sso:sp_certificate'?: any
  /**
   * Kontrola expirácie SSO STS certifikátu pre OBO prístup. Vykoná sa iba ak je podpora ÚPVS SSO zapnutá.
   * @type {any}
   * @memberof HealthChecks
   */
  'sso:proxy_certificate'?: any
  /**
   * Kontrola expirácie STS certifikátu pre kontrolu spojenia s ÚPVS. Vykoná sa iba ak je nastavená premenná `STS_HEALTH_SUBJECT`.
   * @type {any}
   * @memberof HealthChecks
   */
  'sts:certificate'?: any
  /**
   * Kontrola času prvotného vytvorenia objektu pre komunikáciu s ÚPVS. Vykoná sa iba ak je nastavená premenná `STS_HEALTH_SUBJECT`.
   * @type {any}
   * @memberof HealthChecks
   */
  'sts:creation_time'?: any
  /**
   * Kontrola času STS autentifikácie v rámci požiadavky na zistenie stavu formulára. Vykoná sa iba ak je nastavená premenná `STS_HEALTH_SUBJECT`.
   * @type {any}
   * @memberof HealthChecks
   */
  'sts:response_time'?: any
}
/**
 * Odkazy súvisiace s komponentom.
 * @export
 * @interface HealthLinks
 */
export interface HealthLinks {
  /**
   * Odkaz na inštalačnú príručku komponentu.
   * @type {string}
   * @memberof HealthLinks
   */
  installation?: string
  /**
   * Odkaz na špecifikáciu API komponentu.
   * @type {string}
   * @memberof HealthLinks
   */
  documentation?: string
}
/**
 *
 * @export
 * @interface LoginPost200Response
 */
export interface LoginPost200Response {
  /**
   *
   * @type {any}
   * @memberof LoginPost200Response
   */
  token: any
}
/**
 *
 * @export
 * @interface LoginPostRequest
 */
export interface LoginPostRequest {
  /**
   * Base64 SAML assertion získaná z ÚPVS.
   * @type {string}
   * @memberof LoginPostRequest
   */
  saml_assertion: string
}
/**
 * Chyba.
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Správa.
   * @type {string}
   * @memberof ModelError
   */
  message: string
  /**
   *
   * @type {ErrorFault}
   * @memberof ModelError
   */
  fault?: ErrorFault
}
/**
 * Výsledok odoslania SKTalk správy a uloženia medzi odoslané správy.
 * @export
 * @interface SktalkReceiveAndSaveToOutboxResult
 */
export interface SktalkReceiveAndSaveToOutboxResult {
  /**
   * Výsledok odoslania správy, hodnota `0` znamená úspešné prijatie správy na odoslanie.
   * @type {number}
   * @memberof SktalkReceiveAndSaveToOutboxResult
   */
  receive_result: number | null
  /**
   * Indikátor či pri odoslaní správy prišlo k vypršaniu času požiadavky na ÚPVS.
   * @type {boolean}
   * @memberof SktalkReceiveAndSaveToOutboxResult
   */
  receive_timeout: boolean
  /**
   * Výsledok uloženia správy medzi odoslané správy, hodnota `0` znamená úspešné prijatie správy na uloženie medzi odoslané správy.
   * @type {number}
   * @memberof SktalkReceiveAndSaveToOutboxResult
   */
  save_to_outbox_result: number | null
  /**
   * Indikátor či pri uložení správy medzi odoslané správy prišlo k vypršaniu času požiadavky na ÚPVS.
   * @type {boolean}
   * @memberof SktalkReceiveAndSaveToOutboxResult
   */
  save_to_outbox_timeout: boolean | null
}
/**
 * Výsledok odoslania SKTalk správy.
 * @export
 * @interface SktalkReceiveResult
 */
export interface SktalkReceiveResult {
  /**
   * Výsledok odoslania správy, hodnota `0` znamená úspešné prijatie správy na odoslanie.
   * @type {number}
   * @memberof SktalkReceiveResult
   */
  receive_result: number
}
/**
 * Výsledok uloženia SKTalk správy medzi odoslané správy.
 * @export
 * @interface SktalkSaveToOutboxResult
 */
export interface SktalkSaveToOutboxResult {
  /**
   * Výsledok uloženia správy medzi odoslané správy, hodnota `0` znamená úspešné prijatie správy na uloženie medzi odoslané správy.
   * @type {number}
   * @memberof SktalkSaveToOutboxResult
   */
  save_to_outbox_result: number
}
/**
 * ÚPVS identita právnickej osoby.
 * @export
 * @interface UpvsCorporateBody
 */
export interface UpvsCorporateBody {
  /**
   * Právnická osoba.
   * @type {object}
   * @memberof UpvsCorporateBody
   */
  corporate_body?: object
  /**
   * Sektorové identifikátory.
   * @type {Array<UpvsIdentityIdsInner>}
   * @memberof UpvsCorporateBody
   */
  ids?: Array<UpvsIdentityIdsInner>
  /**
   * URI identifikátor.
   * @type {string}
   * @memberof UpvsCorporateBody
   */
  uri?: string
  /**
   * Číslo eDesk schránky.
   * @type {string}
   * @memberof UpvsCorporateBody
   */
  en?: string
  /**
   * Typ:   - `natural_person` fyzická osoba,   - `legal_entity` právnická osoba,   - `technical_account` technický účet,   - `employee_of_public_administration` zamestnanec verejnej správy,   - `institution_of_public_administration` orgán verejnej moci.
   * @type {string}
   * @memberof UpvsCorporateBody
   */
  type?: UpvsCorporateBodyTypeEnum
  /**
   * Stav:   - `registered` registrovaný,   - `activated` aktivovaný,   - `verified` overený,   - `blocked` blokovaný,   - `deactivated` deaktivovaný.
   * @type {string}
   * @memberof UpvsCorporateBody
   */
  status?: UpvsCorporateBodyStatusEnum
  /**
   * Názov alebo meno.
   * @type {string}
   * @memberof UpvsCorporateBody
   */
  name?: string
  /**
   * Sufix.
   * @type {string}
   * @memberof UpvsCorporateBody
   */
  suffix?: string
  /**
   * Rôzne identifikátory.
   * @type {Array<UpvsIdentityVariousIdsInner>}
   * @memberof UpvsCorporateBody
   */
  various_ids?: Array<UpvsIdentityVariousIdsInner>
  /**
   *
   * @type {UpvsIdentityUpvs}
   * @memberof UpvsCorporateBody
   */
  upvs?: UpvsIdentityUpvs
  /**
   * Fyzické adresy.
   * @type {Array<UpvsIdentityAddressesInner>}
   * @memberof UpvsCorporateBody
   */
  addresses?: Array<UpvsIdentityAddressesInner>
  /**
   * E-mailové adresy.
   * @type {Array<UpvsIdentityEmailsInner>}
   * @memberof UpvsCorporateBody
   */
  emails?: Array<UpvsIdentityEmailsInner>
  /**
   * Telefónne čísla.
   * @type {Array<UpvsIdentityPhonesInner>}
   * @memberof UpvsCorporateBody
   */
  phones?: Array<UpvsIdentityPhonesInner>
}

export const UpvsCorporateBodyTypeEnum = {
  NaturalPerson: 'natural_person',
  LegalEntity: 'legal_entity',
  TechnicalAccount: 'technical_account',
  EmployeeOfPublicAdministration: 'employee_of_public_administration',
  InstitutionOfPublicAdministration: 'institution_of_public_administration',
} as const

export type UpvsCorporateBodyTypeEnum =
  (typeof UpvsCorporateBodyTypeEnum)[keyof typeof UpvsCorporateBodyTypeEnum]
export const UpvsCorporateBodyStatusEnum = {
  Registered: 'registered',
  Activated: 'activated',
  Verified: 'verified',
  Blocked: 'blocked',
  Deactivated: 'deactivated',
} as const

export type UpvsCorporateBodyStatusEnum =
  (typeof UpvsCorporateBodyStatusEnum)[keyof typeof UpvsCorporateBodyStatusEnum]

/**
 * Hodnota podľa číselníka.
 * @export
 * @interface UpvsEnumeration
 */
export interface UpvsEnumeration {
  /**
   * Identifikátor hodnoty.
   * @type {string}
   * @memberof UpvsEnumeration
   */
  id?: string
  /**
   * Názov hodnoty.
   * @type {string}
   * @memberof UpvsEnumeration
   */
  name?: string
  /**
   * Popis hodnoty.
   * @type {string}
   * @memberof UpvsEnumeration
   */
  description?: string
}
/**
 * ÚPVS identita.
 * @export
 * @interface UpvsIdentity
 */
export interface UpvsIdentity {
  /**
   * Sektorové identifikátory.
   * @type {Array<UpvsIdentityIdsInner>}
   * @memberof UpvsIdentity
   */
  ids?: Array<UpvsIdentityIdsInner>
  /**
   * URI identifikátor.
   * @type {string}
   * @memberof UpvsIdentity
   */
  uri?: string
  /**
   * Číslo eDesk schránky.
   * @type {string}
   * @memberof UpvsIdentity
   */
  en?: string
  /**
   * Typ:   - `natural_person` fyzická osoba,   - `legal_entity` právnická osoba,   - `technical_account` technický účet,   - `employee_of_public_administration` zamestnanec verejnej správy,   - `institution_of_public_administration` orgán verejnej moci.
   * @type {string}
   * @memberof UpvsIdentity
   */
  type?: UpvsIdentityTypeEnum
  /**
   * Stav:   - `registered` registrovaný,   - `activated` aktivovaný,   - `verified` overený,   - `blocked` blokovaný,   - `deactivated` deaktivovaný.
   * @type {string}
   * @memberof UpvsIdentity
   */
  status?: UpvsIdentityStatusEnum
  /**
   * Názov alebo meno.
   * @type {string}
   * @memberof UpvsIdentity
   */
  name?: string
  /**
   * Sufix.
   * @type {string}
   * @memberof UpvsIdentity
   */
  suffix?: string
  /**
   * Rôzne identifikátory.
   * @type {Array<UpvsIdentityVariousIdsInner>}
   * @memberof UpvsIdentity
   */
  various_ids?: Array<UpvsIdentityVariousIdsInner>
  /**
   *
   * @type {UpvsIdentityUpvs}
   * @memberof UpvsIdentity
   */
  upvs?: UpvsIdentityUpvs
  /**
   * Fyzické adresy.
   * @type {Array<UpvsIdentityAddressesInner>}
   * @memberof UpvsIdentity
   */
  addresses?: Array<UpvsIdentityAddressesInner>
  /**
   * E-mailové adresy.
   * @type {Array<UpvsIdentityEmailsInner>}
   * @memberof UpvsIdentity
   */
  emails?: Array<UpvsIdentityEmailsInner>
  /**
   * Telefónne čísla.
   * @type {Array<UpvsIdentityPhonesInner>}
   * @memberof UpvsIdentity
   */
  phones?: Array<UpvsIdentityPhonesInner>
}

export const UpvsIdentityTypeEnum = {
  NaturalPerson: 'natural_person',
  LegalEntity: 'legal_entity',
  TechnicalAccount: 'technical_account',
  EmployeeOfPublicAdministration: 'employee_of_public_administration',
  InstitutionOfPublicAdministration: 'institution_of_public_administration',
} as const

export type UpvsIdentityTypeEnum = (typeof UpvsIdentityTypeEnum)[keyof typeof UpvsIdentityTypeEnum]
export const UpvsIdentityStatusEnum = {
  Registered: 'registered',
  Activated: 'activated',
  Verified: 'verified',
  Blocked: 'blocked',
  Deactivated: 'deactivated',
} as const

export type UpvsIdentityStatusEnum =
  (typeof UpvsIdentityStatusEnum)[keyof typeof UpvsIdentityStatusEnum]

/**
 *
 * @export
 * @interface UpvsIdentityAddressesInner
 */
export interface UpvsIdentityAddressesInner {
  /**
   * Typ adresy:   - `resident` adresa trvalého pobytu alebo sídla,   - `contact` kontaktná adresa,   - `post_office_box` adresa poštovej schránky,   - `military` vojenská adresa,   - `undefined` nedefinovaná adresa.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  type?: UpvsIdentityAddressesInnerTypeEnum
  /**
   * Formátovaná adresa.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  inline?: string
  /**
   * Krajina podľa číselníka ŠÚSR 0086.
   * @type {UpvsEnumeration}
   * @memberof UpvsIdentityAddressesInner
   */
  country?: UpvsEnumeration
  /**
   * Kraj.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  region?: string
  /**
   * Okres podľa číselníka ŠÚSR 0024.
   * @type {UpvsEnumeration}
   * @memberof UpvsIdentityAddressesInner
   */
  district?: UpvsEnumeration
  /**
   * Obec podľa číselníka ŠÚSR 0025.
   * @type {UpvsEnumeration}
   * @memberof UpvsIdentityAddressesInner
   */
  municipality?: UpvsEnumeration
  /**
   * Časť obce.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  part?: string
  /**
   * Ulica.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  street?: string
  /**
   * Orientačné číslo.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  building_number?: string
  /**
   * Súpisné číslo.
   * @type {number}
   * @memberof UpvsIdentityAddressesInner
   */
  registration_number?: number
  /**
   * Časť budovy.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  unit?: string
  /**
   * Index budovy.
   * @type {number}
   * @memberof UpvsIdentityAddressesInner
   */
  building_index?: number
  /**
   *
   * @type {UpvsIdentityAddressesInnerDeliveryAddress}
   * @memberof UpvsIdentityAddressesInner
   */
  delivery_address?: UpvsIdentityAddressesInnerDeliveryAddress
  /**
   * Záznam v registri adries.
   * @type {string}
   * @memberof UpvsIdentityAddressesInner
   */
  ra_entry?: string
  /**
   * Indikátor či ide o špecifikovanú adresu, ktorá bude nastavená.
   * @type {boolean}
   * @memberof UpvsIdentityAddressesInner
   */
  specified?: boolean
}

export const UpvsIdentityAddressesInnerTypeEnum = {
  Resident: 'resident',
  Contact: 'contact',
  PostOfficeBox: 'post_office_box',
  Military: 'military',
  Undefined: 'undefined',
} as const

export type UpvsIdentityAddressesInnerTypeEnum =
  (typeof UpvsIdentityAddressesInnerTypeEnum)[keyof typeof UpvsIdentityAddressesInnerTypeEnum]

/**
 * Doručovacia adresa.
 * @export
 * @interface UpvsIdentityAddressesInnerDeliveryAddress
 */
export interface UpvsIdentityAddressesInnerDeliveryAddress {
  /**
   * Poštové smerové číslo.
   * @type {string}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddress
   */
  postal_code?: string
  /**
   * Poštová schránka.
   * @type {string}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddress
   */
  post_office_box?: string
  /**
   *
   * @type {UpvsIdentityAddressesInnerDeliveryAddressRecipient}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddress
   */
  recipient?: UpvsIdentityAddressesInnerDeliveryAddressRecipient
}
/**
 * Príjemca.
 * @export
 * @interface UpvsIdentityAddressesInnerDeliveryAddressRecipient
 */
export interface UpvsIdentityAddressesInnerDeliveryAddressRecipient {
  /**
   *
   * @type {UpvsIdentityAddressesInnerDeliveryAddressRecipientCorporateBody}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddressRecipient
   */
  corporate_body?: UpvsIdentityAddressesInnerDeliveryAddressRecipientCorporateBody
  /**
   *
   * @type {UpvsIdentityAddressesInnerDeliveryAddressRecipientNaturalPerson}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddressRecipient
   */
  natural_person?: UpvsIdentityAddressesInnerDeliveryAddressRecipientNaturalPerson
  /**
   * Poznámka.
   * @type {string}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddressRecipient
   */
  note?: string
}
/**
 * Právnická osoba.
 * @export
 * @interface UpvsIdentityAddressesInnerDeliveryAddressRecipientCorporateBody
 */
export interface UpvsIdentityAddressesInnerDeliveryAddressRecipientCorporateBody {
  /**
   * Organizačná jednotka.
   * @type {string}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddressRecipientCorporateBody
   */
  organization_unit?: string
  /**
   * Názov.
   * @type {string}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddressRecipientCorporateBody
   */
  name?: string
}
/**
 * Fyzická osoba.
 * @export
 * @interface UpvsIdentityAddressesInnerDeliveryAddressRecipientNaturalPerson
 */
export interface UpvsIdentityAddressesInnerDeliveryAddressRecipientNaturalPerson {
  /**
   * Meno.
   * @type {string}
   * @memberof UpvsIdentityAddressesInnerDeliveryAddressRecipientNaturalPerson
   */
  name?: string
}
/**
 *
 * @export
 * @interface UpvsIdentityEmailsInner
 */
export interface UpvsIdentityEmailsInner {
  /**
   * Formátovaná adresa.
   * @type {string}
   * @memberof UpvsIdentityEmailsInner
   */
  address?: string
  /**
   * DSig KeyInfo.
   * @type {string}
   * @memberof UpvsIdentityEmailsInner
   */
  dsig_key_info?: string
}
/**
 *
 * @export
 * @interface UpvsIdentityIdsInner
 */
export interface UpvsIdentityIdsInner {
  /**
   * Typ identifikátora.
   * @type {string}
   * @memberof UpvsIdentityIdsInner
   */
  type?: string
  /**
   * Hodnota identifikátora.
   * @type {string}
   * @memberof UpvsIdentityIdsInner
   */
  value?: string
}
/**
 *
 * @export
 * @interface UpvsIdentityPhonesInner
 */
export interface UpvsIdentityPhonesInner {
  /**
   * Typ telefónu podľa číselníka ŠÚSR 4005.
   * @type {UpvsEnumeration}
   * @memberof UpvsIdentityPhonesInner
   */
  type?: UpvsEnumeration
  /**
   * Formátované číslo.
   * @type {string}
   * @memberof UpvsIdentityPhonesInner
   */
  number?: string
  /**
   * Medzinárodné smerové číslo.
   * @type {string}
   * @memberof UpvsIdentityPhonesInner
   */
  international_country_code?: string
  /**
   * Národné číslo.
   * @type {string}
   * @memberof UpvsIdentityPhonesInner
   */
  national_number?: string
  /**
   * Smerové číslo.
   * @type {string}
   * @memberof UpvsIdentityPhonesInner
   */
  area_city_code?: string
  /**
   * Účastnícke číslo.
   * @type {string}
   * @memberof UpvsIdentityPhonesInner
   */
  subscriber_number?: string
  /**
   * Sublinka.
   * @type {string}
   * @memberof UpvsIdentityPhonesInner
   */
  extension?: string
}
/**
 * ÚPVS atribúty.
 * @export
 * @interface UpvsIdentityUpvs
 */
export interface UpvsIdentityUpvs {
  /**
   * Číslo eDesk schránky.
   * @type {string}
   * @memberof UpvsIdentityUpvs
   */
  edesk_number?: string
  /**
   * Stav eDesk schránky:   - `nonexistent` neexistujúca schránka,   - `created` vytvorená schránka (okrem prijímania správ),   - `active` aktivovaná schránka (okrem prijímania doručeniek),   - `deliverable` aktivovaná schránka na doručovanie (vrátane prijímania doručeniek),   - `disabled` deaktivovaná schránka (okrem prijímania doručeniek),   - `deleted` zrušená schránka.
   * @type {string}
   * @memberof UpvsIdentityUpvs
   */
  edesk_status?: UpvsIdentityUpvsEdeskStatusEnum
  /**
   * URI adresa vzdialenej eDesk schránky.
   * @type {string}
   * @memberof UpvsIdentityUpvs
   */
  edesk_remote_uri?: string | null
  /**
   * Indikátor či do eDesk schránky budú doručované CUET správy.
   * @type {boolean}
   * @memberof UpvsIdentityUpvs
   */
  edesk_cuet_delivery_enabled?: boolean
  /**
   * Indikátor či je doručovanie do eDesk schránky obmedzené.
   * @type {boolean}
   * @memberof UpvsIdentityUpvs
   */
  edesk_delivery_limited?: boolean
  /**
   * Preferovaný kanál prijímania správ.
   * @type {string}
   * @memberof UpvsIdentityUpvs
   */
  enotify_preferred_channel?: UpvsIdentityUpvsEnotifyPreferredChannelEnum
  /**
   * Preferovaný kalendár odosielania správ.
   * @type {string}
   * @memberof UpvsIdentityUpvs
   */
  enotify_preferred_calendar?: string
  /**
   * Indikátor či je odosielanie núdzových správ povolené.
   * @type {boolean}
   * @memberof UpvsIdentityUpvs
   */
  enotify_emergency_allowed?: boolean
  /**
   * Indikátor či je odosielanie e-mailov povolené.
   * @type {boolean}
   * @memberof UpvsIdentityUpvs
   */
  enotify_email_allowed?: boolean
  /**
   * Indikátor či je odosielanie SMS povolené.
   * @type {boolean}
   * @memberof UpvsIdentityUpvs
   */
  enotify_sms_allowed?: boolean
  /**
   * Preferovaný jazyk.
   * @type {string}
   * @memberof UpvsIdentityUpvs
   */
  preferred_language?: string
  /**
   * Identifikátor v pôvodnom RE IAM.
   * @type {string}
   * @memberof UpvsIdentityUpvs
   */
  re_iam_identity_id?: string
}

export const UpvsIdentityUpvsEdeskStatusEnum = {
  Nonexistent: 'nonexistent',
  Created: 'created',
  Active: 'active',
  Deliverable: 'deliverable',
  Disabled: 'disabled',
  Deleted: 'deleted',
} as const

export type UpvsIdentityUpvsEdeskStatusEnum =
  (typeof UpvsIdentityUpvsEdeskStatusEnum)[keyof typeof UpvsIdentityUpvsEdeskStatusEnum]
export const UpvsIdentityUpvsEnotifyPreferredChannelEnum = {
  Email: 'email',
  Sms: 'sms',
} as const

export type UpvsIdentityUpvsEnotifyPreferredChannelEnum =
  (typeof UpvsIdentityUpvsEnotifyPreferredChannelEnum)[keyof typeof UpvsIdentityUpvsEnotifyPreferredChannelEnum]

/**
 *
 * @export
 * @interface UpvsIdentityVariousIdsInner
 */
export interface UpvsIdentityVariousIdsInner {
  /**
   * Typ identifikátora.
   * @type {UpvsEnumeration}
   * @memberof UpvsIdentityVariousIdsInner
   */
  type?: UpvsEnumeration
  /**
   * Hodnota identifikátora.
   * @type {string}
   * @memberof UpvsIdentityVariousIdsInner
   */
  value?: string
  /**
   * Indikátor či ide o špecifikovaný identifikátor, ktorý bude nastavený.
   * @type {boolean}
   * @memberof UpvsIdentityVariousIdsInner
   */
  specified?: boolean
}
/**
 * ÚPVS identita fyzickej osoby.
 * @export
 * @interface UpvsNaturalPerson
 */
export interface UpvsNaturalPerson {
  /**
   * Fyzická osoba.
   * @type {object}
   * @memberof UpvsNaturalPerson
   */
  natural_person?: object
  /**
   * Sektorové identifikátory.
   * @type {Array<UpvsIdentityIdsInner>}
   * @memberof UpvsNaturalPerson
   */
  ids?: Array<UpvsIdentityIdsInner>
  /**
   * URI identifikátor.
   * @type {string}
   * @memberof UpvsNaturalPerson
   */
  uri?: string
  /**
   * Číslo eDesk schránky.
   * @type {string}
   * @memberof UpvsNaturalPerson
   */
  en?: string
  /**
   * Typ:   - `natural_person` fyzická osoba,   - `legal_entity` právnická osoba,   - `technical_account` technický účet,   - `employee_of_public_administration` zamestnanec verejnej správy,   - `institution_of_public_administration` orgán verejnej moci.
   * @type {string}
   * @memberof UpvsNaturalPerson
   */
  type?: UpvsNaturalPersonTypeEnum
  /**
   * Stav:   - `registered` registrovaný,   - `activated` aktivovaný,   - `verified` overený,   - `blocked` blokovaný,   - `deactivated` deaktivovaný.
   * @type {string}
   * @memberof UpvsNaturalPerson
   */
  status?: UpvsNaturalPersonStatusEnum
  /**
   * Názov alebo meno.
   * @type {string}
   * @memberof UpvsNaturalPerson
   */
  name?: string
  /**
   * Sufix.
   * @type {string}
   * @memberof UpvsNaturalPerson
   */
  suffix?: string
  /**
   * Rôzne identifikátory.
   * @type {Array<UpvsIdentityVariousIdsInner>}
   * @memberof UpvsNaturalPerson
   */
  various_ids?: Array<UpvsIdentityVariousIdsInner>
  /**
   *
   * @type {UpvsIdentityUpvs}
   * @memberof UpvsNaturalPerson
   */
  upvs?: UpvsIdentityUpvs
  /**
   * Fyzické adresy.
   * @type {Array<UpvsIdentityAddressesInner>}
   * @memberof UpvsNaturalPerson
   */
  addresses?: Array<UpvsIdentityAddressesInner>
  /**
   * E-mailové adresy.
   * @type {Array<UpvsIdentityEmailsInner>}
   * @memberof UpvsNaturalPerson
   */
  emails?: Array<UpvsIdentityEmailsInner>
  /**
   * Telefónne čísla.
   * @type {Array<UpvsIdentityPhonesInner>}
   * @memberof UpvsNaturalPerson
   */
  phones?: Array<UpvsIdentityPhonesInner>
}

export const UpvsNaturalPersonTypeEnum = {
  NaturalPerson: 'natural_person',
  LegalEntity: 'legal_entity',
  TechnicalAccount: 'technical_account',
  EmployeeOfPublicAdministration: 'employee_of_public_administration',
  InstitutionOfPublicAdministration: 'institution_of_public_administration',
} as const

export type UpvsNaturalPersonTypeEnum =
  (typeof UpvsNaturalPersonTypeEnum)[keyof typeof UpvsNaturalPersonTypeEnum]
export const UpvsNaturalPersonStatusEnum = {
  Registered: 'registered',
  Activated: 'activated',
  Verified: 'verified',
  Blocked: 'blocked',
  Deactivated: 'deactivated',
} as const

export type UpvsNaturalPersonStatusEnum =
  (typeof UpvsNaturalPersonStatusEnum)[keyof typeof UpvsNaturalPersonStatusEnum]

/**
 * Afix fyzickej osoby.
 * @export
 * @interface UpvsNaturalPersonAffix
 */
export interface UpvsNaturalPersonAffix {
  /**
   * Typ afixu:   - `aristocratic` aristokratický titul,   - `generation` generačný titul,   - `military` vojenský titul,   - `qualification` kvalifikačný titul.
   * @type {string}
   * @memberof UpvsNaturalPersonAffix
   */
  type?: UpvsNaturalPersonAffixTypeEnum
  /**
   * Afix.
   * @type {string}
   * @memberof UpvsNaturalPersonAffix
   */
  value?: string
}

export const UpvsNaturalPersonAffixTypeEnum = {
  Aristocratic: 'aristocratic',
  Generation: 'generation',
  Military: 'military',
  Qualification: 'qualification',
} as const

export type UpvsNaturalPersonAffixTypeEnum =
  (typeof UpvsNaturalPersonAffixTypeEnum)[keyof typeof UpvsNaturalPersonAffixTypeEnum]

/**
 * Priezvisko fyzickej osoby.
 * @export
 * @interface UpvsNaturalPersonFamilyName
 */
export interface UpvsNaturalPersonFamilyName {
  /**
   * Indikátor či ide o hlavné priezvisko.
   * @type {boolean}
   * @memberof UpvsNaturalPersonFamilyName
   */
  primary?: boolean
  /**
   * Prefix priezviska.
   * @type {string}
   * @memberof UpvsNaturalPersonFamilyName
   */
  prefix?: string
  /**
   * Priezvisko.
   * @type {string}
   * @memberof UpvsNaturalPersonFamilyName
   */
  value?: string
}
/**
 * Existenčná udalosť fyzickej osoby.
 * @export
 * @interface UpvsNaturalPersonVitalEvent
 */
export interface UpvsNaturalPersonVitalEvent {
  /**
   * Dátum udalosti.
   * @type {string}
   * @memberof UpvsNaturalPersonVitalEvent
   */
  date?: string
  /**
   * Krajina udalosti podľa číselníka ŠÚSR 0086.
   * @type {UpvsEnumeration}
   * @memberof UpvsNaturalPersonVitalEvent
   */
  country?: UpvsEnumeration
  /**
   * Okres udalosti podľa číselníka ŠÚSR 0024.
   * @type {UpvsEnumeration}
   * @memberof UpvsNaturalPersonVitalEvent
   */
  district?: UpvsEnumeration
  /**
   * Obec udalosti podľa číselníka ŠÚSR 0025.
   * @type {UpvsEnumeration}
   * @memberof UpvsNaturalPersonVitalEvent
   */
  municipality?: UpvsEnumeration
  /**
   * Časť obce udalosti.
   * @type {string}
   * @memberof UpvsNaturalPersonVitalEvent
   */
  part?: string
}

/**
 * CentrlnaRadnTabuaDostupnLenPreOVMApi - axios parameter creator
 * @export
 */
export const CentrlnaRadnTabuaDostupnLenPreOVMApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Odošle požiadavku na doručenie dokumentu zverejnením. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_DELIVERY`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Doručí dokument zverejnením
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
     * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
     * @param {string} name Názov dokumentu.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
     * @param {string} [_abstract] Abstrakt dokumentu.
     * @param {string} [registryMark] Registratúrna značka dokumentu.
     * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
     * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
     * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCuetDocumentsDeliverByPublishingPost: async (
      requestId: string,
      publisherUri: string,
      authorUri: string,
      name: string,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      originalId?: string,
      _abstract?: string,
      registryMark?: string,
      registryNumber?: string,
      publishedFrom?: string,
      publishedDays?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiCuetDocumentsDeliverByPublishingPost', 'requestId', requestId)
      // verify required parameter 'publisherUri' is not null or undefined
      assertParamExists('apiCuetDocumentsDeliverByPublishingPost', 'publisherUri', publisherUri)
      // verify required parameter 'authorUri' is not null or undefined
      assertParamExists('apiCuetDocumentsDeliverByPublishingPost', 'authorUri', authorUri)
      // verify required parameter 'name' is not null or undefined
      assertParamExists('apiCuetDocumentsDeliverByPublishingPost', 'name', name)
      // verify required parameter 'apiMdurzRecordsPostRequest' is not null or undefined
      assertParamExists(
        'apiCuetDocumentsDeliverByPublishingPost',
        'apiMdurzRecordsPostRequest',
        apiMdurzRecordsPostRequest,
      )
      const localVarPath = `/api/cuet/documents/deliver_by_publishing`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (publisherUri !== undefined) {
        localVarQueryParameter['publisher_uri'] = publisherUri
      }

      if (authorUri !== undefined) {
        localVarQueryParameter['author_uri'] = authorUri
      }

      if (originalId !== undefined) {
        localVarQueryParameter['original_id'] = originalId
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (_abstract !== undefined) {
        localVarQueryParameter['abstract'] = _abstract
      }

      if (registryMark !== undefined) {
        localVarQueryParameter['registry_mark'] = registryMark
      }

      if (registryNumber !== undefined) {
        localVarQueryParameter['registry_number'] = registryNumber
      }

      if (publishedFrom !== undefined) {
        localVarQueryParameter['published_from'] = publishedFrom
      }

      if (publishedDays !== undefined) {
        localVarQueryParameter['published_days'] = publishedDays
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle požiadavku na zmenu doby zverejnenia dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_REVOCATION`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Zmení dobu zverejnenia dokumentu
     * @param {string} id Identifikátor dokumentu.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} revocationReason Dôvod odvolania zverejňovania.
     * @param {string} revokedOn Dátum ukončenia zverejňovania.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCuetDocumentsIdPatch: async (
      id: string,
      requestId: string,
      revocationReason: string,
      revokedOn: string,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiCuetDocumentsIdPatch', 'id', id)
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiCuetDocumentsIdPatch', 'requestId', requestId)
      // verify required parameter 'revocationReason' is not null or undefined
      assertParamExists('apiCuetDocumentsIdPatch', 'revocationReason', revocationReason)
      // verify required parameter 'revokedOn' is not null or undefined
      assertParamExists('apiCuetDocumentsIdPatch', 'revokedOn', revokedOn)
      // verify required parameter 'apiMdurzRecordsIdDeleteRequest' is not null or undefined
      assertParamExists(
        'apiCuetDocumentsIdPatch',
        'apiMdurzRecordsIdDeleteRequest',
        apiMdurzRecordsIdDeleteRequest,
      )
      const localVarPath = `/api/cuet/documents/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (revocationReason !== undefined) {
        localVarQueryParameter['revocation_reason'] = revocationReason
      }

      if (revokedOn !== undefined) {
        localVarQueryParameter['revoked_on'] =
          (revokedOn as any) instanceof Date
            ? (revokedOn as any).toISOString().substring(0, 10)
            : revokedOn
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsIdDeleteRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle požiadavku na zverejnenie dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_ENTERING`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Zverejnení dokument
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
     * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
     * @param {string} name Názov dokumentu.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
     * @param {string} [_abstract] Abstrakt dokumentu.
     * @param {string} [registryMark] Registratúrna značka dokumentu.
     * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
     * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
     * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCuetDocumentsPublishDocumentPost: async (
      requestId: string,
      publisherUri: string,
      authorUri: string,
      name: string,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      originalId?: string,
      _abstract?: string,
      registryMark?: string,
      registryNumber?: string,
      publishedFrom?: string,
      publishedDays?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiCuetDocumentsPublishDocumentPost', 'requestId', requestId)
      // verify required parameter 'publisherUri' is not null or undefined
      assertParamExists('apiCuetDocumentsPublishDocumentPost', 'publisherUri', publisherUri)
      // verify required parameter 'authorUri' is not null or undefined
      assertParamExists('apiCuetDocumentsPublishDocumentPost', 'authorUri', authorUri)
      // verify required parameter 'name' is not null or undefined
      assertParamExists('apiCuetDocumentsPublishDocumentPost', 'name', name)
      // verify required parameter 'apiMdurzRecordsPostRequest' is not null or undefined
      assertParamExists(
        'apiCuetDocumentsPublishDocumentPost',
        'apiMdurzRecordsPostRequest',
        apiMdurzRecordsPostRequest,
      )
      const localVarPath = `/api/cuet/documents/publish_document`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (publisherUri !== undefined) {
        localVarQueryParameter['publisher_uri'] = publisherUri
      }

      if (authorUri !== undefined) {
        localVarQueryParameter['author_uri'] = authorUri
      }

      if (originalId !== undefined) {
        localVarQueryParameter['original_id'] = originalId
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (_abstract !== undefined) {
        localVarQueryParameter['abstract'] = _abstract
      }

      if (registryMark !== undefined) {
        localVarQueryParameter['registry_mark'] = registryMark
      }

      if (registryNumber !== undefined) {
        localVarQueryParameter['registry_number'] = registryNumber
      }

      if (publishedFrom !== undefined) {
        localVarQueryParameter['published_from'] = publishedFrom
      }

      if (publishedDays !== undefined) {
        localVarQueryParameter['published_days'] = publishedDays
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CentrlnaRadnTabuaDostupnLenPreOVMApi - functional programming interface
 * @export
 */
export const CentrlnaRadnTabuaDostupnLenPreOVMApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CentrlnaRadnTabuaDostupnLenPreOVMApiAxiosParamCreator(configuration)
  return {
    /**
     * Odošle požiadavku na doručenie dokumentu zverejnením. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_DELIVERY`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Doručí dokument zverejnením
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
     * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
     * @param {string} name Názov dokumentu.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
     * @param {string} [_abstract] Abstrakt dokumentu.
     * @param {string} [registryMark] Registratúrna značka dokumentu.
     * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
     * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
     * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCuetDocumentsDeliverByPublishingPost(
      requestId: string,
      publisherUri: string,
      authorUri: string,
      name: string,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      originalId?: string,
      _abstract?: string,
      registryMark?: string,
      registryNumber?: string,
      publishedFrom?: string,
      publishedDays?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiCuetDocumentsDeliverByPublishingPost(
          requestId,
          publisherUri,
          authorUri,
          name,
          apiMdurzRecordsPostRequest,
          originalId,
          _abstract,
          registryMark,
          registryNumber,
          publishedFrom,
          publishedDays,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'CentrlnaRadnTabuaDostupnLenPreOVMApi.apiCuetDocumentsDeliverByPublishingPost'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle požiadavku na zmenu doby zverejnenia dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_REVOCATION`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Zmení dobu zverejnenia dokumentu
     * @param {string} id Identifikátor dokumentu.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} revocationReason Dôvod odvolania zverejňovania.
     * @param {string} revokedOn Dátum ukončenia zverejňovania.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCuetDocumentsIdPatch(
      id: string,
      requestId: string,
      revocationReason: string,
      revokedOn: string,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCuetDocumentsIdPatch(
        id,
        requestId,
        revocationReason,
        revokedOn,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CentrlnaRadnTabuaDostupnLenPreOVMApi.apiCuetDocumentsIdPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle požiadavku na zverejnenie dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_ENTERING`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Zverejnení dokument
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
     * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
     * @param {string} name Názov dokumentu.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
     * @param {string} [_abstract] Abstrakt dokumentu.
     * @param {string} [registryMark] Registratúrna značka dokumentu.
     * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
     * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
     * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCuetDocumentsPublishDocumentPost(
      requestId: string,
      publisherUri: string,
      authorUri: string,
      name: string,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      originalId?: string,
      _abstract?: string,
      registryMark?: string,
      registryNumber?: string,
      publishedFrom?: string,
      publishedDays?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCuetDocumentsPublishDocumentPost(
        requestId,
        publisherUri,
        authorUri,
        name,
        apiMdurzRecordsPostRequest,
        originalId,
        _abstract,
        registryMark,
        registryNumber,
        publishedFrom,
        publishedDays,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'CentrlnaRadnTabuaDostupnLenPreOVMApi.apiCuetDocumentsPublishDocumentPost'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * CentrlnaRadnTabuaDostupnLenPreOVMApi - factory interface
 * @export
 */
export const CentrlnaRadnTabuaDostupnLenPreOVMApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CentrlnaRadnTabuaDostupnLenPreOVMApiFp(configuration)
  return {
    /**
     * Odošle požiadavku na doručenie dokumentu zverejnením. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_DELIVERY`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Doručí dokument zverejnením
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
     * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
     * @param {string} name Názov dokumentu.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
     * @param {string} [_abstract] Abstrakt dokumentu.
     * @param {string} [registryMark] Registratúrna značka dokumentu.
     * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
     * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
     * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCuetDocumentsDeliverByPublishingPost(
      requestId: string,
      publisherUri: string,
      authorUri: string,
      name: string,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      originalId?: string,
      _abstract?: string,
      registryMark?: string,
      registryNumber?: string,
      publishedFrom?: string,
      publishedDays?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiCuetDocumentsDeliverByPublishingPost(
          requestId,
          publisherUri,
          authorUri,
          name,
          apiMdurzRecordsPostRequest,
          originalId,
          _abstract,
          registryMark,
          registryNumber,
          publishedFrom,
          publishedDays,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle požiadavku na zmenu doby zverejnenia dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_REVOCATION`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Zmení dobu zverejnenia dokumentu
     * @param {string} id Identifikátor dokumentu.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} revocationReason Dôvod odvolania zverejňovania.
     * @param {string} revokedOn Dátum ukončenia zverejňovania.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCuetDocumentsIdPatch(
      id: string,
      requestId: string,
      revocationReason: string,
      revokedOn: string,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiCuetDocumentsIdPatch(
          id,
          requestId,
          revocationReason,
          revokedOn,
          apiMdurzRecordsIdDeleteRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle požiadavku na zverejnenie dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_ENTERING`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
     * @summary Zverejnení dokument
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
     * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
     * @param {string} name Názov dokumentu.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
     * @param {string} [_abstract] Abstrakt dokumentu.
     * @param {string} [registryMark] Registratúrna značka dokumentu.
     * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
     * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
     * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCuetDocumentsPublishDocumentPost(
      requestId: string,
      publisherUri: string,
      authorUri: string,
      name: string,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      originalId?: string,
      _abstract?: string,
      registryMark?: string,
      registryNumber?: string,
      publishedFrom?: string,
      publishedDays?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiCuetDocumentsPublishDocumentPost(
          requestId,
          publisherUri,
          authorUri,
          name,
          apiMdurzRecordsPostRequest,
          originalId,
          _abstract,
          registryMark,
          registryNumber,
          publishedFrom,
          publishedDays,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CentrlnaRadnTabuaDostupnLenPreOVMApi - object-oriented interface
 * @export
 * @class CentrlnaRadnTabuaDostupnLenPreOVMApi
 * @extends {BaseAPI}
 */
export class CentrlnaRadnTabuaDostupnLenPreOVMApi extends BaseAPI {
  /**
   * Odošle požiadavku na doručenie dokumentu zverejnením. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_DELIVERY`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
   * @summary Doručí dokument zverejnením
   * @param {string} requestId Identifikátor požiadavky.
   * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
   * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
   * @param {string} name Názov dokumentu.
   * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
   * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
   * @param {string} [_abstract] Abstrakt dokumentu.
   * @param {string} [registryMark] Registratúrna značka dokumentu.
   * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
   * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
   * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CentrlnaRadnTabuaDostupnLenPreOVMApi
   */
  public apiCuetDocumentsDeliverByPublishingPost(
    requestId: string,
    publisherUri: string,
    authorUri: string,
    name: string,
    apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
    originalId?: string,
    _abstract?: string,
    registryMark?: string,
    registryNumber?: string,
    publishedFrom?: string,
    publishedDays?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return CentrlnaRadnTabuaDostupnLenPreOVMApiFp(this.configuration)
      .apiCuetDocumentsDeliverByPublishingPost(
        requestId,
        publisherUri,
        authorUri,
        name,
        apiMdurzRecordsPostRequest,
        originalId,
        _abstract,
        registryMark,
        registryNumber,
        publishedFrom,
        publishedDays,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle požiadavku na zmenu doby zverejnenia dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_REVOCATION`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
   * @summary Zmení dobu zverejnenia dokumentu
   * @param {string} id Identifikátor dokumentu.
   * @param {string} requestId Identifikátor požiadavky.
   * @param {string} revocationReason Dôvod odvolania zverejňovania.
   * @param {string} revokedOn Dátum ukončenia zverejňovania.
   * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CentrlnaRadnTabuaDostupnLenPreOVMApi
   */
  public apiCuetDocumentsIdPatch(
    id: string,
    requestId: string,
    revocationReason: string,
    revokedOn: string,
    apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return CentrlnaRadnTabuaDostupnLenPreOVMApiFp(this.configuration)
      .apiCuetDocumentsIdPatch(
        id,
        requestId,
        revocationReason,
        revokedOn,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle požiadavku na zverejnenie dokumentu. Do schránky príde odpoveď s SKTalk triedou `CUET_NOTIFY_ENTERING`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.  Pozor, volanie je dostupné len pre OVM.
   * @summary Zverejnení dokument
   * @param {string} requestId Identifikátor požiadavky.
   * @param {string} publisherUri Identifikátor inštitúcie, ktorá je zverejňovateľom dokumentu.
   * @param {string} authorUri Identifikátor identity, ktorá je autorom dokumentu.
   * @param {string} name Názov dokumentu.
   * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
   * @param {string} [originalId] Identifikátor dokumentu, ktorý je pridelený autorom.
   * @param {string} [_abstract] Abstrakt dokumentu.
   * @param {string} [registryMark] Registratúrna značka dokumentu.
   * @param {string} [registryNumber] Číslo registratúrneho záznamu dokumentu.
   * @param {string} [publishedFrom] Začiatok zverejnenia dokumentu.
   * @param {string} [publishedDays] Počet dní počas ktorých má byť dokument zverejnený.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CentrlnaRadnTabuaDostupnLenPreOVMApi
   */
  public apiCuetDocumentsPublishDocumentPost(
    requestId: string,
    publisherUri: string,
    authorUri: string,
    name: string,
    apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
    originalId?: string,
    _abstract?: string,
    registryMark?: string,
    registryNumber?: string,
    publishedFrom?: string,
    publishedDays?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return CentrlnaRadnTabuaDostupnLenPreOVMApiFp(this.configuration)
      .apiCuetDocumentsPublishDocumentPost(
        requestId,
        publisherUri,
        authorUri,
        name,
        apiMdurzRecordsPostRequest,
        originalId,
        _abstract,
        registryMark,
        registryNumber,
        publishedFrom,
        publishedDays,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DlhodobLoiskoApi - axios parameter creator
 * @export
 */
export const DlhodobLoiskoApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Odošle požiadavku na vyradenie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_CANCEL_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Vyradí záznam z úložiska
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdDeleteDestinationEnum} destination Cieľ poskytnutia záznamu.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdDelete: async (
      id: string,
      requestId: string,
      destination: ApiMdurzRecordsIdDeleteDestinationEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiMdurzRecordsIdDelete', 'id', id)
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiMdurzRecordsIdDelete', 'requestId', requestId)
      // verify required parameter 'destination' is not null or undefined
      assertParamExists('apiMdurzRecordsIdDelete', 'destination', destination)
      // verify required parameter 'apiMdurzRecordsIdDeleteRequest' is not null or undefined
      assertParamExists(
        'apiMdurzRecordsIdDelete',
        'apiMdurzRecordsIdDeleteRequest',
        apiMdurzRecordsIdDeleteRequest,
      )
      const localVarPath = `/api/mdurz/records/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsIdDeleteRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle požiadavku na získanie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_DISSEMINATE_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Získa záznam z úložiska
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdDisseminatePostDestinationEnum} destination Cieľ poskytnutia záznamu.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdDisseminatePost: async (
      id: string,
      requestId: string,
      destination: ApiMdurzRecordsIdDisseminatePostDestinationEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiMdurzRecordsIdDisseminatePost', 'id', id)
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiMdurzRecordsIdDisseminatePost', 'requestId', requestId)
      // verify required parameter 'destination' is not null or undefined
      assertParamExists('apiMdurzRecordsIdDisseminatePost', 'destination', destination)
      // verify required parameter 'apiMdurzRecordsIdDeleteRequest' is not null or undefined
      assertParamExists(
        'apiMdurzRecordsIdDisseminatePost',
        'apiMdurzRecordsIdDeleteRequest',
        apiMdurzRecordsIdDeleteRequest,
      )
      const localVarPath = `/api/mdurz/records/{id}/disseminate`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsIdDeleteRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle požiadavku na predĺženie doby uchovania záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_EXTEND_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  MDURZ zasiela notifikačné správy o blížiacej sa končicej lehote s SKTalk triedou `MDURZ_EXPIRATION_WARNING_04` a notifikačné správy o expirovanom zázname s SKTalk triedou `MDURZ_EXPIRATION_NOTIFICATION_04`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Predĺži dobu uchovania záznamu v úložisku
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; predĺženie o 1 rok,   - &#x60;R2&#x60; predĺženie o 2 roky,   - &#x60;R5&#x60; predĺženie o 5 rokov.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdExtendPatch: async (
      id: string,
      requestId: string,
      retentionPeriod: ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiMdurzRecordsIdExtendPatch', 'id', id)
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiMdurzRecordsIdExtendPatch', 'requestId', requestId)
      // verify required parameter 'retentionPeriod' is not null or undefined
      assertParamExists('apiMdurzRecordsIdExtendPatch', 'retentionPeriod', retentionPeriod)
      // verify required parameter 'apiMdurzRecordsIdDeleteRequest' is not null or undefined
      assertParamExists(
        'apiMdurzRecordsIdExtendPatch',
        'apiMdurzRecordsIdDeleteRequest',
        apiMdurzRecordsIdDeleteRequest,
      )
      const localVarPath = `/api/mdurz/records/{id}/extend`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (retentionPeriod !== undefined) {
        localVarQueryParameter['retention_period'] = retentionPeriod
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsIdDeleteRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle požiadavku na zmenu popisných údajov záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_SET_METADATA_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Zmení popisné údaje záznamu v úložisku
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} customId Nová značka záznamu.
     * @param {string} title Nový názov záznamu.
     * @param {string} description Nový popis záznamu.
     * @param {ApiMdurzRecordsIdPatchAccessEnum} access Nový indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdPatch: async (
      id: string,
      requestId: string,
      customId: string,
      title: string,
      description: string,
      access: ApiMdurzRecordsIdPatchAccessEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiMdurzRecordsIdPatch', 'id', id)
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiMdurzRecordsIdPatch', 'requestId', requestId)
      // verify required parameter 'customId' is not null or undefined
      assertParamExists('apiMdurzRecordsIdPatch', 'customId', customId)
      // verify required parameter 'title' is not null or undefined
      assertParamExists('apiMdurzRecordsIdPatch', 'title', title)
      // verify required parameter 'description' is not null or undefined
      assertParamExists('apiMdurzRecordsIdPatch', 'description', description)
      // verify required parameter 'access' is not null or undefined
      assertParamExists('apiMdurzRecordsIdPatch', 'access', access)
      // verify required parameter 'apiMdurzRecordsIdDeleteRequest' is not null or undefined
      assertParamExists(
        'apiMdurzRecordsIdPatch',
        'apiMdurzRecordsIdDeleteRequest',
        apiMdurzRecordsIdDeleteRequest,
      )
      const localVarPath = `/api/mdurz/records/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (customId !== undefined) {
        localVarQueryParameter['custom_id'] = customId
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (description !== undefined) {
        localVarQueryParameter['description'] = description
      }

      if (access !== undefined) {
        localVarQueryParameter['access'] = access
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsIdDeleteRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle požiadavku na vloženie nového záznamu do úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_INGEST_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Vloží nový záznam do úložiska
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} customId Značka záznamu.
     * @param {string} title Názov záznamu.
     * @param {string} description Popis záznamu.
     * @param {ApiMdurzRecordsPostAccessEnum} access Indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
     * @param {ApiMdurzRecordsPostRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; uchovanie na 1 rok,   - &#x60;R2&#x60; uchovanie na 2 roky,   - &#x60;R5&#x60; uchovanie na 5 rokov.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsPost: async (
      requestId: string,
      customId: string,
      title: string,
      description: string,
      access: ApiMdurzRecordsPostAccessEnum,
      retentionPeriod: ApiMdurzRecordsPostRetentionPeriodEnum,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestId' is not null or undefined
      assertParamExists('apiMdurzRecordsPost', 'requestId', requestId)
      // verify required parameter 'customId' is not null or undefined
      assertParamExists('apiMdurzRecordsPost', 'customId', customId)
      // verify required parameter 'title' is not null or undefined
      assertParamExists('apiMdurzRecordsPost', 'title', title)
      // verify required parameter 'description' is not null or undefined
      assertParamExists('apiMdurzRecordsPost', 'description', description)
      // verify required parameter 'access' is not null or undefined
      assertParamExists('apiMdurzRecordsPost', 'access', access)
      // verify required parameter 'retentionPeriod' is not null or undefined
      assertParamExists('apiMdurzRecordsPost', 'retentionPeriod', retentionPeriod)
      // verify required parameter 'apiMdurzRecordsPostRequest' is not null or undefined
      assertParamExists(
        'apiMdurzRecordsPost',
        'apiMdurzRecordsPostRequest',
        apiMdurzRecordsPostRequest,
      )
      const localVarPath = `/api/mdurz/records`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (requestId !== undefined) {
        localVarQueryParameter['request_id'] = requestId
      }

      if (customId !== undefined) {
        localVarQueryParameter['custom_id'] = customId
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (description !== undefined) {
        localVarQueryParameter['description'] = description
      }

      if (access !== undefined) {
        localVarQueryParameter['access'] = access
      }

      if (retentionPeriod !== undefined) {
        localVarQueryParameter['retention_period'] = retentionPeriod
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiMdurzRecordsPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DlhodobLoiskoApi - functional programming interface
 * @export
 */
export const DlhodobLoiskoApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DlhodobLoiskoApiAxiosParamCreator(configuration)
  return {
    /**
     * Odošle požiadavku na vyradenie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_CANCEL_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Vyradí záznam z úložiska
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdDeleteDestinationEnum} destination Cieľ poskytnutia záznamu.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiMdurzRecordsIdDelete(
      id: string,
      requestId: string,
      destination: ApiMdurzRecordsIdDeleteDestinationEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiMdurzRecordsIdDelete(
        id,
        requestId,
        destination,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DlhodobLoiskoApi.apiMdurzRecordsIdDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle požiadavku na získanie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_DISSEMINATE_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Získa záznam z úložiska
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdDisseminatePostDestinationEnum} destination Cieľ poskytnutia záznamu.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiMdurzRecordsIdDisseminatePost(
      id: string,
      requestId: string,
      destination: ApiMdurzRecordsIdDisseminatePostDestinationEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiMdurzRecordsIdDisseminatePost(
        id,
        requestId,
        destination,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DlhodobLoiskoApi.apiMdurzRecordsIdDisseminatePost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle požiadavku na predĺženie doby uchovania záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_EXTEND_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  MDURZ zasiela notifikačné správy o blížiacej sa končicej lehote s SKTalk triedou `MDURZ_EXPIRATION_WARNING_04` a notifikačné správy o expirovanom zázname s SKTalk triedou `MDURZ_EXPIRATION_NOTIFICATION_04`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Predĺži dobu uchovania záznamu v úložisku
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; predĺženie o 1 rok,   - &#x60;R2&#x60; predĺženie o 2 roky,   - &#x60;R5&#x60; predĺženie o 5 rokov.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiMdurzRecordsIdExtendPatch(
      id: string,
      requestId: string,
      retentionPeriod: ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiMdurzRecordsIdExtendPatch(
        id,
        requestId,
        retentionPeriod,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DlhodobLoiskoApi.apiMdurzRecordsIdExtendPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle požiadavku na zmenu popisných údajov záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_SET_METADATA_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Zmení popisné údaje záznamu v úložisku
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} customId Nová značka záznamu.
     * @param {string} title Nový názov záznamu.
     * @param {string} description Nový popis záznamu.
     * @param {ApiMdurzRecordsIdPatchAccessEnum} access Nový indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiMdurzRecordsIdPatch(
      id: string,
      requestId: string,
      customId: string,
      title: string,
      description: string,
      access: ApiMdurzRecordsIdPatchAccessEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiMdurzRecordsIdPatch(
        id,
        requestId,
        customId,
        title,
        description,
        access,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DlhodobLoiskoApi.apiMdurzRecordsIdPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle požiadavku na vloženie nového záznamu do úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_INGEST_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Vloží nový záznam do úložiska
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} customId Značka záznamu.
     * @param {string} title Názov záznamu.
     * @param {string} description Popis záznamu.
     * @param {ApiMdurzRecordsPostAccessEnum} access Indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
     * @param {ApiMdurzRecordsPostRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; uchovanie na 1 rok,   - &#x60;R2&#x60; uchovanie na 2 roky,   - &#x60;R5&#x60; uchovanie na 5 rokov.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiMdurzRecordsPost(
      requestId: string,
      customId: string,
      title: string,
      description: string,
      access: ApiMdurzRecordsPostAccessEnum,
      retentionPeriod: ApiMdurzRecordsPostRetentionPeriodEnum,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiMdurzRecordsPost(
        requestId,
        customId,
        title,
        description,
        access,
        retentionPeriod,
        apiMdurzRecordsPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DlhodobLoiskoApi.apiMdurzRecordsPost']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DlhodobLoiskoApi - factory interface
 * @export
 */
export const DlhodobLoiskoApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DlhodobLoiskoApiFp(configuration)
  return {
    /**
     * Odošle požiadavku na vyradenie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_CANCEL_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Vyradí záznam z úložiska
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdDeleteDestinationEnum} destination Cieľ poskytnutia záznamu.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdDelete(
      id: string,
      requestId: string,
      destination: ApiMdurzRecordsIdDeleteDestinationEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiMdurzRecordsIdDelete(
          id,
          requestId,
          destination,
          apiMdurzRecordsIdDeleteRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle požiadavku na získanie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_DISSEMINATE_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Získa záznam z úložiska
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdDisseminatePostDestinationEnum} destination Cieľ poskytnutia záznamu.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdDisseminatePost(
      id: string,
      requestId: string,
      destination: ApiMdurzRecordsIdDisseminatePostDestinationEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiMdurzRecordsIdDisseminatePost(
          id,
          requestId,
          destination,
          apiMdurzRecordsIdDeleteRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle požiadavku na predĺženie doby uchovania záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_EXTEND_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  MDURZ zasiela notifikačné správy o blížiacej sa končicej lehote s SKTalk triedou `MDURZ_EXPIRATION_WARNING_04` a notifikačné správy o expirovanom zázname s SKTalk triedou `MDURZ_EXPIRATION_NOTIFICATION_04`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Predĺži dobu uchovania záznamu v úložisku
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; predĺženie o 1 rok,   - &#x60;R2&#x60; predĺženie o 2 roky,   - &#x60;R5&#x60; predĺženie o 5 rokov.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdExtendPatch(
      id: string,
      requestId: string,
      retentionPeriod: ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiMdurzRecordsIdExtendPatch(
          id,
          requestId,
          retentionPeriod,
          apiMdurzRecordsIdDeleteRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle požiadavku na zmenu popisných údajov záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_SET_METADATA_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Zmení popisné údaje záznamu v úložisku
     * @param {string} id Identifikátor záznamu v úložisku.
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} customId Nová značka záznamu.
     * @param {string} title Nový názov záznamu.
     * @param {string} description Nový popis záznamu.
     * @param {ApiMdurzRecordsIdPatchAccessEnum} access Nový indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
     * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsIdPatch(
      id: string,
      requestId: string,
      customId: string,
      title: string,
      description: string,
      access: ApiMdurzRecordsIdPatchAccessEnum,
      apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiMdurzRecordsIdPatch(
          id,
          requestId,
          customId,
          title,
          description,
          access,
          apiMdurzRecordsIdDeleteRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle požiadavku na vloženie nového záznamu do úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_INGEST_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
     * @summary Vloží nový záznam do úložiska
     * @param {string} requestId Identifikátor požiadavky.
     * @param {string} customId Značka záznamu.
     * @param {string} title Názov záznamu.
     * @param {string} description Popis záznamu.
     * @param {ApiMdurzRecordsPostAccessEnum} access Indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
     * @param {ApiMdurzRecordsPostRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; uchovanie na 1 rok,   - &#x60;R2&#x60; uchovanie na 2 roky,   - &#x60;R5&#x60; uchovanie na 5 rokov.
     * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiMdurzRecordsPost(
      requestId: string,
      customId: string,
      title: string,
      description: string,
      access: ApiMdurzRecordsPostAccessEnum,
      retentionPeriod: ApiMdurzRecordsPostRetentionPeriodEnum,
      apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiMdurzRecordsPost(
          requestId,
          customId,
          title,
          description,
          access,
          retentionPeriod,
          apiMdurzRecordsPostRequest,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DlhodobLoiskoApi - object-oriented interface
 * @export
 * @class DlhodobLoiskoApi
 * @extends {BaseAPI}
 */
export class DlhodobLoiskoApi extends BaseAPI {
  /**
   * Odošle požiadavku na vyradenie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_CANCEL_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
   * @summary Vyradí záznam z úložiska
   * @param {string} id Identifikátor záznamu v úložisku.
   * @param {string} requestId Identifikátor požiadavky.
   * @param {ApiMdurzRecordsIdDeleteDestinationEnum} destination Cieľ poskytnutia záznamu.
   * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DlhodobLoiskoApi
   */
  public apiMdurzRecordsIdDelete(
    id: string,
    requestId: string,
    destination: ApiMdurzRecordsIdDeleteDestinationEnum,
    apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DlhodobLoiskoApiFp(this.configuration)
      .apiMdurzRecordsIdDelete(id, requestId, destination, apiMdurzRecordsIdDeleteRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle požiadavku na získanie záznamu z úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_DISSEMINATE_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
   * @summary Získa záznam z úložiska
   * @param {string} id Identifikátor záznamu v úložisku.
   * @param {string} requestId Identifikátor požiadavky.
   * @param {ApiMdurzRecordsIdDisseminatePostDestinationEnum} destination Cieľ poskytnutia záznamu.
   * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DlhodobLoiskoApi
   */
  public apiMdurzRecordsIdDisseminatePost(
    id: string,
    requestId: string,
    destination: ApiMdurzRecordsIdDisseminatePostDestinationEnum,
    apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DlhodobLoiskoApiFp(this.configuration)
      .apiMdurzRecordsIdDisseminatePost(
        id,
        requestId,
        destination,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle požiadavku na predĺženie doby uchovania záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_EXTEND_PRESERVATION_REPLY_04` obsahujúca uložený záznam. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  MDURZ zasiela notifikačné správy o blížiacej sa končicej lehote s SKTalk triedou `MDURZ_EXPIRATION_WARNING_04` a notifikačné správy o expirovanom zázname s SKTalk triedou `MDURZ_EXPIRATION_NOTIFICATION_04`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
   * @summary Predĺži dobu uchovania záznamu v úložisku
   * @param {string} id Identifikátor záznamu v úložisku.
   * @param {string} requestId Identifikátor požiadavky.
   * @param {ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; predĺženie o 1 rok,   - &#x60;R2&#x60; predĺženie o 2 roky,   - &#x60;R5&#x60; predĺženie o 5 rokov.
   * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DlhodobLoiskoApi
   */
  public apiMdurzRecordsIdExtendPatch(
    id: string,
    requestId: string,
    retentionPeriod: ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum,
    apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DlhodobLoiskoApiFp(this.configuration)
      .apiMdurzRecordsIdExtendPatch(
        id,
        requestId,
        retentionPeriod,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle požiadavku na zmenu popisných údajov záznamu v úložisku. Do schránky príde odpoveď s SKTalk triedou `MDURZ_SET_METADATA_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
   * @summary Zmení popisné údaje záznamu v úložisku
   * @param {string} id Identifikátor záznamu v úložisku.
   * @param {string} requestId Identifikátor požiadavky.
   * @param {string} customId Nová značka záznamu.
   * @param {string} title Nový názov záznamu.
   * @param {string} description Nový popis záznamu.
   * @param {ApiMdurzRecordsIdPatchAccessEnum} access Nový indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
   * @param {ApiMdurzRecordsIdDeleteRequest} apiMdurzRecordsIdDeleteRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DlhodobLoiskoApi
   */
  public apiMdurzRecordsIdPatch(
    id: string,
    requestId: string,
    customId: string,
    title: string,
    description: string,
    access: ApiMdurzRecordsIdPatchAccessEnum,
    apiMdurzRecordsIdDeleteRequest: ApiMdurzRecordsIdDeleteRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DlhodobLoiskoApiFp(this.configuration)
      .apiMdurzRecordsIdPatch(
        id,
        requestId,
        customId,
        title,
        description,
        access,
        apiMdurzRecordsIdDeleteRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle požiadavku na vloženie nového záznamu do úložiska. Do schránky príde odpoveď s SKTalk triedou `MDURZ_INGEST_REPLY_04`. Voči zaslanej požiadavke je možné párovanie cez poskytnutý `request_id`.  Volanie automaticky validuje, či je interne používaná správna verzia formulára. Nie je potrebné kontrolovať validitu formulára externe.
   * @summary Vloží nový záznam do úložiska
   * @param {string} requestId Identifikátor požiadavky.
   * @param {string} customId Značka záznamu.
   * @param {string} title Názov záznamu.
   * @param {string} description Popis záznamu.
   * @param {ApiMdurzRecordsPostAccessEnum} access Indikátor dostupnosti záznamu:   - &#x60;PUBLIC&#x60; verejný,   - &#x60;PRIVATE&#x60; súkromný.
   * @param {ApiMdurzRecordsPostRetentionPeriodEnum} retentionPeriod Dĺžka uchovania záznamu:   - &#x60;R1&#x60; uchovanie na 1 rok,   - &#x60;R2&#x60; uchovanie na 2 roky,   - &#x60;R5&#x60; uchovanie na 5 rokov.
   * @param {ApiMdurzRecordsPostRequest} apiMdurzRecordsPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DlhodobLoiskoApi
   */
  public apiMdurzRecordsPost(
    requestId: string,
    customId: string,
    title: string,
    description: string,
    access: ApiMdurzRecordsPostAccessEnum,
    retentionPeriod: ApiMdurzRecordsPostRetentionPeriodEnum,
    apiMdurzRecordsPostRequest: ApiMdurzRecordsPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return DlhodobLoiskoApiFp(this.configuration)
      .apiMdurzRecordsPost(
        requestId,
        customId,
        title,
        description,
        access,
        retentionPeriod,
        apiMdurzRecordsPostRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ApiMdurzRecordsIdDeleteDestinationEnum = {
  Edesk: 'EDESK',
  None: 'NONE',
} as const
export type ApiMdurzRecordsIdDeleteDestinationEnum =
  (typeof ApiMdurzRecordsIdDeleteDestinationEnum)[keyof typeof ApiMdurzRecordsIdDeleteDestinationEnum]
/**
 * @export
 */
export const ApiMdurzRecordsIdDisseminatePostDestinationEnum = {
  Edesk: 'EDESK',
  None: 'NONE',
} as const
export type ApiMdurzRecordsIdDisseminatePostDestinationEnum =
  (typeof ApiMdurzRecordsIdDisseminatePostDestinationEnum)[keyof typeof ApiMdurzRecordsIdDisseminatePostDestinationEnum]
/**
 * @export
 */
export const ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum = {
  R1: 'R1',
  R3: 'R3',
  R5: 'R5',
} as const
export type ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum =
  (typeof ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum)[keyof typeof ApiMdurzRecordsIdExtendPatchRetentionPeriodEnum]
/**
 * @export
 */
export const ApiMdurzRecordsIdPatchAccessEnum = {
  Public: 'PUBLIC',
  Private: 'PRIVATE',
} as const
export type ApiMdurzRecordsIdPatchAccessEnum =
  (typeof ApiMdurzRecordsIdPatchAccessEnum)[keyof typeof ApiMdurzRecordsIdPatchAccessEnum]
/**
 * @export
 */
export const ApiMdurzRecordsPostAccessEnum = {
  Public: 'PUBLIC',
  Private: 'PRIVATE',
} as const
export type ApiMdurzRecordsPostAccessEnum =
  (typeof ApiMdurzRecordsPostAccessEnum)[keyof typeof ApiMdurzRecordsPostAccessEnum]
/**
 * @export
 */
export const ApiMdurzRecordsPostRetentionPeriodEnum = {
  R1: 'R1',
  R3: 'R3',
  R5: 'R5',
} as const
export type ApiMdurzRecordsPostRetentionPeriodEnum =
  (typeof ApiMdurzRecordsPostRetentionPeriodEnum)[keyof typeof ApiMdurzRecordsPostRetentionPeriodEnum]

/**
 * InformcieOPrihlsenomPouvateoviApi - axios parameter creator
 * @export
 */
export const InformcieOPrihlsenomPouvateoviApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Vráti bezpečnostné informácie prihláseného používateľa.
     * @summary Vráti bezpečnostné informácie prihláseného používateľa
     * @param {string} accept
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiUpvsAssertionGet: async (
      accept: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accept' is not null or undefined
      assertParamExists('apiUpvsAssertionGet', 'accept', accept)
      const localVarPath = `/api/upvs/assertion`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API + OBO Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (accept != null) {
        localVarHeaderParameter['Accept'] = String(accept)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vráti identitu prihláseného používateľa.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vráti identitu prihláseného používateľa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiUpvsIdentityGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/upvs/identity`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API + OBO Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * InformcieOPrihlsenomPouvateoviApi - functional programming interface
 * @export
 */
export const InformcieOPrihlsenomPouvateoviApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    InformcieOPrihlsenomPouvateoviApiAxiosParamCreator(configuration)
  return {
    /**
     * Vráti bezpečnostné informácie prihláseného používateľa.
     * @summary Vráti bezpečnostné informácie prihláseného používateľa
     * @param {string} accept
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiUpvsAssertionGet(
      accept: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiUpvsAssertionGet(accept, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['InformcieOPrihlsenomPouvateoviApi.apiUpvsAssertionGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vráti identitu prihláseného používateľa.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vráti identitu prihláseného používateľa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiUpvsIdentityGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpvsNaturalPerson>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiUpvsIdentityGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['InformcieOPrihlsenomPouvateoviApi.apiUpvsIdentityGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * InformcieOPrihlsenomPouvateoviApi - factory interface
 * @export
 */
export const InformcieOPrihlsenomPouvateoviApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = InformcieOPrihlsenomPouvateoviApiFp(configuration)
  return {
    /**
     * Vráti bezpečnostné informácie prihláseného používateľa.
     * @summary Vráti bezpečnostné informácie prihláseného používateľa
     * @param {string} accept
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiUpvsAssertionGet(accept: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .apiUpvsAssertionGet(accept, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vráti identitu prihláseného používateľa.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vráti identitu prihláseného používateľa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiUpvsIdentityGet(options?: RawAxiosRequestConfig): AxiosPromise<UpvsNaturalPerson> {
      return localVarFp.apiUpvsIdentityGet(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * InformcieOPrihlsenomPouvateoviApi - object-oriented interface
 * @export
 * @class InformcieOPrihlsenomPouvateoviApi
 * @extends {BaseAPI}
 */
export class InformcieOPrihlsenomPouvateoviApi extends BaseAPI {
  /**
   * Vráti bezpečnostné informácie prihláseného používateľa.
   * @summary Vráti bezpečnostné informácie prihláseného používateľa
   * @param {string} accept
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InformcieOPrihlsenomPouvateoviApi
   */
  public apiUpvsAssertionGet(accept: string, options?: RawAxiosRequestConfig) {
    return InformcieOPrihlsenomPouvateoviApiFp(this.configuration)
      .apiUpvsAssertionGet(accept, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vráti identitu prihláseného používateľa.  Pozor, volanie je dostupné len pre OVM.
   * @summary Vráti identitu prihláseného používateľa
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InformcieOPrihlsenomPouvateoviApi
   */
  public apiUpvsIdentityGet(options?: RawAxiosRequestConfig) {
    return InformcieOPrihlsenomPouvateoviApiFp(this.configuration)
      .apiUpvsIdentityGet(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ManamentAutentifikanchCertifiktovAdministrciaApi - axios parameter creator
 * @export
 */
export const ManamentAutentifikanchCertifiktovAdministrciaApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Zmaže certifikát
     * @param {string} id Identifikátor certifikátu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationCertificatesIdDelete: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('administrationCertificatesIdDelete', 'id', id)
      const localVarPath = `/administration/certificates/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Administration Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Vráti informácie o certifikáte
     * @param {string} id Identifikátor certifikátu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationCertificatesIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('administrationCertificatesIdGet', 'id', id)
      const localVarPath = `/administration/certificates/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Administration Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Vygeneruje nový certifikát
     * @param {AdministrationCertificatesPostRequest} administrationCertificatesPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationCertificatesPost: async (
      administrationCertificatesPostRequest: AdministrationCertificatesPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'administrationCertificatesPostRequest' is not null or undefined
      assertParamExists(
        'administrationCertificatesPost',
        'administrationCertificatesPostRequest',
        administrationCertificatesPostRequest,
      )
      const localVarPath = `/administration/certificates`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Administration Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        administrationCertificatesPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ManamentAutentifikanchCertifiktovAdministrciaApi - functional programming interface
 * @export
 */
export const ManamentAutentifikanchCertifiktovAdministrciaApiFp = function (
  configuration?: Configuration,
) {
  const localVarAxiosParamCreator =
    ManamentAutentifikanchCertifiktovAdministrciaApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Zmaže certifikát
     * @param {string} id Identifikátor certifikátu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async administrationCertificatesIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.administrationCertificatesIdDelete(
        id,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'ManamentAutentifikanchCertifiktovAdministrciaApi.administrationCertificatesIdDelete'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Vráti informácie o certifikáte
     * @param {string} id Identifikátor certifikátu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async administrationCertificatesIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AdministrationCertificatesIdGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.administrationCertificatesIdGet(
        id,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'ManamentAutentifikanchCertifiktovAdministrciaApi.administrationCertificatesIdGet'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Vygeneruje nový certifikát
     * @param {AdministrationCertificatesPostRequest} administrationCertificatesPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async administrationCertificatesPost(
      administrationCertificatesPostRequest: AdministrationCertificatesPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.administrationCertificatesPost(
        administrationCertificatesPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'ManamentAutentifikanchCertifiktovAdministrciaApi.administrationCertificatesPost'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ManamentAutentifikanchCertifiktovAdministrciaApi - factory interface
 * @export
 */
export const ManamentAutentifikanchCertifiktovAdministrciaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ManamentAutentifikanchCertifiktovAdministrciaApiFp(configuration)
  return {
    /**
     *
     * @summary Zmaže certifikát
     * @param {string} id Identifikátor certifikátu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationCertificatesIdDelete(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .administrationCertificatesIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Vráti informácie o certifikáte
     * @param {string} id Identifikátor certifikátu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationCertificatesIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdministrationCertificatesIdGet200Response> {
      return localVarFp
        .administrationCertificatesIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Vygeneruje nový certifikát
     * @param {AdministrationCertificatesPostRequest} administrationCertificatesPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationCertificatesPost(
      administrationCertificatesPostRequest: AdministrationCertificatesPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .administrationCertificatesPost(administrationCertificatesPostRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ManamentAutentifikanchCertifiktovAdministrciaApi - object-oriented interface
 * @export
 * @class ManamentAutentifikanchCertifiktovAdministrciaApi
 * @extends {BaseAPI}
 */
export class ManamentAutentifikanchCertifiktovAdministrciaApi extends BaseAPI {
  /**
   *
   * @summary Zmaže certifikát
   * @param {string} id Identifikátor certifikátu.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManamentAutentifikanchCertifiktovAdministrciaApi
   */
  public administrationCertificatesIdDelete(id: string, options?: RawAxiosRequestConfig) {
    return ManamentAutentifikanchCertifiktovAdministrciaApiFp(this.configuration)
      .administrationCertificatesIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Vráti informácie o certifikáte
   * @param {string} id Identifikátor certifikátu.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManamentAutentifikanchCertifiktovAdministrciaApi
   */
  public administrationCertificatesIdGet(id: string, options?: RawAxiosRequestConfig) {
    return ManamentAutentifikanchCertifiktovAdministrciaApiFp(this.configuration)
      .administrationCertificatesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Vygeneruje nový certifikát
   * @param {AdministrationCertificatesPostRequest} administrationCertificatesPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManamentAutentifikanchCertifiktovAdministrciaApi
   */
  public administrationCertificatesPost(
    administrationCertificatesPostRequest: AdministrationCertificatesPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ManamentAutentifikanchCertifiktovAdministrciaApiFp(this.configuration)
      .administrationCertificatesPost(administrationCertificatesPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ManipulciaSoSchrnkouApi - axios parameter creator
 * @export
 */
export const ManipulciaSoSchrnkouApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Vráti zoznam priečinkov v schránke.
     * @summary Vráti zoznam priečinkov v schránke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskFoldersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/edesk/folders`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vráti zoznam správ v priečinku schránky.
     * @summary Vráti zoznam správ v priečinku schránky
     * @param {number} id eDesk identifikátor priečinka.
     * @param {number} [page] Číslo stránky zoznamu správ.
     * @param {number} [perPage] Počet správ na stránke zoznamu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskFoldersIdMessagesGet: async (
      id: number,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiEdeskFoldersIdMessagesGet', 'id', id)
      const localVarPath = `/api/edesk/folders/{id}/messages`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Autorizuje doručenku v schránke.
     * @summary Autorizuje doručenku v schránke
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdAuthorizePost: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiEdeskMessagesIdAuthorizePost', 'id', id)
      const localVarPath = `/api/edesk/messages/{id}/authorize`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vymaže správu zo schránky.  Volanie vráti úspešnú odpoveď aj v prípade keď správa už bola vymazaná alebo neexistuje.
     * @summary Vymaže správu zo schránky
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdDelete: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiEdeskMessagesIdDelete', 'id', id)
      const localVarPath = `/api/edesk/messages/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vráti správu zo schránky.
     * @summary Vráti správu zo schránky
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdGet: async (
      id: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiEdeskMessagesIdGet', 'id', id)
      const localVarPath = `/api/edesk/messages/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Presunie správu do iného priečinka v schránke.  Volanie vráti neúspešnú odpoveď v prípade keď správa alebo priečinok neexistuje.
     * @summary Presunie správu do iného priečinka v schránke
     * @param {number} id eDesk identifikátor správy.
     * @param {ApiEdeskMessagesIdPatchRequest} apiEdeskMessagesIdPatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdPatch: async (
      id: number,
      apiEdeskMessagesIdPatchRequest: ApiEdeskMessagesIdPatchRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiEdeskMessagesIdPatch', 'id', id)
      // verify required parameter 'apiEdeskMessagesIdPatchRequest' is not null or undefined
      assertParamExists(
        'apiEdeskMessagesIdPatch',
        'apiEdeskMessagesIdPatchRequest',
        apiEdeskMessagesIdPatchRequest,
      )
      const localVarPath = `/api/edesk/messages/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiEdeskMessagesIdPatchRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vráti zoznam správ v schránke na základe vyhľadávacích kritérií.
     * @summary Vráti zoznam správ v schránke na základe vyhľadávacích kritérií
     * @param {Uuid} correlationId Correlation ID vyhľadávaných správ.
     * @param {number} [page] Číslo stránky zoznamu správ.
     * @param {number} [perPage] Počet správ na stránke zoznamu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesSearchGet: async (
      correlationId: Uuid,
      page?: number,
      perPage?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'correlationId' is not null or undefined
      assertParamExists('apiEdeskMessagesSearchGet', 'correlationId', correlationId)
      const localVarPath = `/api/edesk/messages/search`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (correlationId !== undefined) {
        for (const [key, value] of Object.entries(correlationId)) {
          localVarQueryParameter[key] = value
        }
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (perPage !== undefined) {
        localVarQueryParameter['per_page'] = perPage
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ManipulciaSoSchrnkouApi - functional programming interface
 * @export
 */
export const ManipulciaSoSchrnkouApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ManipulciaSoSchrnkouApiAxiosParamCreator(configuration)
  return {
    /**
     * Vráti zoznam priečinkov v schránke.
     * @summary Vráti zoznam priečinkov v schránke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEdeskFoldersGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdeskFolder>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEdeskFoldersGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManipulciaSoSchrnkouApi.apiEdeskFoldersGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vráti zoznam správ v priečinku schránky.
     * @summary Vráti zoznam správ v priečinku schránky
     * @param {number} id eDesk identifikátor priečinka.
     * @param {number} [page] Číslo stránky zoznamu správ.
     * @param {number} [perPage] Počet správ na stránke zoznamu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEdeskFoldersIdMessagesGet(
      id: number,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdeskHeader>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEdeskFoldersIdMessagesGet(
        id,
        page,
        perPage,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManipulciaSoSchrnkouApi.apiEdeskFoldersIdMessagesGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Autorizuje doručenku v schránke.
     * @summary Autorizuje doručenku v schránke
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEdeskMessagesIdAuthorizePost(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiEdeskMessagesIdAuthorizePost200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEdeskMessagesIdAuthorizePost(
        id,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManipulciaSoSchrnkouApi.apiEdeskMessagesIdAuthorizePost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vymaže správu zo schránky.  Volanie vráti úspešnú odpoveď aj v prípade keď správa už bola vymazaná alebo neexistuje.
     * @summary Vymaže správu zo schránky
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEdeskMessagesIdDelete(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEdeskMessagesIdDelete(
        id,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManipulciaSoSchrnkouApi.apiEdeskMessagesIdDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vráti správu zo schránky.
     * @summary Vráti správu zo schránky
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEdeskMessagesIdGet(
      id: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdeskMessage>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEdeskMessagesIdGet(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManipulciaSoSchrnkouApi.apiEdeskMessagesIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Presunie správu do iného priečinka v schránke.  Volanie vráti neúspešnú odpoveď v prípade keď správa alebo priečinok neexistuje.
     * @summary Presunie správu do iného priečinka v schránke
     * @param {number} id eDesk identifikátor správy.
     * @param {ApiEdeskMessagesIdPatchRequest} apiEdeskMessagesIdPatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEdeskMessagesIdPatch(
      id: number,
      apiEdeskMessagesIdPatchRequest: ApiEdeskMessagesIdPatchRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEdeskMessagesIdPatch(
        id,
        apiEdeskMessagesIdPatchRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManipulciaSoSchrnkouApi.apiEdeskMessagesIdPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vráti zoznam správ v schránke na základe vyhľadávacích kritérií.
     * @summary Vráti zoznam správ v schránke na základe vyhľadávacích kritérií
     * @param {Uuid} correlationId Correlation ID vyhľadávaných správ.
     * @param {number} [page] Číslo stránky zoznamu správ.
     * @param {number} [perPage] Počet správ na stránke zoznamu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEdeskMessagesSearchGet(
      correlationId: Uuid,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdeskHeader>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEdeskMessagesSearchGet(
        correlationId,
        page,
        perPage,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ManipulciaSoSchrnkouApi.apiEdeskMessagesSearchGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ManipulciaSoSchrnkouApi - factory interface
 * @export
 */
export const ManipulciaSoSchrnkouApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ManipulciaSoSchrnkouApiFp(configuration)
  return {
    /**
     * Vráti zoznam priečinkov v schránke.
     * @summary Vráti zoznam priečinkov v schránke
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskFoldersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<EdeskFolder>> {
      return localVarFp.apiEdeskFoldersGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Vráti zoznam správ v priečinku schránky.
     * @summary Vráti zoznam správ v priečinku schránky
     * @param {number} id eDesk identifikátor priečinka.
     * @param {number} [page] Číslo stránky zoznamu správ.
     * @param {number} [perPage] Počet správ na stránke zoznamu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskFoldersIdMessagesGet(
      id: number,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<EdeskHeader>> {
      return localVarFp
        .apiEdeskFoldersIdMessagesGet(id, page, perPage, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Autorizuje doručenku v schránke.
     * @summary Autorizuje doručenku v schránke
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdAuthorizePost(
      id: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiEdeskMessagesIdAuthorizePost200Response> {
      return localVarFp
        .apiEdeskMessagesIdAuthorizePost(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vymaže správu zo schránky.  Volanie vráti úspešnú odpoveď aj v prípade keď správa už bola vymazaná alebo neexistuje.
     * @summary Vymaže správu zo schránky
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdDelete(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .apiEdeskMessagesIdDelete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vráti správu zo schránky.
     * @summary Vráti správu zo schránky
     * @param {number} id eDesk identifikátor správy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdGet(id: number, options?: RawAxiosRequestConfig): AxiosPromise<EdeskMessage> {
      return localVarFp
        .apiEdeskMessagesIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Presunie správu do iného priečinka v schránke.  Volanie vráti neúspešnú odpoveď v prípade keď správa alebo priečinok neexistuje.
     * @summary Presunie správu do iného priečinka v schránke
     * @param {number} id eDesk identifikátor správy.
     * @param {ApiEdeskMessagesIdPatchRequest} apiEdeskMessagesIdPatchRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesIdPatch(
      id: number,
      apiEdeskMessagesIdPatchRequest: ApiEdeskMessagesIdPatchRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .apiEdeskMessagesIdPatch(id, apiEdeskMessagesIdPatchRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vráti zoznam správ v schránke na základe vyhľadávacích kritérií.
     * @summary Vráti zoznam správ v schránke na základe vyhľadávacích kritérií
     * @param {Uuid} correlationId Correlation ID vyhľadávaných správ.
     * @param {number} [page] Číslo stránky zoznamu správ.
     * @param {number} [perPage] Počet správ na stránke zoznamu.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEdeskMessagesSearchGet(
      correlationId: Uuid,
      page?: number,
      perPage?: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<EdeskHeader>> {
      return localVarFp
        .apiEdeskMessagesSearchGet(correlationId, page, perPage, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ManipulciaSoSchrnkouApi - object-oriented interface
 * @export
 * @class ManipulciaSoSchrnkouApi
 * @extends {BaseAPI}
 */
export class ManipulciaSoSchrnkouApi extends BaseAPI {
  /**
   * Vráti zoznam priečinkov v schránke.
   * @summary Vráti zoznam priečinkov v schránke
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManipulciaSoSchrnkouApi
   */
  public apiEdeskFoldersGet(options?: RawAxiosRequestConfig) {
    return ManipulciaSoSchrnkouApiFp(this.configuration)
      .apiEdeskFoldersGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vráti zoznam správ v priečinku schránky.
   * @summary Vráti zoznam správ v priečinku schránky
   * @param {number} id eDesk identifikátor priečinka.
   * @param {number} [page] Číslo stránky zoznamu správ.
   * @param {number} [perPage] Počet správ na stránke zoznamu.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManipulciaSoSchrnkouApi
   */
  public apiEdeskFoldersIdMessagesGet(
    id: number,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ManipulciaSoSchrnkouApiFp(this.configuration)
      .apiEdeskFoldersIdMessagesGet(id, page, perPage, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Autorizuje doručenku v schránke.
   * @summary Autorizuje doručenku v schránke
   * @param {number} id eDesk identifikátor správy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManipulciaSoSchrnkouApi
   */
  public apiEdeskMessagesIdAuthorizePost(id: number, options?: RawAxiosRequestConfig) {
    return ManipulciaSoSchrnkouApiFp(this.configuration)
      .apiEdeskMessagesIdAuthorizePost(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vymaže správu zo schránky.  Volanie vráti úspešnú odpoveď aj v prípade keď správa už bola vymazaná alebo neexistuje.
   * @summary Vymaže správu zo schránky
   * @param {number} id eDesk identifikátor správy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManipulciaSoSchrnkouApi
   */
  public apiEdeskMessagesIdDelete(id: number, options?: RawAxiosRequestConfig) {
    return ManipulciaSoSchrnkouApiFp(this.configuration)
      .apiEdeskMessagesIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vráti správu zo schránky.
   * @summary Vráti správu zo schránky
   * @param {number} id eDesk identifikátor správy.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManipulciaSoSchrnkouApi
   */
  public apiEdeskMessagesIdGet(id: number, options?: RawAxiosRequestConfig) {
    return ManipulciaSoSchrnkouApiFp(this.configuration)
      .apiEdeskMessagesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Presunie správu do iného priečinka v schránke.  Volanie vráti neúspešnú odpoveď v prípade keď správa alebo priečinok neexistuje.
   * @summary Presunie správu do iného priečinka v schránke
   * @param {number} id eDesk identifikátor správy.
   * @param {ApiEdeskMessagesIdPatchRequest} apiEdeskMessagesIdPatchRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManipulciaSoSchrnkouApi
   */
  public apiEdeskMessagesIdPatch(
    id: number,
    apiEdeskMessagesIdPatchRequest: ApiEdeskMessagesIdPatchRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ManipulciaSoSchrnkouApiFp(this.configuration)
      .apiEdeskMessagesIdPatch(id, apiEdeskMessagesIdPatchRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vráti zoznam správ v schránke na základe vyhľadávacích kritérií.
   * @summary Vráti zoznam správ v schránke na základe vyhľadávacích kritérií
   * @param {Uuid} correlationId Correlation ID vyhľadávaných správ.
   * @param {number} [page] Číslo stránky zoznamu správ.
   * @param {number} [perPage] Počet správ na stránke zoznamu.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManipulciaSoSchrnkouApi
   */
  public apiEdeskMessagesSearchGet(
    correlationId: Uuid,
    page?: number,
    perPage?: number,
    options?: RawAxiosRequestConfig,
  ) {
    return ManipulciaSoSchrnkouApiFp(this.configuration)
      .apiEdeskMessagesSearchGet(correlationId, page, perPage, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PodpisovanieApi - axios parameter creator
 * @export
 */
export const PodpisovanieApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Rozšíri digitálny podpis z EPES na T formu pridaním kvalifikovanej časovej pečiatky.
     * @summary Pridá kvalifikovanú časovú pečiatku.
     * @param {ApiCepAddTimestampPostRequest} apiCepAddTimestampPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepAddTimestampPost: async (
      apiCepAddTimestampPostRequest: ApiCepAddTimestampPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiCepAddTimestampPostRequest' is not null or undefined
      assertParamExists(
        'apiCepAddTimestampPost',
        'apiCepAddTimestampPostRequest',
        apiCepAddTimestampPostRequest,
      )
      const localVarPath = `/api/cep/add_timestamp`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiCepAddTimestampPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Podpíše súbor elektronickou pečaťou.  Umožňuje aj pridanie podpisu k už podpísanému dokumentu.
     * @summary Podpíše súbor elektronickou pečaťou
     * @param {ApiCepSignPostRequest} apiCepSignPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepSignPost: async (
      apiCepSignPostRequest: ApiCepSignPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiCepSignPostRequest' is not null or undefined
      assertParamExists('apiCepSignPost', 'apiCepSignPostRequest', apiCepSignPostRequest)
      const localVarPath = `/api/cep/sign`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiCepSignPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Podpíše súbory elektronickou pečaťou a overí vstupné dokumenty vočí validátorom dátových objektov. Spracúva viacero skupín objektov v jednom requeste. Umožňuje aj spoločne podpisovať viacero nepodpísaných objektov jedným podpisom, pridávať podpis do podpisovej obálky a spoločne podpisovať nepodpísané objekty s už podpísanými objektami z ASiC-E XAdES alebo ASiC-E CAdES jedným podpisom.
     * @summary Podpíše súbory elektronickou pečaťou
     * @param {ApiCepSignV2PostRequest} apiCepSignV2PostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepSignV2Post: async (
      apiCepSignV2PostRequest: ApiCepSignV2PostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiCepSignV2PostRequest' is not null or undefined
      assertParamExists('apiCepSignV2Post', 'apiCepSignV2PostRequest', apiCepSignV2PostRequest)
      const localVarPath = `/api/cep/sign_v2`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiCepSignV2PostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vráti informácie o type a forme podpisov podpísaného dokumentu.  Neoveruje platnosť podpisov, ani časových pečiatok, tak isto neoveruje legislatívnu formu podpisu.
     * @summary Vráti informácie o type a forme podpisov.
     * @param {ApiCepSignaturesInfoPostRequest} apiCepSignaturesInfoPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepSignaturesInfoPost: async (
      apiCepSignaturesInfoPostRequest: ApiCepSignaturesInfoPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiCepSignaturesInfoPostRequest' is not null or undefined
      assertParamExists(
        'apiCepSignaturesInfoPost',
        'apiCepSignaturesInfoPostRequest',
        apiCepSignaturesInfoPostRequest,
      )
      const localVarPath = `/api/cep/signatures_info`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiCepSignaturesInfoPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Informatívne overí podpisy na súbore. Informácie o overení ZEP vracia na základe údajov, ktoré má k dispozícii v čase volania.  Pre formáty podpisov bez časovej pečiatky nezabezpečuje ich rozšírenie o časovú pečiatku.
     * @summary Informatívne overí podpisy na súbore
     * @param {ApiCepVerifyPostRequest} apiCepVerifyPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepVerifyPost: async (
      apiCepVerifyPostRequest: ApiCepVerifyPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiCepVerifyPostRequest' is not null or undefined
      assertParamExists('apiCepVerifyPost', 'apiCepVerifyPostRequest', apiCepVerifyPostRequest)
      const localVarPath = `/api/cep/verify`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiCepVerifyPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PodpisovanieApi - functional programming interface
 * @export
 */
export const PodpisovanieApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PodpisovanieApiAxiosParamCreator(configuration)
  return {
    /**
     * Rozšíri digitálny podpis z EPES na T formu pridaním kvalifikovanej časovej pečiatky.
     * @summary Pridá kvalifikovanú časovú pečiatku.
     * @param {ApiCepAddTimestampPostRequest} apiCepAddTimestampPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCepAddTimestampPost(
      apiCepAddTimestampPostRequest: ApiCepAddTimestampPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCepAddTimestampPost200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCepAddTimestampPost(
        apiCepAddTimestampPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PodpisovanieApi.apiCepAddTimestampPost']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Podpíše súbor elektronickou pečaťou.  Umožňuje aj pridanie podpisu k už podpísanému dokumentu.
     * @summary Podpíše súbor elektronickou pečaťou
     * @param {ApiCepSignPostRequest} apiCepSignPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCepSignPost(
      apiCepSignPostRequest: ApiCepSignPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCepSignPost200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCepSignPost(
        apiCepSignPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PodpisovanieApi.apiCepSignPost']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Podpíše súbory elektronickou pečaťou a overí vstupné dokumenty vočí validátorom dátových objektov. Spracúva viacero skupín objektov v jednom requeste. Umožňuje aj spoločne podpisovať viacero nepodpísaných objektov jedným podpisom, pridávať podpis do podpisovej obálky a spoločne podpisovať nepodpísané objekty s už podpísanými objektami z ASiC-E XAdES alebo ASiC-E CAdES jedným podpisom.
     * @summary Podpíše súbory elektronickou pečaťou
     * @param {ApiCepSignV2PostRequest} apiCepSignV2PostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCepSignV2Post(
      apiCepSignV2PostRequest: ApiCepSignV2PostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCepSignV2Post200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCepSignV2Post(
        apiCepSignV2PostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PodpisovanieApi.apiCepSignV2Post']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vráti informácie o type a forme podpisov podpísaného dokumentu.  Neoveruje platnosť podpisov, ani časových pečiatok, tak isto neoveruje legislatívnu formu podpisu.
     * @summary Vráti informácie o type a forme podpisov.
     * @param {ApiCepSignaturesInfoPostRequest} apiCepSignaturesInfoPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCepSignaturesInfoPost(
      apiCepSignaturesInfoPostRequest: ApiCepSignaturesInfoPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiCepSignaturesInfoPost200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCepSignaturesInfoPost(
        apiCepSignaturesInfoPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PodpisovanieApi.apiCepSignaturesInfoPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Informatívne overí podpisy na súbore. Informácie o overení ZEP vracia na základe údajov, ktoré má k dispozícii v čase volania.  Pre formáty podpisov bez časovej pečiatky nezabezpečuje ich rozšírenie o časovú pečiatku.
     * @summary Informatívne overí podpisy na súbore
     * @param {ApiCepVerifyPostRequest} apiCepVerifyPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiCepVerifyPost(
      apiCepVerifyPostRequest: ApiCepVerifyPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCepVerifyPost200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiCepVerifyPost(
        apiCepVerifyPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PodpisovanieApi.apiCepVerifyPost']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PodpisovanieApi - factory interface
 * @export
 */
export const PodpisovanieApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PodpisovanieApiFp(configuration)
  return {
    /**
     * Rozšíri digitálny podpis z EPES na T formu pridaním kvalifikovanej časovej pečiatky.
     * @summary Pridá kvalifikovanú časovú pečiatku.
     * @param {ApiCepAddTimestampPostRequest} apiCepAddTimestampPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepAddTimestampPost(
      apiCepAddTimestampPostRequest: ApiCepAddTimestampPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiCepAddTimestampPost200Response> {
      return localVarFp
        .apiCepAddTimestampPost(apiCepAddTimestampPostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Podpíše súbor elektronickou pečaťou.  Umožňuje aj pridanie podpisu k už podpísanému dokumentu.
     * @summary Podpíše súbor elektronickou pečaťou
     * @param {ApiCepSignPostRequest} apiCepSignPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepSignPost(
      apiCepSignPostRequest: ApiCepSignPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiCepSignPost200Response> {
      return localVarFp
        .apiCepSignPost(apiCepSignPostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Podpíše súbory elektronickou pečaťou a overí vstupné dokumenty vočí validátorom dátových objektov. Spracúva viacero skupín objektov v jednom requeste. Umožňuje aj spoločne podpisovať viacero nepodpísaných objektov jedným podpisom, pridávať podpis do podpisovej obálky a spoločne podpisovať nepodpísané objekty s už podpísanými objektami z ASiC-E XAdES alebo ASiC-E CAdES jedným podpisom.
     * @summary Podpíše súbory elektronickou pečaťou
     * @param {ApiCepSignV2PostRequest} apiCepSignV2PostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepSignV2Post(
      apiCepSignV2PostRequest: ApiCepSignV2PostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiCepSignV2Post200Response> {
      return localVarFp
        .apiCepSignV2Post(apiCepSignV2PostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vráti informácie o type a forme podpisov podpísaného dokumentu.  Neoveruje platnosť podpisov, ani časových pečiatok, tak isto neoveruje legislatívnu formu podpisu.
     * @summary Vráti informácie o type a forme podpisov.
     * @param {ApiCepSignaturesInfoPostRequest} apiCepSignaturesInfoPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepSignaturesInfoPost(
      apiCepSignaturesInfoPostRequest: ApiCepSignaturesInfoPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiCepSignaturesInfoPost200Response> {
      return localVarFp
        .apiCepSignaturesInfoPost(apiCepSignaturesInfoPostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Informatívne overí podpisy na súbore. Informácie o overení ZEP vracia na základe údajov, ktoré má k dispozícii v čase volania.  Pre formáty podpisov bez časovej pečiatky nezabezpečuje ich rozšírenie o časovú pečiatku.
     * @summary Informatívne overí podpisy na súbore
     * @param {ApiCepVerifyPostRequest} apiCepVerifyPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiCepVerifyPost(
      apiCepVerifyPostRequest: ApiCepVerifyPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiCepVerifyPost200Response> {
      return localVarFp
        .apiCepVerifyPost(apiCepVerifyPostRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PodpisovanieApi - object-oriented interface
 * @export
 * @class PodpisovanieApi
 * @extends {BaseAPI}
 */
export class PodpisovanieApi extends BaseAPI {
  /**
   * Rozšíri digitálny podpis z EPES na T formu pridaním kvalifikovanej časovej pečiatky.
   * @summary Pridá kvalifikovanú časovú pečiatku.
   * @param {ApiCepAddTimestampPostRequest} apiCepAddTimestampPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PodpisovanieApi
   */
  public apiCepAddTimestampPost(
    apiCepAddTimestampPostRequest: ApiCepAddTimestampPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PodpisovanieApiFp(this.configuration)
      .apiCepAddTimestampPost(apiCepAddTimestampPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Podpíše súbor elektronickou pečaťou.  Umožňuje aj pridanie podpisu k už podpísanému dokumentu.
   * @summary Podpíše súbor elektronickou pečaťou
   * @param {ApiCepSignPostRequest} apiCepSignPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PodpisovanieApi
   */
  public apiCepSignPost(
    apiCepSignPostRequest: ApiCepSignPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PodpisovanieApiFp(this.configuration)
      .apiCepSignPost(apiCepSignPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Podpíše súbory elektronickou pečaťou a overí vstupné dokumenty vočí validátorom dátových objektov. Spracúva viacero skupín objektov v jednom requeste. Umožňuje aj spoločne podpisovať viacero nepodpísaných objektov jedným podpisom, pridávať podpis do podpisovej obálky a spoločne podpisovať nepodpísané objekty s už podpísanými objektami z ASiC-E XAdES alebo ASiC-E CAdES jedným podpisom.
   * @summary Podpíše súbory elektronickou pečaťou
   * @param {ApiCepSignV2PostRequest} apiCepSignV2PostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PodpisovanieApi
   */
  public apiCepSignV2Post(
    apiCepSignV2PostRequest: ApiCepSignV2PostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PodpisovanieApiFp(this.configuration)
      .apiCepSignV2Post(apiCepSignV2PostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vráti informácie o type a forme podpisov podpísaného dokumentu.  Neoveruje platnosť podpisov, ani časových pečiatok, tak isto neoveruje legislatívnu formu podpisu.
   * @summary Vráti informácie o type a forme podpisov.
   * @param {ApiCepSignaturesInfoPostRequest} apiCepSignaturesInfoPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PodpisovanieApi
   */
  public apiCepSignaturesInfoPost(
    apiCepSignaturesInfoPostRequest: ApiCepSignaturesInfoPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PodpisovanieApiFp(this.configuration)
      .apiCepSignaturesInfoPost(apiCepSignaturesInfoPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Informatívne overí podpisy na súbore. Informácie o overení ZEP vracia na základe údajov, ktoré má k dispozícii v čase volania.  Pre formáty podpisov bez časovej pečiatky nezabezpečuje ich rozšírenie o časovú pečiatku.
   * @summary Informatívne overí podpisy na súbore
   * @param {ApiCepVerifyPostRequest} apiCepVerifyPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PodpisovanieApi
   */
  public apiCepVerifyPost(
    apiCepVerifyPostRequest: ApiCepVerifyPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return PodpisovanieApiFp(this.configuration)
      .apiCepVerifyPost(apiCepVerifyPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PrihlasovaniePomocouEIDApi - axios parameter creator
 * @export
 */
export const PrihlasovaniePomocouEIDApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Prihlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom prihlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGIN_CALLBACK_URL).  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
     * @summary Prihlási používateľa pomocou eID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Prihlási používateľa pomocou slovensko.sk (ÚPVS) na základe prijatej SAML assertion.  Umožňuje vykonať ÚPVS SSO mimo slovensko-sk-api a poslať na API iba SAML assertion.  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
     * @summary Prihlási používateľa pomocou SAML assertion
     * @param {LoginPostRequest} loginPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginPost: async (
      loginPostRequest: LoginPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginPostRequest' is not null or undefined
      assertParamExists('loginPost', 'loginPostRequest', loginPostRequest)
      const localVarPath = `/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odhlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom odhlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGOUT_CALLBACK_URL).  Ak URL obsahuje callback (pri odhlásení iniciovanom zo strany ÚPVS), je potrebné spraviť redirect na callback.
     * @summary Odhlási používateľa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API + OBO Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PrihlasovaniePomocouEIDApi - functional programming interface
 * @export
 */
export const PrihlasovaniePomocouEIDApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PrihlasovaniePomocouEIDApiAxiosParamCreator(configuration)
  return {
    /**
     * Prihlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom prihlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGIN_CALLBACK_URL).  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
     * @summary Prihlási používateľa pomocou eID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PrihlasovaniePomocouEIDApi.loginGet']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Prihlási používateľa pomocou slovensko.sk (ÚPVS) na základe prijatej SAML assertion.  Umožňuje vykonať ÚPVS SSO mimo slovensko-sk-api a poslať na API iba SAML assertion.  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
     * @summary Prihlási používateľa pomocou SAML assertion
     * @param {LoginPostRequest} loginPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginPost(
      loginPostRequest: LoginPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginPost(loginPostRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PrihlasovaniePomocouEIDApi.loginPost']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odhlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom odhlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGOUT_CALLBACK_URL).  Ak URL obsahuje callback (pri odhlásení iniciovanom zo strany ÚPVS), je potrebné spraviť redirect na callback.
     * @summary Odhlási používateľa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PrihlasovaniePomocouEIDApi.logoutGet']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PrihlasovaniePomocouEIDApi - factory interface
 * @export
 */
export const PrihlasovaniePomocouEIDApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PrihlasovaniePomocouEIDApiFp(configuration)
  return {
    /**
     * Prihlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom prihlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGIN_CALLBACK_URL).  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
     * @summary Prihlási používateľa pomocou eID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.loginGet(options).then((request) => request(axios, basePath))
    },
    /**
     * Prihlási používateľa pomocou slovensko.sk (ÚPVS) na základe prijatej SAML assertion.  Umožňuje vykonať ÚPVS SSO mimo slovensko-sk-api a poslať na API iba SAML assertion.  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
     * @summary Prihlási používateľa pomocou SAML assertion
     * @param {LoginPostRequest} loginPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginPost(
      loginPostRequest: LoginPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<LoginPost200Response> {
      return localVarFp
        .loginPost(loginPostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Odhlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom odhlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGOUT_CALLBACK_URL).  Ak URL obsahuje callback (pri odhlásení iniciovanom zo strany ÚPVS), je potrebné spraviť redirect na callback.
     * @summary Odhlási používateľa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.logoutGet(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * PrihlasovaniePomocouEIDApi - object-oriented interface
 * @export
 * @class PrihlasovaniePomocouEIDApi
 * @extends {BaseAPI}
 */
export class PrihlasovaniePomocouEIDApi extends BaseAPI {
  /**
   * Prihlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom prihlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGIN_CALLBACK_URL).  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
   * @summary Prihlási používateľa pomocou eID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrihlasovaniePomocouEIDApi
   */
  public loginGet(options?: RawAxiosRequestConfig) {
    return PrihlasovaniePomocouEIDApiFp(this.configuration)
      .loginGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Prihlási používateľa pomocou slovensko.sk (ÚPVS) na základe prijatej SAML assertion.  Umožňuje vykonať ÚPVS SSO mimo slovensko-sk-api a poslať na API iba SAML assertion.  V parametri `token` bude zaslaný OBO (On-Behalf-Of) token použiteľný na získanie údajov o prihlásenom používateľovi alebo na volanie ďaľších rozhraní v mene prihláseného používateľa.
   * @summary Prihlási používateľa pomocou SAML assertion
   * @param {LoginPostRequest} loginPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrihlasovaniePomocouEIDApi
   */
  public loginPost(loginPostRequest: LoginPostRequest, options?: RawAxiosRequestConfig) {
    return PrihlasovaniePomocouEIDApiFp(this.configuration)
      .loginPost(loginPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odhlási používateľa pomocou slovensko.sk (ÚPVS).  Po úspešnom odhlásení nasleduje presmerovanie späť na callback URL tretej strany nastavený v premenných prostredia API (LOGOUT_CALLBACK_URL).  Ak URL obsahuje callback (pri odhlásení iniciovanom zo strany ÚPVS), je potrebné spraviť redirect na callback.
   * @summary Odhlási používateľa
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PrihlasovaniePomocouEIDApi
   */
  public logoutGet(options?: RawAxiosRequestConfig) {
    return PrihlasovaniePomocouEIDApiFp(this.configuration)
      .logoutGet(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StavKomponentuMonitoringApi - axios parameter creator
 * @export
 */
export const StavKomponentuMonitoringApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Vráti stav komponentu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/health`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StavKomponentuMonitoringApi - functional programming interface
 * @export
 */
export const StavKomponentuMonitoringApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StavKomponentuMonitoringApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Vráti stav komponentu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Health>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StavKomponentuMonitoringApi.healthGet']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StavKomponentuMonitoringApi - factory interface
 * @export
 */
export const StavKomponentuMonitoringApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StavKomponentuMonitoringApiFp(configuration)
  return {
    /**
     *
     * @summary Vráti stav komponentu
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthGet(options?: RawAxiosRequestConfig): AxiosPromise<Health> {
      return localVarFp.healthGet(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * StavKomponentuMonitoringApi - object-oriented interface
 * @export
 * @class StavKomponentuMonitoringApi
 * @extends {BaseAPI}
 */
export class StavKomponentuMonitoringApi extends BaseAPI {
  /**
   *
   * @summary Vráti stav komponentu
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StavKomponentuMonitoringApi
   */
  public healthGet(options?: RawAxiosRequestConfig) {
    return StavKomponentuMonitoringApiFp(this.configuration)
      .healthGet(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UniverzlneSynchrnneRozhranieSluiebPVSApi - axios parameter creator
 * @export
 */
export const UniverzlneSynchrnneRozhranieSluiebPVSApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Vráti odpoveď synchrónnej služby ÚPVS.
     * @summary Vráti odpoveď synchrónnej služby ÚPVS
     * @param {string} accept
     * @param {ApiUsrPostRequest} apiUsrPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiUsrPost: async (
      accept: string,
      apiUsrPostRequest: ApiUsrPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accept' is not null or undefined
      assertParamExists('apiUsrPost', 'accept', accept)
      // verify required parameter 'apiUsrPostRequest' is not null or undefined
      assertParamExists('apiUsrPost', 'apiUsrPostRequest', apiUsrPostRequest)
      const localVarPath = `/api/usr`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      if (accept != null) {
        localVarHeaderParameter['Accept'] = String(accept)
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiUsrPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UniverzlneSynchrnneRozhranieSluiebPVSApi - functional programming interface
 * @export
 */
export const UniverzlneSynchrnneRozhranieSluiebPVSApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UniverzlneSynchrnneRozhranieSluiebPVSApiAxiosParamCreator(configuration)
  return {
    /**
     * Vráti odpoveď synchrónnej služby ÚPVS.
     * @summary Vráti odpoveď synchrónnej služby ÚPVS
     * @param {string} accept
     * @param {ApiUsrPostRequest} apiUsrPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiUsrPost(
      accept: string,
      apiUsrPostRequest: ApiUsrPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiUsrPost(
        accept,
        apiUsrPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UniverzlneSynchrnneRozhranieSluiebPVSApi.apiUsrPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UniverzlneSynchrnneRozhranieSluiebPVSApi - factory interface
 * @export
 */
export const UniverzlneSynchrnneRozhranieSluiebPVSApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UniverzlneSynchrnneRozhranieSluiebPVSApiFp(configuration)
  return {
    /**
     * Vráti odpoveď synchrónnej služby ÚPVS.
     * @summary Vráti odpoveď synchrónnej služby ÚPVS
     * @param {string} accept
     * @param {ApiUsrPostRequest} apiUsrPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiUsrPost(
      accept: string,
      apiUsrPostRequest: ApiUsrPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .apiUsrPost(accept, apiUsrPostRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UniverzlneSynchrnneRozhranieSluiebPVSApi - object-oriented interface
 * @export
 * @class UniverzlneSynchrnneRozhranieSluiebPVSApi
 * @extends {BaseAPI}
 */
export class UniverzlneSynchrnneRozhranieSluiebPVSApi extends BaseAPI {
  /**
   * Vráti odpoveď synchrónnej služby ÚPVS.
   * @summary Vráti odpoveď synchrónnej služby ÚPVS
   * @param {string} accept
   * @param {ApiUsrPostRequest} apiUsrPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UniverzlneSynchrnneRozhranieSluiebPVSApi
   */
  public apiUsrPost(
    accept: string,
    apiUsrPostRequest: ApiUsrPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return UniverzlneSynchrnneRozhranieSluiebPVSApiFp(this.configuration)
      .apiUsrPost(accept, apiUsrPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * VyhadvanieIdenttDostupnLenPreOVMApi - axios parameter creator
 * @export
 */
export const VyhadvanieIdenttDostupnLenPreOVMApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Vráti identitu.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vráti identitu
     * @param {string} id ID identity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiIamIdentitiesIdGet: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('apiIamIdentitiesIdGet', 'id', id)
      const localVarPath = `/api/iam/identities/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vyhľadá identity podľa kritérií.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vyhľadá identity podľa kritérií
     * @param {ApiIamIdentitiesSearchPostRequest} apiIamIdentitiesSearchPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiIamIdentitiesSearchPost: async (
      apiIamIdentitiesSearchPostRequest: ApiIamIdentitiesSearchPostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiIamIdentitiesSearchPostRequest' is not null or undefined
      assertParamExists(
        'apiIamIdentitiesSearchPost',
        'apiIamIdentitiesSearchPostRequest',
        apiIamIdentitiesSearchPostRequest,
      )
      const localVarPath = `/api/iam/identities/search`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiIamIdentitiesSearchPostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VyhadvanieIdenttDostupnLenPreOVMApi - functional programming interface
 * @export
 */
export const VyhadvanieIdenttDostupnLenPreOVMApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    VyhadvanieIdenttDostupnLenPreOVMApiAxiosParamCreator(configuration)
  return {
    /**
     * Vráti identitu.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vráti identitu
     * @param {string} id ID identity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiIamIdentitiesIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiIamIdentitiesIdGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiIamIdentitiesIdGet(id, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['VyhadvanieIdenttDostupnLenPreOVMApi.apiIamIdentitiesIdGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vyhľadá identity podľa kritérií.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vyhľadá identity podľa kritérií
     * @param {ApiIamIdentitiesSearchPostRequest} apiIamIdentitiesSearchPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiIamIdentitiesSearchPost(
      apiIamIdentitiesSearchPostRequest: ApiIamIdentitiesSearchPostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiIamIdentitiesIdGet200Response>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiIamIdentitiesSearchPost(
        apiIamIdentitiesSearchPostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['VyhadvanieIdenttDostupnLenPreOVMApi.apiIamIdentitiesSearchPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * VyhadvanieIdenttDostupnLenPreOVMApi - factory interface
 * @export
 */
export const VyhadvanieIdenttDostupnLenPreOVMApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = VyhadvanieIdenttDostupnLenPreOVMApiFp(configuration)
  return {
    /**
     * Vráti identitu.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vráti identitu
     * @param {string} id ID identity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiIamIdentitiesIdGet(
      id: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiIamIdentitiesIdGet200Response> {
      return localVarFp
        .apiIamIdentitiesIdGet(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vyhľadá identity podľa kritérií.  Pozor, volanie je dostupné len pre OVM.
     * @summary Vyhľadá identity podľa kritérií
     * @param {ApiIamIdentitiesSearchPostRequest} apiIamIdentitiesSearchPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiIamIdentitiesSearchPost(
      apiIamIdentitiesSearchPostRequest: ApiIamIdentitiesSearchPostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<ApiIamIdentitiesIdGet200Response>> {
      return localVarFp
        .apiIamIdentitiesSearchPost(apiIamIdentitiesSearchPostRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * VyhadvanieIdenttDostupnLenPreOVMApi - object-oriented interface
 * @export
 * @class VyhadvanieIdenttDostupnLenPreOVMApi
 * @extends {BaseAPI}
 */
export class VyhadvanieIdenttDostupnLenPreOVMApi extends BaseAPI {
  /**
   * Vráti identitu.  Pozor, volanie je dostupné len pre OVM.
   * @summary Vráti identitu
   * @param {string} id ID identity.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VyhadvanieIdenttDostupnLenPreOVMApi
   */
  public apiIamIdentitiesIdGet(id: string, options?: RawAxiosRequestConfig) {
    return VyhadvanieIdenttDostupnLenPreOVMApiFp(this.configuration)
      .apiIamIdentitiesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vyhľadá identity podľa kritérií.  Pozor, volanie je dostupné len pre OVM.
   * @summary Vyhľadá identity podľa kritérií
   * @param {ApiIamIdentitiesSearchPostRequest} apiIamIdentitiesSearchPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VyhadvanieIdenttDostupnLenPreOVMApi
   */
  public apiIamIdentitiesSearchPost(
    apiIamIdentitiesSearchPostRequest: ApiIamIdentitiesSearchPostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return VyhadvanieIdenttDostupnLenPreOVMApiFp(this.configuration)
      .apiIamIdentitiesSearchPost(apiIamIdentitiesSearchPostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ZasielaniePodanApi - axios parameter creator
 * @export
 */
export const ZasielaniePodanApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Vráti dokument súvisiaci s formulárom. Napr. XSD schému, XSLT transformáciu.
     * @summary Vráti dokument súvisiaci s formulárom
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {ApiEformFormTemplateRelatedDocumentGetTypeEnum} type Verzia formuláru.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEformFormTemplateRelatedDocumentGet: async (
      identifier: string,
      version: string,
      type: ApiEformFormTemplateRelatedDocumentGetTypeEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'identifier' is not null or undefined
      assertParamExists('apiEformFormTemplateRelatedDocumentGet', 'identifier', identifier)
      // verify required parameter 'version' is not null or undefined
      assertParamExists('apiEformFormTemplateRelatedDocumentGet', 'version', version)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('apiEformFormTemplateRelatedDocumentGet', 'type', type)
      const localVarPath = `/api/eform/form_template_related_document`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (identifier !== undefined) {
        localVarQueryParameter['identifier'] = identifier
      }

      if (version !== undefined) {
        localVarQueryParameter['version'] = version
      }

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Vráti stav formuláru.
     * @summary Vráti stav formuláru
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEformStatusGet: async (
      identifier: string,
      version: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'identifier' is not null or undefined
      assertParamExists('apiEformStatusGet', 'identifier', identifier)
      // verify required parameter 'version' is not null or undefined
      assertParamExists('apiEformStatusGet', 'version', version)
      const localVarPath = `/api/eform/status`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (identifier !== undefined) {
        localVarQueryParameter['identifier'] = identifier
      }

      if (version !== undefined) {
        localVarQueryParameter['version'] = version
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Zvaliduje dáta voči definícii formuláru.
     * @summary Zvaliduje dáta voči definícii formuláru
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {ApiEformValidatePostRequest} apiEformValidatePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEformValidatePost: async (
      identifier: string,
      version: string,
      apiEformValidatePostRequest: ApiEformValidatePostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'identifier' is not null or undefined
      assertParamExists('apiEformValidatePost', 'identifier', identifier)
      // verify required parameter 'version' is not null or undefined
      assertParamExists('apiEformValidatePost', 'version', version)
      // verify required parameter 'apiEformValidatePostRequest' is not null or undefined
      assertParamExists(
        'apiEformValidatePost',
        'apiEformValidatePostRequest',
        apiEformValidatePostRequest,
      )
      const localVarPath = `/api/eform/validate`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (identifier !== undefined) {
        localVarQueryParameter['identifier'] = identifier
      }

      if (version !== undefined) {
        localVarQueryParameter['version'] = version
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiEformValidatePostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Pripraví odosielanie podania aj po vypršaní WebSSO session.  Vráti OBO (On-Behalf-Of) token použiteľný na odoslanie podaní prihláseného používateľa aj po vypršaní WebSSO session. OBO token je platný 120 minút.
     * @summary Pripraví odosielanie podania aj po vypršaní WebSSO session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkPrepareForLaterReceiveGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/sktalk/prepare_for_later_receive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API + OBO Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle SKTalk správu a uloží ju medzi odoslané správy v schránke.  Nakoľko ide o dve operácie, ktoré nie je možné transakčne spojiť, možu nastať prípady keď odoslanie prebehne úspešne ale uloženie zlyhá.  Volanie neuloží správu medzi odoslané ak výsledok odoslania nemá hodnotu `0` alebo ak prišlo k vypršaniu času požiadavky na ÚPVS.
     * @summary Odošle správu a uloží ju medzi odoslané správy v schránke
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkReceiveAndSaveToOutboxPost: async (
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiSktalkReceivePostRequest' is not null or undefined
      assertParamExists(
        'apiSktalkReceiveAndSaveToOutboxPost',
        'apiSktalkReceivePostRequest',
        apiSktalkReceivePostRequest,
      )
      const localVarPath = `/api/sktalk/receive_and_save_to_outbox`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication API + OBO Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiSktalkReceivePostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Odošle SKTalk správu.  Za normálnych okolností je potrebné odoslanú správu následne uložiť medzi odoslané správy v schránke. Využite endpoint `api/sktalk/save_to_outbox` alebo `api/sktalk/receive_and_save_to_outbox`.
     * @summary Odošle správu
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkReceivePost: async (
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiSktalkReceivePostRequest' is not null or undefined
      assertParamExists(
        'apiSktalkReceivePost',
        'apiSktalkReceivePostRequest',
        apiSktalkReceivePostRequest,
      )
      const localVarPath = `/api/sktalk/receive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication API + OBO Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiSktalkReceivePostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Uloží SKTalk správu medzi odoslané správy v schránke.  Za normálnych okolností je potrebné uloženú správu predtým odoslať. Využite endpoint `api/sktalk/receive` alebo `api/sktalk/receive_and_save_to_outbox`.
     * @summary Uloží správu medzi odoslané správy v schránke
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkSaveToOutboxPost: async (
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'apiSktalkReceivePostRequest' is not null or undefined
      assertParamExists(
        'apiSktalkSaveToOutboxPost',
        'apiSktalkReceivePostRequest',
        apiSktalkReceivePostRequest,
      )
      const localVarPath = `/api/sktalk/save_to_outbox`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication API Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      // authentication API + OBO Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        apiSktalkReceivePostRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ZasielaniePodanApi - functional programming interface
 * @export
 */
export const ZasielaniePodanApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ZasielaniePodanApiAxiosParamCreator(configuration)
  return {
    /**
     * Vráti dokument súvisiaci s formulárom. Napr. XSD schému, XSLT transformáciu.
     * @summary Vráti dokument súvisiaci s formulárom
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {ApiEformFormTemplateRelatedDocumentGetTypeEnum} type Verzia formuláru.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEformFormTemplateRelatedDocumentGet(
      identifier: string,
      version: string,
      type: ApiEformFormTemplateRelatedDocumentGetTypeEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiEformFormTemplateRelatedDocumentGet200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiEformFormTemplateRelatedDocumentGet(
          identifier,
          version,
          type,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanApi.apiEformFormTemplateRelatedDocumentGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Vráti stav formuláru.
     * @summary Vráti stav formuláru
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEformStatusGet(
      identifier: string,
      version: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiEformStatusGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEformStatusGet(
        identifier,
        version,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanApi.apiEformStatusGet']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Zvaliduje dáta voči definícii formuláru.
     * @summary Zvaliduje dáta voči definícii formuláru
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {ApiEformValidatePostRequest} apiEformValidatePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiEformValidatePost(
      identifier: string,
      version: string,
      apiEformValidatePostRequest: ApiEformValidatePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiEformValidatePost200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiEformValidatePost(
        identifier,
        version,
        apiEformValidatePostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanApi.apiEformValidatePost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Pripraví odosielanie podania aj po vypršaní WebSSO session.  Vráti OBO (On-Behalf-Of) token použiteľný na odoslanie podaní prihláseného používateľa aj po vypršaní WebSSO session. OBO token je platný 120 minút.
     * @summary Pripraví odosielanie podania aj po vypršaní WebSSO session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSktalkPrepareForLaterReceiveGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginPost200Response>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.apiSktalkPrepareForLaterReceiveGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanApi.apiSktalkPrepareForLaterReceiveGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle SKTalk správu a uloží ju medzi odoslané správy v schránke.  Nakoľko ide o dve operácie, ktoré nie je možné transakčne spojiť, možu nastať prípady keď odoslanie prebehne úspešne ale uloženie zlyhá.  Volanie neuloží správu medzi odoslané ak výsledok odoslania nemá hodnotu `0` alebo ak prišlo k vypršaniu času požiadavky na ÚPVS.
     * @summary Odošle správu a uloží ju medzi odoslané správy v schránke
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSktalkReceiveAndSaveToOutboxPost(
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveAndSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSktalkReceiveAndSaveToOutboxPost(
        apiSktalkReceivePostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanApi.apiSktalkReceiveAndSaveToOutboxPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Odošle SKTalk správu.  Za normálnych okolností je potrebné odoslanú správu následne uložiť medzi odoslané správy v schránke. Využite endpoint `api/sktalk/save_to_outbox` alebo `api/sktalk/receive_and_save_to_outbox`.
     * @summary Odošle správu
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSktalkReceivePost(
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkReceiveResult>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSktalkReceivePost(
        apiSktalkReceivePostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanApi.apiSktalkReceivePost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Uloží SKTalk správu medzi odoslané správy v schránke.  Za normálnych okolností je potrebné uloženú správu predtým odoslať. Využite endpoint `api/sktalk/receive` alebo `api/sktalk/receive_and_save_to_outbox`.
     * @summary Uloží správu medzi odoslané správy v schránke
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async apiSktalkSaveToOutboxPost(
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SktalkSaveToOutboxResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.apiSktalkSaveToOutboxPost(
        apiSktalkReceivePostRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanApi.apiSktalkSaveToOutboxPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ZasielaniePodanApi - factory interface
 * @export
 */
export const ZasielaniePodanApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ZasielaniePodanApiFp(configuration)
  return {
    /**
     * Vráti dokument súvisiaci s formulárom. Napr. XSD schému, XSLT transformáciu.
     * @summary Vráti dokument súvisiaci s formulárom
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {ApiEformFormTemplateRelatedDocumentGetTypeEnum} type Verzia formuláru.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEformFormTemplateRelatedDocumentGet(
      identifier: string,
      version: string,
      type: ApiEformFormTemplateRelatedDocumentGetTypeEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiEformFormTemplateRelatedDocumentGet200Response> {
      return localVarFp
        .apiEformFormTemplateRelatedDocumentGet(identifier, version, type, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Vráti stav formuláru.
     * @summary Vráti stav formuláru
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEformStatusGet(
      identifier: string,
      version: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiEformStatusGet200Response> {
      return localVarFp
        .apiEformStatusGet(identifier, version, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Zvaliduje dáta voči definícii formuláru.
     * @summary Zvaliduje dáta voči definícii formuláru
     * @param {string} identifier Identifikátor formuláru.
     * @param {string} version Verzia formuláru.
     * @param {ApiEformValidatePostRequest} apiEformValidatePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiEformValidatePost(
      identifier: string,
      version: string,
      apiEformValidatePostRequest: ApiEformValidatePostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ApiEformValidatePost200Response> {
      return localVarFp
        .apiEformValidatePost(identifier, version, apiEformValidatePostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Pripraví odosielanie podania aj po vypršaní WebSSO session.  Vráti OBO (On-Behalf-Of) token použiteľný na odoslanie podaní prihláseného používateľa aj po vypršaní WebSSO session. OBO token je platný 120 minút.
     * @summary Pripraví odosielanie podania aj po vypršaní WebSSO session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkPrepareForLaterReceiveGet(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<LoginPost200Response> {
      return localVarFp
        .apiSktalkPrepareForLaterReceiveGet(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle SKTalk správu a uloží ju medzi odoslané správy v schránke.  Nakoľko ide o dve operácie, ktoré nie je možné transakčne spojiť, možu nastať prípady keď odoslanie prebehne úspešne ale uloženie zlyhá.  Volanie neuloží správu medzi odoslané ak výsledok odoslania nemá hodnotu `0` alebo ak prišlo k vypršaniu času požiadavky na ÚPVS.
     * @summary Odošle správu a uloží ju medzi odoslané správy v schránke
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkReceiveAndSaveToOutboxPost(
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveAndSaveToOutboxResult> {
      return localVarFp
        .apiSktalkReceiveAndSaveToOutboxPost(apiSktalkReceivePostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Odošle SKTalk správu.  Za normálnych okolností je potrebné odoslanú správu následne uložiť medzi odoslané správy v schránke. Využite endpoint `api/sktalk/save_to_outbox` alebo `api/sktalk/receive_and_save_to_outbox`.
     * @summary Odošle správu
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkReceivePost(
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkReceiveResult> {
      return localVarFp
        .apiSktalkReceivePost(apiSktalkReceivePostRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Uloží SKTalk správu medzi odoslané správy v schránke.  Za normálnych okolností je potrebné uloženú správu predtým odoslať. Využite endpoint `api/sktalk/receive` alebo `api/sktalk/receive_and_save_to_outbox`.
     * @summary Uloží správu medzi odoslané správy v schránke
     * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    apiSktalkSaveToOutboxPost(
      apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SktalkSaveToOutboxResult> {
      return localVarFp
        .apiSktalkSaveToOutboxPost(apiSktalkReceivePostRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ZasielaniePodanApi - object-oriented interface
 * @export
 * @class ZasielaniePodanApi
 * @extends {BaseAPI}
 */
export class ZasielaniePodanApi extends BaseAPI {
  /**
   * Vráti dokument súvisiaci s formulárom. Napr. XSD schému, XSLT transformáciu.
   * @summary Vráti dokument súvisiaci s formulárom
   * @param {string} identifier Identifikátor formuláru.
   * @param {string} version Verzia formuláru.
   * @param {ApiEformFormTemplateRelatedDocumentGetTypeEnum} type Verzia formuláru.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanApi
   */
  public apiEformFormTemplateRelatedDocumentGet(
    identifier: string,
    version: string,
    type: ApiEformFormTemplateRelatedDocumentGetTypeEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return ZasielaniePodanApiFp(this.configuration)
      .apiEformFormTemplateRelatedDocumentGet(identifier, version, type, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Vráti stav formuláru.
   * @summary Vráti stav formuláru
   * @param {string} identifier Identifikátor formuláru.
   * @param {string} version Verzia formuláru.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanApi
   */
  public apiEformStatusGet(identifier: string, version: string, options?: RawAxiosRequestConfig) {
    return ZasielaniePodanApiFp(this.configuration)
      .apiEformStatusGet(identifier, version, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Zvaliduje dáta voči definícii formuláru.
   * @summary Zvaliduje dáta voči definícii formuláru
   * @param {string} identifier Identifikátor formuláru.
   * @param {string} version Verzia formuláru.
   * @param {ApiEformValidatePostRequest} apiEformValidatePostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanApi
   */
  public apiEformValidatePost(
    identifier: string,
    version: string,
    apiEformValidatePostRequest: ApiEformValidatePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ZasielaniePodanApiFp(this.configuration)
      .apiEformValidatePost(identifier, version, apiEformValidatePostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Pripraví odosielanie podania aj po vypršaní WebSSO session.  Vráti OBO (On-Behalf-Of) token použiteľný na odoslanie podaní prihláseného používateľa aj po vypršaní WebSSO session. OBO token je platný 120 minút.
   * @summary Pripraví odosielanie podania aj po vypršaní WebSSO session
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanApi
   */
  public apiSktalkPrepareForLaterReceiveGet(options?: RawAxiosRequestConfig) {
    return ZasielaniePodanApiFp(this.configuration)
      .apiSktalkPrepareForLaterReceiveGet(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle SKTalk správu a uloží ju medzi odoslané správy v schránke.  Nakoľko ide o dve operácie, ktoré nie je možné transakčne spojiť, možu nastať prípady keď odoslanie prebehne úspešne ale uloženie zlyhá.  Volanie neuloží správu medzi odoslané ak výsledok odoslania nemá hodnotu `0` alebo ak prišlo k vypršaniu času požiadavky na ÚPVS.
   * @summary Odošle správu a uloží ju medzi odoslané správy v schránke
   * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanApi
   */
  public apiSktalkReceiveAndSaveToOutboxPost(
    apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ZasielaniePodanApiFp(this.configuration)
      .apiSktalkReceiveAndSaveToOutboxPost(apiSktalkReceivePostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Odošle SKTalk správu.  Za normálnych okolností je potrebné odoslanú správu následne uložiť medzi odoslané správy v schránke. Využite endpoint `api/sktalk/save_to_outbox` alebo `api/sktalk/receive_and_save_to_outbox`.
   * @summary Odošle správu
   * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanApi
   */
  public apiSktalkReceivePost(
    apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ZasielaniePodanApiFp(this.configuration)
      .apiSktalkReceivePost(apiSktalkReceivePostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Uloží SKTalk správu medzi odoslané správy v schránke.  Za normálnych okolností je potrebné uloženú správu predtým odoslať. Využite endpoint `api/sktalk/receive` alebo `api/sktalk/receive_and_save_to_outbox`.
   * @summary Uloží správu medzi odoslané správy v schránke
   * @param {ApiSktalkReceivePostRequest} apiSktalkReceivePostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanApi
   */
  public apiSktalkSaveToOutboxPost(
    apiSktalkReceivePostRequest: ApiSktalkReceivePostRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ZasielaniePodanApiFp(this.configuration)
      .apiSktalkSaveToOutboxPost(apiSktalkReceivePostRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ApiEformFormTemplateRelatedDocumentGetTypeEnum = {
  ClsFXsdEdoc: 'CLS_F_XSD_EDOC',
  ClsFXsltTxtSgn: 'CLS_F_XSLT_TXT_SGN',
} as const
export type ApiEformFormTemplateRelatedDocumentGetTypeEnum =
  (typeof ApiEformFormTemplateRelatedDocumentGetTypeEnum)[keyof typeof ApiEformFormTemplateRelatedDocumentGetTypeEnum]

/**
 * ZasielaniePodanAdministrciaApi - axios parameter creator
 * @export
 */
export const ZasielaniePodanAdministrciaApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Spustí manuálnu aktualizáciu lokálneho úložiska všetkých formulárov. Za normálnych okolností sa spúšťa automaticky a nie je ho potrebné spúštať manuálne.
     * @summary Spustí synchronizáciu formulárov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationEformSynchronizeGet: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/administration/eform/synchronize`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Administration Token required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ZasielaniePodanAdministrciaApi - functional programming interface
 * @export
 */
export const ZasielaniePodanAdministrciaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ZasielaniePodanAdministrciaApiAxiosParamCreator(configuration)
  return {
    /**
     * Spustí manuálnu aktualizáciu lokálneho úložiska všetkých formulárov. Za normálnych okolností sa spúšťa automaticky a nie je ho potrebné spúštať manuálne.
     * @summary Spustí synchronizáciu formulárov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async administrationEformSynchronizeGet(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.administrationEformSynchronizeGet(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ZasielaniePodanAdministrciaApi.administrationEformSynchronizeGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ZasielaniePodanAdministrciaApi - factory interface
 * @export
 */
export const ZasielaniePodanAdministrciaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ZasielaniePodanAdministrciaApiFp(configuration)
  return {
    /**
     * Spustí manuálnu aktualizáciu lokálneho úložiska všetkých formulárov. Za normálnych okolností sa spúšťa automaticky a nie je ho potrebné spúštať manuálne.
     * @summary Spustí synchronizáciu formulárov
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    administrationEformSynchronizeGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .administrationEformSynchronizeGet(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ZasielaniePodanAdministrciaApi - object-oriented interface
 * @export
 * @class ZasielaniePodanAdministrciaApi
 * @extends {BaseAPI}
 */
export class ZasielaniePodanAdministrciaApi extends BaseAPI {
  /**
   * Spustí manuálnu aktualizáciu lokálneho úložiska všetkých formulárov. Za normálnych okolností sa spúšťa automaticky a nie je ho potrebné spúštať manuálne.
   * @summary Spustí synchronizáciu formulárov
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ZasielaniePodanAdministrciaApi
   */
  public administrationEformSynchronizeGet(options?: RawAxiosRequestConfig) {
    return ZasielaniePodanAdministrciaApiFp(this.configuration)
      .administrationEformSynchronizeGet(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
