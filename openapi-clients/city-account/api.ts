/* tslint:disable */
/* eslint-disable */
/**
 * User Module - city account
 * User module use for store additional data for users and authentication against Azure AD
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

export interface ChangeEmailRequestDto {
  /**
   * New email for a user
   */
  newEmail: string
}
export interface ClientInfoResponseDto {
  /**
   * Human-readable name for the client (prefix from OAUTH2_CLIENT_LIST)
   */
  name: string
  /**
   * Human-readable title for the client (for frontend display)
   */
  title?: string
}
export interface CognitoGetUserData {
  /**
   * Id from cognito
   */
  sub: string
  /**
   * Is email verified in cognito?
   */
  email_verified?: string
  /**
   * Usually name of the company
   */
  name?: string
  /**
   * Which type of verified tier it is?
   */
  'custom:tier'?: CognitoGetUserDataCustomTierEnum
  /**
   * Which type of account it is?
   */
  'custom:account_type': CognitoGetUserDataCustomAccountTypeEnum
  /**
   * client_id of the oAuth origin
   */
  'custom:origin_client_id'?: string
  /**
   * Name of the oAuth origin corresponding to the custom:origin_client_id
   */
  'custom:origin_client_name'?: string
  /**
   * First name
   */
  given_name?: string
  /**
   * Last name
   */
  family_name?: string
  /**
   * email
   */
  email: string
  /**
   * User Id from cognito, same as sub
   */
  idUser: string
  /**
   * User create date
   */
  UserCreateDate?: string
  /**
   * User updated date
   */
  UserLastModifiedDate?: string
  /**
   * Is user enabled?
   */
  Enabled: boolean
  /**
   * Cognito confirmation statue
   */
  UserStatus?: CognitoGetUserDataUserStatusEnum
}

export const CognitoGetUserDataCustomTierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type CognitoGetUserDataCustomTierEnum =
  (typeof CognitoGetUserDataCustomTierEnum)[keyof typeof CognitoGetUserDataCustomTierEnum]
export const CognitoGetUserDataCustomAccountTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type CognitoGetUserDataCustomAccountTypeEnum =
  (typeof CognitoGetUserDataCustomAccountTypeEnum)[keyof typeof CognitoGetUserDataCustomAccountTypeEnum]
export const CognitoGetUserDataUserStatusEnum = {
  Archived: 'ARCHIVED',
  Compromised: 'COMPROMISED',
  Confirmed: 'CONFIRMED',
  ForceChangePassword: 'FORCE_CHANGE_PASSWORD',
  ResetRequired: 'RESET_REQUIRED',
  Unconfirmed: 'UNCONFIRMED',
  Unknown: 'UNKNOWN',
} as const

export type CognitoGetUserDataUserStatusEnum =
  (typeof CognitoGetUserDataUserStatusEnum)[keyof typeof CognitoGetUserDataUserStatusEnum]

/**
 * Account type from Cognito
 */

export const ContactAndIdInfoTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type ContactAndIdInfoTypeEnum =
  (typeof ContactAndIdInfoTypeEnum)[keyof typeof ContactAndIdInfoTypeEnum]

export interface DeactivateAccountResponseDto {
  /**
   * Marks if the operation has been successful
   */
  success: boolean
  /**
   * Status of the anonymization of user in bloomreach
   */
  bloomreachRemoved: DeactivateAccountResponseDtoBloomreachRemovedEnum
  /**
   * Status of the removal of tax delivery methods in Noris. If false, there was an error. If true it was successful, or the user is not a tax payer in Noris.
   */
  taxDeliveryMethodsRemoved: boolean
}

export const DeactivateAccountResponseDtoBloomreachRemovedEnum = {
  NotFound: 'NOT_FOUND',
  NotActive: 'NOT_ACTIVE',
  Error: 'ERROR',
  Success: 'SUCCESS',
} as const

export type DeactivateAccountResponseDtoBloomreachRemovedEnum =
  (typeof DeactivateAccountResponseDtoBloomreachRemovedEnum)[keyof typeof DeactivateAccountResponseDtoBloomreachRemovedEnum]

export interface DpbUserDto {
  /**
   * User ID
   */
  id: string
  /**
   * User email
   */
  email: string
  /**
   * Is email verified in cognito?
   */
  email_verified?: string
  /**
   * Account type
   */
  account_type: DpbUserDtoAccountTypeEnum
  /**
   * Name (usually company name for legal entities)
   */
  name?: string
  /**
   * Given name (first name)
   */
  given_name?: string
  /**
   * Family name (last name)
   */
  family_name?: string
}

export const DpbUserDtoAccountTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type DpbUserDtoAccountTypeEnum =
  (typeof DpbUserDtoAccountTypeEnum)[keyof typeof DpbUserDtoAccountTypeEnum]

/**
 * Type of Gdpr category
 */

export const GDPRCategoryEnum = {
  City: 'CITY',
  Esbs: 'ESBS',
  Swimmingpools: 'SWIMMINGPOOLS',
  Taxes: 'TAXES',
  Init: 'INIT',
  Library: 'LIBRARY',
} as const

export type GDPRCategoryEnum = (typeof GDPRCategoryEnum)[keyof typeof GDPRCategoryEnum]

/**
 * Type of subType - unsubscribe or subscribe
 */

export const GDPRSubTypeEnum = {
  Subscribe: 'subscribe',
  Unsubscribe: 'unsubscribe',
} as const

export type GDPRSubTypeEnum = (typeof GDPRSubTypeEnum)[keyof typeof GDPRSubTypeEnum]

/**
 * Type of Gdpr subscription
 */

export const GDPRTypeEnum = {
  Analytics: 'ANALYTICS',
  Dataprocessing: 'DATAPROCESSING',
  FormalCommunication: 'FORMAL_COMMUNICATION',
  License: 'LICENSE',
  Marketing: 'MARKETING',
} as const

export type GDPRTypeEnum = (typeof GDPRTypeEnum)[keyof typeof GDPRTypeEnum]

export interface GdprDataDto {
  /**
   * Type of Gdpr subscription
   */
  type: GDPRTypeEnum
  /**
   * Type of Gdpr category
   */
  category: GDPRCategoryEnum
}

export interface GetNewVerifiedUsersBirthNumbersResponseDto {
  /**
   * List of birth numbers
   */
  birthNumbers: Array<string>
  /**
   * Next date to query.
   */
  nextSince: string
}
export interface GetUserDataByBirthNumbersBatchResponseDto {
  /**
   * A record of users keyed by their birth number
   */
  users: { [key: string]: ResponseUserByBirthNumberDto }
}
export interface LegalPersonContactAndIdInfoResponseDto {
  /**
   * External ID from Cognito
   */
  externalId: string
  /**
   * Account type from Cognito
   */
  accountType: ContactAndIdInfoTypeEnum
  /**
   * Email address
   */
  email?: string
  /**
   * Company name
   */
  name?: string
  /**
   * ICO (Company identification number)
   */
  ico?: string
}

export interface ManuallyVerifyUserRequestDto {
  /**
   * userBirthNumber
   */
  birthNumber: string
  /**
   * Ifo of the user
   */
  ifo?: string
  /**
   * ico
   */
  ico?: string
}
export interface MarkDeceasedAccountRequestDto {
  /**
   * List of birthnumbers/external IDs to mark as deceased
   */
  birthNumbers: Array<string>
}
export interface MarkDeceasedAccountResponseDto {
  /**
   * List of birth numbers with success marked for each data storage.
   */
  results: Array<MarkDeceasedAccountResponseItemDto>
}
export interface MarkDeceasedAccountResponseItemDto {
  /**
   * Birth number of the deceased person
   */
  birthNumber: string
  /**
   * Whether the user was successfully marked as deceased in the database
   */
  databaseMarked: boolean
  /**
   * Whether the user was successfully archived in Cognito / mail was changed.
   */
  cognitoArchived: boolean
  /**
   * Status of the anonymization of user in Bloomreach
   */
  bloomreachRemoved?: MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum
}

export const MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum = {
  NotFound: 'NOT_FOUND',
  NotActive: 'NOT_ACTIVE',
  Error: 'ERROR',
  Success: 'SUCCESS',
} as const

export type MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum =
  (typeof MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum)[keyof typeof MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum]

/**
 * Single ASCII error code per OAuth 2.0 specification (Authorization Endpoint)
 */

export const OAuth2AuthorizationErrorCode = {
  InvalidRequest: 'invalid_request',
  UnauthorizedClient: 'unauthorized_client',
  AccessDenied: 'access_denied',
  UnsupportedResponseType: 'unsupported_response_type',
  InvalidScope: 'invalid_scope',
  ServerError: 'server_error',
  TemporarilyUnavailable: 'temporarily_unavailable',
} as const

export type OAuth2AuthorizationErrorCode =
  (typeof OAuth2AuthorizationErrorCode)[keyof typeof OAuth2AuthorizationErrorCode]

export interface OAuth2AuthorizationErrorDto {
  /**
   * Single ASCII error code per OAuth 2.0 specification (Authorization Endpoint)
   */
  error: OAuth2AuthorizationErrorCode
  /**
   * Human-readable ASCII text providing additional information for debugging (not displayed to end-user)
   */
  error_description?: string
  /**
   * URI identifying a human-readable web page with information about the error
   */
  error_uri?: string
  /**
   * Exact value received from the client in the authorization request. REQUIRED if and only if the state parameter was present in the client authorization request. Only included when redirecting (not in direct error responses).
   */
  state?: string
}

/**
 * @type OAuth2ControllerTokenRequest
 */
export type OAuth2ControllerTokenRequest =
  | ({ grant_type: 'authorization_code' } & TokenRequestDto)
  | ({ grant_type: 'refresh_token' } & RefreshTokenRequestDto)

/**
 * Single ASCII error code per OAuth 2.0 specification (Token Endpoint)
 */

export const OAuth2TokenErrorCode = {
  InvalidRequest: 'invalid_request',
  InvalidClient: 'invalid_client',
  InvalidGrant: 'invalid_grant',
  UnauthorizedClient: 'unauthorized_client',
  UnsupportedGrantType: 'unsupported_grant_type',
  InvalidScope: 'invalid_scope',
} as const

export type OAuth2TokenErrorCode = (typeof OAuth2TokenErrorCode)[keyof typeof OAuth2TokenErrorCode]

export interface OAuth2TokenErrorDto {
  /**
   * Single ASCII error code per OAuth 2.0 specification (Token Endpoint)
   */
  error: OAuth2TokenErrorCode
  /**
   * Human-readable ASCII text providing additional information for debugging (not displayed to end-user)
   */
  error_description?: string
  /**
   * URI identifying a human-readable web page with information about the error
   */
  error_uri?: string
}

export interface OnlySuccessDto {
  /**
   * Marks if the operation has been successful
   */
  success: boolean
}
export interface RefreshTokenRequestDto {
  /**
   * Grant type, must be \"refresh_token\"
   */
  grant_type: RefreshTokenRequestDtoGrantTypeEnum
  /**
   * The refresh token issued by the authorization server
   */
  refresh_token: string
  /**
   * Space-delimited list of scopes (optional - should not request new scopes)
   */
  scope?: string
  /**
   * The client identifier. Required for client authentication; can be omitted if using HTTP Basic Authentication header
   */
  client_id?: string
  /**
   * The client secret. Required if client has a secret configured. Can be provided via HTTP Basic Authentication or this parameter
   */
  client_secret?: string
}

export const RefreshTokenRequestDtoGrantTypeEnum = {
  RefreshToken: 'refresh_token',
} as const

export type RefreshTokenRequestDtoGrantTypeEnum =
  (typeof RefreshTokenRequestDtoGrantTypeEnum)[keyof typeof RefreshTokenRequestDtoGrantTypeEnum]

export interface RequestBatchNewUserBirthNumbers {
  /**
   * Date to query.
   */
  since: string
  /**
   * Optionally specify maximum number to return. Will not return more than internal limit (100).
   */
  take?: number
}
export interface RequestBatchQueryUsersByBirthNumbersDto {
  /**
   * Birth numbers without slash which should be retrieved from user database.
   */
  birthNumbers: Array<string>
}
export interface RequestBodyValidateEdeskForUserIdsDto {
  /**
   * How many records to skip
   */
  offset?: number
}
export interface RequestBodyVerifyIdentityCardDto {
  /**
   * Birth number for check
   */
  birthNumber: string
  /**
   * String of identitiy card
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   */
  turnstileToken: string
}
export interface RequestBodyVerifyWithEidDto {
  /**
   * Token returned by https://fix.slovensko-sk-api.bratislava.sk/login
   */
  oboToken: string
}
export interface RequestBodyVerifyWithRpoDto {
  /**
   * ico
   */
  ico: string
  /**
   * Birth number of legal entity\'s executive
   */
  birthNumber: string
  /**
   * Identity card of legal entity\'s executive
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   */
  turnstileToken: string
}
export interface RequestGdprDataDto {
  gdprData: Array<GdprDataDto>
}
export interface RequestValidatePhysicalEntityRfoDto {
  /**
   * Id of the physical entity object in db
   */
  physicalEntityId: string
}
export interface ResponseCustomErrorVerificationEidDto {
  /**
   * status
   */
  status: string
  /**
   * Message about error
   */
  message: string
  /**
   * Error name for decoding.
   */
  errorName: ResponseCustomErrorVerificationEidDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationEidDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseCustomErrorVerificationEidDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum]

export interface ResponseCustomErrorVerificationIdentityCardDto {
  /**
   * status
   */
  status: string
  /**
   * Message about error
   */
  message: string
  /**
   * Error name for decoding.
   */
  errorName: ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum]

export interface ResponseGdprLegalPersonDataDto {
  /**
   * Type of Gdpr category
   */
  category: GDPRCategoryEnum
  /**
   * Type of Gdpr subscription
   */
  type: GDPRTypeEnum
  /**
   * Type of subType - unsubscribe or subscribe
   */
  subType: GDPRSubTypeEnum
}

export interface ResponseGdprUserDataDto {
  /**
   * Type of Gdpr category
   */
  category: GDPRCategoryEnum
  /**
   * Type of Gdpr subscription
   */
  type: GDPRTypeEnum
  /**
   * Type of subType - unsubscribe or subscribe
   */
  subType: GDPRSubTypeEnum
}

export interface ResponseInternalServerErrorDto {
  /**
   * statusCode
   */
  statusCode: number
  /**
   * Message about error
   */
  message: string
}
export interface ResponseLegalPersonDataDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Ico of company, which this user represents
   */
  ico: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
  /**
   * Subscription Data in array
   */
  gdprData: Array<ResponseGdprLegalPersonDataDto>
}
export interface ResponseLegalPersonDataSimpleDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Ico of company, which this user represents
   */
  ico: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
}
export interface ResponseNotFoundErrorVerificationIdentityCardDto {
  /**
   * status
   */
  status: string
  /**
   * Message about error
   */
  message: string
  /**
   * Error name for decoding.
   */
  errorName: string
}
export interface ResponseUserByBirthNumberDto {
  /**
   * userBirthNumber
   */
  birthNumber: string | null
  /**
   * email
   */
  email: string | null
  /**
   * Cognito Id
   */
  externalId: string | null
  /**
   * Special user attribute for user segmentation
   */
  userAttribute: object
  /**
   * Tier from cognito
   */
  cognitoAttributes?: object
  /**
   * Delivery method for tax documents at lock date
   */
  taxDeliveryMethodAtLockDate?: ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum | null
}

export const ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum = {
  Edesk: 'EDESK',
  CityAccount: 'CITY_ACCOUNT',
  Postal: 'POSTAL',
} as const

export type ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum =
  (typeof ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum)[keyof typeof ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum]

export interface ResponseUserDataBasicDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
  /**
   * State, if we can communicate user with email, or user have active e-desk slovensko.sk mail or we need to communicate with him with post. First we are looking for edesk, if he has registered edesk communication in NASES use edesk. If not, check if there is subscription for communication through email, use email from city account. Else use Postal communication.
   */
  officialCorrespondenceChannel: UserOfficialCorrespondenceChannelEnum | null
  /**
   * True if user was registered and have verified birth number until 2024-04-22. This date can be varied every year. In this date, user are sent into Noris and taxes will be generated.
   */
  wasVerifiedBeforeTaxDeadline: boolean
  /**
   * Can show banner for formal communication through email? If it was shown and clicked, it will not be shown.
   */
  showEmailCommunicationBanner: boolean
}

export interface ResponseUserDataDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
  /**
   * State, if we can communicate user with email, or user have active e-desk slovensko.sk mail or we need to communicate with him with post. First we are looking for edesk, if he has registered edesk communication in NASES use edesk. If not, check if there is subscription for communication through email, use email from city account. Else use Postal communication.
   */
  officialCorrespondenceChannel: UserOfficialCorrespondenceChannelEnum | null
  /**
   * True if user was registered and have verified birth number until 2024-04-22. This date can be varied every year. In this date, user are sent into Noris and taxes will be generated.
   */
  wasVerifiedBeforeTaxDeadline: boolean
  /**
   * Can show banner for formal communication through email? If it was shown and clicked, it will not be shown.
   */
  showEmailCommunicationBanner: boolean
  /**
   * Subscription Data in array
   */
  gdprData: Array<ResponseGdprUserDataDto>
}

export interface ResponseValidatePhysicalEntityRfoDto {
  /**
   * Entity data (updated if new info was found in state registry)
   */
  physicalEntity: object
  /**
   * Data received from RFO
   */
  rfoData: object
  /**
   * Data received from UPVS
   */
  upvsResult: object
}
export interface ResponseVerificationDto {
  /**
   * number of status code
   */
  statusCode: number
  /**
   * status
   */
  status: string
  /**
   * Message about update
   */
  message: string
  /**
   * Error if exists
   */
  errorName?: ResponseVerificationDtoErrorNameEnum
}

export const ResponseVerificationDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseVerificationDtoErrorNameEnum =
  (typeof ResponseVerificationDtoErrorNameEnum)[keyof typeof ResponseVerificationDtoErrorNameEnum]

export interface ResponseVerificationIdentityCardToQueueDto {
  /**
   * number of status code
   */
  statusCode: number
  /**
   * status
   */
  status: string
  /**
   * Message about update
   */
  message: ResponseVerificationIdentityCardToQueueDtoMessageEnum
  /**
   * Error if exists
   */
  errorName?: ResponseVerificationIdentityCardToQueueDtoErrorNameEnum
}

export const ResponseVerificationIdentityCardToQueueDtoMessageEnum = {
  SendToQueue: 'SendToQueue',
  AlreadyVerified: 'AlreadyVerified',
} as const

export type ResponseVerificationIdentityCardToQueueDtoMessageEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum]
export const ResponseVerificationIdentityCardToQueueDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseVerificationIdentityCardToQueueDtoErrorNameEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum]

export interface StoreTokensRequestDto {
  /**
   * Access token from user authentication (e.g., from Cognito)
   */
  access_token: string
  /**
   * ID token from user authentication
   */
  id_token?: string
  /**
   * Refresh token from user authentication
   */
  refresh_token: string
  /**
   * UUID of the authorization request stored in the database
   */
  payload: string
  /**
   * Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
   */
  client_id?: string
  /**
   * Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
   */
  redirect_uri?: string
  /**
   * Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
   */
  state?: string
}
export interface TokenRequestDto {
  /**
   * Grant type, must be \"authorization_code\"
   */
  grant_type: TokenRequestDtoGrantTypeEnum
  /**
   * Authorization code received from the authorization endpoint
   */
  code: string
  /**
   * Must be identical to the redirect_uri used in the authorization request
   */
  redirect_uri: string
  /**
   * Code verifier for PKCE (RFC 7636). Must match the code_challenge from authorization request
   */
  code_verifier: string
  /**
   * The client identifier. Required for client authentication; can be omitted if using HTTP Basic Authentication header
   */
  client_id?: string
  /**
   * The client secret. Required if client has a secret configured. Can be provided via HTTP Basic Authentication or this parameter
   */
  client_secret?: string
  /**
   * The value of the state parameter sent in authorization request (for verification)
   */
  state?: string
}

export const TokenRequestDtoGrantTypeEnum = {
  AuthorizationCode: 'authorization_code',
} as const

export type TokenRequestDtoGrantTypeEnum =
  (typeof TokenRequestDtoGrantTypeEnum)[keyof typeof TokenRequestDtoGrantTypeEnum]

export interface TokenResponseDto {
  /**
   * Access token issued by the authorization server
   */
  access_token: string
  /**
   * Token type, typically \"Bearer\"
   */
  token_type: TokenResponseDtoTokenTypeEnum
  /**
   * Refresh token used to obtain new access tokens
   */
  refresh_token?: string
  /**
   * Expiration time of the access token in seconds
   */
  expires_in: number
  /**
   * Space-delimited list of scopes granted
   */
  scope?: string
}

export const TokenResponseDtoTokenTypeEnum = {
  Bearer: 'Bearer',
} as const

export type TokenResponseDtoTokenTypeEnum =
  (typeof TokenResponseDtoTokenTypeEnum)[keyof typeof TokenResponseDtoTokenTypeEnum]

export interface UpsertUserRecordClientRequestDto {
  /**
   * Client that the user logged in through
   */
  loginClient: UpsertUserRecordClientRequestDtoLoginClientEnum
}

export const UpsertUserRecordClientRequestDtoLoginClientEnum = {
  Dpb: 'DPB',
  PaasMpa: 'PAAS_MPA',
  CityAccount: 'CITY_ACCOUNT',
} as const

export type UpsertUserRecordClientRequestDtoLoginClientEnum =
  (typeof UpsertUserRecordClientRequestDtoLoginClientEnum)[keyof typeof UpsertUserRecordClientRequestDtoLoginClientEnum]

export interface UserContactAndIdInfoResponseDto {
  /**
   * External ID from Cognito
   */
  externalId: string
  /**
   * Account type from Cognito
   */
  accountType: ContactAndIdInfoTypeEnum
  /**
   * Email address
   */
  email?: string
  /**
   * First name
   */
  firstName?: string
  /**
   * Last name
   */
  lastName?: string
  /**
   * Birth number
   */
  birthNumber?: string
}

/**
 * @type UserControllerChangeEmail200Response
 */
export type UserControllerChangeEmail200Response =
  | ResponseLegalPersonDataSimpleDto
  | ResponseUserDataBasicDto

/**
 * @type UserControllerGetOrCreateUser200Response
 */
export type UserControllerGetOrCreateUser200Response =
  | ResponseLegalPersonDataDto
  | ResponseUserDataDto

/**
 * @type UserIntegrationControllerGetContactAndIdInfoByExternalId200Response
 */
export type UserIntegrationControllerGetContactAndIdInfoByExternalId200Response =
  | ({ accountType: 'fo' } & UserContactAndIdInfoResponseDto)
  | ({ accountType: 'fo-p' } & LegalPersonContactAndIdInfoResponseDto)
  | ({ accountType: 'po' } & LegalPersonContactAndIdInfoResponseDto)

/**
 * State, if we can communicate user with email, or user have active e-desk slovensko.sk mail or we need to communicate with him with post. First we are looking for edesk, if he has registered edesk communication in NASES use edesk. If not, check if there is subscription for communication through email, use email from city account. Else use Postal communication.
 */

export const UserOfficialCorrespondenceChannelEnum = {
  Postal: 'POSTAL',
  Edesk: 'EDESK',
  Email: 'EMAIL',
} as const

export type UserOfficialCorrespondenceChannelEnum =
  (typeof UserOfficialCorrespondenceChannelEnum)[keyof typeof UserOfficialCorrespondenceChannelEnum]

export interface UserVerifyState {
  /**
   * Id of given user\'s email, if exists
   */
  externalId?: string | null
  /**
   * Type of user.
   */
  type?: UserVerifyStateTypeEnum
  /**
   * Marks if the user with given email is in database.
   */
  isInDatabase: boolean
  /**
   * Marks if the user with given email is in cognito.
   */
  isInCognito: boolean
  /**
   * Current cognito tier, marks the status of verifying.
   */
  cognitoTier?: UserVerifyStateCognitoTierEnum
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   */
  birthNumberAlreadyExists?: string
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   */
  birthNumberIcoAlreadyExists?: string
  /**
   * Marks if the user with given email is verified.
   */
  isVerified: boolean
  /**
   * Possible cause of the verify error.
   */
  possibleCause?: string
}

export const UserVerifyStateTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type UserVerifyStateTypeEnum =
  (typeof UserVerifyStateTypeEnum)[keyof typeof UserVerifyStateTypeEnum]
export const UserVerifyStateCognitoTierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type UserVerifyStateCognitoTierEnum =
  (typeof UserVerifyStateCognitoTierEnum)[keyof typeof UserVerifyStateCognitoTierEnum]

export interface ValidateEdeskForUserIdsResponseDto {
  /**
   * Number of users that were validated
   */
  validatedUsers: number
  /**
   * Temp debug data
   */
  enitites: object
}
export interface ValidatedUsersToPhysicalEntitiesResponseDto {
  existingPhysicalEntitiesUpdated: number
  newPhysicalEntitiesCreated: number
}
export interface VerificationDataForUser {
  /**
   * Id of the user in cognito.
   */
  userId: string
  /**
   * userBirthNumber
   */
  birthNumber: string
  /**
   * Id card used for verification.
   */
  idCard: string
  /**
   * Ico used for verification.
   */
  ico?: string
  /**
   * Created timestamp
   */
  verifyStart: string
}
export interface VerificationDataForUserResponseDto {
  /**
   * Id of the user in cognito.
   */
  externalId: string | null
  /**
   * Email of the user.
   */
  email: string | null
  /**
   * Verification data for the user in the last month. Ordered by start date descending.
   */
  verificationDataLastMonth: Array<VerificationDataForUser>
}

/**
 * ADMINApi - axios parameter creator
 */
export const ADMINApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerCheckUserVerifyState', 'email', email)
      const localVarPath = `/admin/status/user/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeactivateAccount: async (
      externalId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalId' is not null or undefined
      assertParamExists('adminControllerDeactivateAccount', 'externalId', externalId)
      const localVarPath = `/admin/deactivate/{externalId}`.replace(
        `{${'externalId'}}`,
        encodeURIComponent(String(externalId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
     * @summary Get birth numbers of newly verified users.
     * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetNewVerifiedUsersBirthNumbers: async (
      requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBatchNewUserBirthNumbers' is not null or undefined
      assertParamExists(
        'adminControllerGetNewVerifiedUsersBirthNumbers',
        'requestBatchNewUserBirthNumbers',
        requestBatchNewUserBirthNumbers,
      )
      const localVarPath = `/admin/get-verified-users-birth-numbers-batch`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBatchNewUserBirthNumbers,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber: async (
      birthNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('adminControllerGetUserDataByBirthNumber', 'birthNumber', birthNumber)
      const localVarPath = `/admin/userdata`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      if (birthNumber !== undefined) {
        localVarQueryParameter['birthNumber'] = birthNumber
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumbersBatch: async (
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBatchQueryUsersByBirthNumbersDto' is not null or undefined
      assertParamExists(
        'adminControllerGetUserDataByBirthNumbersBatch',
        'requestBatchQueryUsersByBirthNumbersDto',
        requestBatchQueryUsersByBirthNumbersDto,
      )
      const localVarPath = `/admin/userdata-batch`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBatchQueryUsersByBirthNumbersDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetVerificationDataForUser: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerGetVerificationDataForUser', 'email', email)
      const localVarPath = `/admin/user/id-card-verification-data/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
     * @summary Mark accounts as deceased
     * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerMarkAccountsAsDeceasedByBirthnumber: async (
      markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'markDeceasedAccountRequestDto' is not null or undefined
      assertParamExists(
        'adminControllerMarkAccountsAsDeceasedByBirthnumber',
        'markDeceasedAccountRequestDto',
        markDeceasedAccountRequestDto,
      )
      const localVarPath = `/admin/mark-deceased`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        markDeceasedAccountRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
     * @summary Will activate one time sync of all users from cognito to db at 3am
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerSyncCognitoToDb: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/activate-sync-cognito-to-db`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidateEdeskForUserIds: async (
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyValidateEdeskForUserIdsDto' is not null or undefined
      assertParamExists(
        'adminControllerValidateEdeskForUserIds',
        'requestBodyValidateEdeskForUserIdsDto',
        requestBodyValidateEdeskForUserIdsDto,
      )
      const localVarPath = `/admin/validate-edesk-by-cognito-where-first-try`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyValidateEdeskForUserIdsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatePhysicalEntityRfo: async (
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestValidatePhysicalEntityRfoDto' is not null or undefined
      assertParamExists(
        'adminControllerValidatePhysicalEntityRfo',
        'requestValidatePhysicalEntityRfoDto',
        requestValidatePhysicalEntityRfoDto,
      )
      const localVarPath = `/admin/validate-physical-entity-rfo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestValidatePhysicalEntityRfoDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatedUsersToPhysicalEntities: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/validated-users-to-physical-entities`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerVerifyUserManually: async (
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerVerifyUserManually', 'email', email)
      // verify required parameter 'manuallyVerifyUserRequestDto' is not null or undefined
      assertParamExists(
        'adminControllerVerifyUserManually',
        'manuallyVerifyUserRequestDto',
        manuallyVerifyUserRequestDto,
      )
      const localVarPath = `/admin/user/verify-manually/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        manuallyVerifyUserRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ADMINApi - functional programming interface
 */
export const ADMINApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ADMINApiAxiosParamCreator(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCheckUserVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserVerifyState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerCheckUserVerifyState(
        email,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerCheckUserVerifyState']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerDeactivateAccount(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeactivateAccountResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerDeactivateAccount(
        externalId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerDeactivateAccount']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
     * @summary Get birth numbers of newly verified users.
     * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetNewVerifiedUsersBirthNumbers(
      requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetNewVerifiedUsersBirthNumbersResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetNewVerifiedUsersBirthNumbers(
          requestBatchNewUserBirthNumbers,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetNewVerifiedUsersBirthNumbers']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserByBirthNumberDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumber(
          birthNumber,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetUserDataByBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumbersBatch(
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetUserDataByBirthNumbersBatchResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumbersBatch(
          requestBatchQueryUsersByBirthNumbersDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetUserDataByBirthNumbersBatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetVerificationDataForUser(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationDataForUserResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetVerificationDataForUser(email, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetVerificationDataForUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
     * @summary Mark accounts as deceased
     * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerMarkAccountsAsDeceasedByBirthnumber(
      markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkDeceasedAccountResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerMarkAccountsAsDeceasedByBirthnumber(
          markDeceasedAccountRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerMarkAccountsAsDeceasedByBirthnumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
     * @summary Will activate one time sync of all users from cognito to db at 3am
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerSyncCognitoToDb(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerSyncCognitoToDb(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerSyncCognitoToDb']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidateEdeskForUserIds(
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateEdeskForUserIdsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidateEdeskForUserIds(
          requestBodyValidateEdeskForUserIdsDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidateEdeskForUserIds']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidatePhysicalEntityRfo(
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseValidatePhysicalEntityRfoDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidatePhysicalEntityRfo(
          requestValidatePhysicalEntityRfoDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidatePhysicalEntityRfo']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidatedUsersToPhysicalEntities(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ValidatedUsersToPhysicalEntitiesResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidatedUsersToPhysicalEntities(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidatedUsersToPhysicalEntities']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerVerifyUserManually(
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnlySuccessDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerVerifyUserManually(
        email,
        manuallyVerifyUserRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerVerifyUserManually']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ADMINApi - factory interface
 */
export const ADMINApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ADMINApiFp(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserVerifyState> {
      return localVarFp
        .adminControllerCheckUserVerifyState(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeactivateAccount(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeactivateAccountResponseDto> {
      return localVarFp
        .adminControllerDeactivateAccount(externalId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
     * @summary Get birth numbers of newly verified users.
     * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetNewVerifiedUsersBirthNumbers(
      requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetNewVerifiedUsersBirthNumbersResponseDto> {
      return localVarFp
        .adminControllerGetNewVerifiedUsersBirthNumbers(requestBatchNewUserBirthNumbers, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserByBirthNumberDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumber(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumbersBatch(
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetUserDataByBirthNumbersBatchResponseDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumbersBatch(
          requestBatchQueryUsersByBirthNumbersDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetVerificationDataForUser(
      email: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VerificationDataForUserResponseDto> {
      return localVarFp
        .adminControllerGetVerificationDataForUser(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
     * @summary Mark accounts as deceased
     * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerMarkAccountsAsDeceasedByBirthnumber(
      markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MarkDeceasedAccountResponseDto> {
      return localVarFp
        .adminControllerMarkAccountsAsDeceasedByBirthnumber(markDeceasedAccountRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
     * @summary Will activate one time sync of all users from cognito to db at 3am
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerSyncCognitoToDb(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .adminControllerSyncCognitoToDb(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidateEdeskForUserIds(
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ValidateEdeskForUserIdsResponseDto> {
      return localVarFp
        .adminControllerValidateEdeskForUserIds(requestBodyValidateEdeskForUserIdsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatePhysicalEntityRfo(
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseValidatePhysicalEntityRfoDto> {
      return localVarFp
        .adminControllerValidatePhysicalEntityRfo(requestValidatePhysicalEntityRfoDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatedUsersToPhysicalEntities(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ValidatedUsersToPhysicalEntitiesResponseDto> {
      return localVarFp
        .adminControllerValidatedUsersToPhysicalEntities(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerVerifyUserManually(
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OnlySuccessDto> {
      return localVarFp
        .adminControllerVerifyUserManually(email, manuallyVerifyUserRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ADMINApi - object-oriented interface
 */
export class ADMINApi extends BaseAPI {
  /**
   * Return the state of user verifying.
   * @summary Get user\'s verify state
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerCheckUserVerifyState(email: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerCheckUserVerifyState(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deactivates user account in cognito and deletes personal info from database.
   * @summary Deactivate user account
   * @param {string} externalId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerDeactivateAccount(externalId: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerDeactivateAccount(externalId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
   * @summary Get birth numbers of newly verified users.
   * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetNewVerifiedUsersBirthNumbers(
    requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetNewVerifiedUsersBirthNumbers(requestBatchNewUserBirthNumbers, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get user data by birthnumber
   * @summary Get user data
   * @param {string} birthNumber userBirthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetUserDataByBirthNumber(
    birthNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumber(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get user data by birthnumbers in batch.
   * @summary Get user data
   * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetUserDataByBirthNumbersBatch(
    requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumbersBatch(
        requestBatchQueryUsersByBirthNumbersDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
   * @summary Get verification data for user.
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetVerificationDataForUser(email: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetVerificationDataForUser(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
   * @summary Mark accounts as deceased
   * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerMarkAccountsAsDeceasedByBirthnumber(
    markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerMarkAccountsAsDeceasedByBirthnumber(markDeceasedAccountRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
   * @summary Will activate one time sync of all users from cognito to db at 3am
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerSyncCognitoToDb(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerSyncCognitoToDb(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
   * @summary Validate edesk for physicalEntities
   * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerValidateEdeskForUserIds(
    requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidateEdeskForUserIds(requestBodyValidateEdeskForUserIdsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Manually update entity data against RFO (and UPVS) if possible
   * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerValidatePhysicalEntityRfo(
    requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidatePhysicalEntityRfo(requestValidatePhysicalEntityRfoDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
   * @summary Create physicalEntity records for validated users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerValidatedUsersToPhysicalEntities(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidatedUsersToPhysicalEntities(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
   * @summary Manually verify user.
   * @param {string} email
   * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerVerifyUserManually(
    email: string,
    manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerVerifyUserManually(email, manuallyVerifyUserRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AppApi - axios parameter creator
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AppApi - functional programming interface
 */
export const AppApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealthCheck(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealthCheck(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AppApi.appControllerHealthCheck']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AppApi - factory interface
 */
export const AppApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AppApiFp(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .appControllerHealthCheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AppApi - object-oriented interface
 */
export class AppApi extends BaseAPI {
  /**
   * See if app is working!
   * @summary HealthCheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public appControllerHealthCheck(options?: RawAxiosRequestConfig) {
    return AppApiFp(this.configuration)
      .appControllerHealthCheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CognitoGetUserData>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(options?: RawAxiosRequestConfig): AxiosPromise<CognitoGetUserData> {
      return localVarFp.authControllerLogin(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Check if user is authorized
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public authControllerLogin(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DPBApi - axios parameter creator
 */
export const DPBApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns user data for the authenticated user
     * @summary Get user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dpbControllerUserData: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/dpb/userdata`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DPBApi - functional programming interface
 */
export const DPBApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DPBApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns user data for the authenticated user
     * @summary Get user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dpbControllerUserData(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DpbUserDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dpbControllerUserData(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DPBApi.dpbControllerUserData']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DPBApi - factory interface
 */
export const DPBApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DPBApiFp(configuration)
  return {
    /**
     * Returns user data for the authenticated user
     * @summary Get user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dpbControllerUserData(options?: RawAxiosRequestConfig): AxiosPromise<DpbUserDto> {
      return localVarFp.dpbControllerUserData(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * DPBApi - object-oriented interface
 */
export class DPBApi extends BaseAPI {
  /**
   * Returns user data for the authenticated user
   * @summary Get user data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public dpbControllerUserData(options?: RawAxiosRequestConfig) {
    return DPBApiFp(this.configuration)
      .dpbControllerUserData(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * OAuth2Api - axios parameter creator
 */
export const OAuth2ApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Initiate OAuth2 authorization flow with PKCE (RFC 7636). Redirects to frontend for user authentication (HTTP 303 See Other).
     * @summary OAuth2 Authorization Endpoint
     * @param {OAuth2ControllerAuthorizeResponseTypeEnum} responseType Response type. Must be \&quot;code\&quot; for Authorization Code flow. \&quot;token\&quot; is not allowed if PKCE is required.
     * @param {string} clientId The client identifier for your application
     * @param {string} redirectUri The redirect URI registered for your application
     * @param {string} [scope] Space-delimited list of scopes
     * @param {string} [state] CSRF protection: random value generated by the app and returned unchanged (RECOMMENDED per RFC 6749)
     * @param {string} [codeChallenge] Code challenge for PKCE (RFC 7636). Optional - only required if using PKCE or if client requires it
     * @param {OAuth2ControllerAuthorizeCodeChallengeMethodEnum} [codeChallengeMethod] Code challenge method for PKCE. Optional - required if code_challenge is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerAuthorize: async (
      responseType: OAuth2ControllerAuthorizeResponseTypeEnum,
      clientId: string,
      redirectUri: string,
      scope?: string,
      state?: string,
      codeChallenge?: string,
      codeChallengeMethod?: OAuth2ControllerAuthorizeCodeChallengeMethodEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'responseType' is not null or undefined
      assertParamExists('oAuth2ControllerAuthorize', 'responseType', responseType)
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('oAuth2ControllerAuthorize', 'clientId', clientId)
      // verify required parameter 'redirectUri' is not null or undefined
      assertParamExists('oAuth2ControllerAuthorize', 'redirectUri', redirectUri)
      const localVarPath = `/oauth2/authorize`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (responseType !== undefined) {
        localVarQueryParameter['response_type'] = responseType
      }

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId
      }

      if (redirectUri !== undefined) {
        localVarQueryParameter['redirect_uri'] = redirectUri
      }

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state
      }

      if (codeChallenge !== undefined) {
        localVarQueryParameter['code_challenge'] = codeChallenge
      }

      if (codeChallengeMethod !== undefined) {
        localVarQueryParameter['code_challenge_method'] = codeChallengeMethod
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Complete authorization flow after tokens are stored via POST /oauth2/store. Called by frontend with authorization request ID. Checks if tokens are stored, generates authorization grant, and redirects to client redirect_uri with authorization code (HTTP 303 See Other).
     * @summary OAuth2 Continue Endpoint
     * @param {string} payload UUID of the authorization request stored in the database
     * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
     * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
     * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerContinueComplete: async (
      payload: string,
      clientId?: string,
      redirectUri?: string,
      state?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'payload' is not null or undefined
      assertParamExists('oAuth2ControllerContinueComplete', 'payload', payload)
      const localVarPath = `/oauth2/continue`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (payload !== undefined) {
        localVarQueryParameter['payload'] = payload
      }

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId
      }

      if (redirectUri !== undefined) {
        localVarQueryParameter['redirect_uri'] = redirectUri
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get client information (name and title) by client_id from authorization request for frontend display.
     * @summary OAuth2 Client Info Endpoint
     * @param {string} payload UUID of the authorization request stored in the database
     * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
     * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
     * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerInfo: async (
      payload: string,
      clientId?: string,
      redirectUri?: string,
      state?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'payload' is not null or undefined
      assertParamExists('oAuth2ControllerInfo', 'payload', payload)
      const localVarPath = `/oauth2/info`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (payload !== undefined) {
        localVarQueryParameter['payload'] = payload
      }

      if (clientId !== undefined) {
        localVarQueryParameter['client_id'] = clientId
      }

      if (redirectUri !== undefined) {
        localVarQueryParameter['redirect_uri'] = redirectUri
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Store tokens after user authentication. Called by frontend with tokens and authorization request ID.
     * @summary OAuth2 Store Tokens Endpoint
     * @param {StoreTokensRequestDto} storeTokensRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerStoreTokens: async (
      storeTokensRequestDto: StoreTokensRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'storeTokensRequestDto' is not null or undefined
      assertParamExists(
        'oAuth2ControllerStoreTokens',
        'storeTokensRequestDto',
        storeTokensRequestDto,
      )
      const localVarPath = `/oauth2/store`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        storeTokensRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Exchange authorization code for tokens or refresh access token. Returns JSON response per RFC 6749 Section 5.1.
     * @summary OAuth2 Token Endpoint
     * @param {OAuth2ControllerTokenRequest} oAuth2ControllerTokenRequest Token request - use authorization_code or refresh_token grant type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerToken: async (
      oAuth2ControllerTokenRequest: OAuth2ControllerTokenRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'oAuth2ControllerTokenRequest' is not null or undefined
      assertParamExists(
        'oAuth2ControllerToken',
        'oAuth2ControllerTokenRequest',
        oAuth2ControllerTokenRequest,
      )
      const localVarPath = `/oauth2/token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        oAuth2ControllerTokenRequest,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * OAuth2Api - functional programming interface
 */
export const OAuth2ApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OAuth2ApiAxiosParamCreator(configuration)
  return {
    /**
     * Initiate OAuth2 authorization flow with PKCE (RFC 7636). Redirects to frontend for user authentication (HTTP 303 See Other).
     * @summary OAuth2 Authorization Endpoint
     * @param {OAuth2ControllerAuthorizeResponseTypeEnum} responseType Response type. Must be \&quot;code\&quot; for Authorization Code flow. \&quot;token\&quot; is not allowed if PKCE is required.
     * @param {string} clientId The client identifier for your application
     * @param {string} redirectUri The redirect URI registered for your application
     * @param {string} [scope] Space-delimited list of scopes
     * @param {string} [state] CSRF protection: random value generated by the app and returned unchanged (RECOMMENDED per RFC 6749)
     * @param {string} [codeChallenge] Code challenge for PKCE (RFC 7636). Optional - only required if using PKCE or if client requires it
     * @param {OAuth2ControllerAuthorizeCodeChallengeMethodEnum} [codeChallengeMethod] Code challenge method for PKCE. Optional - required if code_challenge is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oAuth2ControllerAuthorize(
      responseType: OAuth2ControllerAuthorizeResponseTypeEnum,
      clientId: string,
      redirectUri: string,
      scope?: string,
      state?: string,
      codeChallenge?: string,
      codeChallengeMethod?: OAuth2ControllerAuthorizeCodeChallengeMethodEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oAuth2ControllerAuthorize(
        responseType,
        clientId,
        redirectUri,
        scope,
        state,
        codeChallenge,
        codeChallengeMethod,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['OAuth2Api.oAuth2ControllerAuthorize']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Complete authorization flow after tokens are stored via POST /oauth2/store. Called by frontend with authorization request ID. Checks if tokens are stored, generates authorization grant, and redirects to client redirect_uri with authorization code (HTTP 303 See Other).
     * @summary OAuth2 Continue Endpoint
     * @param {string} payload UUID of the authorization request stored in the database
     * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
     * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
     * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oAuth2ControllerContinueComplete(
      payload: string,
      clientId?: string,
      redirectUri?: string,
      state?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oAuth2ControllerContinueComplete(
        payload,
        clientId,
        redirectUri,
        state,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['OAuth2Api.oAuth2ControllerContinueComplete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get client information (name and title) by client_id from authorization request for frontend display.
     * @summary OAuth2 Client Info Endpoint
     * @param {string} payload UUID of the authorization request stored in the database
     * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
     * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
     * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oAuth2ControllerInfo(
      payload: string,
      clientId?: string,
      redirectUri?: string,
      state?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientInfoResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oAuth2ControllerInfo(
        payload,
        clientId,
        redirectUri,
        state,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['OAuth2Api.oAuth2ControllerInfo']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Store tokens after user authentication. Called by frontend with tokens and authorization request ID.
     * @summary OAuth2 Store Tokens Endpoint
     * @param {StoreTokensRequestDto} storeTokensRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oAuth2ControllerStoreTokens(
      storeTokensRequestDto: StoreTokensRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oAuth2ControllerStoreTokens(
        storeTokensRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['OAuth2Api.oAuth2ControllerStoreTokens']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Exchange authorization code for tokens or refresh access token. Returns JSON response per RFC 6749 Section 5.1.
     * @summary OAuth2 Token Endpoint
     * @param {OAuth2ControllerTokenRequest} oAuth2ControllerTokenRequest Token request - use authorization_code or refresh_token grant type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oAuth2ControllerToken(
      oAuth2ControllerTokenRequest: OAuth2ControllerTokenRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oAuth2ControllerToken(
        oAuth2ControllerTokenRequest,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['OAuth2Api.oAuth2ControllerToken']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * OAuth2Api - factory interface
 */
export const OAuth2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OAuth2ApiFp(configuration)
  return {
    /**
     * Initiate OAuth2 authorization flow with PKCE (RFC 7636). Redirects to frontend for user authentication (HTTP 303 See Other).
     * @summary OAuth2 Authorization Endpoint
     * @param {OAuth2ControllerAuthorizeResponseTypeEnum} responseType Response type. Must be \&quot;code\&quot; for Authorization Code flow. \&quot;token\&quot; is not allowed if PKCE is required.
     * @param {string} clientId The client identifier for your application
     * @param {string} redirectUri The redirect URI registered for your application
     * @param {string} [scope] Space-delimited list of scopes
     * @param {string} [state] CSRF protection: random value generated by the app and returned unchanged (RECOMMENDED per RFC 6749)
     * @param {string} [codeChallenge] Code challenge for PKCE (RFC 7636). Optional - only required if using PKCE or if client requires it
     * @param {OAuth2ControllerAuthorizeCodeChallengeMethodEnum} [codeChallengeMethod] Code challenge method for PKCE. Optional - required if code_challenge is provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerAuthorize(
      responseType: OAuth2ControllerAuthorizeResponseTypeEnum,
      clientId: string,
      redirectUri: string,
      scope?: string,
      state?: string,
      codeChallenge?: string,
      codeChallengeMethod?: OAuth2ControllerAuthorizeCodeChallengeMethodEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .oAuth2ControllerAuthorize(
          responseType,
          clientId,
          redirectUri,
          scope,
          state,
          codeChallenge,
          codeChallengeMethod,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Complete authorization flow after tokens are stored via POST /oauth2/store. Called by frontend with authorization request ID. Checks if tokens are stored, generates authorization grant, and redirects to client redirect_uri with authorization code (HTTP 303 See Other).
     * @summary OAuth2 Continue Endpoint
     * @param {string} payload UUID of the authorization request stored in the database
     * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
     * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
     * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerContinueComplete(
      payload: string,
      clientId?: string,
      redirectUri?: string,
      state?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .oAuth2ControllerContinueComplete(payload, clientId, redirectUri, state, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get client information (name and title) by client_id from authorization request for frontend display.
     * @summary OAuth2 Client Info Endpoint
     * @param {string} payload UUID of the authorization request stored in the database
     * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
     * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
     * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerInfo(
      payload: string,
      clientId?: string,
      redirectUri?: string,
      state?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ClientInfoResponseDto> {
      return localVarFp
        .oAuth2ControllerInfo(payload, clientId, redirectUri, state, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Store tokens after user authentication. Called by frontend with tokens and authorization request ID.
     * @summary OAuth2 Store Tokens Endpoint
     * @param {StoreTokensRequestDto} storeTokensRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerStoreTokens(
      storeTokensRequestDto: StoreTokensRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .oAuth2ControllerStoreTokens(storeTokensRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Exchange authorization code for tokens or refresh access token. Returns JSON response per RFC 6749 Section 5.1.
     * @summary OAuth2 Token Endpoint
     * @param {OAuth2ControllerTokenRequest} oAuth2ControllerTokenRequest Token request - use authorization_code or refresh_token grant type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oAuth2ControllerToken(
      oAuth2ControllerTokenRequest: OAuth2ControllerTokenRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenResponseDto> {
      return localVarFp
        .oAuth2ControllerToken(oAuth2ControllerTokenRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * OAuth2Api - object-oriented interface
 */
export class OAuth2Api extends BaseAPI {
  /**
   * Initiate OAuth2 authorization flow with PKCE (RFC 7636). Redirects to frontend for user authentication (HTTP 303 See Other).
   * @summary OAuth2 Authorization Endpoint
   * @param {OAuth2ControllerAuthorizeResponseTypeEnum} responseType Response type. Must be \&quot;code\&quot; for Authorization Code flow. \&quot;token\&quot; is not allowed if PKCE is required.
   * @param {string} clientId The client identifier for your application
   * @param {string} redirectUri The redirect URI registered for your application
   * @param {string} [scope] Space-delimited list of scopes
   * @param {string} [state] CSRF protection: random value generated by the app and returned unchanged (RECOMMENDED per RFC 6749)
   * @param {string} [codeChallenge] Code challenge for PKCE (RFC 7636). Optional - only required if using PKCE or if client requires it
   * @param {OAuth2ControllerAuthorizeCodeChallengeMethodEnum} [codeChallengeMethod] Code challenge method for PKCE. Optional - required if code_challenge is provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public oAuth2ControllerAuthorize(
    responseType: OAuth2ControllerAuthorizeResponseTypeEnum,
    clientId: string,
    redirectUri: string,
    scope?: string,
    state?: string,
    codeChallenge?: string,
    codeChallengeMethod?: OAuth2ControllerAuthorizeCodeChallengeMethodEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuth2ApiFp(this.configuration)
      .oAuth2ControllerAuthorize(
        responseType,
        clientId,
        redirectUri,
        scope,
        state,
        codeChallenge,
        codeChallengeMethod,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Complete authorization flow after tokens are stored via POST /oauth2/store. Called by frontend with authorization request ID. Checks if tokens are stored, generates authorization grant, and redirects to client redirect_uri with authorization code (HTTP 303 See Other).
   * @summary OAuth2 Continue Endpoint
   * @param {string} payload UUID of the authorization request stored in the database
   * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
   * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
   * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public oAuth2ControllerContinueComplete(
    payload: string,
    clientId?: string,
    redirectUri?: string,
    state?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuth2ApiFp(this.configuration)
      .oAuth2ControllerContinueComplete(payload, clientId, redirectUri, state, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get client information (name and title) by client_id from authorization request for frontend display.
   * @summary OAuth2 Client Info Endpoint
   * @param {string} payload UUID of the authorization request stored in the database
   * @param {string} [clientId] Optional client identifier. Used as fallback for error handling if the original client_id cannot be recovered from the stored authorization request
   * @param {string} [redirectUri] Optional redirect URI. Used as fallback for error handling if the original redirect_uri cannot be recovered from the stored authorization request
   * @param {string} [state] Optional state parameter. Used as fallback for error handling if the original state cannot be recovered from the stored authorization request. CSRF protection value per RFC 6749
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public oAuth2ControllerInfo(
    payload: string,
    clientId?: string,
    redirectUri?: string,
    state?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuth2ApiFp(this.configuration)
      .oAuth2ControllerInfo(payload, clientId, redirectUri, state, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Store tokens after user authentication. Called by frontend with tokens and authorization request ID.
   * @summary OAuth2 Store Tokens Endpoint
   * @param {StoreTokensRequestDto} storeTokensRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public oAuth2ControllerStoreTokens(
    storeTokensRequestDto: StoreTokensRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuth2ApiFp(this.configuration)
      .oAuth2ControllerStoreTokens(storeTokensRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Exchange authorization code for tokens or refresh access token. Returns JSON response per RFC 6749 Section 5.1.
   * @summary OAuth2 Token Endpoint
   * @param {OAuth2ControllerTokenRequest} oAuth2ControllerTokenRequest Token request - use authorization_code or refresh_token grant type
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public oAuth2ControllerToken(
    oAuth2ControllerTokenRequest: OAuth2ControllerTokenRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return OAuth2ApiFp(this.configuration)
      .oAuth2ControllerToken(oAuth2ControllerTokenRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

export const OAuth2ControllerAuthorizeResponseTypeEnum = {
  Code: 'code',
  Token: 'token',
} as const
export type OAuth2ControllerAuthorizeResponseTypeEnum =
  (typeof OAuth2ControllerAuthorizeResponseTypeEnum)[keyof typeof OAuth2ControllerAuthorizeResponseTypeEnum]
export const OAuth2ControllerAuthorizeCodeChallengeMethodEnum = {
  S256: 'S256',
  Plain: 'plain',
} as const
export type OAuth2ControllerAuthorizeCodeChallengeMethodEnum =
  (typeof OAuth2ControllerAuthorizeCodeChallengeMethodEnum)[keyof typeof OAuth2ControllerAuthorizeCodeChallengeMethodEnum]

/**
 * UserIntegrationApi - axios parameter creator
 */
export const UserIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns contact and ID information for user or legal person based on external ID. This endpoint requires API key authentication.
     * @summary Get user contact and ID information by external ID
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userIntegrationControllerGetContactAndIdInfoByExternalId: async (
      externalId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalId' is not null or undefined
      assertParamExists(
        'userIntegrationControllerGetContactAndIdInfoByExternalId',
        'externalId',
        externalId,
      )
      const localVarPath = `/user-integration/contact-and-id-info/{externalId}`.replace(
        `{${'externalId'}}`,
        encodeURIComponent(String(externalId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserIntegrationApi - functional programming interface
 */
export const UserIntegrationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserIntegrationApiAxiosParamCreator(configuration)
  return {
    /**
     * Returns contact and ID information for user or legal person based on external ID. This endpoint requires API key authentication.
     * @summary Get user contact and ID information by external ID
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userIntegrationControllerGetContactAndIdInfoByExternalId(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserIntegrationControllerGetContactAndIdInfoByExternalId200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userIntegrationControllerGetContactAndIdInfoByExternalId(
          externalId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserIntegrationApi.userIntegrationControllerGetContactAndIdInfoByExternalId'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UserIntegrationApi - factory interface
 */
export const UserIntegrationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserIntegrationApiFp(configuration)
  return {
    /**
     * Returns contact and ID information for user or legal person based on external ID. This endpoint requires API key authentication.
     * @summary Get user contact and ID information by external ID
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userIntegrationControllerGetContactAndIdInfoByExternalId(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserIntegrationControllerGetContactAndIdInfoByExternalId200Response> {
      return localVarFp
        .userIntegrationControllerGetContactAndIdInfoByExternalId(externalId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserIntegrationApi - object-oriented interface
 */
export class UserIntegrationApi extends BaseAPI {
  /**
   * Returns contact and ID information for user or legal person based on external ID. This endpoint requires API key authentication.
   * @summary Get user contact and ID information by external ID
   * @param {string} externalId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userIntegrationControllerGetContactAndIdInfoByExternalId(
    externalId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return UserIntegrationApiFp(this.configuration)
      .userIntegrationControllerGetContactAndIdInfoByExternalId(externalId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserVerificationsApi - axios parameter creator
 */
export const UserVerificationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard: async (
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyIdentityCardDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyBirthNumberAndIdentityCard',
        'requestBodyVerifyIdentityCardDto',
        requestBodyVerifyIdentityCardDto,
      )
      const localVarPath = `/user-verification/identity-card`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyIdentityCardDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard: async (
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithRpoDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyIcoBirthNumberAndIdentityCard',
        'requestBodyVerifyWithRpoDto',
        requestBodyVerifyWithRpoDto,
      )
      const localVarPath = `/user-verification/ico-rpo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithRpoDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid: async (
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithEidDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyWithEid',
        'requestBodyVerifyWithEidDto',
        requestBodyVerifyWithEidDto,
      )
      const localVarPath = `/user-verification/eid`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithEidDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserVerificationsApi - functional programming interface
 */
export const UserVerificationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserVerificationsApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseVerificationIdentityCardToQueueDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyIcoBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyWithEid(
        requestBodyVerifyWithEidDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UserVerificationsApi.verificationControllerVerifyWithEid']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UserVerificationsApi - factory interface
 */
export const UserVerificationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserVerificationsApiFp(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationIdentityCardToQueueDto> {
      return localVarFp
        .verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserVerificationsApi - object-oriented interface
 */
export class UserVerificationsApi extends BaseAPI {
  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public verificationControllerVerifyBirthNumberAndIdentityCard(
    requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyBirthNumberAndIdentityCard(
        requestBodyVerifyIdentityCardDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via the register of legal entities
   * @summary Validate user via rpo
   * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public verificationControllerVerifyIcoBirthNumberAndIdentityCard(
    requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
        requestBodyVerifyWithRpoDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
   * @summary Validate user via eid
   * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public verificationControllerVerifyWithEid(
    requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersManipulationApi - axios parameter creator
 */
export const UsersManipulationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail: async (
      changeEmailRequestDto: ChangeEmailRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'changeEmailRequestDto' is not null or undefined
      assertParamExists('userControllerChangeEmail', 'changeEmailRequestDto', changeEmailRequestDto)
      const localVarPath = `/user/change-email`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeEmailRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically Bloomreach Customer. Use this endpoint AFTER login/registration, not during the login/registration flow. For login/registration flows, use `/upsert-user-record-client` instead to track which client the user logged in through. This endpoint is intended for subsequent user data fetches after the user is already authenticated (e.g., forms backend, next.js app fetching user data).
     * @summary Get or create user with their data (use when already logged in, not duing login/registration)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/get-or-create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/remove-birthnumber`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerSubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/subscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerUnsubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/unsubscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser: async (
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'id', id)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'type', type)
      // verify required parameter 'category' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'category', category)
      const localVarPath = `/user/public/unsubscribe/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUserByExternalId: async (
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'id', id)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'type', type)
      // verify required parameter 'category' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'category', category)
      const localVarPath = `/user/public/unsubscribe/external-id/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
     * @summary Update or create bloomreach customer for logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdateOrCreateBloomreachCustomer: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/update-or-create-bloomreach-customer`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Gets or creates the user/legal person and records a login client for the currently authenticated user. This tracks which client the user logged in through and increments the login count. Use this endpoint DURING login/registration flows to track login client usage. For subsequent user data fetches after login (e.g., forms backend, next.js app), use `/get-or-create` instead. This endpoint should be called once per login/registration to properly track which client was used.
     * @summary Upsert user and record login client (use during login/registration)
     * @param {UpsertUserRecordClientRequestDto} upsertUserRecordClientRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpsertUserAndRecordClient: async (
      upsertUserRecordClientRequestDto: UpsertUserRecordClientRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'upsertUserRecordClientRequestDto' is not null or undefined
      assertParamExists(
        'userControllerUpsertUserAndRecordClient',
        'upsertUserRecordClientRequestDto',
        upsertUserRecordClientRequestDto,
      )
      const localVarPath = `/user/upsert-user-record-client`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'
      localVarHeaderParameter['Accept'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        upsertUserRecordClientRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersManipulationApi - functional programming interface
 */
export const UsersManipulationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersManipulationApiAxiosParamCreator(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerChangeEmail(
      changeEmailRequestDto: ChangeEmailRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerChangeEmail200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerChangeEmail(
        changeEmailRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerChangeEmail']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint returns all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically Bloomreach Customer. Use this endpoint AFTER login/registration, not during the login/registration flow. For login/registration flows, use `/upsert-user-record-client` instead to track which client the user logged in through. This endpoint is intended for subsequent user data fetches after the user is already authenticated (e.g., forms backend, next.js app fetching user data).
     * @summary Get or create user with their data (use when already logged in, not duing login/registration)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerGetOrCreateUser(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerGetOrCreateUser(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerGetOrCreateUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRemoveBirthNumber(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerRemoveBirthNumber(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerRemoveBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerSubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUser(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribePublicUser(
        id,
        type,
        category,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribePublicUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUserByExternalId(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerUnsubscribePublicUserByExternalId(
          id,
          type,
          category,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UsersManipulationApi.userControllerUnsubscribePublicUserByExternalId'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
     * @summary Update or create bloomreach customer for logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdateOrCreateBloomreachCustomer(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerUpdateOrCreateBloomreachCustomer(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUpdateOrCreateBloomreachCustomer']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Gets or creates the user/legal person and records a login client for the currently authenticated user. This tracks which client the user logged in through and increments the login count. Use this endpoint DURING login/registration flows to track login client usage. For subsequent user data fetches after login (e.g., forms backend, next.js app), use `/get-or-create` instead. This endpoint should be called once per login/registration to properly track which client was used.
     * @summary Upsert user and record login client (use during login/registration)
     * @param {UpsertUserRecordClientRequestDto} upsertUserRecordClientRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpsertUserAndRecordClient(
      upsertUserRecordClientRequestDto: UpsertUserRecordClientRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerUpsertUserAndRecordClient(
          upsertUserRecordClientRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUpsertUserAndRecordClient']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UsersManipulationApi - factory interface
 */
export const UsersManipulationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersManipulationApiFp(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail(
      changeEmailRequestDto: ChangeEmailRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerChangeEmail200Response> {
      return localVarFp
        .userControllerChangeEmail(changeEmailRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically Bloomreach Customer. Use this endpoint AFTER login/registration, not during the login/registration flow. For login/registration flows, use `/upsert-user-record-client` instead to track which client the user logged in through. This endpoint is intended for subsequent user data fetches after the user is already authenticated (e.g., forms backend, next.js app fetching user data).
     * @summary Get or create user with their data (use when already logged in, not duing login/registration)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerGetOrCreateUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerRemoveBirthNumber(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUser(id, type, category, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUserByExternalId(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUserByExternalId(id, type, category, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
     * @summary Update or create bloomreach customer for logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdateOrCreateBloomreachCustomer(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerUpdateOrCreateBloomreachCustomer(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Gets or creates the user/legal person and records a login client for the currently authenticated user. This tracks which client the user logged in through and increments the login count. Use this endpoint DURING login/registration flows to track login client usage. For subsequent user data fetches after login (e.g., forms backend, next.js app), use `/get-or-create` instead. This endpoint should be called once per login/registration to properly track which client was used.
     * @summary Upsert user and record login client (use during login/registration)
     * @param {UpsertUserRecordClientRequestDto} upsertUserRecordClientRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpsertUserAndRecordClient(
      upsertUserRecordClientRequestDto: UpsertUserRecordClientRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerUpsertUserAndRecordClient(upsertUserRecordClientRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersManipulationApi - object-oriented interface
 */
export class UsersManipulationApi extends BaseAPI {
  /**
   * Change email saved in database for a given cognito user.
   * @summary Change email of cognito user in database
   * @param {ChangeEmailRequestDto} changeEmailRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerChangeEmail(
    changeEmailRequestDto: ChangeEmailRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerChangeEmail(changeEmailRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically Bloomreach Customer. Use this endpoint AFTER login/registration, not during the login/registration flow. For login/registration flows, use `/upsert-user-record-client` instead to track which client the user logged in through. This endpoint is intended for subsequent user data fetches after the user is already authenticated (e.g., forms backend, next.js app fetching user data).
   * @summary Get or create user with their data (use when already logged in, not duing login/registration)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerGetOrCreateUser(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerGetOrCreateUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerRemoveBirthNumber(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerRemoveBirthNumber(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
   * @summary Create subscribed or unsubscribed log for logged in users
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerSubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
   * @summary Unsubscribe logged user
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUnsubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by uuid with different categories of subscription
   * @summary Unsubscribe user by uuid
   * @param {string} id
   * @param {GDPRTypeEnum} type Type of Gdpr subscription
   * @param {GDPRCategoryEnum} category Type of Gdpr category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUnsubscribePublicUser(
    id: string,
    type: GDPRTypeEnum,
    category: GDPRCategoryEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUser(id, type, category, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by external Id from cognito with different categories of subscription
   * @summary Unsubscribe user by external Id
   * @param {string} id
   * @param {GDPRTypeEnum} type Type of Gdpr subscription
   * @param {GDPRCategoryEnum} category Type of Gdpr category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUnsubscribePublicUserByExternalId(
    id: string,
    type: GDPRTypeEnum,
    category: GDPRCategoryEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUserByExternalId(id, type, category, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
   * @summary Update or create bloomreach customer for logged user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUpdateOrCreateBloomreachCustomer(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUpdateOrCreateBloomreachCustomer(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Gets or creates the user/legal person and records a login client for the currently authenticated user. This tracks which client the user logged in through and increments the login count. Use this endpoint DURING login/registration flows to track login client usage. For subsequent user data fetches after login (e.g., forms backend, next.js app), use `/get-or-create` instead. This endpoint should be called once per login/registration to properly track which client was used.
   * @summary Upsert user and record login client (use during login/registration)
   * @param {UpsertUserRecordClientRequestDto} upsertUserRecordClientRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUpsertUserAndRecordClient(
    upsertUserRecordClientRequestDto: UpsertUserRecordClientRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUpsertUserAndRecordClient(upsertUserRecordClientRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
