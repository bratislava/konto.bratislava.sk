/* tslint:disable */
/* eslint-disable */
/**
 * User Module - city account
 * User module use for store additional data for users and authentication against Azure AD
 *
 * The version of the OpenAPI document: 1.0
 * Contact: inovacie@bratislava.sk
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

export interface ChangeEmailRequestDto {
  /**
   * New email for a user
   */
  newEmail: string
}
export interface CognitoGetUserData {
  /**
   * Id from cognito
   */
  sub: string
  /**
   * Is email verified in cognito?
   */
  email_verified?: string
  /**
   * Usually name of the company
   */
  name?: string
  /**
   * Which type of verified tier it is?
   */
  'custom:tier'?: object
  /**
   * Which type of account it is?
   */
  'custom:account_type': CognitoGetUserDataCustomAccountTypeEnum
  /**
   * First name
   */
  given_name?: string
  /**
   * Last name
   */
  family_name?: string
  /**
   * email
   */
  email: string
  /**
   * User Id from cognito, same as sub
   */
  idUser: string
  /**
   * User create date
   */
  UserCreateDate?: string
  /**
   * User updated date
   */
  UserLastModifiedDate?: string
  /**
   * Is user enabled?
   */
  Enabled: boolean
  /**
   * Cognito confirmation statue
   */
  UserStatus?: CognitoGetUserDataUserStatusEnum
}

export const CognitoGetUserDataCustomAccountTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type CognitoGetUserDataCustomAccountTypeEnum =
  (typeof CognitoGetUserDataCustomAccountTypeEnum)[keyof typeof CognitoGetUserDataCustomAccountTypeEnum]
export const CognitoGetUserDataUserStatusEnum = {
  Archived: 'ARCHIVED',
  Compromised: 'COMPROMISED',
  Confirmed: 'CONFIRMED',
  ForceChangePassword: 'FORCE_CHANGE_PASSWORD',
  ResetRequired: 'RESET_REQUIRED',
  Unconfirmed: 'UNCONFIRMED',
  Unknown: 'UNKNOWN',
} as const

export type CognitoGetUserDataUserStatusEnum =
  (typeof CognitoGetUserDataUserStatusEnum)[keyof typeof CognitoGetUserDataUserStatusEnum]

export interface DeactivateAccountResponseDto {
  /**
   * Marks if the operation has been successful
   */
  success: boolean
  /**
   * Status of the anonymization of user in bloomreach
   */
  bloomreachRemoved: DeactivateAccountResponseDtoBloomreachRemovedEnum
  /**
   * Status of the removal of tax delivery methods in Noris. If false, there was an error. If true it was successful, or the user is not a tax payer in Noris.
   */
  taxDeliveryMethodsRemoved: boolean
}

export const DeactivateAccountResponseDtoBloomreachRemovedEnum = {
  NotFound: 'NOT_FOUND',
  NotActive: 'NOT_ACTIVE',
  Error: 'ERROR',
  Success: 'SUCCESS',
} as const

export type DeactivateAccountResponseDtoBloomreachRemovedEnum =
  (typeof DeactivateAccountResponseDtoBloomreachRemovedEnum)[keyof typeof DeactivateAccountResponseDtoBloomreachRemovedEnum]

/**
 * Type of Gdpr category
 */

export const GDPRCategoryEnum = {
  City: 'CITY',
  Esbs: 'ESBS',
  Swimmingpools: 'SWIMMINGPOOLS',
  Taxes: 'TAXES',
  Init: 'INIT',
  Library: 'LIBRARY',
} as const

export type GDPRCategoryEnum = (typeof GDPRCategoryEnum)[keyof typeof GDPRCategoryEnum]

/**
 * Type of subType - unsubscribe or subscribe
 */

export const GDPRSubTypeEnum = {
  Subscribe: 'subscribe',
  Unsubscribe: 'unsubscribe',
} as const

export type GDPRSubTypeEnum = (typeof GDPRSubTypeEnum)[keyof typeof GDPRSubTypeEnum]

/**
 * Type of Gdpr subscription
 */

export const GDPRTypeEnum = {
  Analytics: 'ANALYTICS',
  Dataprocessing: 'DATAPROCESSING',
  FormalCommunication: 'FORMAL_COMMUNICATION',
  License: 'LICENSE',
  Marketing: 'MARKETING',
} as const

export type GDPRTypeEnum = (typeof GDPRTypeEnum)[keyof typeof GDPRTypeEnum]

export interface GdprDataDto {
  /**
   * Type of Gdpr subscription
   */
  type: GDPRTypeEnum
  /**
   * Type of Gdpr category
   */
  category: GDPRCategoryEnum
}

export interface GetNewVerifiedUsersBirthNumbersResponseDto {
  /**
   * List of birth numbers
   */
  birthNumbers: Array<string>
  /**
   * Next date to query.
   */
  nextSince: string
}
export interface GetUserDataByBirthNumbersBatchResponseDto {
  /**
   * A record of users keyed by their birth number
   */
  users: { [key: string]: ResponseUserByBirthNumberDto }
}
export interface ManuallyVerifyUserRequestDto {
  /**
   * userBirthNumber
   */
  birthNumber: string
  /**
   * Ifo of the user
   */
  ifo?: string
  /**
   * ico
   */
  ico?: string
}
export interface MarkDeceasedAccountRequestDto {
  /**
   * List of birthnumbers/external IDs to mark as deceased
   */
  birthNumbers: Array<string>
}
export interface MarkDeceasedAccountResponseDto {
  /**
   * List of birth numbers with success marked for each data storage.
   */
  results: Array<MarkDeceasedAccountResponseItemDto>
}
export interface MarkDeceasedAccountResponseItemDto {
  /**
   * Birth number of the deceased person
   */
  birthNumber: string
  /**
   * Whether the user was successfully marked as deceased in the database
   */
  databaseMarked: boolean
  /**
   * Whether the user was successfully archived in Cognito / mail was changed.
   */
  cognitoArchived: boolean
  /**
   * Status of the anonymization of user in Bloomreach
   */
  bloomreachRemoved?: MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum
}

export const MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum = {
  NotFound: 'NOT_FOUND',
  NotActive: 'NOT_ACTIVE',
  Error: 'ERROR',
  Success: 'SUCCESS',
} as const

export type MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum =
  (typeof MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum)[keyof typeof MarkDeceasedAccountResponseItemDtoBloomreachRemovedEnum]

export interface OnlySuccessDto {
  /**
   * Marks if the operation has been successful
   */
  success: boolean
}
export interface RequestBatchNewUserBirthNumbers {
  /**
   * Date to query.
   */
  since: string
  /**
   * Optionally specify maximum number to return. Will not return more than internal limit (100).
   */
  take?: number
}
export interface RequestBatchQueryUsersByBirthNumbersDto {
  /**
   * Birth numbers without slash which should be retrieved from user database.
   */
  birthNumbers: Array<string>
}
export interface RequestBodyValidateEdeskForUserIdsDto {
  /**
   * How many records to skip
   */
  offset?: number
}
export interface RequestBodyVerifyIdentityCardDto {
  /**
   * Birth number for check
   */
  birthNumber: string
  /**
   * String of identitiy card
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   */
  turnstileToken: string
}
export interface RequestBodyVerifyWithEidDto {
  /**
   * Token returned by https://fix.slovensko-sk-api.bratislava.sk/login
   */
  oboToken: string
}
export interface RequestBodyVerifyWithRpoDto {
  /**
   * ico
   */
  ico: string
  /**
   * Birth number of legal entity\'s executive
   */
  birthNumber: string
  /**
   * Identity card of legal entity\'s executive
   */
  identityCard: string
  /**
   * Token returned by turnstile captcha
   */
  turnstileToken: string
}
export interface RequestGdprDataDto {
  gdprData: Array<GdprDataDto>
}
export interface RequestValidatePhysicalEntityRfoDto {
  /**
   * Id of the physical entity object in db
   */
  physicalEntityId: string
}
export interface ResponseCustomErrorVerificationEidDto {
  /**
   * status
   */
  status: string
  /**
   * Message about error
   */
  message: string
  /**
   * Error name for decoding.
   */
  errorName: ResponseCustomErrorVerificationEidDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationEidDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseCustomErrorVerificationEidDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationEidDtoErrorNameEnum]

export interface ResponseCustomErrorVerificationIdentityCardDto {
  /**
   * status
   */
  status: string
  /**
   * Message about error
   */
  message: string
  /**
   * Error name for decoding.
   */
  errorName: ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum
}

export const ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum =
  (typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum)[keyof typeof ResponseCustomErrorVerificationIdentityCardDtoErrorNameEnum]

export interface ResponseGdprLegalPersonDataDto {
  /**
   * Type of Gdpr category
   */
  category: GDPRCategoryEnum
  /**
   * Type of Gdpr subscription
   */
  type: GDPRTypeEnum
  /**
   * Type of subType - unsubscribe or subscribe
   */
  subType: GDPRSubTypeEnum
}

export interface ResponseGdprUserDataDto {
  /**
   * Type of Gdpr category
   */
  category: GDPRCategoryEnum
  /**
   * Type of Gdpr subscription
   */
  type: GDPRTypeEnum
  /**
   * Type of subType - unsubscribe or subscribe
   */
  subType: GDPRSubTypeEnum
}

export interface ResponseInternalServerErrorDto {
  /**
   * statusCode
   */
  statusCode: number
  /**
   * Message about error
   */
  message: string
}
export interface ResponseLegalPersonDataDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Ico of company, which this user represents
   */
  ico: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
  /**
   * Subscription Data in array
   */
  gdprData: Array<ResponseGdprLegalPersonDataDto>
}
export interface ResponseLegalPersonDataSimpleDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Ico of company, which this user represents
   */
  ico: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
}
export interface ResponseNotFoundErrorVerificationIdentityCardDto {
  /**
   * status
   */
  status: string
  /**
   * Message about error
   */
  message: string
  /**
   * Error name for decoding.
   */
  errorName: string
}
export interface ResponseUserByBirthNumberDto {
  /**
   * userBirthNumber
   */
  birthNumber: string | null
  /**
   * email
   */
  email: string | null
  /**
   * Cognito Id
   */
  externalId: string | null
  /**
   * Special user attribute for user segmentation
   */
  userAttribute: object
  /**
   * Tier from cognito
   */
  cognitoAttributes?: object
  /**
   * Delivery method for tax documents at lock date
   */
  taxDeliveryMethodAtLockDate?: ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum | null
}

export const ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum = {
  Edesk: 'EDESK',
  CityAccount: 'CITY_ACCOUNT',
  Postal: 'POSTAL',
} as const

export type ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum =
  (typeof ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum)[keyof typeof ResponseUserByBirthNumberDtoTaxDeliveryMethodAtLockDateEnum]

export interface ResponseUserDataBasicDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
  /**
   * State, if we can communicate user with email, or user have active e-desk slovensko.sk mail or we need to communicate with him with post. First we are looking for edesk, if he has registered edesk communication in NASES use edesk. If not, check if there is subscription for communication through email, use email from city account. Else use Postal communication.
   */
  officialCorrespondenceChannel: UserOfficialCorrespondenceChannelEnum | null
  /**
   * True if user was registered and have verified birth number until 2024-04-22. This date can be varied every year. In this date, user are sent into Noris and taxes will be generated.
   */
  wasVerifiedBeforeTaxDeadline: boolean
  /**
   * Can show banner for formal communication through email? If it was shown and clicked, it will not be shown.
   */
  showEmailCommunicationBanner: boolean
}

export interface ResponseUserDataDto {
  /**
   * Local ID of user
   */
  id: string
  /**
   * Created timestamp
   */
  createdAt: string
  /**
   * Last updated timestamp
   */
  updatedAt: string
  /**
   * Id from cognito, it is not required. We can have also only subscribed user, who are not city account users
   */
  externalId: string | null
  /**
   * Email
   */
  email: string | null
  /**
   * Birth number
   */
  birthNumber: string | null
  /**
   * State, if we can communicate user with email, or user have active e-desk slovensko.sk mail or we need to communicate with him with post. First we are looking for edesk, if he has registered edesk communication in NASES use edesk. If not, check if there is subscription for communication through email, use email from city account. Else use Postal communication.
   */
  officialCorrespondenceChannel: UserOfficialCorrespondenceChannelEnum | null
  /**
   * True if user was registered and have verified birth number until 2024-04-22. This date can be varied every year. In this date, user are sent into Noris and taxes will be generated.
   */
  wasVerifiedBeforeTaxDeadline: boolean
  /**
   * Can show banner for formal communication through email? If it was shown and clicked, it will not be shown.
   */
  showEmailCommunicationBanner: boolean
  /**
   * Subscription Data in array
   */
  gdprData: Array<ResponseGdprUserDataDto>
}

export interface ResponseValidatePhysicalEntityRfoDto {
  /**
   * Entity data (updated if new info was found in state registry)
   */
  physicalEntity: object
  /**
   * Data received from RFO
   */
  rfoData: object
  /**
   * Data received from UPVS
   */
  upvsResult: object
}
export interface ResponseVerificationDto {
  /**
   * number of status code
   */
  statusCode: number
  /**
   * status
   */
  status: string
  /**
   * Message about update
   */
  message: string
  /**
   * Error if exists
   */
  errorName?: ResponseVerificationDtoErrorNameEnum
}

export const ResponseVerificationDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseVerificationDtoErrorNameEnum =
  (typeof ResponseVerificationDtoErrorNameEnum)[keyof typeof ResponseVerificationDtoErrorNameEnum]

export interface ResponseVerificationIdentityCardToQueueDto {
  /**
   * number of status code
   */
  statusCode: number
  /**
   * status
   */
  status: string
  /**
   * Message about update
   */
  message: ResponseVerificationIdentityCardToQueueDtoMessageEnum
  /**
   * Error if exists
   */
  errorName?: ResponseVerificationIdentityCardToQueueDtoErrorNameEnum
}

export const ResponseVerificationIdentityCardToQueueDtoMessageEnum = {
  SendToQueue: 'SendToQueue',
  AlreadyVerified: 'AlreadyVerified',
} as const

export type ResponseVerificationIdentityCardToQueueDtoMessageEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoMessageEnum]
export const ResponseVerificationIdentityCardToQueueDtoErrorNameEnum = {
  RfoAccessError: 'RFO_ACCESS_ERROR',
  RfoNotResponding: 'RFO_NOT_RESPONDING',
  RpoNotResponding: 'RPO_NOT_RESPONDING',
  DeadPerson: 'DEAD_PERSON',
  BirthNumberAndIdentityCardInconsistency: 'BIRTH_NUMBER_AND_IDENTITY_CARD_INCONSISTENCY',
  BirthnumberIfoDuplicity: 'BIRTHNUMBER_IFO_DUPLICITY',
  BirthnumberIcoDuplicity: 'BIRTHNUMBER_ICO_DUPLICITY',
  BirthNumberNotExists: 'BIRTH_NUMBER_NOT_EXISTS',
  BirthNumberWrongFormat: 'BIRTH_NUMBER_WRONG_FORMAT',
  DatabaseError: 'DATABASE_ERROR',
  InvalidCaptcha: 'INVALID_CAPTCHA',
  VerifyEidError: 'VERIFY_EID_ERROR',
  UnexpectedUpvsResponse: 'UNEXPECTED_UPVS_RESPONSE',
  RpoFieldNotExists: 'RPO_FIELD_NOT_EXISTS',
  IcoNotProvided: 'ICO_NOT_PROVIDED',
  IfoNotProvided: 'IFO_NOT_PROVIDED',
  EmptyRfoResponse: 'EMPTY_RFO_RESPONSE',
  EmptyRpoResponse: 'EMPTY_RPO_RESPONSE',
} as const

export type ResponseVerificationIdentityCardToQueueDtoErrorNameEnum =
  (typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum)[keyof typeof ResponseVerificationIdentityCardToQueueDtoErrorNameEnum]

/**
 * @type UserControllerChangeEmail200Response
 */
export type UserControllerChangeEmail200Response =
  | ResponseLegalPersonDataSimpleDto
  | ResponseUserDataBasicDto

/**
 * @type UserControllerGetOrCreateUser200Response
 */
export type UserControllerGetOrCreateUser200Response =
  | ResponseLegalPersonDataDto
  | ResponseUserDataDto

/**
 * State, if we can communicate user with email, or user have active e-desk slovensko.sk mail or we need to communicate with him with post. First we are looking for edesk, if he has registered edesk communication in NASES use edesk. If not, check if there is subscription for communication through email, use email from city account. Else use Postal communication.
 */

export const UserOfficialCorrespondenceChannelEnum = {
  Postal: 'POSTAL',
  Edesk: 'EDESK',
  Email: 'EMAIL',
} as const

export type UserOfficialCorrespondenceChannelEnum =
  (typeof UserOfficialCorrespondenceChannelEnum)[keyof typeof UserOfficialCorrespondenceChannelEnum]

export interface UserVerifyState {
  /**
   * Id of given user\'s email, if exists
   */
  externalId?: string | null
  /**
   * Type of user.
   */
  type?: UserVerifyStateTypeEnum
  /**
   * Marks if the user with given email is in database.
   */
  isInDatabase: boolean
  /**
   * Marks if the user with given email is in cognito.
   */
  isInCognito: boolean
  /**
   * Current cognito tier, marks the status of verifying.
   */
  cognitoTier?: UserVerifyStateCognitoTierEnum
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   */
  birthNumberAlreadyExists?: string
  /**
   * If set, then this number was used for verifiying, but is already in our database for other user.
   */
  birthNumberIcoAlreadyExists?: string
  /**
   * Marks if the user with given email is verified.
   */
  isVerified: boolean
  /**
   * Possible cause of the verify error.
   */
  possibleCause?: string
}

export const UserVerifyStateTypeEnum = {
  Fo: 'fo',
  Po: 'po',
  FoP: 'fo-p',
} as const

export type UserVerifyStateTypeEnum =
  (typeof UserVerifyStateTypeEnum)[keyof typeof UserVerifyStateTypeEnum]
export const UserVerifyStateCognitoTierEnum = {
  New: 'NEW',
  QueueIdentityCard: 'QUEUE_IDENTITY_CARD',
  NotVerifiedIdentityCard: 'NOT_VERIFIED_IDENTITY_CARD',
  IdentityCard: 'IDENTITY_CARD',
  Eid: 'EID',
} as const

export type UserVerifyStateCognitoTierEnum =
  (typeof UserVerifyStateCognitoTierEnum)[keyof typeof UserVerifyStateCognitoTierEnum]

export interface ValidateEdeskForUserIdsResponseDto {
  /**
   * Number of users that were validated
   */
  validatedUsers: number
  /**
   * Temp debug data
   */
  enitites: object
}
export interface ValidatedUsersToPhysicalEntitiesResponseDto {
  existingPhysicalEntitiesUpdated: number
  newPhysicalEntitiesCreated: number
}
export interface VerificationDataForUser {
  /**
   * Id of the user in cognito.
   */
  userId: string
  /**
   * userBirthNumber
   */
  birthNumber: string
  /**
   * Id card used for verification.
   */
  idCard: string
  /**
   * Ico used for verification.
   */
  ico?: string
  /**
   * Created timestamp
   */
  verifyStart: string
}
export interface VerificationDataForUserResponseDto {
  /**
   * Id of the user in cognito.
   */
  externalId: string | null
  /**
   * Email of the user.
   */
  email: string | null
  /**
   * Verification data for the user in the last month. Ordered by start date descending.
   */
  verificationDataLastMonth: Array<VerificationDataForUser>
}

/**
 * ADMINApi - axios parameter creator
 */
export const ADMINApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerCheckUserVerifyState', 'email', email)
      const localVarPath = `/admin/status/user/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeactivateAccount: async (
      externalId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'externalId' is not null or undefined
      assertParamExists('adminControllerDeactivateAccount', 'externalId', externalId)
      const localVarPath = `/admin/deactivate/{externalId}`.replace(
        `{${'externalId'}}`,
        encodeURIComponent(String(externalId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
     * @summary Get birth numbers of newly verified users.
     * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetNewVerifiedUsersBirthNumbers: async (
      requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBatchNewUserBirthNumbers' is not null or undefined
      assertParamExists(
        'adminControllerGetNewVerifiedUsersBirthNumbers',
        'requestBatchNewUserBirthNumbers',
        requestBatchNewUserBirthNumbers,
      )
      const localVarPath = `/admin/get-verified-users-birth-numbers-batch`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBatchNewUserBirthNumbers,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber: async (
      birthNumber: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'birthNumber' is not null or undefined
      assertParamExists('adminControllerGetUserDataByBirthNumber', 'birthNumber', birthNumber)
      const localVarPath = `/admin/userdata`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      if (birthNumber !== undefined) {
        localVarQueryParameter['birthNumber'] = birthNumber
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumbersBatch: async (
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBatchQueryUsersByBirthNumbersDto' is not null or undefined
      assertParamExists(
        'adminControllerGetUserDataByBirthNumbersBatch',
        'requestBatchQueryUsersByBirthNumbersDto',
        requestBatchQueryUsersByBirthNumbersDto,
      )
      const localVarPath = `/admin/userdata-batch`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBatchQueryUsersByBirthNumbersDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetVerificationDataForUser: async (
      email: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerGetVerificationDataForUser', 'email', email)
      const localVarPath = `/admin/user/id-card-verification-data/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
     * @summary Mark accounts as deceased
     * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerMarkAccountsAsDeceasedByBirthnumber: async (
      markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'markDeceasedAccountRequestDto' is not null or undefined
      assertParamExists(
        'adminControllerMarkAccountsAsDeceasedByBirthnumber',
        'markDeceasedAccountRequestDto',
        markDeceasedAccountRequestDto,
      )
      const localVarPath = `/admin/mark-deceased`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        markDeceasedAccountRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
     * @summary Will activate one time sync of all users from cognito to db at 3am
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerSyncCognitoToDb: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/activate-sync-cognito-to-db`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidateEdeskForUserIds: async (
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyValidateEdeskForUserIdsDto' is not null or undefined
      assertParamExists(
        'adminControllerValidateEdeskForUserIds',
        'requestBodyValidateEdeskForUserIdsDto',
        requestBodyValidateEdeskForUserIdsDto,
      )
      const localVarPath = `/admin/validate-edesk-by-cognito-where-first-try`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyValidateEdeskForUserIdsDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatePhysicalEntityRfo: async (
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestValidatePhysicalEntityRfoDto' is not null or undefined
      assertParamExists(
        'adminControllerValidatePhysicalEntityRfo',
        'requestValidatePhysicalEntityRfoDto',
        requestValidatePhysicalEntityRfoDto,
      )
      const localVarPath = `/admin/validate-physical-entity-rfo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestValidatePhysicalEntityRfoDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatedUsersToPhysicalEntities: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/admin/validated-users-to-physical-entities`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerVerifyUserManually: async (
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('adminControllerVerifyUserManually', 'email', email)
      // verify required parameter 'manuallyVerifyUserRequestDto' is not null or undefined
      assertParamExists(
        'adminControllerVerifyUserManually',
        'manuallyVerifyUserRequestDto',
        manuallyVerifyUserRequestDto,
      )
      const localVarPath = `/admin/user/verify-manually/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication apiKey required
      await setApiKeyToObject(localVarHeaderParameter, 'apiKey', configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        manuallyVerifyUserRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ADMINApi - functional programming interface
 */
export const ADMINApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ADMINApiAxiosParamCreator(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerCheckUserVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserVerifyState>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerCheckUserVerifyState(
        email,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerCheckUserVerifyState']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerDeactivateAccount(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeactivateAccountResponseDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerDeactivateAccount(
        externalId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerDeactivateAccount']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
     * @summary Get birth numbers of newly verified users.
     * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetNewVerifiedUsersBirthNumbers(
      requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetNewVerifiedUsersBirthNumbersResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetNewVerifiedUsersBirthNumbers(
          requestBatchNewUserBirthNumbers,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetNewVerifiedUsersBirthNumbers']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserByBirthNumberDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumber(
          birthNumber,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetUserDataByBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetUserDataByBirthNumbersBatch(
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetUserDataByBirthNumbersBatchResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetUserDataByBirthNumbersBatch(
          requestBatchQueryUsersByBirthNumbersDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetUserDataByBirthNumbersBatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerGetVerificationDataForUser(
      email: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationDataForUserResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerGetVerificationDataForUser(email, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerGetVerificationDataForUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
     * @summary Mark accounts as deceased
     * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerMarkAccountsAsDeceasedByBirthnumber(
      markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarkDeceasedAccountResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerMarkAccountsAsDeceasedByBirthnumber(
          markDeceasedAccountRequestDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerMarkAccountsAsDeceasedByBirthnumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
     * @summary Will activate one time sync of all users from cognito to db at 3am
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerSyncCognitoToDb(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerSyncCognitoToDb(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerSyncCognitoToDb']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidateEdeskForUserIds(
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateEdeskForUserIdsResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidateEdeskForUserIds(
          requestBodyValidateEdeskForUserIdsDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidateEdeskForUserIds']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidatePhysicalEntityRfo(
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseValidatePhysicalEntityRfoDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidatePhysicalEntityRfo(
          requestValidatePhysicalEntityRfoDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidatePhysicalEntityRfo']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerValidatedUsersToPhysicalEntities(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ValidatedUsersToPhysicalEntitiesResponseDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.adminControllerValidatedUsersToPhysicalEntities(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerValidatedUsersToPhysicalEntities']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminControllerVerifyUserManually(
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnlySuccessDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminControllerVerifyUserManually(
        email,
        manuallyVerifyUserRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ADMINApi.adminControllerVerifyUserManually']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ADMINApi - factory interface
 */
export const ADMINApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ADMINApiFp(configuration)
  return {
    /**
     * Return the state of user verifying.
     * @summary Get user\'s verify state
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerCheckUserVerifyState(
      email: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserVerifyState> {
      return localVarFp
        .adminControllerCheckUserVerifyState(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deactivates user account in cognito and deletes personal info from database.
     * @summary Deactivate user account
     * @param {string} externalId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerDeactivateAccount(
      externalId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeactivateAccountResponseDto> {
      return localVarFp
        .adminControllerDeactivateAccount(externalId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
     * @summary Get birth numbers of newly verified users.
     * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetNewVerifiedUsersBirthNumbers(
      requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetNewVerifiedUsersBirthNumbersResponseDto> {
      return localVarFp
        .adminControllerGetNewVerifiedUsersBirthNumbers(requestBatchNewUserBirthNumbers, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get user data by birthnumber
     * @summary Get user data
     * @param {string} birthNumber userBirthNumber
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumber(
      birthNumber: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserByBirthNumberDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumber(birthNumber, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get user data by birthnumbers in batch.
     * @summary Get user data
     * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetUserDataByBirthNumbersBatch(
      requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetUserDataByBirthNumbersBatchResponseDto> {
      return localVarFp
        .adminControllerGetUserDataByBirthNumbersBatch(
          requestBatchQueryUsersByBirthNumbersDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
     * @summary Get verification data for user.
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerGetVerificationDataForUser(
      email: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VerificationDataForUserResponseDto> {
      return localVarFp
        .adminControllerGetVerificationDataForUser(email, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
     * @summary Mark accounts as deceased
     * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerMarkAccountsAsDeceasedByBirthnumber(
      markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MarkDeceasedAccountResponseDto> {
      return localVarFp
        .adminControllerMarkAccountsAsDeceasedByBirthnumber(markDeceasedAccountRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
     * @summary Will activate one time sync of all users from cognito to db at 3am
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerSyncCognitoToDb(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .adminControllerSyncCognitoToDb(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
     * @summary Validate edesk for physicalEntities
     * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidateEdeskForUserIds(
      requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ValidateEdeskForUserIdsResponseDto> {
      return localVarFp
        .adminControllerValidateEdeskForUserIds(requestBodyValidateEdeskForUserIdsDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Manually update entity data against RFO (and UPVS) if possible
     * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatePhysicalEntityRfo(
      requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseValidatePhysicalEntityRfoDto> {
      return localVarFp
        .adminControllerValidatePhysicalEntityRfo(requestValidatePhysicalEntityRfoDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
     * @summary Create physicalEntity records for validated users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerValidatedUsersToPhysicalEntities(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ValidatedUsersToPhysicalEntitiesResponseDto> {
      return localVarFp
        .adminControllerValidatedUsersToPhysicalEntities(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
     * @summary Manually verify user.
     * @param {string} email
     * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminControllerVerifyUserManually(
      email: string,
      manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<OnlySuccessDto> {
      return localVarFp
        .adminControllerVerifyUserManually(email, manuallyVerifyUserRequestDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ADMINApi - object-oriented interface
 */
export class ADMINApi extends BaseAPI {
  /**
   * Return the state of user verifying.
   * @summary Get user\'s verify state
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerCheckUserVerifyState(email: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerCheckUserVerifyState(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deactivates user account in cognito and deletes personal info from database.
   * @summary Deactivate user account
   * @param {string} externalId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerDeactivateAccount(externalId: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerDeactivateAccount(externalId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves birth numbers for up to `take` newly verified users since the specified date. Returns paginated results with a `nextSince` timestamp for subsequent requests.
   * @summary Get birth numbers of newly verified users.
   * @param {RequestBatchNewUserBirthNumbers} requestBatchNewUserBirthNumbers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetNewVerifiedUsersBirthNumbers(
    requestBatchNewUserBirthNumbers: RequestBatchNewUserBirthNumbers,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetNewVerifiedUsersBirthNumbers(requestBatchNewUserBirthNumbers, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get user data by birthnumber
   * @summary Get user data
   * @param {string} birthNumber userBirthNumber
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetUserDataByBirthNumber(
    birthNumber: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumber(birthNumber, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get user data by birthnumbers in batch.
   * @summary Get user data
   * @param {RequestBatchQueryUsersByBirthNumbersDto} requestBatchQueryUsersByBirthNumbersDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetUserDataByBirthNumbersBatch(
    requestBatchQueryUsersByBirthNumbersDto: RequestBatchQueryUsersByBirthNumbersDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetUserDataByBirthNumbersBatch(
        requestBatchQueryUsersByBirthNumbersDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns data used for verification by identity card for given user in the last month. If the email is for a legal person, it returns the data for the given legal person.
   * @summary Get verification data for user.
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerGetVerificationDataForUser(email: string, options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerGetVerificationDataForUser(email, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is intended to be used manually when a person is reported as deceased. When called, it deactivates the user account in cognito and marks it as deceased.
   * @summary Mark accounts as deceased
   * @param {MarkDeceasedAccountRequestDto} markDeceasedAccountRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerMarkAccountsAsDeceasedByBirthnumber(
    markDeceasedAccountRequestDto: MarkDeceasedAccountRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerMarkAccountsAsDeceasedByBirthnumber(markDeceasedAccountRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is intended to be used manually to trigger a sync of all users from cognito and then call getOrCreate for each user.
   * @summary Will activate one time sync of all users from cognito to db at 3am
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerSyncCognitoToDb(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerSyncCognitoToDb(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Take up to 100 physicalEntities linked to users without any attempts to validate uri and try using cognito data to validate
   * @summary Validate edesk for physicalEntities
   * @param {RequestBodyValidateEdeskForUserIdsDto} requestBodyValidateEdeskForUserIdsDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerValidateEdeskForUserIds(
    requestBodyValidateEdeskForUserIdsDto: RequestBodyValidateEdeskForUserIdsDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidateEdeskForUserIds(requestBodyValidateEdeskForUserIdsDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Manually update entity data against RFO (and UPVS) if possible
   * @param {RequestValidatePhysicalEntityRfoDto} requestValidatePhysicalEntityRfoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerValidatePhysicalEntityRfo(
    requestValidatePhysicalEntityRfoDto: RequestValidatePhysicalEntityRfoDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidatePhysicalEntityRfo(requestValidatePhysicalEntityRfoDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Warning - do not run this in parallel, you risk creating duplicates. Processes up to 1000 at once. Where physicalEntity with matching birth number but no linked user is found, it is automatically linked instead of creating a new one
   * @summary Create physicalEntity records for validated users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerValidatedUsersToPhysicalEntities(options?: RawAxiosRequestConfig) {
    return ADMINApiFp(this.configuration)
      .adminControllerValidatedUsersToPhysicalEntities(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Manually verify user, or legal person (depending on data in cognito), with provided data like birth number etc.
   * @summary Manually verify user.
   * @param {string} email
   * @param {ManuallyVerifyUserRequestDto} manuallyVerifyUserRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public adminControllerVerifyUserManually(
    email: string,
    manuallyVerifyUserRequestDto: ManuallyVerifyUserRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return ADMINApiFp(this.configuration)
      .adminControllerVerifyUserManually(email, manuallyVerifyUserRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AppApi - axios parameter creator
 */
export const AppApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthcheck`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AppApi - functional programming interface
 */
export const AppApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AppApiAxiosParamCreator(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async appControllerHealthCheck(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.appControllerHealthCheck(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AppApi.appControllerHealthCheck']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AppApi - factory interface
 */
export const AppApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AppApiFp(configuration)
  return {
    /**
     * See if app is working!
     * @summary HealthCheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    appControllerHealthCheck(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .appControllerHealthCheck(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AppApi - object-oriented interface
 */
export class AppApi extends BaseAPI {
  /**
   * See if app is working!
   * @summary HealthCheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public appControllerHealthCheck(options?: RawAxiosRequestConfig) {
    return AppApiFp(this.configuration)
      .appControllerHealthCheck(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogin(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CognitoGetUserData>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary Check if user is authorized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogin(options?: RawAxiosRequestConfig): AxiosPromise<CognitoGetUserData> {
      return localVarFp.authControllerLogin(options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Check if user is authorized
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public authControllerLogin(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authControllerLogin(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UserVerificationsApi - axios parameter creator
 */
export const UserVerificationsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard: async (
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyIdentityCardDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyBirthNumberAndIdentityCard',
        'requestBodyVerifyIdentityCardDto',
        requestBodyVerifyIdentityCardDto,
      )
      const localVarPath = `/user-verification/identity-card`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyIdentityCardDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard: async (
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithRpoDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyIcoBirthNumberAndIdentityCard',
        'requestBodyVerifyWithRpoDto',
        requestBodyVerifyWithRpoDto,
      )
      const localVarPath = `/user-verification/ico-rpo`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithRpoDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid: async (
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestBodyVerifyWithEidDto' is not null or undefined
      assertParamExists(
        'verificationControllerVerifyWithEid',
        'requestBodyVerifyWithEidDto',
        requestBodyVerifyWithEidDto,
      )
      const localVarPath = `/user-verification/eid`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBodyVerifyWithEidDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserVerificationsApi - functional programming interface
 */
export const UserVerificationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserVerificationsApiAxiosParamCreator(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ResponseVerificationIdentityCardToQueueDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UserVerificationsApi.verificationControllerVerifyIcoBirthNumberAndIdentityCard'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseVerificationDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verificationControllerVerifyWithEid(
        requestBodyVerifyWithEidDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UserVerificationsApi.verificationControllerVerifyWithEid']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UserVerificationsApi - factory interface
 */
export const UserVerificationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UserVerificationsApiFp(configuration)
  return {
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyBirthNumberAndIdentityCard(
      requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationIdentityCardToQueueDto> {
      return localVarFp
        .verificationControllerVerifyBirthNumberAndIdentityCard(
          requestBodyVerifyIdentityCardDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via the register of legal entities
     * @summary Validate user via rpo
     * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyIcoBirthNumberAndIdentityCard(
      requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
          requestBodyVerifyWithRpoDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
     * @summary Validate user via eid
     * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verificationControllerVerifyWithEid(
      requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseVerificationDto> {
      return localVarFp
        .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UserVerificationsApi - object-oriented interface
 */
export class UserVerificationsApi extends BaseAPI {
  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {RequestBodyVerifyIdentityCardDto} requestBodyVerifyIdentityCardDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public verificationControllerVerifyBirthNumberAndIdentityCard(
    requestBodyVerifyIdentityCardDto: RequestBodyVerifyIdentityCardDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyBirthNumberAndIdentityCard(
        requestBodyVerifyIdentityCardDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via the register of legal entities
   * @summary Validate user via rpo
   * @param {RequestBodyVerifyWithRpoDto} requestBodyVerifyWithRpoDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public verificationControllerVerifyIcoBirthNumberAndIdentityCard(
    requestBodyVerifyWithRpoDto: RequestBodyVerifyWithRpoDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyIcoBirthNumberAndIdentityCard(
        requestBodyVerifyWithRpoDto,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint validates users via eid by contacting slovensko.sk and returns user data upon successful validation.
   * @summary Validate user via eid
   * @param {RequestBodyVerifyWithEidDto} requestBodyVerifyWithEidDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public verificationControllerVerifyWithEid(
    requestBodyVerifyWithEidDto: RequestBodyVerifyWithEidDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UserVerificationsApiFp(this.configuration)
      .verificationControllerVerifyWithEid(requestBodyVerifyWithEidDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersManipulationApi - axios parameter creator
 */
export const UsersManipulationApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail: async (
      changeEmailRequestDto: ChangeEmailRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'changeEmailRequestDto' is not null or undefined
      assertParamExists('userControllerChangeEmail', 'changeEmailRequestDto', changeEmailRequestDto)
      const localVarPath = `/user/change-email`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        changeEmailRequestDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/get-or-create`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/remove-birthnumber`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerSubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/subscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser: async (
      requestGdprDataDto: RequestGdprDataDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestGdprDataDto' is not null or undefined
      assertParamExists(
        'userControllerUnsubscribeLoggedUser',
        'requestGdprDataDto',
        requestGdprDataDto,
      )
      const localVarPath = `/user/unsubscribe`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestGdprDataDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser: async (
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'id', id)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'type', type)
      // verify required parameter 'category' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUser', 'category', category)
      const localVarPath = `/user/public/unsubscribe/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUserByExternalId: async (
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'id', id)
      // verify required parameter 'type' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'type', type)
      // verify required parameter 'category' is not null or undefined
      assertParamExists('userControllerUnsubscribePublicUserByExternalId', 'category', category)
      const localVarPath = `/user/public/unsubscribe/external-id/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
     * @summary Update or create bloomreach customer for logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdateOrCreateBloomreachCustomer: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/update-or-create-bloomreach-customer`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersManipulationApi - functional programming interface
 */
export const UsersManipulationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersManipulationApiAxiosParamCreator(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerChangeEmail(
      changeEmailRequestDto: ChangeEmailRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerChangeEmail200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerChangeEmail(
        changeEmailRequestDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerChangeEmail']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerGetOrCreateUser(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerGetOrCreateUser(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerGetOrCreateUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRemoveBirthNumber(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerRemoveBirthNumber(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerRemoveBirthNumber']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerSubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UserControllerGetOrCreateUser200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribeLoggedUser(
        requestGdprDataDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribeLoggedUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUser(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUnsubscribePublicUser(
        id,
        type,
        category,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUnsubscribePublicUser']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUnsubscribePublicUserByExternalId(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerUnsubscribePublicUserByExternalId(
          id,
          type,
          category,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap[
          'UsersManipulationApi.userControllerUnsubscribePublicUserByExternalId'
        ]?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
     * @summary Update or create bloomreach customer for logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdateOrCreateBloomreachCustomer(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseUserDataDto>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userControllerUpdateOrCreateBloomreachCustomer(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersManipulationApi.userControllerUpdateOrCreateBloomreachCustomer']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UsersManipulationApi - factory interface
 */
export const UsersManipulationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = UsersManipulationApiFp(configuration)
  return {
    /**
     * Change email saved in database for a given cognito user.
     * @summary Change email of cognito user in database
     * @param {ChangeEmailRequestDto} changeEmailRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerChangeEmail(
      changeEmailRequestDto: ChangeEmailRequestDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerChangeEmail200Response> {
      return localVarFp
        .userControllerChangeEmail(changeEmailRequestDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
     * @summary Get or create user with his data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOrCreateUser(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerGetOrCreateUser(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveBirthNumber(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerRemoveBirthNumber(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
     * @summary Create subscribed or unsubscribed log for logged in users
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
     * @summary Unsubscribe logged user
     * @param {RequestGdprDataDto} requestGdprDataDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribeLoggedUser(
      requestGdprDataDto: RequestGdprDataDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserControllerGetOrCreateUser200Response> {
      return localVarFp
        .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by uuid with different categories of subscription
     * @summary Unsubscribe user by uuid
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUser(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUser(id, type, category, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * unsubscribe any user by external Id from cognito with different categories of subscription
     * @summary Unsubscribe user by external Id
     * @param {string} id
     * @param {GDPRTypeEnum} type Type of Gdpr subscription
     * @param {GDPRCategoryEnum} category Type of Gdpr category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUnsubscribePublicUserByExternalId(
      id: string,
      type: GDPRTypeEnum,
      category: GDPRCategoryEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<string> {
      return localVarFp
        .userControllerUnsubscribePublicUserByExternalId(id, type, category, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
     * @summary Update or create bloomreach customer for logged user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdateOrCreateBloomreachCustomer(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ResponseUserDataDto> {
      return localVarFp
        .userControllerUpdateOrCreateBloomreachCustomer(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersManipulationApi - object-oriented interface
 */
export class UsersManipulationApi extends BaseAPI {
  /**
   * Change email saved in database for a given cognito user.
   * @summary Change email of cognito user in database
   * @param {ChangeEmailRequestDto} changeEmailRequestDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerChangeEmail(
    changeEmailRequestDto: ChangeEmailRequestDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerChangeEmail(changeEmailRequestDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint return all user data in database of city account and his gdpr latest gdpr data. Null in gdpr means is not subscribe neither unsubscribe. If this endpoint will create user, create automatically License subscription.
   * @summary Get or create user with his data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerGetOrCreateUser(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerGetOrCreateUser(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerRemoveBirthNumber(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerRemoveBirthNumber(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWT token. You can send subscription data from model in array, or you can send empty array in gdprData and it will automatically create subscribed data.
   * @summary Create subscribed or unsubscribed log for logged in users
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerSubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerSubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint is used only for logged user, user is paired by JWTtoken. You can send unsubscription data from model in array, or you can send empty array in gdprData and it will automatically create unsubscribed data.
   * @summary Unsubscribe logged user
   * @param {RequestGdprDataDto} requestGdprDataDto
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUnsubscribeLoggedUser(
    requestGdprDataDto: RequestGdprDataDto,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribeLoggedUser(requestGdprDataDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by uuid with different categories of subscription
   * @summary Unsubscribe user by uuid
   * @param {string} id
   * @param {GDPRTypeEnum} type Type of Gdpr subscription
   * @param {GDPRCategoryEnum} category Type of Gdpr category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUnsubscribePublicUser(
    id: string,
    type: GDPRTypeEnum,
    category: GDPRCategoryEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUser(id, type, category, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * unsubscribe any user by external Id from cognito with different categories of subscription
   * @summary Unsubscribe user by external Id
   * @param {string} id
   * @param {GDPRTypeEnum} type Type of Gdpr subscription
   * @param {GDPRCategoryEnum} category Type of Gdpr category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUnsubscribePublicUserByExternalId(
    id: string,
    type: GDPRTypeEnum,
    category: GDPRCategoryEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUnsubscribePublicUserByExternalId(id, type, category, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This controller will call bloomreach endpoint with bloomreach credentials from env variables. This endpoint is used to update or create bloomreach customer for logged user. It is used to track user attributes change in cognito.
   * @summary Update or create bloomreach customer for logged user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   */
  public userControllerUpdateOrCreateBloomreachCustomer(options?: RawAxiosRequestConfig) {
    return UsersManipulationApiFp(this.configuration)
      .userControllerUpdateOrCreateBloomreachCustomer(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
