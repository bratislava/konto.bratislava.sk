import * as path from 'node:path'
import { promises as fs } from 'fs'
import { getInterCss } from '../../src/summary-pdf/interCss'
import { getTailwindCss } from '../../src/summary-pdf/tailwindCss'
// synchronizedPrettier must be used until https://github.com/jestjs/jest/issues/14305 is solved
import synchronizedPrettier from '@prettier/sync'
import { get as getAppRootDir } from 'app-root-dir'

/*
 * This script generates base64-encoded assets from files and strings and writes them to the src/generated-assets
 * directory as TypeScript files.
 *
 * After examining multiple solutions that:
 *  - load the file as a string (file loaders in esbuild/vite/webpack, using fs directly) - for static assets,
 *  - pre-evaluate script (babel-plugin-preval, esbuild custom plugins) - for scripts that need to access the file system
 *    in their evaluation - e.g. generating Tailwind or Inter font CSS
 *
 * this no-frills approach was chosen for its simplicity and ease of use. It works in all environments (jest,
 * Next.js/Nest) or built/directly imported version of the library consistently and is as performant as other solutions.
 */

function convertStringToBase64(str: string) {
  const normalizedStr = str.replace(/\r\n/g, '\n')
  return Buffer.from(normalizedStr).toString('base64')
}

const rootDir = getAppRootDir()

const assetsList = [
  {
    name: 'taxPdf',
    type: 'base64' as const,
    getBase64Content: async () =>
      fs.readFile(path.join(rootDir, './resources/Priznanie_komplet_tlacivo.pdf'), {
        encoding: 'base64',
      }),
  },
  {
    name: 'taxPdfFont',
    type: 'base64' as const,
    getBase64Content: async () =>
      fs.readFile(path.join(rootDir, './resources/LiberationSans.ttf'), {
        encoding: 'base64',
      }),
  },
  {
    name: 'summaryPdfCss',
    type: 'string' as const,
    getStringContent: async () => {
      const cssArray = await Promise.all([getInterCss(), getTailwindCss()])
      const joinedStrings = cssArray.join('\n')

      return joinedStrings
    },
  },
]

const reformatWithPrettier = (code: string) => {
  const configFile = path.join(rootDir, './.prettierrc.js')
  const options = synchronizedPrettier.resolveConfig(configFile)
  if (!options) {
    throw new Error('Prettier options not found')
  }

  return synchronizedPrettier.format(code, { ...options, parser: 'typescript' })
}

const renderBase64Content = (base64String: string) => {
  const code = `/* This file is automatically generated, don't change the contents, see "scripts/assets/". */ 

export default Buffer.from(${JSON.stringify(base64String)}, 'base64')\n`

  return reformatWithPrettier(code)
}

const renderStringContent = async (cssString: string) => {
  const { default: stringToTemplateLiteral } = await import('string-to-template-literal')

  const code = `/* This file is automatically generated, don't change the contents, see "scripts/assets/". */ 

export default ${stringToTemplateLiteral(cssString)}\n`

  return reformatWithPrettier(code)
}

const srcAssetsDir = path.join(rootDir, './src/generated-assets')

export const getRenderedAssets = () => {
  return assetsList.map(async (asset) => {
    const { name, type } = asset
    let content: string

    if (type === 'base64') {
      const base64Content = await asset.getBase64Content()
      content = renderBase64Content(base64Content)
    } else if (type === 'string') {
      const stringContent = await asset.getStringContent()
      content = await renderStringContent(stringContent)
    } else {
      throw new Error(`Unknown asset type: ${type}`)
    }

    return {
      path: path.join(srcAssetsDir, `./${name}.ts`),
      content,
    }
  })
}

export const generateAssetFiles = async () => {
  await fs.mkdir(srcAssetsDir, { recursive: true })
  const assets = await Promise.all(getRenderedAssets())
  for (const { path, content } of assets) {
    await fs.writeFile(path, content)
  }
}
